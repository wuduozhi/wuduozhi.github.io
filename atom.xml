<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-08T16:47:59.404Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大学|记一次比赛</title>
    <link href="http://yoursite.com/2017/12/09/%E5%A4%A7%E5%AD%A6-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%AF%94%E8%B5%9B/"/>
    <id>http://yoursite.com/2017/12/09/大学-记一次比赛/</id>
    <published>2017-12-09T00:10:32.000Z</published>
    <updated>2017-12-08T16:47:59.404Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我的第一次比赛"><a href="#我的第一次比赛" class="headerlink" title="我的第一次比赛"></a>我的第一次比赛</h3><p>说起这次比赛，也挺好玩，自己先前根本不知道是怎么回事，江哥先找到我说想一起组队参加比赛，我也答应了。这是自己在大学第一个参加的比赛，是学校联想俱乐部举办的，比赛内容就是参赛队员想一个产品，有创意的产品。</p>
<p>然后,我们就开始讨论要搞什么，最初是说搞教育那一块的，但觉得太low了，就换成了旅游出行的个性化推荐，创新点主要是能实时通过天气、景点人流、交通情况等因素，实时为旅客修改旅游计划，为用户提供最佳的旅游路线。</p>
<p>最开始是初赛，需要做ppt和上台答辩，说白了，这个比赛就是看谁弄得ppt好看和谁的忽悠能力强就能得奖。ppt是黄智威弄的，还需要一个产品的原型，然后自己是弄原型，其实也就是弄个首页，都不是事。还是黄智威拼，弄ppt到半夜。答辩时黄智威和黄卫江上去讲的，毫无悬念，我们进入了决赛。</p>
<p>初赛后不久是决赛，ppt是用的初赛的，但是原型就不能用初赛的了，需要搞完善一点的，不过这次不是我搞的了，是黄卫江搞的，自己有点惭愧啊，就是个打酱油的。决赛是黄智威自己上去答辩，黄卫江上课去了，我坐在台下给黄智威录像。很幸运，决赛我们的了二等奖。其中，还有一个有趣的环节呢，那就是刷票啊，不知道黄智威怎么搞的，花钱加别人刷票，这小子可以的。</p>
<p>本以为我们能够进决赛的，我们还为此决定搞个半产品出来呢。我们三个专门去蓝杰向胡哥请教了一番，还想好了下一步的分工了。不曾想，回宿舍后，通知说没有进省赛。</p>
<p>这就是自己第一次的比赛经历啦，虽然不精彩，但是自己也认识到一个团队需要不同的人才能做成一件事。就像黄智威，能说，会忽悠；黄卫江，能为了完成任务，熬上几夜；我自己呢，可能在技术这一块擅长一点，所以前期也没做什么工作，是要在做产品的时候出力的。</p>
<p><img src="/images/mmexport1512485485927.jpg" alt="enter description here" title="mmexport1512485485927"></p>
<p><img src="/images/mmexport1512658490870.jpg" alt="enter description here" title="mmexport1512658490870"></p>
<p><img src="/images/mmexport1512658490870.jpg" alt="enter description here" title="mmexport1512658490870"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;我的第一次比赛&quot;&gt;&lt;a href=&quot;#我的第一次比赛&quot; class=&quot;headerlink&quot; title=&quot;我的第一次比赛&quot;&gt;&lt;/a&gt;我的第一次比赛&lt;/h3&gt;&lt;p&gt;说起这次比赛，也挺好玩，自己先前根本不知道是怎么回事，江哥先找到我说想一起组队参加比赛，我也答应了。
    
    </summary>
    
    
      <category term="大学" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>PHP|文件上传</title>
    <link href="http://yoursite.com/2017/12/03/PHP-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2017/12/03/PHP-文件上传/</id>
    <published>2017-12-02T23:30:13.000Z</published>
    <updated>2017-12-02T16:28:11.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这几天，在忙弦歌知湖改版的事情，虽然不是很难，但是bug还是层出不穷，有很多细节的东西没有考虑到，最坑的是投稿的功能了，需要上传文件，同时，自己也是第一次处理文件上传，以前都是弄一些表单数据，没什么细节需要处理，但文件就不同了，要考虑大小、类型、存的位置…</p>
<h3 id="一些干货"><a href="#一些干货" class="headerlink" title="一些干货"></a>一些干货</h3><h4 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h4><p>来一个前端测试的表单：upload.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;form action=&quot;upload.php&quot; method=&quot;post&quot; multipart=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt;</div><div class="line">        &lt;input type=&quot;file&quot; name=&quot;img&quot; multiple&gt;</div><div class="line">        &lt;input type=&quot;submit&quot;&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>再来一个处理文件的php文件，upload.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$img = $_FILES[&apos;img&apos;];</div><div class="line">var_dump($img);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>先看看我们得到的是一个什么东西吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">array (size=5)</div><div class="line">  &apos;name&apos; =&gt; string &apos;父亲1.png&apos; (length=11)</div><div class="line">  &apos;type&apos; =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">  &apos;tmp_name&apos; =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php444D.tmp&apos; (length=39)</div><div class="line">  &apos;error&apos; =&gt; int 0</div><div class="line">  &apos;size&apos; =&gt; int 186938</div></pre></td></tr></table></figure></p>
<p>  我们得到了一个数组，包含了许多信息，比如文件名、文件类型、文件大小，同时还有临时存储的位置、是否有错误，如果 ‘error’ 不等于0，就说明发生错误了，我们就不能接收了。那我们如何将这个文件保存到我们想要保存的地方呢？那就用 ove_uploaded_file() 函数吧。</p>
<p>接收的PHP代码是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$img = $_FILES[&apos;img&apos;];</div><div class="line">var_dump($img);</div><div class="line"></div><div class="line">$path = &apos;upload&apos;;  </div><div class="line">$realName = time().&apos;jpg&apos;;</div><div class="line">$realPath = $path.&apos;/&apos;.$relaName;</div><div class="line">if(move_uploaded_file($img[&apos;temp_name&apos;]) ,$realPath )&#123;</div><div class="line">	echo &apos;上传成功&apos;;</div><div class="line">&#125;else&#123;</div><div class="line">	echo &apos;上传失败&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们的当前文件夹内有一个 upload的文件夹，这样写是没问题的，但是如果没有upload的文件夹呢？如果有个人删了这个文件夹呢？那岂不是完蛋了，所以我们首先要判断文件夹是否存在，如果不存在要先建立文件夹。还有一个问题，如果文件夹内已经有了相同文件名的文件呢？尽管我们用了time（）函数来为文件取名字，但是谁还没有背的时候呢？所以还是要判断一下文件是否存在，在执行 move_uploaded_file() 函数。</p>
<p>先说说创建文件夹吧，mkdir（）这个函数似乎只能建立一级文件夹，所以我们要建立多级文件夹的时候，就需要递归运行了，看看下面的递归建立文件夹的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//创建多级文件夹 $dirname = &apos;upload/image/exter&apos;;</div><div class="line">function mkdir_r($dirName, $rights=0777)&#123;</div><div class="line"></div><div class="line">    $dirs = explode(&apos;/&apos;, $dirName);</div><div class="line"></div><div class="line">    $dir=&apos;&apos;;</div><div class="line"></div><div class="line">    foreach ($dirs as $part) &#123;</div><div class="line"></div><div class="line">        $dir.=$part.&apos;/&apos;;</div><div class="line"></div><div class="line">        if (!is_dir($dir) &amp;&amp; strlen($dir)&gt;0)</div><div class="line"></div><div class="line">            mkdir($dir, $rights);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数的代码还是简单易懂的，就是传文件路径，逐级判断是否有此文件夹，没有就建立文件夹。</p>
<p>然后是判断文件是否存在，用file_exist()函数。</p>
<p>上面是最基本的考虑，如果还需要限制文件大小和文件的类型，可以根据得到的数组，进行判断。</p>
<p>这个是上传单个文件的，如果是多个文件呢？就像这样的表单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;form action=&quot;upload.php&quot; method=&quot;post&quot; multipart=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt;</div><div class="line">        &lt;input type=&quot;file&quot; name=&quot;img[]&quot; multiple&gt;</div><div class="line">        &lt;input type=&quot;submit&quot;&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>相信细心的你已经看出不同来了，现在的name变成img[] 了，也就是说能上传多张照片了。先不急，看看我们得到的是什么吧:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$img = $_FILES[&apos;img&apos;];</div><div class="line">var_dump($img);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>我们得到的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">array (size=5)</div><div class="line">  &apos;name&apos; =&gt; </div><div class="line">    array (size=3)</div><div class="line">      0 =&gt; string &apos;父亲1.png&apos; (length=11)</div><div class="line">      1 =&gt; string &apos;父亲2.png&apos; (length=11)</div><div class="line">      2 =&gt; string &apos;父亲3.png&apos; (length=11)</div><div class="line">  &apos;type&apos; =&gt; </div><div class="line">    array (size=3)</div><div class="line">      0 =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">      1 =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">      2 =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">  &apos;tmp_name&apos; =&gt; </div><div class="line">    array (size=3)</div><div class="line">      0 =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php457E.tmp&apos; (length=39)</div><div class="line">      1 =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php457F.tmp&apos; (length=39)</div><div class="line">      2 =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php4580.tmp&apos; (length=39)</div><div class="line">  &apos;error&apos; =&gt; </div><div class="line">    array (size=3)</div><div class="line">      0 =&gt; int 0</div><div class="line">      1 =&gt; int 0</div><div class="line">      2 =&gt; int 0</div><div class="line">  &apos;size&apos; =&gt; </div><div class="line">    array (size=3)</div><div class="line">      0 =&gt; int 186938</div><div class="line">      1 =&gt; int 208693</div><div class="line">      2 =&gt; int 197557</div></pre></td></tr></table></figure></p>
<p>是这样的一个数组了，不知为何，总觉得这个数组不是我们想要的形式，我们想得到的是这样的一个数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">array (size=3)</div><div class="line">  0 =&gt; </div><div class="line">    array (size=5)</div><div class="line">      &apos;name&apos; =&gt; string &apos;父亲1.png&apos; (length=11)</div><div class="line">      &apos;type&apos; =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">      &apos;tmp_name&apos; =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php1933.tmp&apos; (length=39)</div><div class="line">      &apos;error&apos; =&gt; int 0</div><div class="line">      &apos;size&apos; =&gt; int 186938</div><div class="line">  1 =&gt; </div><div class="line">    array (size=5)</div><div class="line">      &apos;name&apos; =&gt; string &apos;父亲2.png&apos; (length=11)</div><div class="line">      &apos;type&apos; =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">      &apos;tmp_name&apos; =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php1944.tmp&apos; (length=39)</div><div class="line">      &apos;error&apos; =&gt; int 0</div><div class="line">      &apos;size&apos; =&gt; int 208693</div><div class="line">  2 =&gt; </div><div class="line">    array (size=5)</div><div class="line">      &apos;name&apos; =&gt; string &apos;父亲3.png&apos; (length=11)</div><div class="line">      &apos;type&apos; =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">      &apos;tmp_name&apos; =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php1945.tmp&apos; (length=39)</div><div class="line">      &apos;error&apos; =&gt; int 0</div><div class="line">      &apos;size&apos; =&gt; int 197557</div></pre></td></tr></table></figure></p>
<p>如果是这样的形式的数组，那就清晰多了，那我们要怎么把之前形式的数组变成这样的呢？那就需要下面的函数了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/处理多文件上传</div><div class="line">function reArrayFiles($file)</div><div class="line">&#123;</div><div class="line">    $file_ary = array();</div><div class="line">    $file_count = count($file[&apos;name&apos;]);</div><div class="line">    $file_key = array_keys($file);</div><div class="line">    </div><div class="line">    for($i=0;$i&lt;$file_count;$i++)</div><div class="line">    &#123;</div><div class="line">        foreach($file_key as $val)</div><div class="line">        &#123;</div><div class="line">            $file_ary[$i][$val] = $file[$val][$i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return $file_ary;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这个函数的整理，就能得到我们想要的形式的数组了，然后就变成了我们想要形式的数组啦。附上一个完整的upload.php代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;?php</div><div class="line"></div><div class="line">$img = $_FILES[&apos;img&apos;];</div><div class="line"></div><div class="line">if(!empty($img))</div><div class="line">&#123;</div><div class="line">    $img_desc = reArrayFiles($img);</div><div class="line">    </div><div class="line">    foreach($img_desc as $val)</div><div class="line">    &#123;</div><div class="line">        $newname = date(&apos;YmdHis&apos;,time()).mt_rand().&apos;.jpg&apos;;</div><div class="line">		$path = &apos;upload/image/exter&apos;;</div><div class="line">		if(!is_dir($path))&#123;</div><div class="line">			mkdir_r($path);</div><div class="line">		&#125;</div><div class="line">        move_uploaded_file($val[&apos;tmp_name&apos;],$path.&apos;/&apos;.$newname);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//创建多级文件夹 $dirname = &apos;upload/image/exter&apos;;</div><div class="line">function mkdir_r($dirName, $rights=0777)&#123;</div><div class="line"></div><div class="line">    $dirs = explode(&apos;/&apos;, $dirName);</div><div class="line"></div><div class="line">    $dir=&apos;&apos;;</div><div class="line"></div><div class="line">    foreach ($dirs as $part) &#123;</div><div class="line"></div><div class="line">        $dir.=$part.&apos;/&apos;;</div><div class="line"></div><div class="line">        if (!is_dir($dir) &amp;&amp; strlen($dir)&gt;0)</div><div class="line"></div><div class="line">            mkdir($dir, $rights);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//处理多文件上传</div><div class="line">function reArrayFiles($file)</div><div class="line">&#123;</div><div class="line">    $file_ary = array();</div><div class="line">    $file_count = count($file[&apos;name&apos;]);</div><div class="line">    $file_key = array_keys($file);</div><div class="line">    </div><div class="line">    for($i=0;$i&lt;$file_count;$i++)</div><div class="line">    &#123;</div><div class="line">        foreach($file_key as $val)</div><div class="line">        &#123;</div><div class="line">            $file_ary[$i][$val] = $file[$val][$i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return $file_ary;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h3><p>文件上传是很重要的，但需要处理的细节也有很多，所以需要小心处理、慎重处理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这几天，在忙弦歌知湖改版的事情，虽然不是很难，但是bug还是层出不穷，有很多细节的东西没有考虑到，最坑的是投稿的功能了，需要上传文件，同时，
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>数据结构|队列</title>
    <link href="http://yoursite.com/2017/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2017/11/12/数据结构-队列/</id>
    <published>2017-11-11T23:36:59.000Z</published>
    <updated>2017-12-08T16:46:17.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列简介"><a href="#队列简介" class="headerlink" title="队列简介"></a>队列简介</h3><h4 id="队列的特点"><a href="#队列的特点" class="headerlink" title="队列的特点"></a>队列的特点</h4><p>队列 (Queue) 与栈一样，是一种线性存储结构，它具有如下特点： </p>
<ol>
<li>队列中的数据元素遵循 “先进先出”（First In First Out）的原则</li>
<li>在队尾添加元素，在队头删除元素</li>
</ol>
<p>简单点说，队列就像排队打饭一样，先来的先打饭，后来的在队尾后面排队，等前面的人打好，才轮到自己。</p>
<h4 id="队列的相关概念"><a href="#队列的相关概念" class="headerlink" title="队列的相关概念"></a>队列的相关概念</h4><ol>
<li>队头与队尾：允许元素插入的一端称为队尾，允许元素删除的一端称为队头</li>
<li>入队：队列的插入操作</li>
<li>出队：队列的删除操作</li>
</ol>
<p>例如，我们有一个存储整型元素的队列，我们依次入队：{ 1,2,3 }</p>
<p><img src="/images/610439-20160130151830318-592472607.png" alt="enter description here" title="610439-20160130151830318-592472607"></p>
<p>添加元素时，元素只能从队尾一端进入队列，也就是说2只能跟在1后面，3只能跟在2后面。</p>
<p>出队的顺序是这样的：</p>
<p><img src="/images/610439-20160130151820974-712348880.png" alt="enter description here" title="610439-20160130151820974-712348880"></p>
<p>元素只能从队首出队列，出队列的顺序为：1、2、3，与入队列时的顺序是一样的，这就是我们说的 “先进新出” 啦。</p>
<h4 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h4><p>队列通常提供的操作：</p>
<ol>
<li>入队：通常命名为push( );</li>
<li>出队：通常命名为pop( );</li>
<li>求队列中元素的个数</li>
<li>判断队列是否为空</li>
<li>获取队首元素</li>
</ol>
<h4 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h4><p>队列跟栈一样，都是一种特殊的线性结构，因此可以使用数组、链表作为底层的数据结构。</p>
<h3 id="基于数组的循环队列实现"><a href="#基于数组的循环队列实现" class="headerlink" title="基于数组的循环队列实现"></a>基于数组的循环队列实现</h3><p>以数组作为底层数据结构时，一般讲的队列为<strong>循环队列</strong>。这是因为队列在顺序存储上的不足：每次从数组头部删除元素（出队）后，需要将头部以后的所有元素往前移动一个位置，这是一个时间复杂度为O（n）的操作，代价挺大的。</p>
<p><img src="/images/610439-20160130152004193-1945216114.png" alt="enter description here" title="610439-20160130152004193-1945216114"></p>
<p>可能有人说，把队首标志往后移不就不用移动元素了吗？的确，但那样会造成数组空间的 “流失”。我们希望队列的插入与删除操作O(1)的时间复杂度，同时不会造成数组空间的浪费，我们应该使用循环队列。所谓的循环队列，可以把数组看成一个首尾相连的圆环，删除元素是将队首标志往后移动，添加元素是若数组尾部已经没有空间，则考虑数组首部的空间是否空闲，如果是，则在数组头部进行插入。</p>
<p><img src="/images/610439-20160130152048146-364086587.png" alt="enter description here" title="610439-20160130152048146-364086587"></p>
<p>那么问题来啦,我们怎么区别空队列和队列已满这两种状态呢？</p>
<ol>
<li>栈空：队首标志 = 队尾标志是，表示栈空，即红绿两个标志在图中重叠是为栈空。</li>
<li>栈满：队尾+1 = 队首时，表示栈空。图三最下面的队列极为一个满队列。尽管还有一个空位，但我们不存储元素。</li>
</ol>
<h4 id="循环队列的抽象数据类型"><a href="#循环队列的抽象数据类型" class="headerlink" title="循环队列的抽象数据类型"></a>循环队列的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">class LoopQueue</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    LoopQueue(int c = 10);</div><div class="line">    ~LoopQueue();</div><div class="line">public:</div><div class="line">    bool isEmpty();        //队列的判空</div><div class="line">    int size();            //队列的大小</div><div class="line">    bool push(T t);        //入队列</div><div class="line">    bool pop();            //出队列</div><div class="line">    T front();            //队首元素</div><div class="line"> </div><div class="line">private:</div><div class="line">    int capacity;</div><div class="line">    int begin;</div><div class="line">    int end;</div><div class="line">    T*  queue;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>begin：队首标志</li>
<li>end：队尾标志</li>
<li>c\apacity：数组容量</li>
<li>queue：数组</li>
</ol>
<h4 id="队列的具体实现"><a href="#队列的具体实现" class="headerlink" title="队列的具体实现"></a>队列的具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">LoopQueue&lt;T&gt;::LoopQueue(int c = 10)</div><div class="line">: capacity(c), begin(0), end(0), queue(nullptr)</div><div class="line">&#123;</div><div class="line">    queue = new T[capacity];</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template&lt;typename T&gt;</div><div class="line">LoopQueue&lt;T&gt;::~LoopQueue()</div><div class="line">&#123;</div><div class="line">    delete[]queue;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">bool LoopQueue&lt;T&gt;::isEmpty()</div><div class="line">&#123;</div><div class="line">    if (begin == end)</div><div class="line">        return true;</div><div class="line">    return false;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template&lt;typename T&gt;</div><div class="line">int LoopQueue&lt;T&gt;::size()</div><div class="line">&#123;</div><div class="line">    return (end-begin+capacity)%capacity; //计算队列长度</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template&lt;typename T&gt;</div><div class="line">bool LoopQueue&lt;T&gt;::push(T t)</div><div class="line">&#123;</div><div class="line">    if (end + 1 % capacity == begin) //判断队列是否已满</div><div class="line">    &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    queue[end] = t;</div><div class="line">    end = (end + 1) % capacity;</div><div class="line">    return true;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">bool LoopQueue&lt;T&gt;::pop()</div><div class="line">&#123;</div><div class="line">    if (end == begin) //判断队列是否为空</div><div class="line">    &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    begin = (begin + 1) % capacity;</div><div class="line">    return true;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">T LoopQueue&lt;T&gt;::front()</div><div class="line">&#123;</div><div class="line">    if (end == begin)</div><div class="line">    &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return queue[begin];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="基于链表的队列实现"><a href="#基于链表的队列实现" class="headerlink" title="基于链表的队列实现"></a>基于链表的队列实现</h3><p>链队列是基于链表实现的队列，它不存在数组 O(n) 的元素移动问题或空间浪费问题。我们所要确定的就是链表那头做队首，那头做队尾。考虑到链表的特点，以链表头部作为队首，尾部作为队尾是最适合的。由于插入是在尾部，所以存储一个指向队尾的指针，可以节省遍历找队尾的时间，方便从链表尾部插入数据；使用带头节点的链表，方便从链表头删除元素。</p>
<p><img src="/images/610439-20160130152133068-1288144578.png" alt="enter description here" title="610439-20160130152133068-1288144578"></p>
<h4 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">struct Node</div><div class="line">&#123;</div><div class="line">    Node(T t) :value(t), next(nullptr)&#123;&#125;</div><div class="line">    Node() = default;</div><div class="line"> </div><div class="line">    T value;</div><div class="line">    Node&lt;T&gt; * next;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>vaule : 链表节点的值</li>
<li>next : 指针，指向下一个节点</li>
</ol>
<h4 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">class LinkQueue</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    LinkQueue();</div><div class="line">    ~LinkQueue();</div><div class="line"> </div><div class="line">    bool isEmpty();</div><div class="line">    int size();</div><div class="line">    bool pop();</div><div class="line">    void push(T t);</div><div class="line">    T front();</div><div class="line"> </div><div class="line">private:</div><div class="line">    Node&lt;T&gt;* phead;</div><div class="line">    Node&lt;T&gt;* pend;</div><div class="line">    int count;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="队列的具体实现-1"><a href="#队列的具体实现-1" class="headerlink" title="队列的具体实现"></a>队列的具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">LinkQueue&lt;T&gt;::LinkQueue()</div><div class="line">    :phead(nullptr),pend(nullptr),count(0)</div><div class="line">&#123;</div><div class="line">    phead = new Node&lt;T&gt;();</div><div class="line">    pend = phead;</div><div class="line">    count = 0;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">LinkQueue&lt;T&gt;::~LinkQueue()</div><div class="line">&#123;</div><div class="line">    while (phead-&gt;next != nullptr)</div><div class="line">    &#123;</div><div class="line">        Node&lt;T&gt; * pnode = phead;</div><div class="line">        phead = phead-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">bool LinkQueue&lt;T&gt;:: isEmpty()</div><div class="line">&#123;</div><div class="line">    return count==0;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">int LinkQueue&lt;T&gt;::size()</div><div class="line">&#123;</div><div class="line">    return count;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">//在队尾插入</div><div class="line">template &lt;typename T&gt;</div><div class="line">void LinkQueue&lt;T&gt;::push(T t)</div><div class="line">&#123;</div><div class="line">    Node&lt;T&gt;* pnode = new Node&lt;T&gt;(t);</div><div class="line">    pend-&gt;next = pnode;</div><div class="line">    pend = pnode;</div><div class="line">    count++;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">//在队首弹出</div><div class="line">template &lt;typename T&gt;</div><div class="line">bool LinkQueue&lt;T&gt;::pop()</div><div class="line">&#123;</div><div class="line">    if (count == 0)</div><div class="line">        return false;</div><div class="line">    Node&lt;T&gt;* pnode = phead-&gt;next;</div><div class="line">    phead-&gt;next = phead-&gt;next-&gt;next;</div><div class="line">    delete pnode;</div><div class="line">    count--;</div><div class="line">    return true;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">//获取队首元素</div><div class="line">template&lt;typename T&gt;</div><div class="line">T LinkQueue&lt;T&gt;::front()</div><div class="line">&#123;</div><div class="line">    return phead-&gt;next-&gt;value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;队列简介&quot;&gt;&lt;a href=&quot;#队列简介&quot; class=&quot;headerlink&quot; title=&quot;队列简介&quot;&gt;&lt;/a&gt;队列简介&lt;/h3&gt;&lt;h4 id=&quot;队列的特点&quot;&gt;&lt;a href=&quot;#队列的特点&quot; class=&quot;headerlink&quot; title=&quot;队列的特点&quot;&gt;
    
    </summary>
    
      <category term="DataStruct" scheme="http://yoursite.com/categories/DataStruct/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构|栈</title>
    <link href="http://yoursite.com/2017/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>http://yoursite.com/2017/11/11/数据结构-栈/</id>
    <published>2017-11-11T00:30:21.000Z</published>
    <updated>2017-12-08T16:45:54.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈的简介"><a href="#栈的简介" class="headerlink" title="栈的简介"></a>栈的简介</h3><h4 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h4><p>栈（Stack）是一种特殊的线性存储结构，它具有一下特点：</p>
<ol>
<li>栈中的数据元素遵守 “先进后出(First In Last Out)”的yuanze</li>
<li>限定只能在栈顶进行插入和删除操作</li>
</ol>
<h4 id="栈的相关概念"><a href="#栈的相关概念" class="headerlink" title="栈的相关概念"></a>栈的相关概念</h4><ol>
<li>栈顶与栈底：允许元素插入与删除的一端称为栈顶，另一端称为栈底。</li>
<li>压栈：栈的插入操作，叫做进栈，也称压栈、入栈</li>
<li>弹栈：栈的删除操作，也叫做出栈</li>
</ol>
<p>例如我们有一个存储整型元素的栈，我们依次压出：｛1，2，3｝</p>
<p><img src="/images/610439-20160130013806989-121668995.png" alt="enter description here" title="610439-20160130013806989-121668995"></p>
<p>在压栈的过程中，栈顶的位置一直 “向上 ” 移动，而栈底是固定不变的，也就是说我们只在线性表的一端执行操作。</p>
<p>如果我们要把栈中的元素弹出来：</p>
<p><img src="/images/610439-20160130013814661-295746330.png" alt="enter description here" title="610439-20160130013814661-295746330"></p>
<p>出栈的顺序为 3、2、1 ，顺序与入栈时相反，这也就是栈的特点之一：先入后出。弹栈过程中，栈顶的位置一直在“向下移动”，而栈底一直保持不变。</p>
<p>如果你玩过一种称为汉诺塔的益智玩具，你就会知道游戏中小圆盘的存取就是一种先进后出的顺序，一个圆柱就是一个栈：</p>
<p><img src="/images/610439-20160130013821489-1542512229.png" alt="enter description here" title="610439-20160130013821489-1542512229"></p>
<h4 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h4><p>栈的常用操作为：</p>
<ol>
<li>弹栈，通常命名为 pop()</li>
<li>压栈，通常命名为push()</li>
<li>求栈的大小</li>
<li>判断栈是否为空</li>
<li>获取栈顶的元素</li>
</ol>
<h4 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h4><p>前面有说过，栈是一种特殊的线性表，那栈的存储结构就跟线性表是一样的，可以用数组或链表作为底层实现了。</p>
<p>本文我们以数组和单链表作为底层数据结构实现栈。</p>
<h3 id="基于数组的栈实现"><a href="#基于数组的栈实现" class="headerlink" title="基于数组的栈实现"></a>基于数组的栈实现</h3><p>当一数组为底层结构时，通常一数组头作为栈底，数组头数组尾为栈顶的方向：</p>
<p><img src="/images/610439-20160130013928458-208656397.png" alt="enter description here" title="610439-20160130013928458-208656397"></p>
<h4 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">class ArrayStack</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    ArrayStack(int s = 10);    //默认的栈容量为10</div><div class="line">    ~ArrayStack();</div><div class="line"> </div><div class="line">public:</div><div class="line">    T top();            //获取栈顶元素</div><div class="line">    void push(T t);        //压栈操作</div><div class="line">    T pop();            //弹栈操作</div><div class="line">    bool isEmpty();        //判空操作</div><div class="line">    int size();            //求栈的大小</div><div class="line"> </div><div class="line">private:</div><div class="line">    int count;            //栈的元素数量</div><div class="line">    int capacity;        //栈的容量</div><div class="line">    T * array;            //底层为数组</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>count 为栈的元素数量，capacity为栈的容量，count&lt;=capacity，当栈满的时候，count = capacity。</li>
<li>本实现中不支持栈的动态扩容，栈满的时候无法再插入元素。栈的容量在定义栈的时候就需要指定，默认的栈容量为10。</li>
</ol>
<h4 id="栈的具体实现"><a href="#栈的具体实现" class="headerlink" title="栈的具体实现"></a>栈的具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"> /*栈的判空操作*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">bool ArrayStack&lt;T&gt;::isEmpty()</div><div class="line">&#123;</div><div class="line">     return count == 0; //栈元素为0时为栈空</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">/*返回栈的大小*/</div><div class="line"> template &lt;typename  T&gt;</div><div class="line">int ArrayStack&lt;T&gt;::size()</div><div class="line">&#123;</div><div class="line">     return count;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">/*插入元素*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">void ArrayStack&lt;T&gt;::push(T t)</div><div class="line">&#123;</div><div class="line">     if (count != capacity)    //先判断是否栈满</div><div class="line">     &#123;</div><div class="line">         array[count++] = t;   </div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">/*弹栈*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">T ArrayStack&lt;T&gt;::pop()</div><div class="line">&#123;</div><div class="line">     if (count != 0)    //先判断是否是空栈</div><div class="line">     &#123;</div><div class="line">         return array[--count];</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">/*获取栈顶元素*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">T ArrayStack&lt;T&gt;::top()</div><div class="line">&#123;</div><div class="line">     if (count != 0)</div><div class="line">     &#123;</div><div class="line">         return array[count - 1];</div><div class="line">     &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="基于单链表的栈"><a href="#基于单链表的栈" class="headerlink" title="基于单链表的栈"></a>基于单链表的栈</h3><p>以链表为底层的数据结构时，以链表头为作为栈顶较为合适，这样方便节点的插入与删除。压栈产生的新节点将一直出现在链表的头部</p>
<p><img src="/images/610439-20160130013944943-399164407.png" alt="enter description here" title="610439-20160130013944943-399164407"></p>
<h4 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*链表节点结构*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">struct Node</div><div class="line">&#123;</div><div class="line">    Node(T t) :value(t), next(nullptr)&#123;&#125;;</div><div class="line">    Node() :next(nullptr)&#123;&#125;;</div><div class="line"> </div><div class="line">public:</div><div class="line">    T value;</div><div class="line">    Node&lt;T&gt;* next;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>value:栈中元素的值</li>
<li>next:链表节点指针，指向直接后继</li>
</ol>
<h4 id="栈的抽象数据类型-1"><a href="#栈的抽象数据类型-1" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">*栈的抽象数据结构*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">class LinkStack</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     LinkStack();</div><div class="line">     ~LinkStack();</div><div class="line">public:</div><div class="line"> </div><div class="line">     bool isEmpty();</div><div class="line">     int size();</div><div class="line">     void push(T t);</div><div class="line">     T pop();</div><div class="line">     T top();</div><div class="line"> </div><div class="line">private:</div><div class="line"> </div><div class="line">     Node&lt;T&gt;* phead;</div><div class="line">     int count;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="栈的具体实现-1"><a href="#栈的具体实现-1" class="headerlink" title="栈的具体实现"></a>栈的具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/*返回栈的大小*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">int LinkStack&lt;T&gt;::size()</div><div class="line">&#123;</div><div class="line">     return count;</div><div class="line">&#125;;</div><div class="line">/*栈的判空操作*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">bool LinkStack&lt;T&gt;::isEmpty()</div><div class="line">&#123;</div><div class="line">     return count == 0;</div><div class="line">&#125;;</div><div class="line">/*插入元素*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">void LinkStack&lt;T&gt;::push(T t)</div><div class="line">&#123;</div><div class="line">     Node &lt;T&gt; *pnode = new  Node&lt;T&gt;(t);</div><div class="line">     pnode-&gt;next = phead-&gt;next;</div><div class="line">     phead-&gt;next = pnode;</div><div class="line">     count++;</div><div class="line">&#125;;</div><div class="line">/*弹栈*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">T LinkStack&lt;T&gt;::pop()</div><div class="line">&#123;</div><div class="line">     if (phead-&gt;next != nullptr) //栈空判断</div><div class="line">     &#123;</div><div class="line">         Node&lt;T&gt;* pdel = phead-&gt;next;</div><div class="line">         phead-&gt;next = phead-&gt;next-&gt;next;</div><div class="line">         T value = pdel-&gt;value;</div><div class="line">         delete pdel;</div><div class="line">         count--;</div><div class="line">         return value;</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">/*获取栈顶元素*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">T LinkStack&lt;T&gt;::top()</div><div class="line">&#123;</div><div class="line">    if (phead-&gt;next!=nullptr)</div><div class="line">        return phead-&gt;next-&gt;value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>参考 <a href="http://www.cnblogs.com/QG-whz/p/5170418.html" target="_blank" rel="external">http://www.cnblogs.com/QG-whz/p/5170418.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;栈的简介&quot;&gt;&lt;a href=&quot;#栈的简介&quot; class=&quot;headerlink&quot; title=&quot;栈的简介&quot;&gt;&lt;/a&gt;栈的简介&lt;/h3&gt;&lt;h4 id=&quot;栈的特点&quot;&gt;&lt;a href=&quot;#栈的特点&quot; class=&quot;headerlink&quot; title=&quot;栈的特点&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="DataStruct" scheme="http://yoursite.com/categories/DataStruct/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构|线性表</title>
    <link href="http://yoursite.com/2017/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/10/26/数据结构-线性表/</id>
    <published>2017-10-25T22:34:11.000Z</published>
    <updated>2017-12-08T16:44:56.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表"></a>什么是线性表</h3><p>线性表是一种线性结构，它是由零个和多个数据元素元素构成的有序序列。线性表的特征是在一个序列中，除了头尾元素，每个元素都有且只有一个直接前驱，有且只有一个直接后继，而序列头元素没有直接前驱，序列尾元素没有直接后继。<br>数据结构中常见的线性结构有数组、单链表、双链表、循环链表等。线性表中的元素为某种相同的抽象数据类型。可以是C语言的内置类型或结构体，也可以是C++自定义类型。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组在实际的物理内存上也是连续存储的。如果我们用C语言声明一个数组，如：int  array[7]  = {1,2,3,4,5,6,7} ;则他们在在内存中就类似下图：</p>
<p><img src="/images/610439-20160129211728583-2081927870.png" alt="enter description here" title="610439-20160129211728583-2081927870">  </p>
<p>通过上图我们也能得知：当我们声明一个数组时，也就相当于在内存中开辟了一段连续的内存地址。这是数组最重要的性质，有了这个性质，我们就能通过下标很快的访问到数组中的元素，访问速度快的数组的很大的优点。同时，数组分为固定数组与动态数组。其中固定数组的大小必须在编译时就能够确认，动态数组允许在运行时申请数组内存。复杂点的数组是多维数组，多维数组实际上也是通过一维数组来实现的。在C语言中，可以通过malloc来分配动态数组，C+ +使用new。另外，C++的标准模板库提供了动态数组类型vector以及内置有固定数组类型array。 </p>
<p> 用数组实现线性表，会有很快的访问速度，但我们要插入呢？岂不是要把插入位置之后的数据都往后移动一位呢？再说删除，岂不是也要把删除之后的元素前移一位呢？这就很麻烦。还有一个一个问题是：如果我们不知道我们有多少元素时，我们要事先声明多大的数组呢？多了，会浪费空间，少了，就需要扩容，扩容就需要重新声明一个数组，再把数据复制到新的数组中，这也是一个耗时的操作噢。</p>
<p> 总之， 用数组实现线性表有利有弊， 需要根据实际问题来确定是否使用。 </p>
<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>前面提到了数组插入和删除麻烦和需要提前确定大小这些不足，那么有没有其他好的替代品呢？ 有的，那就是用链表来实现的线性表。单向链表是链表的一种。链表由节点所构成，节点内含一个指向下一个节点的指针，节点依次链接成为链表。因此，链表这种数据结构通常在物理内存上是不连续的。链表的通常含有一个头节点，头节点不存放实际的值，它含有一个指针，指向存放元素的第一个节点。那也就是说，在内存允许的情况下，我们需要添加节点的时候，就只需要把链表最后的节点的指针指向新的节点。简单点说，我们可以不用事先确定线性表的大小了，可以按需分配了，可喜可贺啊。</p>
<p><img src="/images/610439-20160129211741349-1771220512.png" alt="enter description here" title="610439-20160129211741349-177122051"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//节点结构</div><div class="line">template &lt;typename T&gt;</div><div class="line">class Node</div><div class="line">&#123;</div><div class="line">public :</div><div class="line">    T _value;</div><div class="line">    Node* _next;</div><div class="line">public:</div><div class="line">    Node() = default;</div><div class="line">    Node(T value, Node * next)</div><div class="line">        : _value(value), _next(next)&#123;&#125;</div><div class="line">&#125;;</div><div class="line">_value: 节点的值</div><div class="line">_next： 指针，指向下一个节点</div></pre></td></tr></table></figure>
<h4 id="单链表ADT"><a href="#单链表ADT" class="headerlink" title="单链表ADT"></a>单链表ADT</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">class SingleLink</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    typedef Node&lt;T&gt;*  pointer;</div><div class="line">    SingleLink();</div><div class="line">    ~SingleLink();</div><div class="line"> </div><div class="line">    int size();                         //获取长度</div><div class="line">    bool isEmpty();                     //判空</div><div class="line"> </div><div class="line">    Node&lt;T&gt;* insert(int index, T t); //在指定位置进行插入</div><div class="line">    Node&lt;T&gt;* insert_head(T t);         //在链表头进行插入</div><div class="line">    Node&lt;T&gt;* insert_last(T t);         //在链表尾进行插入</div><div class="line"> </div><div class="line">    Node&lt;T&gt;*  del(int index);         //在指定位置进行删除</div><div class="line">    Node&lt;T&gt;*  delete_head();         //删除链表头</div><div class="line">    Node&lt;T&gt;*  delete_last();         //删除链表尾</div><div class="line"> </div><div class="line">    T get(int index);                 //获取指定位置的元素</div><div class="line">    T get_head();                     //获取链表头元素</div><div class="line">    T get_last();                     //获取链表尾元素</div><div class="line"> </div><div class="line">    Node&lt;T&gt;* getHead();                 //获取链表头节点</div><div class="line"> </div><div class="line">private :</div><div class="line">    int count;</div><div class="line">    Node&lt;T&gt; * phead;                </div><div class="line"> </div><div class="line">private :</div><div class="line">    Node&lt;T&gt; * getNode(int index);      //获取指定位置的节点</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="单链表添加"><a href="#单链表添加" class="headerlink" title="单链表添加"></a>单链表添加</h4><p>链表的插入元素操作时间复杂度O（1），只需要进行指针的指向修改操作。</p>
<p><img src="/images/610439-20160129211802552-1568099093.png" alt="enter description here" title="610439-20160129211802552-1568099093"></p>
<p>在2之后添加7：</p>
<ul>
<li>为元素7构建节点 。</li>
<li>将节点2 的next指针指向节点7。</li>
<li>将节点7的next指向节点3。（节点3 的位置要先保留起来）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">在指定位置插入新节点</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* SingleLink&lt;T&gt;::insert(int index, T t)</div><div class="line">&#123;</div><div class="line">    Node&lt;T&gt; * preNode = getNode(index);</div><div class="line">    if (preNode)</div><div class="line">    &#123;</div><div class="line">        Node&lt;T&gt; *newNode = new Node&lt;T&gt;(t,preNode-&gt;_next);</div><div class="line">        preNode-&gt;_next = newNode;</div><div class="line">        count++;</div><div class="line">        return newNode;</div><div class="line">    &#125;</div><div class="line">    return nullptr;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">从头部插入</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* SingleLink&lt;T&gt;::insert_head(T t)</div><div class="line">&#123;</div><div class="line">    return insert(0, t);</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">从尾部进行插入</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* SingleLink&lt;T&gt;::insert_last(T t)</div><div class="line">&#123;</div><div class="line">    return insert(count, t);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="单链表删除节点"><a href="#单链表删除节点" class="headerlink" title="单链表删除节点"></a>单链表删除节点</h4><p>单链表的删除操作同样是一个时间复杂度O（1）的操作，它也只需要修改节点的指针指针后即可销毁被删除节点。<br>例如我们删除链表元素7：</p>
<p><img src="/images/610439-20160129211816786-1957915729.png" alt="enter description here" title="610439-20160129211816786-1957915729"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">删除链表指定位置元素</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* SingleLink&lt;T&gt;::del(int index)</div><div class="line">&#123;</div><div class="line">    if (isEmpty())</div><div class="line">        return nullptr;</div><div class="line">    Node&lt;T&gt;* ptrNode = getNode(index);</div><div class="line">    Node&lt;T&gt;* delNode = ptrNode-&gt;_next;</div><div class="line">    ptrNode-&gt;_next = delNode-&gt;_next;</div><div class="line">    count--;</div><div class="line">    delete delNode;</div><div class="line">    return ptrNode-&gt;_next;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">删除头节点</div><div class="line">*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* SingleLink&lt;T&gt;::delete_head()</div><div class="line">&#123;</div><div class="line">    return del(0);</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">删除尾节点</div><div class="line">*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">Node&lt;T&gt;*SingleLink&lt;T&gt;::delete_last()</div><div class="line">&#123;</div><div class="line">    return del(count);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单链表的节点链接是单方向的，要得到指定节点的前一个节点，必须从头遍历链表。<br>双向链表是链表的一种。与单链表一样，双向节点由节点链接而成，每个节点含有两个指针，分别指向直接前驱与直接后继。从双向链表的任何一个节点开始都能够遍历整个链表。<br>我们将双向链表实现为双向循环链表，也即是最后一个元素的后继将指向头节点，整个链表形成一个循环<br>例如，我们为元素1，2，3，4，5 构建一个双向循环链表。</p>
<p><img src="/images/610439-20160129211829474-2026702975.png" alt="enter description here" title="610439-20160129211829474-2026702975"></p>
<h4 id="双向链表节点结构"><a href="#双向链表节点结构" class="headerlink" title="双向链表节点结构"></a>双向链表节点结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">双向链表的节点结构</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">struct Node</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Node()= default;</div><div class="line">    Node(T value, Node&lt;T&gt;* preptr, Node&lt;T&gt;* nextptr)</div><div class="line">        :_value(value), pre_ptr(preptr), next_ptr(nextptr)&#123;&#125;</div><div class="line"> </div><div class="line">public:</div><div class="line">    T _value;</div><div class="line">    Node&lt;T&gt;* pre_ptr;</div><div class="line">    Node&lt;T&gt;* next_ptr;</div><div class="line">&#125;;</div><div class="line">_value: 节点元素的值</div><div class="line">pre_ptr:指向直接前驱的指针</div><div class="line">next_ptr:指向直接后继的指针</div></pre></td></tr></table></figure>
<h4 id="双向链表的抽象数据结构"><a href="#双向链表的抽象数据结构" class="headerlink" title="双向链表的抽象数据结构"></a>双向链表的抽象数据结构</h4><p>双向链表类的定义与单链表相似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 双向链表类</div><div class="line">*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">class DoubleLink</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    typedef Node&lt;T&gt;* pointer;</div><div class="line">public:</div><div class="line">    DoubleLink();</div><div class="line">    ~DoubleLink()&#123;&#125;;</div><div class="line">public:</div><div class="line">    Node&lt;T&gt;* insert(int index, T value);</div><div class="line">    Node&lt;T&gt;* insert_front(T value);</div><div class="line">    Node&lt;T&gt;* insert_last(T value);</div><div class="line"> </div><div class="line">    Node&lt;T&gt;* del(int index);</div><div class="line">    Node&lt;T&gt;* delete_front();</div><div class="line">    Node&lt;T&gt;* delete_last();</div><div class="line"> </div><div class="line">    bool isEmpty();</div><div class="line">    int size();</div><div class="line"> </div><div class="line">    T get(int index);</div><div class="line">    T get_front();</div><div class="line">    T get_last();</div><div class="line">    Node&lt;T&gt;* getHead();</div><div class="line"> </div><div class="line">private:</div><div class="line">    Node&lt;T&gt;* phead;</div><div class="line">    int count;</div><div class="line">private :</div><div class="line">    Node&lt;T&gt;* getNode(int index);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="双向链表添加节点"><a href="#双向链表添加节点" class="headerlink" title="双向链表添加节点"></a>双向链表添加节点</h4><p>与单链表一样，双向链表添加节点的时间复杂度为O（1），它也只需要修改相关指针的指向。</p>
<p><img src="/images/610439-20160129211844927-167005435.png" alt="enter description here" title="610439-20160129211844927-167005435"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*将新节点插到第一个位置</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::insert_front(T value)</div><div class="line">&#123;</div><div class="line">    Node&lt;T&gt;* newNode = new Node&lt;int&gt;(value, phead, phead-&gt;next_ptr);</div><div class="line">    phead-&gt;next_ptr -&gt;pre_ptr= newNode;</div><div class="line">    phead-&gt;next_ptr = newNode;</div><div class="line">    count++;</div><div class="line">    return newNode;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">*将新节点插到链表尾部</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::insert_last(T value)</div><div class="line">&#123;</div><div class="line">    Node&lt;T&gt; * newNode = new Node&lt;int&gt;(value, phead-&gt;pre_ptr, phead);</div><div class="line">    phead-&gt;pre_ptr-&gt;next_ptr = newNode;</div><div class="line">    phead-&gt;pre_ptr = newNode;</div><div class="line">    count++;</div><div class="line">    return newNode;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">*将节点位置插到index位置之前</div><div class="line">*/</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::insert(int index, T value)</div><div class="line">&#123;</div><div class="line">    if (index == 0)</div><div class="line">        return insert_front(value);</div><div class="line"> </div><div class="line">    Node&lt;T&gt;* pNode = getNode(index);</div><div class="line">    if (pNode == nullptr)</div><div class="line">        return nullptr;</div><div class="line">    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value, pNode-&gt;pre_ptr, pNode);</div><div class="line">    pNode-&gt;pre_ptr-&gt;next_ptr = newNode;</div><div class="line">    pNode-&gt;pre_ptr = newNode;</div><div class="line">    count++;</div><div class="line"> </div><div class="line">    return newNode;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="双向链表删除节点"><a href="#双向链表删除节点" class="headerlink" title="双向链表删除节点"></a>双向链表删除节点</h4><p>双向链表的删除操作时间复杂度为O（1）.我们删除节点7：</p>
<p><img src="/images/610439-20160129211855802-449700803.png" alt="enter description here" title="610439-20160129211855802-449700803"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*删除链表第一个节点</div><div class="line">*返回删除后链表第一个节点</div><div class="line">*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::delete_front()</div><div class="line">&#123;</div><div class="line">    if (count == 0)</div><div class="line">    &#123;</div><div class="line">        return nullptr;</div><div class="line">    &#125;</div><div class="line">    Node&lt;T&gt;* pnode = phead-&gt;next_ptr;</div><div class="line">    phead-&gt;next_ptr = pnode-&gt;next_ptr;</div><div class="line">    pnode-&gt;next_ptr-&gt;pre_ptr = phead;</div><div class="line">    delete pnode;</div><div class="line">    count--;</div><div class="line">    return phead-&gt;next_ptr;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">*删除链表的末尾节点</div><div class="line">*返回删除后链表尾部元素</div><div class="line">*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::delete_last()</div><div class="line">&#123;</div><div class="line">    if (count == 0)</div><div class="line">    &#123;</div><div class="line">        return nullptr;</div><div class="line">    &#125;</div><div class="line">    Node&lt;T&gt;*pnode = phead-&gt;pre_ptr;</div><div class="line">    pnode-&gt;pre_ptr-&gt;next_ptr = phead;</div><div class="line">    phead-&gt;pre_ptr = pnode-&gt;pre_ptr;</div><div class="line">    delete pnode;</div><div class="line">    count--;</div><div class="line">    return phead-&gt;pre_ptr;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">*删除指定位置的元素</div><div class="line">*</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::del(int index)</div><div class="line">&#123;</div><div class="line">    if (index == 0)</div><div class="line">        return delete_front();</div><div class="line">    if (index == count - 1)</div><div class="line">        return delete_last();</div><div class="line">    if (index &gt;= count)</div><div class="line">        return nullptr;</div><div class="line">    Node&lt;T&gt;* pnode = getNode(index);</div><div class="line">    pnode-&gt;pre_ptr-&gt;next_ptr = pnode-&gt;next_ptr;</div><div class="line">    pnode-&gt;next_ptr-&gt;pre_ptr = pnode-&gt;pre_ptr;</div><div class="line"> </div><div class="line">    Node&lt;T&gt;* ptemp = pnode-&gt;pre_ptr;</div><div class="line">    delete pnode;</div><div class="line">    count--;</div><div class="line">    return ptemp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是线性表&quot;&gt;&lt;a href=&quot;#什么是线性表&quot; class=&quot;headerlink&quot; title=&quot;什么是线性表&quot;&gt;&lt;/a&gt;什么是线性表&lt;/h3&gt;&lt;p&gt;线性表是一种线性结构，它是由零个和多个数据元素元素构成的有序序列。线性表的特征是在一个序列中，除了头尾元素，
    
    </summary>
    
      <category term="DataStruct" scheme="http://yoursite.com/categories/DataStruct/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>生活|58到家面试</title>
    <link href="http://yoursite.com/2017/10/24/%E7%94%9F%E6%B4%BB-58%E5%88%B0%E5%AE%B6%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2017/10/24/生活-58到家面试/</id>
    <published>2017-10-24T00:14:57.000Z</published>
    <updated>2017-10-26T14:24:23.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 在上周，学长（王自琰）回校宣讲，我就自告奋勇把简历给他了，说实话，效率挺高啊，第二天就叫去面试了。说是周五，但自己有课，就跟Hr说换时间，就订在周一了。</p>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p> 58到家在一个软件园里，门卫叔叔说里面有二十栋楼，每一栋都是一个公司基本。这是自己到这种地方，有点小激动啊。然后摸索着找到了17栋，58所在地。然后填表，开始面试。</p>
<p> 来的可能是一个Leader。然后我们两个就坐在等待区，开始 “交谈” 。面试官看起来挺好的，看了一下我的简历，然后看我做过的项目，看到一个专业名词就问一下。比如说看到 Ajax ,就会问你 Ajax 的实现原理，还叫我画了数据交互的过程；看到 MVC 就叫你说一下对 MVC 的理解；看到数据库，就会问你数据库的操作，原理…；还有就是如果看到比较难的功能点，也会停下来问你这个功能点是如何实现的。<strong>总的说，你写的简历，就是你自己给自己挖的坑。</strong></p>
<p>在这次简历中，自己就给自己挖了一个大坑：写了一个照书上一步步来完成的成绩管理系统。然后还说自己学到了如何分析系统功能、怎么设计系统架构及数据库，这个坑足够大啊。面试官就在这里开始发问了，然后才发现自己并不是真正的懂，答非所问了，哎，自己挖的坑还是要自己跳啊。好不容易混过系统这一关了，接着是数据库，先叫你画 ER 图，然后简单描述下各表关系，再接着就是一些数据库的操作，什么排序啊、多表连接啊… 由于多表连接这个自己不是经常用，也栽了。最后，由于这个项目是用Java弄的，面试官又开始问你一些 Java 的东西了，然后问int，double…的范围，说真心话，自己对这些基础的东西真的不是很不不上心，又栽了。</p>
<p>最后是JavaWeb方面的东西，看到了 JSP和Servlet，然后问你这两者的关系、Servlet有那些方法，怪自己没学透啦，再一次栽了。然后，我们说了一些框架的学习方面的东西，这时候是一起交流的阶段，就像是老师和学生那样，在学习的过程中遇到的问题，可以问面试官，大家一起交流，感觉挺好。</p>
<p>然后，面试就结束了，估计这一次是没希望啦，但自己要的就是面试的这一个过程，加油。遗憾的是，最后没有问面试官觉得自己怎么样。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这可以说是自己真正意义上的技术面试，加油，小智。<br><img src="/images/IMG_20171023_154930.jpg" alt="在软件园" title="IMG_20171023_154930"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt; 在上周，学长（王自琰）回校宣讲，我就自告奋勇把简历给他了，说实话，效率挺高啊，第二天就叫去面试了。说是周五，但自己有课，就跟Hr说换时间，
    
    </summary>
    
      <category term="college" scheme="http://yoursite.com/categories/college/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>PHP|Slim入门demo</title>
    <link href="http://yoursite.com/2017/10/12/PHP-Slim%E5%85%A5%E9%97%A8demo/"/>
    <id>http://yoursite.com/2017/10/12/PHP-Slim入门demo/</id>
    <published>2017-10-12T08:44:11.000Z</published>
    <updated>2017-10-12T01:43:52.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>暑假在弦歌开发新生宝典的时候，就接触到Slim这个框架，但当时自己并没有深入了解，因为环境这些都是学长们搭的，我自己只需要写好自己的业务逻辑部分就好了，所以不深入理解也不影响工作。新学期开始，学长要求继续晚上新生宝典，也就是说重构，既然这样，那就需要深入了解Slim了。在一次读源码，感觉还是有很多问题需要解决,比如说：Slim是怎么实现路由转发的？Slim是怎么实现数据库连接的？Slim的作用是什么？给我们带来了什么样的方便之处？</p>
<h3 id="什么是Slim"><a href="#什么是Slim" class="headerlink" title="什么是Slim"></a>什么是Slim</h3><p>官方解释：Slim是一款 PHP 微框架，可以帮助你快速编写简单但功能强大的 web 应用和 API 。在它的核心，Slim 是一个调度程序，它接收一个 HTTP 请求，调用一个适当的回调例程，然后返回一个 HTTP 响应。我个人的理解是这样的：Slim帮我们把客户端的请求与响应封装起来，让我们不用去关心请求与响应，只需要关心业务逻辑部分，简单点说，就只需要处理好数据的响应。一个 Slim 应用包含多个响应特定 HTTP 请求的路由。每个路由调用一个回调并返回一个 HTTP 响应。</p>
<h3 id="怎么安装Slim"><a href="#怎么安装Slim" class="headerlink" title="怎么安装Slim"></a>怎么安装Slim</h3><p>官方推荐使用composer安装，自己也是因此而接触到composer，不用不知道，觉得这个工具挺好的，值得推荐。Slim的安装非常简单，只需要在我们的项目根目录中，运行以下 bash 命令，就可以将最新的稳定版安装到项目的 vendor/ 目录中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer require slim/slim &quot;^3.0&quot;</div></pre></td></tr></table></figure>
<p>举个例子，比如说我们的项目是SlimDemo，我们就只需要在SlimDemo的目录下运行上述命令，就能下载安装Slim了，同时你会发现SlimDemo目录下会出现vendor文件夹、composer.json文件和composer.lock文件。此时，恭喜你安装成功了。</p>
<h3 id="运行Slim"><a href="#运行Slim" class="headerlink" title="运行Slim"></a>运行Slim</h3><p>就用我自己的例子给大家讲解一下吧：</p>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p>项目的文件目录推荐如下：#表示一级目录，##表示二级目录</p>
<p>#app    —-项目主要目录</p>
<p>##routes.php    —-定义路由</p>
<p>##function.php  —-功能函数</p>
<p>#public    —-用户可以访问的目录</p>
<p>##index.php    —-index页面</p>
<p>#vendor    —-使用composer自动生成的目录</p>
<p>##composer.json    —-composer配置文件</p>
<p>##composer.lock    —-composer文件不需要管</p>
<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>按照上面的目录结构创建文件的目录app和public，vendor目录使用composer命令自动生成，所以不需要我们创建。</p>
<h5 id="编辑index-php文件"><a href="#编辑index-php文件" class="headerlink" title="编辑index.php文件"></a>编辑index.php文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">use \Psr\Http\Message\ServerRequestInterface as Request;</div><div class="line">use \Psr\Http\Message\ResponseInterface as Response;</div><div class="line"></div><div class="line">require &apos;../vendor/autoload.php&apos;;   //添加Slim</div><div class="line">require &apos;../app/function.php&apos; ;        //添加功能函数</div><div class="line"></div><div class="line">$app = new \Slim\App;</div><div class="line"></div><div class="line">require &apos;../app/routes.php&apos;;            //添加路由管理</div><div class="line"></div><div class="line">$app-&gt;run();                            //执行</div></pre></td></tr></table></figure>
<h5 id="添加路由管理文件"><a href="#添加路由管理文件" class="headerlink" title="添加路由管理文件"></a>添加路由管理文件</h5><p>在app文件夹里面创建routes.php文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$app-&gt;get(&apos;/hello&apos;,&apos;sayHello&apos;);//get方法路由，并回调sayHello方法</div></pre></td></tr></table></figure>
<h5 id="添加function-php"><a href="#添加function-php" class="headerlink" title="添加function.php"></a>添加function.php</h5><p>我们设置了路由调用 sayHello 函数，所以我们现在在function.php 文件中添加 sayHello函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function syaHello($request, $response, $args)&#123;</div><div class="line">   echo &quot;Hello World&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，我们的小demo就好啦，打开服务器，在浏览器中输入： <a href="http://127.0.0.1/SlimDemo/public/index.php/hello" target="_blank" rel="external">http://127.0.0.1/SlimDemo/public/index.php/hello</a> ;就能输出 Hello World啦。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h3 id="安装Composer"><a href="#安装Composer" class="headerlink" title="安装Composer"></a>安装Composer</h3><ul>
<li><p>下载<br>在终端执行curl -sS <a href="https://getcomposer.org/installer" target="_blank" rel="external">https://getcomposer.org/installer</a> | php下载composer</p>
</li>
<li><p>设置</p>
</li>
</ul>
<p>将Composer设置为全局运行程序方便使用,执行mv composer.phar /usr/local/bin/composer</p>
<ul>
<li>测试</li>
</ul>
<p>执行composer -v,如果能查看到版本信息，则说明安装成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;暑假在弦歌开发新生宝典的时候，就接触到Slim这个框架，但当时自己并没有深入了解，因为环境这些都是学长们搭的，我自己只需要写好自己的业务逻辑
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="Slim" scheme="http://yoursite.com/tags/Slim/"/>
    
  </entry>
  
  <entry>
    <title>游玩|2017国庆</title>
    <link href="http://yoursite.com/2017/10/10/%E6%B8%B8%E7%8E%A9-2017%E5%9B%BD%E5%BA%86/"/>
    <id>http://yoursite.com/2017/10/10/游玩-2017国庆/</id>
    <published>2017-10-09T23:06:50.000Z</published>
    <updated>2017-12-08T16:45:20.477Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h3><p>高中那会，就想着在大学的时候，要多走走，了解外面的世界是怎么样的…</p>
<h3 id="八班国庆小分队"><a href="#八班国庆小分队" class="headerlink" title="八班国庆小分队"></a>八班国庆小分队</h3><p>不知为何，很多人都想来长沙玩，说实话，确实不知道长沙有什么好玩的，这是个无解的问题。就连我远在大连和吉林的同学都过来了，坐30个小时的绿皮车过来确实不容易啊。人家大老远过来，怎么着也不能让人家留有遗憾，所以就带这几个哥们去凤凰古城玩一波啦，去之前听人家说那边挺美的，去之后，应该也算挺美的吧。先来几张图吧：<br><img src="/images/1507427701193.jpeg" alt="enter description here" title="1507427701193"><br><img src="/images/IMG_20171003_223043.jpg" alt="enter description here" title="IMG_20171003_223043"><br><img src="/images/IMG_20171003_211350.jpg" alt="enter description here" title="IMG_20171003_211350"></p>
<p>哈哈，不骗你吧，在城市久了，到了这古镇，还是会有另一番韵味的。</p>
<h3 id="坐车恐惧症"><a href="#坐车恐惧症" class="headerlink" title="坐车恐惧症"></a>坐车恐惧症</h3><p>不骗你，去一趟凤凰回来，我对大巴车有了一种恐惧感。为什么呢？就是坐车多了，怕了呗。我的天，从长沙到凤凰，需要做6个小时的大巴车，要注意的是六个小时是开的比较快的情况下，如果司机技术不是很好，那就好坐七八个小时了。长这么大，这是坐车最久的一次了。我们早上七点出发，到下午3点才到，途中还只能吃方便面充饥，那个酸楚不是能想象的到的。坐车的时候，真后悔出来玩啊，在宿舍带着多好，何必来受这份罪呢？还好景色不让我失望，不然这会是一个悲惨的国庆。</p>
<h3 id="在凤凰"><a href="#在凤凰" class="headerlink" title="在凤凰"></a>在凤凰</h3><p>两天时间，在车上就度过了一天，留给我们的就只有一天的时间了。到了之后，就找酒店放行李，然后大吃一餐，那叫一个爽啊。接着，我们就去看篝火晚会，去之前，意为会想电视上那样一群人围着火坐一圈，然后大碗喝酒大口吃肉呢。现实是这样的，大家确实是围着火坐一圈，但酒和肉就没有了，想哭。在晚会中，也了解到苗族的一些风俗，不虚此行吧。</p>
<h3 id="长沙会师"><a href="#长沙会师" class="headerlink" title="长沙会师"></a>长沙会师</h3><p>在五号这一天，想着东北老同学晚上也要走了，长沙的就都来聚聚，一起吃个饭吧。然后，能过来的就都过来了。然后，在五一地铁站口会师了，接着就到五一消遣。说实话，人多确实难办事啊，一条街走了两个小时，从街头走到街尾，就到了吃饭的时间了。在茶颜悦色这破店就停了差不多一个小时了，等好久才买到的茶，还是带头发的，可以说是买一送一啦，然后就去找店员干一波…<br><img src="/images/-f4fce435b08868e.jpg" alt="enter description here" title="-f4fce435b08868e"><br><img src="/images/135d0a2aa2cfb394.jpg" alt="enter description here" title="135d0a2aa2cfb394"><br><img src="/images/173694c9a419c1e0.jpg" alt="enter description here" title="173694c9a419c1e0"></p>
<h3 id="大聚餐"><a href="#大聚餐" class="headerlink" title="大聚餐"></a>大聚餐</h3><p>逛累玩累，就找地吃饭了。大家找了一个湘菜馆，坐一起吃饭。在他乡一起吃饭和在海南一起吃饭的感觉就是不一样，这种感觉难以用言语表达，就像一家人一样。</p>
<h3 id="散伙"><a href="#散伙" class="headerlink" title="散伙"></a>散伙</h3><p>天下没有不散的聚会。吃饱喝足的时刻，也是分离的时刻了。到车站后，时间还早，就到麦当劳里坐，聊聊家常啊。随着年龄的增长，现在聊天的话题都是跟工作相关的了，有要考研的，要工作的….</p>
<p>愿我们都能变成自己想成为的那个人，世界在变，我们感情不变。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h3&gt;&lt;p&gt;高中那会，就想着在大学的时候，要多走走，了解外面的世界是怎么样的…&lt;/p&gt;
&lt;h3 id=&quot;八班国庆小分队&quot;
    
    </summary>
    
      <category term="colleage" scheme="http://yoursite.com/categories/colleage/"/>
    
    
  </entry>
  
  <entry>
    <title>求职|第一次电话面试</title>
    <link href="http://yoursite.com/2017/09/30/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2017/09/30/第一次电话面试/</id>
    <published>2017-09-30T00:08:21.000Z</published>
    <updated>2017-09-29T16:43:12.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>经过开学第一个星期的疯狂投简历、笔试风波后，自己本以为求职风波就可以暂停一波了，但是就在前几天，蓝杰的学长发了一则深信服的招聘信息，自己看了一下觉得自己挺符合的，并且简历也都写好了，就给学长发过去了，反正不管结果如何，自己也没损失嘛…</p>
<h3 id="电话面试"><a href="#电话面试" class="headerlink" title="电话面试"></a>电话面试</h3><p>投了简历之后，学长跟我说这两天就会有电话面试，让我保持手机畅通。说实话，这两天我手机的电池还真没有少过50%，毕竟第一次电话面试，万一没电了就尴尬了。同时，自己还对笔试时发现的不足进行了一次恶补，就是一些Mysql的知识和PHP面向对象的一些细节啦。然后，自己还上网找了一些PHP的面试题看了一下，不看不知道啊，一看收获还挺大的，还真的有一些知识是自己不知道的，并且平时也不会注意的细节。偷偷告诉你，面试的时候还真的问了一些题，好开心。</p>
<p>一共打了20分钟的电话。面试官问的话就10多分钟吧，并且问的问题都是一些不能在基础的问题了，比如说get和post的区别啊，主键和索引的区别啊，php中echo、print，print_r的区别啊,mvc思想啊，一些比较难的问题，比如说计算机网络啊、Linux啊，都没有问道。在面试官问到数据库这一部分的时候，自己很担心问道Mysql的优化方面的东西，毕竟自己在这一块真的可以说是空白。自己也知道他肯定会问的，所以就提前坦白了说自己在这一块没什么了解，然后面试官就只问了一些简单的问题，就问其他的问题了。是啊，不懂就是不懂，面试官提前并不知道你不懂，出于对你的考虑，肯定会问你一下，如果你坦白了，就不会问了，并且这样也不会让面试变的尴尬。</p>
<p>各个领域都问了一些简单的问题后，面试官就说觉得我还可以，问我什么时候可以来面试。我说寒假或者暑假，然后他就叫我有时间就联系他，他好让Hr联系我。接着，我就问了一些实习方面的问题，面试就结束了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>哈哈，没想到自己第一次电话面试就通过了，有一点有意外。虽然说，难度算不上是一些正规的面试，但是对自己也是一种锻炼。</p>
<p>不得不说，有人内推，就是不一样，起码笔试就省了，直接进入面试环节。说实话，笔试也是不容易的，运气不好，碰到自己不擅长的领域就什么都没了。还有就是，要提前准备好简历，机会一来，就果断把简历发出去。</p>
<p>我在努力，我在成长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h3&gt;&lt;p&gt;经过开学第一个星期的疯狂投简历、笔试风波后，自己本以为求职风波就可以暂停一波了，但是就在前几天，蓝杰的学长发了一则深信服的招聘信息，自己看了
    
    </summary>
    
      <category term="colleage" scheme="http://yoursite.com/categories/colleage/"/>
    
    
      <category term="求职" scheme="http://yoursite.com/tags/%E6%B1%82%E8%81%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构|什么是数据结构</title>
    <link href="http://yoursite.com/2017/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2017/09/28/数据结构-什么是数据结构/</id>
    <published>2017-09-27T20:29:18.000Z</published>
    <updated>2017-09-27T13:32:58.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h3><p>自己在大一时，就从学长口中得知数据结构的重要性，自己也买书琢磨了一波，但对此的理解也仅限与表面，没有了解到其的奥秘。不过，随着一年多的编程，自己逐渐了解数据结构的重要性，也逐渐揭开他的面纱…</p>
<p>作为 一名计算机专业的学生，写的代码不能仅限于实现功能，我们应该有更高的追求，比如说尽量使用较少的空间啊、让程序能运行的更快啊…这些都是我们需要注意的。数据结构作为计算机专业的基本课程，个人觉得就是教我们怎么更合理地使用内存及硬盘，简单间就是怎么最大化利用我们的存储空间；还有就是怎么来存放我们的数据，以便我们能更好更快的操作数据，比如说查找、删除、添加…</p>
<h3 id="什么数据结构"><a href="#什么数据结构" class="headerlink" title="什么数据结构"></a>什么数据结构</h3><p>对于数据结构的定义，我们应该分开来看：一个是数据，另一个数结构。首先，我们先说说什么是数据：</p>
<h4 id="什么是数据"><a href="#什么是数据" class="headerlink" title="什么是数据"></a>什么是数据</h4><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。这个官方定义不是很容易理解，用我们自己的话说，数据就是计算机能处理的东西，比如说整型、实数型，当然，还包括字符、声音、图像…比如说我们常用的搜索引擎，一般会有网页、MP3、图片、视频等分类。其中，MP3是声音数据，图片是图像数据。说白了，我们所说的数据就是符号，但其必须具有两个属性：</p>
<ul>
<li>可以输入到计算机中</li>
<li>能被计算机处理</li>
</ul>
<p>对于整型、实数型等数值数据，计算机可以进行数值计算；对于字符数据类型，需要进行非数值处理。而声音、图像、视频等其实可以通过编码的手段编程字符数据来处理。</p>
<h4 id="什么是结构"><a href="#什么是结构" class="headerlink" title="什么是结构"></a>什么是结构</h4><p>结构，简单来说就是数据之间的关系。我们都知道，在现实中，不同数据之间不是独立的，而是存在某种特定的关系，我们称这些关系为结构。那么在计算机中也是如此，计算机中的数据并不是孤立的、杂乱无章的，而是具有内在联系的数据集合。我们要写一个好的程序，就要分析处理对象的特性及各处理对象之间存在的关系。我们知道了结构就是关系，那么都有那些具体的关系呢？</p>
<p>按照视点的不同，我们把数据结构分为逻辑结构和物理结构。</p>
<h5 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><p>逻辑结构：是指数据对象中数据元素之间的相互关系。</p>
<p>集合关系：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。就是类似与我们数学中所说的集合，各元素之间没有关系，彼此平等。</p>
<p>线性结构：线性结构中的数据元素之间是一对一的关系。就像排队一样，我们只和我们前面的人有关系，和其他人没有关系。</p>
<p>树形结构：树形结构中的元素之间存在一种一对多的层次关系。就像我们所见的数一样，从下往上，枝叶逐渐增多，但下一层只和上一层有关系。</p>
<p>图形结构：图形结构的数据元素是多对多的关系，就像地图一样，不同的节点之间都会有关系。</p>
<p>逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据之间的逻辑关系，我们要懂得根据实际的问题来选择合适的结构来组织我们的数据。</p>
<h5 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h5><p>物理结构：是指数据的逻辑结构在计算机中的存储形式。说白了，选定了具体的逻辑结构后，我们要怎么样把数据存在计算机中。数据的物理结构应该正确反映数据元素之间的逻辑关系。如何在计算机中存储元素之间的逻辑关系，是实现物理结构的重点和难点。</p>
<p>顺序存储结构：把数据元素存放在地址连续的存储单元中。这种存储结构很简单，就类似与我们开的数组，大家按顺序排好队，每个人占一端空间，大家都不插队。这种方式存储数据，最大的好处是易于遍历，大家都在一起，当然容易遍历啦，但是删除操作就很麻烦，需要把要删除的数字后面的数都往上移位。</p>
<p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元不一定是要连续的。哪要怎么从找到下一个位置呢？这时候就需要指针上场了。这种存储方式比较灵活，数据存放在那不重要，只要一个指针存放了相应的地址就能找到。但查找就很困难了，因为每一次查找都必须从头开始查找。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开场白&quot;&gt;&lt;a href=&quot;#开场白&quot; class=&quot;headerlink&quot; title=&quot;开场白&quot;&gt;&lt;/a&gt;开场白&lt;/h3&gt;&lt;p&gt;自己在大一时，就从学长口中得知数据结构的重要性，自己也买书琢磨了一波，但对此的理解也仅限与表面，没有了解到其的奥秘。不过，随着一年多
    
    </summary>
    
      <category term="DataStruct" scheme="http://yoursite.com/categories/DataStruct/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>生活|记一周的求职经历</title>
    <link href="http://yoursite.com/2017/09/25/%E7%94%9F%E6%B4%BB-%E8%AE%B0%E4%B8%80%E5%91%A8%E7%9A%84%E6%B1%82%E8%81%8C%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2017/09/25/生活-记一周的求职经历/</id>
    <published>2017-09-25T00:03:54.000Z</published>
    <updated>2017-09-24T16:49:29.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h3><p>大二开学第一周，自己就尝试着扮演大三或者大四的角色，加入到找实习找工作的行列中，体验生活。在这一周的折腾中，自己也有所感悟。</p>
<h3 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h3><h4 id="猎豹移动"><a href="#猎豹移动" class="headerlink" title="猎豹移动"></a>猎豹移动</h4><p>自己在宣讲会的前一天就在蓝杰见到 Hr 小姐姐了，听小姐姐讲了猎豹移动的一些信息，比如员工宿舍啊、食堂啊、培养计划啊…说实话，自己当时是很被吸引的，也很希望自己能有机会到这样的公司里学习。第二天晚上（周一），自己约上几个学长，就一起听了宣讲会，然后参加笔试。当然，笔试的结果是惨败（在前前一篇文章就讲过了），这里就不细讲了。</p>
<h4 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h4><p>深信服的笔试是在网上弄的。自己也不知到怎么滴就投了PHP岗位的，虽然也学过并用PHP开发了新生宝典，但熟练程度还不至于背出来一些常见函数啊，基本上都是现用现查的，所以结果可想而知。除了PHP，笔试还设计了服务器、linux、数据库方面的知识，也就是关于网站的方方面面都有了，并且都是一些很深入的问题，比如说怎么Apache和Nginx的差别啊，Nginx还有什么其他的作用啊；怎么优化Mysql数据库啊；怎么防止sql注入攻击啊；各种数据库引擎的不同啊…哇，我天，我只能说自己要走的路还很长呢…</p>
<h4 id="恒生"><a href="#恒生" class="headerlink" title="恒生"></a>恒生</h4><p>恒生的笔试是在今天（周六）进行的。自己本来不想去的，但仔细想想反正周六也没什么事，就去玩玩嘛，就在学校。笔试的题目感觉还可以，不算难，就是一些基础的东西，但自己还是不是很懂，可能好久没有看了吧，记忆有点模糊了。笔试中考了一些简单的数据库操作，就是给你一些表，让你写SQL语句找出需要的数据，说实话，这是很容易的，但自己基本都是用客户端操作数据库的，并且用到的都是一些简单的增删改查，总之，就是自己不懂做。</p>
<h4 id="博登信息"><a href="#博登信息" class="headerlink" title="博登信息"></a>博登信息</h4><p>这是唯一一家不需要笔试的，投简历就直接通知面试了。周五下午去面试，更可恶的是并不是一个懂技术的人来面试而是Hr小姐姐来跟我聊，聊的就是自己的一些情况：在学校学了什么 核心课，自己有学了什么，做过什么，并没有问用到什么技术。好吧，我也无话可说啊。虽然不是技术面试，但也算是面试，自己感觉自己表现还是可以的，不是很紧张，也表达出来了自己想要表达的东西。如果放在中学，自己肯定会吞吞吐吐的，不懂怎么组织语言，讲话没主次.。 </p>
<h3 id="自己的一些感悟"><a href="#自己的一些感悟" class="headerlink" title="自己的一些感悟"></a>自己的一些感悟</h3><p>经过这一周的折腾，自己还是有点收获的，也明确了自己今后的学习重点，折腾是值得的。同时，也意识到笔试是个很重要的东西，笔试也确实能看出一个人的水平。同时，笔试考的知识，也同样是面试的时候，面试官要问你的问题，比如说上面提到的Mysql数据库的优化啊、怎么防止SQL注入攻击啊…如果你用笔都不能写下你想要表达的东西，你怎么能用言语讲述出来呢？此外，如果你真的有水平，笔试也是你展示自己的一个很好的机会。如果你的答案与别人与众不同且正确，那么肯定会得到面试官的青睐。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>小伙子，还是要一步一个脚印踏踏实实来，打好基础，并多思考技术背后的原理…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;小记&quot;&gt;&lt;a href=&quot;#小记&quot; class=&quot;headerlink&quot; title=&quot;小记&quot;&gt;&lt;/a&gt;小记&lt;/h3&gt;&lt;p&gt;大二开学第一周，自己就尝试着扮演大三或者大四的角色，加入到找实习找工作的行列中，体验生活。在这一周的折腾中，自己也有所感悟。&lt;/p&gt;
&lt;h3
    
    </summary>
    
      <category term="life" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次深信服网上笔试</title>
    <link href="http://yoursite.com/2017/09/22/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%BD%91%E4%B8%8A%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2017/09/22/记一次深信服网上笔试/</id>
    <published>2017-09-21T23:28:19.000Z</published>
    <updated>2017-09-21T15:48:37.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大一暑假，在蓝杰学习，看到很多学长到外面实习，自己也对外面的时间充满着期待，也想去外面闯荡一番…新学期开始，很多企业来学校校招，自己虽然大二，但也鼓足勇气投了简历，一股劲地向前冲。</p>
<h3 id="笔试经历"><a href="#笔试经历" class="headerlink" title="笔试经历"></a>笔试经历</h3><p>现在想想，自己应该有投了七八个简历了，但只参见了猎豹和深信服的笔试，走得最远的也仅限于笔试了。猎豹的笔试是考的C++和一些算法，自己是惨败啊。今晚呢，再次抱着找虐的心态参加了深信服的网上笔试。自己投的是PHP的开发岗，但考的不仅仅是PHP的知识，还有一些数据结构和算法的知识，可见数据结构和算法对于程序员来说是多么重要的东西。</p>
<p>既然投的是PHP嘛，当然还是有PHP方面的东西的啦。笔试中还设计了PHP对字符串对数组的操作，还有 一些面向对象的知识，比如说叫你写出五个魔方函数啊…这些都是一些最基本的东西，但说实话，自己在写代码的时候，真的还没关注过这些，都是在要用的时候在查的，所以结果就是自己的惨败啦。</p>
<p>最令我想不到的是，笔试中还有一些网络安全、服务器和数据库方面的知识。比如说简单叙述下GET和POST的区别，这个自己虽然有看过，但要细讲还是有难度的。自己还碰到了很多答不上来的题，比如说简单叙述Nginx和Apache的区别，怎么防止SQL注入攻击，怎么提高Mysql的性能…我的天，这可让我如何是好。反正就是一句话，自己需要学习和钻研的东西还有很多…</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过这几次的折腾，自己知道基础的重要性，并且对知识的掌握不能只停留在表面，还应该深入地研究，做到见树见林。<strong>革命尚未成功，同志仍需努力</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;大一暑假，在蓝杰学习，看到很多学长到外面实习，自己也对外面的时间充满着期待，也想去外面闯荡一番…新学期开始，很多企业来学校校招，自己虽然大二
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的第一次笔试</title>
    <link href="http://yoursite.com/2017/09/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2017/09/20/我的第一次笔试/</id>
    <published>2017-09-20T00:19:01.000Z</published>
    <updated>2017-09-19T16:39:49.694Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h3><p>现在是北京时间 2017年9月20号凌晨零点20分，距我人生第一次笔试已经过去了一天了。我是在18号进行笔试的，Hr 说笔试后第二天会发面试通知，所以整晚我都在满怀期待地等待着，直到过了12点，最后的希望都烟消云散了…</p>
<h3 id="笔试ing"><a href="#笔试ing" class="headerlink" title="笔试ing"></a>笔试ing</h3><p>总的来说，这次笔试是比较简单的，考的都是一些基础题，比如说第一题就考了指针，第二题考了树的遍历方法，第三题考了排序算法…这些东西自己在大一的时候都有接触过，但并没有深入的了解，只是知道这些东西的存在，所以也导致笔试的时候不能百分百确定答案。这些东西虽然基础，但恰恰就是因为基础，我们才需要真真正正地弄懂，并深入的了解他。这也怪自己大一的时候不懂事，觉得这些东西用不上，就没有深入地去了解，导致笔试的惨败。笔试还考了一些算法，对字符串、数组的操作啊。对于算法这一块，自己也是近期才认识到它的重要性，以前觉得它难，但小学期练了一些CCF的题之后，接触到了一些算法，比如动态规划、最短路径啊，虽然一时难以理解，但花点时间慢慢琢磨，还是能弄懂的。算法当然也不是短时间内就能提高的，需要时间来积累，慢慢钻研，当量足够的时候，才能有质的改变。最后一道题是讲述网络的，就是叫你描述一下从输入网址到显示网页，这一过程中发生了什么。本来呢，自己在网络这一块应该是可以的，但是因为好久没看了，只是知道个大概，细节的一些东西都忘了，自己答得也不是很好。网络这东西，也是需要慢慢研究的啊。</p>
<h3 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h3><p>通过这一次惨败，自己懂得了许多。</p>
<ul>
<li>对于基础的学习，不能小视，需重视，吃透它，深入它</li>
<li>对于算法啊、网络啊，这些必须的知识，要经常性地复习，做到能描述的清清楚楚</li>
</ul>
<p>虽败，但不能服输。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简要&quot;&gt;&lt;a href=&quot;#简要&quot; class=&quot;headerlink&quot; title=&quot;简要&quot;&gt;&lt;/a&gt;简要&lt;/h3&gt;&lt;p&gt;现在是北京时间 2017年9月20号凌晨零点20分，距我人生第一次笔试已经过去了一天了。我是在18号进行笔试的，Hr 说笔试后第二天会发面试
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK环境配置</title>
    <link href="http://yoursite.com/2017/09/13/JDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/09/13/JDK环境配置/</id>
    <published>2017-09-13T00:14:54.000Z</published>
    <updated>2017-09-12T16:55:10.061Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这几天在学习Struts框架，要求的jdk版本不能太高，可恨的是，自己正在使用的是1.8的，无奈之下，只能卸载了重新装 1.7 版本的。</p>
<h3 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h3><h4 id="安装JDK开发环境"><a href="#安装JDK开发环境" class="headerlink" title="安装JDK开发环境"></a>安装JDK开发环境</h4><ol>
<li>下载：<a href="http://www.oracle.com/" target="_blank" rel="external">下载网站</a> 下载就跟我们平时下载软件一样，不过要下载符合自己操作系统的镜像。</li>
<li>开始安装  安装过程也跟我们安装软件一样，不过建议最好改一下安装的位置，就别放在C盘啦。</li>
</ol>
<p>注：当提示安装JRE时，可以选择不要安装。但如果要安装，就不能放在刚刚安装 jdk 同一级目录中。比如 jdk安装在  D:\Program Files\Java\ ；jre就不能安装在 D:\Program Files\Java\了，可以这样安装 ：jdk安装在 D:\Program Files\Java\jdk1.7.0_80 ；jre安装在 D:\Program Files\Java\jre7 。原因是安装jre的时候会覆盖掉jdk中的一些 jre 包，导致缺少tools.jar。</p>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>对于Java程序开发而言，主要会使用JDK的两个命令：javac.exe、java.exe。路径：C:\Java\jdk 1.7.0 _09\bin。但是这些命令由于不属于windows自己的命令，所以要想使用，就需要进行路径配置。 </p>
<p>单击“计算机-属性-高级系统设置”，单击“环境变量”。在“系统变量”栏下单击“新建”，创建新的系统环境变量。</p>
<p>需要创建的环境变量有：</p>
<ol>
<li>新建-&gt;变量名”JAVA_HOME”，变量值<strong>“C:\Java\jdk1.8.0_05”（即JDK的安装路径）</strong></li>
<li>编辑-&gt;变量名”Path”，在原变量值的最后面加上<strong>“;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin”</strong></li>
<li>新建-&gt;变量名“CLASSPATH”,变量值<strong>“.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”</strong>不要忘记 .  。</li>
</ol>
<h4 id="确认环境配置是否真确"><a href="#确认环境配置是否真确" class="headerlink" title="确认环境配置是否真确"></a>确认环境配置是否真确</h4><p>在控制台分别输入java，javac，java -version 命令，出现如下所示的JDK的编译器信息，包括修改命令的语法和参数选项等信息。如果都出现了，就说明你成功了。</p>
<h4 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h4><p>写下自己的第一个Java程序 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;    </div><div class="line">    System.out.println(&quot;Hello Java&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保存为hello.java , 然后在文件所在目录下打开命令行窗口，依次输入  javac hello.java ,java hello 命令，就会在命令行打印出 “HelloWorld” 了。</p>
<p>程序解析：</p>
<p>首先编写java源代码程序，扩展名.java；<br>在命令行模式中，输入命令：javac 源文件名.java，对源代码进行编译，生成class字节码文件；<br>编译完成后，如果没有报错信息，输入命令：java HelloWorld，对class字节码文件进行解释运行,执行时不需要添加.class扩展名。</p>
<p>注：若在CMD中输入javac test.java命令后，显示’javac’不是内部或外部命令，原因是因为没有提前安装好JDK开发环境或环境变量配置有误。 </p>
<blockquote>
<p><a href="http://www.cnblogs.com/smyhvae/p/3788534.html" target="_blank" rel="external">参考资料</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这几天在学习Struts框架，要求的jdk版本不能太高，可恨的是，自己正在使用的是1.8的，无奈之下，只能卸载了重新装 1.7 版本的。&lt;/
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/09/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/"/>
    <id>http://yoursite.com/2017/09/11/动态规划经典例题/</id>
    <published>2017-09-11T01:54:48.479Z</published>
    <updated>2017-09-16T16:43:37.079Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划——由实践总结经验</p>
<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul>
<li>基础题目<ul>
<li>矩阵取数问题</li>
<li>最大子段和</li>
<li>最长公共子序列问题</li>
<li>编辑距离问题</li>
<li>最长单增子序列</li>
<li>0-1背包问题</li>
<li>正整数分组</li>
</ul>
</li>
<li>进阶题目<br>  -最大子矩阵和<ul>
<li>循环数组最大字段和</li>
<li>多重背包问题</li>
</ul>
</li>
</ul>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学校出门一台政策，要求计算机专业的学生必须参加CCF的考试，且必须通过考核后，才能毕业.无奈之下，需要认真钻研动态规划算法，应付考试。在经过两周多的训练和查阅资料，对其有了一点理解理解。</p>
<p>在我看来，动态规划的核心在于将待求解问题分解为子问题，子问题的规模小于原问题，并且求解方法一致，但原问题的求解依赖于子问题，子问题之间往往不相互独立。典型特征就是，动态规划中所使用的递推公式。与之相比，分治法的核心在于将原问题规模缩小，分解为多个子问题，且各个子问题之间相互独立。</p>
<p>核心思想：</p>
<ul>
<li>全局最优解包含局部最优解。</li>
<li>状态转移方程</li>
</ul>
<h3 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h3><h4 id="矩阵取数问题"><a href="#矩阵取数问题" class="headerlink" title="矩阵取数问题"></a>矩阵取数问题</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>一个NN矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。</p>
<p>例如：3 3的方格。<br>1 3 3<br>2 1 3<br>2 2 1<br>能够获得的最大价值为：11。</p>
<p>输入<br>第1行：N，N为矩阵的大小。(2 &lt;= N &lt;= 500)<br>第2 - N + 1行：每行N个数，中间用空格隔开，对应格子中奖励的价值。（1 &lt;= N[i] &lt;= 10000)<br>输出<br>输出能够获得的最大价值。<br>输入示例<br>3<br>1 3 3<br>2 1 3<br>2 2 1<br>输出示例<br>11</p>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; nums(n);</div><div class="line">    vector&lt;vector&lt;long long&gt; &gt; dp(n + 1);</div><div class="line">    for(int i = 0; i &lt; n;i++)&#123;</div><div class="line">        vector&lt;int&gt; row(n);</div><div class="line">        vector&lt;long long&gt; maxRow(n + 1,0);</div><div class="line">        for(int j = 0;j &lt; n;j++)&#123;</div><div class="line">            cin &gt;&gt; row[j];</div><div class="line">        &#125;</div><div class="line">        nums[i] = row;</div><div class="line">        dp[i] = maxRow;</div><div class="line">    &#125;</div><div class="line">    vector&lt;long long&gt; maxRow(n + 1,0);</div><div class="line">    dp[n] = maxRow;</div><div class="line"></div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        for(int j = 1; j &lt;= n; j++)&#123;</div><div class="line">            dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]) + nums[i - 1][j - 1];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt; dp[n][n]&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在本例中，我们用dp[i][j]来表示从点（0，0）走到点（i,j）时，所能得到的最大值，也就是说，dp[][]数组中存储的是从原点到点（i,j）的所有有局部最优解，这就体现了我们重要思想中的 <strong>全局最优解包含局部最优解*</strong>。简单点说，最后的解就是通过前面的局部的最优解通过状态转移方程一步步的得到的。</p>
<h4 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。当所给的整数均为负数时和为0。<br>例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。</p>
<p>输入<br>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：N个整数（-10^9 &lt;= A[i] &lt;= 10^9）<br>输出<br>输出最大子段和。<br>输入示例<br>6<br>-2<br>11<br>-4<br>13<br>-5<br>-2<br>输出示例<br>20</p>
<h6 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">/*动态规划算法:</div><div class="line">b[j]=max&#123;a[i]++a[j]&#125;,1&lt;=i&lt;=j,且1&lt;=j&lt;=n,则所求的最大子段和为max b[j]，1&lt;=j&lt;=n。</div><div class="line"></div><div class="line">由b[j]的定义可易知，当b[j-1]&gt;0时b[j]=b[j-1]+a[j]，否则b[j]=a[j]。故b[j]</div><div class="line">的动态规划递归式为:</div><div class="line"></div><div class="line">b[j]=max(b[j-1]+a[j],a[j])，1&lt;=j&lt;=n。</div><div class="line">代码中，pre就相当与b[j]；result保存b[j]中的最大值</div><div class="line">T(n)=O(n)</div><div class="line">*/</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    int cur;</div><div class="line">    cin &gt;&gt; cur;</div><div class="line">    long long result = cur;</div><div class="line">    long long pre = cur;</div><div class="line">    for(int i = 1; i &lt; n;i++)&#123;</div><div class="line">       cin &gt;&gt; cur;</div><div class="line">       if(pre &gt; 0)&#123;</div><div class="line">           pre = pre + cur;</div><div class="line">       &#125;</div><div class="line">       else&#123;</div><div class="line">           pre = cur;</div><div class="line">       &#125;</div><div class="line">       if(pre &gt; result)&#123;</div><div class="line">           result = pre;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; result&lt;&lt;endl;</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">/*</div><div class="line">动态规划:数组为in[]，设dp[i] 是以in[i]结尾的子数组的最大和.</div><div class="line">对于元素in[i+1],它有两种选择：a、vec[i+1]接着前面的子数组构成最大和，b、in[i+1]自己单独构成子数组。</div><div class="line">则dp[i+1] = max&#123;dp[i]+in[i+1],  in[i+1]&#125;</div><div class="line">*/</div><div class="line">int main()&#123;</div><div class="line">    int n;cin&gt;&gt;n;</div><div class="line">    int in[n];</div><div class="line">    int dp[n];</div><div class="line">    for(int i=0;i&lt;n;i++)&#123;</div><div class="line">        cin&gt;&gt;in[i];</div><div class="line">        dp[i]=in[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(int i=1;i&lt;n;i++)&#123;</div><div class="line">        dp[i] = max(dp[i-1]+in[i],  in[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(int i=0;i&lt;n;i++)&#123;</div><div class="line">        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>对于此题呢，这里给出了两种写法，但两者思想都是一样的，都是用了动态规划的思想。在第一中写法中，我们用变量pre代表序列中以 i 结尾的连续数列的最大值，这就是当前i的最优节，一个局部最优解，通过状态转移方程不断得到全部的最优解。第二种写法是比较容易接受的，dp[i] 代表的是序列中以 i 结尾的连续数列的最大值,那么dp[i+1]=max(dp[i]+a[i+1],a[i+1])。</p>
<h4 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>最长公共子序列的问题常用于解决字符串的相似度，是一个非常实用的算法，作为码农，此算法是我们的必备基本功。</p>
<p>给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。<br>比如两个串为：<br>abcicba<br>abdkscab<br>ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。</p>
<p>输入<br>第1行：字符串A<br>第2行：字符串B<br>(A,B的长度 &lt;= 1000)<br>输出<br>输出最长的子序列，如果有多个，随意输出1个。</p>
<p>输入示例<br>abcicba<br>abdkscab<br>输出示例<br>abca</p>
<h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line">using namespace std;</div><div class="line">typedef struct &#123;</div><div class="line">    int x;</div><div class="line">    int y;</div><div class="line">    char node = &apos;\0&apos;;</div><div class="line">    int maxLength = 0;</div><div class="line">&#125; DpNode;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    string a;</div><div class="line">    string b;</div><div class="line">    std:cin &gt;&gt; a &gt;&gt;b;</div><div class="line">    vector&lt;vector&lt;DpNode&gt; &gt; dp(a.size() + 1);</div><div class="line">    for (int i = 0; i &lt;= a.size(); i++) &#123;</div><div class="line">        vector&lt;DpNode&gt; dpRow(b.size() + 1);</div><div class="line">        dp[i] = dpRow;</div><div class="line">    &#125;</div><div class="line">    for (int i = 1; i &lt;= a.size(); i++) &#123;</div><div class="line">        for (int j = 1; j &lt;= b.size(); j++) &#123;</div><div class="line">            if (a[i - 1] == b[j - 1]) &#123;</div><div class="line">                dp[i][j].maxLength = dp[i - 1][j - 1].maxLength + 1;</div><div class="line">                dp[i][j].x = i - 1;</div><div class="line">                dp[i][j].y = j - 1;</div><div class="line">                dp[i][j].node = a[i - 1];</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                if (dp[i - 1][j].maxLength &gt; dp[i][j - 1].maxLength) &#123;</div><div class="line">                    dp[i][j].maxLength = dp[i - 1][j].maxLength;</div><div class="line">                    dp[i][j].x = i - 1;</div><div class="line">                    dp[i][j].y = j;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    dp[i][j].maxLength = dp[i][j - 1].maxLength;</div><div class="line">                    dp[i][j].x = i;</div><div class="line">                    dp[i][j].y = j - 1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int x = a.size();</div><div class="line">    int y = b.size();</div><div class="line">    char c;</div><div class="line">    list&lt;char&gt; result;</div><div class="line">    int xTemp;</div><div class="line">    while (x != 0 &amp;&amp; y != 0) &#123;</div><div class="line">        c = dp[x][y].node;</div><div class="line">        if (c != &apos;\0&apos;) &#123;</div><div class="line">            result.push_front(c);</div><div class="line">        &#125;</div><div class="line">        xTemp = x;</div><div class="line">        x = dp[xTemp][y].x;</div><div class="line">        y = dp[xTemp][y].y;</div><div class="line">    &#125;</div><div class="line">    for (list&lt;char&gt;::iterator it = result.begin(); it != result.end(); it++) &#123;</div><div class="line">        cout &lt;&lt; *it;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。<br>例如将kitten一字转成sitting：<br>sitten （k-&gt;s）<br>sittin （e-&gt;i）<br>sitting （-&gt;g）<br>所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。<br>给出两个字符串a,b，求a和b的编辑距离。<br>输入<br>第1行：字符串a(a的长度 &lt;= 1000)。<br>第2行：字符串b(b的长度 &lt;= 1000)。<br>输出<br>输出a和b的编辑距离。</p>
<p>输入示例<br>kitten<br>sitting<br>输出示例<br>3</p>
<h5 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    string a;</div><div class="line">    string b;</div><div class="line">    cin &gt;&gt; a &gt;&gt; b;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; dp(a.size() + 1);</div><div class="line">    vector&lt;int&gt; dpRow(b.size() + 1);</div><div class="line">    dp[0] = dpRow;</div><div class="line">    for(int i = 0; i &lt;= b.size();i++ )&#123;</div><div class="line">        dp[0][i] = i;</div><div class="line">    &#125;</div><div class="line">    for(int i = 1; i &lt;= a.size();i++)&#123;</div><div class="line">        vector&lt;int&gt; dpRow(b.size() + 1);</div><div class="line">        dp[i] = dpRow;</div><div class="line">        dp[i][0] = i;</div><div class="line">    &#125;</div><div class="line">    int minTemp;</div><div class="line">    for(int i = 0; i &lt; a.size();i++)&#123;</div><div class="line">        for(int j = 0; j &lt; b.size();j++)&#123;</div><div class="line">            if(a[i] == b[j])&#123;</div><div class="line">                dp[i + 1][j + 1] = dp[i][j];</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                minTemp = min(dp[i][j] + 1,dp[i][j + 1] + 1);</div><div class="line">                dp[i + 1][j + 1] = min(minTemp,dp[i + 1][j] + 1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt;dp[a.size()][b.size()]&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最长单增子序列"><a href="#最长单增子序列" class="headerlink" title="最长单增子序列"></a>最长单增子序列</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的）<br>例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。<br>输入<br>第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9)<br>输出<br>输出最长递增子序列的长度。<br>输入示例<br>8<br>5<br>1<br>6<br>8<br>2<br>4<br>5<br>10<br>输出示例<br>5</p>
<h5 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;climits&gt;</div><div class="line">using namespace std;</div><div class="line">/**</div><div class="line"> * maxs[x] 中记录了目前单调子序列中长度为x的所有子序列中，最后一个元素的最小值。</div><div class="line"> * 比如当然有两个单调子序列长度为2: 1 3; 1 4。maxs[2] = 3</div><div class="line"> * 代表了最优情况，因为元素越小继续延伸的潜力越大</div><div class="line"> */</div><div class="line">void updateMaxArray(vector&lt;int&gt; &amp;maxs, int newNum)</div><div class="line">&#123;</div><div class="line">    int temp = 0;</div><div class="line">    for (int left = 0, right = maxs.size() - 1, mid = left + (right - left) / 2; left &lt;= right;) &#123;</div><div class="line">        if (maxs[mid] &lt; newNum) &#123;</div><div class="line">            temp = mid;</div><div class="line">            left = mid + 1;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            right = mid - 1;</div><div class="line">        &#125;</div><div class="line">        mid = left + (right - left) / 2;</div><div class="line">    &#125;</div><div class="line">    if (temp != maxs.size() - 1) &#123;</div><div class="line">        maxs[temp + 1] = newNum;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        maxs.insert(maxs.begin() + temp + 1, newNum);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    int cur;</div><div class="line">    vector&lt;int&gt; maxs(1, INT_MIN);</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        cin &gt;&gt; cur;</div><div class="line">        updateMaxArray(maxs, cur);</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; (maxs.size() - 1) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。<br>输入<br>第1行，2个整数，N和W中间用空格隔开。N为物品的数量，W为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= W &lt;= 10000)<br>第2 - N + 1行，每行2个整数，Wi和Pi，分别是物品的体积和物品的价值。(1 &lt;= Wi, Pi &lt;= 10000)<br>输出<br>输出可以容纳的最大价值。<br>输入示例<br>3 6<br>2 5<br>3 8<br>4 9<br>输出示例<br>14<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int dp[101][10001];</div><div class="line">/**</div><div class="line"> * dp[i][j] -&gt; 在前个物品中任意选取，容量不超过j的物品最大价值</div><div class="line"> * dp[i][j] = dp[i-1][j] 第i个物品的重量大于j</div><div class="line"> * dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]] + p[i]) 否则</div><div class="line"> */</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n,m;</div><div class="line">    cin &gt;&gt; n &gt;&gt; m;</div><div class="line">    vector&lt;int&gt; w(n + 1);</div><div class="line">    vector&lt;int&gt; p(n + 1);</div><div class="line">    for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">        cin &gt;&gt; w[i] &gt;&gt; p[i];</div><div class="line">    &#125;</div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        for(int j = 1;j &lt;= m;j++)&#123;</div><div class="line">            if(w[i] &lt;= j)&#123;</div><div class="line">                dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - w[i]] + p[i]);</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                dp[i][j] = dp[i - 1][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="正整数分组"><a href="#正整数分组" class="headerlink" title="正整数分组"></a>正整数分组</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>将一堆正整数分为2组，要求2组的和相差最小。<br>例如：1 2 3 4 5，将1 2 4分为1组，3 5分为1组，两组和相差1，是所有方案中相差最少的。<br>输入<br>第1行：一个数N，N为正整数的数量。<br>第2 - N+1行，N个正整数。<br>(N &lt;= 100, 所有正整数的和 &lt;= 10000)<br>输出<br>输出这个最小差<br>输入示例<br>5<br>1<br>2<br>3<br>4<br>5<br>输出示例<br>1<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">/**</div><div class="line"> * f[i][j] -&gt; 在前i个数中选取一些数，总和不超过j的最大值</div><div class="line"> * f[i][j] = f[i-1][j]  第i个数大于j</div><div class="line"> * f[i][j] = max(f[i - 1][j],f[i - 1][j - nums[i - 1]] + nums[i - 1]) 否则</div><div class="line"> */</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    vector&lt;int&gt; nums(n);</div><div class="line">    int total = 0;</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        cin &gt;&gt; nums[i];</div><div class="line">        total = total+ nums[i];</div><div class="line">    &#125;</div><div class="line">    int half = total / 2;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; f(n + 1);</div><div class="line">    for (int i = 0; i &lt;= n; i++) &#123;</div><div class="line">        vector&lt;int&gt; temp(half + 1);</div><div class="line">        f[i] = temp;</div><div class="line">    &#125;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt;::iterator fIter = f.begin();</div><div class="line">    fill((*fIter).begin(),(*fIter).end(),0);</div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        for(int j = 1; j &lt;= half;j++)&#123;</div><div class="line">            if(nums[i - 1] &gt; j)&#123;</div><div class="line">                f[i][j] = f[i - 1][j];</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                f[i][j] = max(f[i - 1][j],f[i - 1][j - nums[i - 1]] + nums[i - 1]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; (total - 2*f[n][half])  &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="进阶题目"><a href="#进阶题目" class="headerlink" title="进阶题目"></a>进阶题目</h3><h4 id="最大子矩阵和"><a href="#最大子矩阵和" class="headerlink" title="最大子矩阵和"></a>最大子矩阵和</h4><p>问题描述<br>一个MN的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的值。<br>例如：33的矩阵：<br>-1 3 -1<br>2 -1 3<br>-3 1 2<br>和最大的子矩阵是：<br>3 -1<br>-1 3<br>1 2<br>输入<br>第1行：M和N，中间用空格隔开（2 &lt;= M,N &lt;= 500)。<br>第2 - N + 1行：矩阵中的元素，每行M个数，中间用空格隔开。(-10^9 &lt;= M[i] &lt;= 10^9)<br>输出<br>输出和的最大值。如果所有数都是负数，就输出0。<br>输入示例<br>3 3<br>-1 3 -1<br>2 -1 3<br>-3 1 2<br>输出示例<br>7<br>代码说明<br>这道题目与基础题目中的最大子段和有些像，但本题是二维空间。但可以通过一些手段将其转化为一维空间。<br>设想，整个矩阵有3行，最大子矩阵可能的行数1/2/3; 矩阵数组为a[i][j]:<br>矩阵行数为1：分别求第一行、第二行、第三行的最大子段和max1,max2,max3,那么max(max1,max2,max3)即为最大子矩阵和<br>矩阵行数为2：最大子矩阵出现在第1-2行或第2-3行，只有这两种情况。如果有一个一维数组total:<br>total[k] = a[0][k] + a[1][k] total最大字段和max1<br>total[k] = a[1][k] + a[2][k] total最大字段和max2<br>那么max = max(max1,max2)即为最大子矩阵和<br>矩阵行数为3：最大子矩阵出现在第1-3行，只有一种情况。如果有一个一维数组total:<br>total[k] = a[0][k] + a[1][k] + a[2][k] total最大字段和max<br>那么max即为最大子矩阵和<br>通过这个例子是不是可以感受到一些启发？将 第i行到第j行压缩为一行(求和),即可以转化为求解最大子段和,此时可获得行数为(j-i+1)时的最大子矩阵和<br>假设n*m的矩阵的最大子矩阵的行数为i(1&lt;=i&lt;=n) 如果有一个一维数组total:<br>total[k] = a[0][k] + … +a[i-1][k] total最大字段和max1<br>…<br>total[k] = a[n-i][k] + … + a[n - 1][k] total最大字段和max..<br>那么max = max(max1,…)即为最大子矩阵和<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;climits&gt;</div><div class="line">using namespace std;</div><div class="line">/**</div><div class="line">* 求最大字段和</div><div class="line">*/</div><div class="line">int maxSubSequence(vector&lt;int&gt;&amp; arr) &#123;</div><div class="line">    if (arr.size() &gt; 0) &#123;</div><div class="line">        int maxSub = arr[0];</div><div class="line">        int temp = arr[0];</div><div class="line">        for (int i = 1; i &lt; arr.size(); i++) &#123;</div><div class="line">            if (temp &gt; 0) &#123;</div><div class="line">                temp = temp + arr[i];</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                temp = arr[i];</div><div class="line">            &#125;</div><div class="line">            maxSub = max(maxSub, temp);</div><div class="line">        &#125;</div><div class="line">        return maxSub;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int m, n;</div><div class="line">    cin &gt;&gt; m &gt;&gt; n;</div><div class="line">    //初始化</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; nums(n);</div><div class="line">    // total[i][k] = nums[0][k] + ... + nums[i][k];</div><div class="line">    // 所以nums[i..j][k] = total[j][k]-total[i - 1][k]</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; total(n);</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        vector&lt;int&gt; row(m);</div><div class="line">        vector&lt;int&gt; totalRow(m);</div><div class="line">        if (i == 0) &#123;</div><div class="line">            for (int j = 0; j &lt; m; j++) &#123;</div><div class="line">                cin &gt;&gt; row[j];</div><div class="line">                totalRow[j] = row[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            for (int j = 0; j &lt; m; j++) &#123;</div><div class="line">                cin &gt;&gt; row[j];</div><div class="line">                totalRow[j] = total[i - 1][j] + row[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nums[i] = row;</div><div class="line">        total[i] = totalRow;</div><div class="line">    &#125;</div><div class="line">    int maxSub = INT_MIN;</div><div class="line">    // 最大子矩阵行数为 i</div><div class="line">    vector&lt;int&gt; result(m);</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        for (int j = i; j &lt; n; j++) &#123;</div><div class="line">            for (int k = 0; k &lt; m; k++) &#123;</div><div class="line">                if (i == 0) &#123;</div><div class="line">                    result[k] = total[j][k];</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    result[k] = total[j][k] - total[i - 1][k];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            int maxTemp = maxSubSequence(result);</div><div class="line">            if (maxTemp &gt; maxSub) &#123;</div><div class="line">                maxSub = maxTemp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; maxSub &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考<a href="http://blog.csdn.net/beiyeqingteng/article/details/7056687" target="_blank" rel="external">http://blog.csdn.net/beiyeqingteng/article/details/7056687</a></p>
</blockquote>
<h4 id="循环数组最大字段和"><a href="#循环数组最大字段和" class="headerlink" title="循环数组最大字段和"></a>循环数组最大字段和</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>N个整数组成的循环序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续的子段和的最大值（循环序列是指n个数围成一个圈，因此需要考虑a[n-1],a[n],a[1],a[2]这样的序列）。当所给的整数均为负数时和为0。<br>例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。<br>输入<br>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)<br>第2 - N+1行：N个整数 (-10^9 &lt;= S[i] &lt;= 10^9)<br>输出<br>输出循环数组的最大子段和。<br>输入示例<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>6<br>-2<br>11<br>-4<br>13<br>-5<br>-2<br>输出示例<br>1<br>20<br>代码说明<br>如果最大字段和不是跨越数组头尾的情况，即为普通的最大字段和求解问题。<br>如果最大子段和跨越数组头尾，即 arr[j…n-1] + arr[0…i];易得子段arr[i+1…j-1] 为最小子段和，这种情况也就可以转化为 total[0…n-1] - minSubSequence<br>二者取max即为循环数组最大字段和<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;climits&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt;n;</div><div class="line">    ll cur,preMax,preMin;</div><div class="line">    cin &gt;&gt; preMax;</div><div class="line">    ll total = preMax;</div><div class="line">    ll maxSub = preMax;</div><div class="line">    ll minSub = preMax;</div><div class="line">    preMin = preMax;</div><div class="line">    for(int i = 1;i &lt; n;i++)&#123;</div><div class="line">        cin &gt;&gt; cur;</div><div class="line">        total = total + cur;</div><div class="line">        if(preMax &gt; 0)&#123;</div><div class="line">            preMax = preMax + cur;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            preMax = cur;</div><div class="line">        &#125;</div><div class="line">        if(preMin &lt; 0)&#123;</div><div class="line">            preMin = preMin + cur;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            preMin = cur;</div><div class="line">        &#125;</div><div class="line">        maxSub = max(maxSub,preMax);</div><div class="line">        minSub = min(minSub,preMin);</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; max(maxSub,total - minSub) &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>有N种物品，每种物品的数量为C1，C2……Cn。从中任选若干件放在容量为W的背包里，每种物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。<br>输入<br>第1行，2个整数，N和W中间用空格隔开。N为物品的种类，W为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= W &lt;= 50000)<br>第2 - N + 1行，每行3个整数，Wi，Pi和Ci分别是物品体积、价值和数量。(1 &lt;= Wi, Pi &lt;= 10000， 1 &lt;= Ci &lt;= 200)<br>输出<br>输出可以容纳的最大价值。<br>输入示例<br>3 6<br>2 2 5<br>3 3 8<br>1 4 1<br>输出示例<br>9</p>
<h5 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h5><p>将多重背包分解为0-1背包<br>利用二进制的思想，任何一个数都可以由2的幂次表示：N = 1 + 2 + 4 + … + 2^i + (left);<br>即每个物品都可以被分解。假设物品的数量为14,则从14个物品中任取N个物品都可以转化为由以下物品组合(以下物品在每次组合中只能取一次)<br>1^0 重量是Wi，体积是Vi<br>2^2 重量是2 Wi , 体积是2 Vi<br>2^3 重量是4 Wi , 体积是4 Vi<br>14 - (1+2+4) 重量是7 Wi , 体积是7 Vi<br>分解完成后，再利用0-1背包思路求解</p>
<h5 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">typedef struct &#123;</div><div class="line">    int w;</div><div class="line">    int p;</div><div class="line">&#125; Thing;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n,w;</div><div class="line">    cin &gt;&gt; n &gt;&gt; w;</div><div class="line">    </div><div class="line">    //分解</div><div class="line">    vector&lt;Thing&gt; things;</div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        Thing thing;</div><div class="line">        cin &gt;&gt; thing.w &gt;&gt; thing.p;</div><div class="line">        int num;</div><div class="line">        cin &gt;&gt; num;</div><div class="line">        for(int k = 1; k &lt;= num;k &lt;&lt;= 1)&#123;</div><div class="line">            Thing temp;</div><div class="line">            temp.w = k * thing.w;</div><div class="line">            temp.p = k * thing.p;</div><div class="line">            num -= k;</div><div class="line">            things.push_back(temp);</div><div class="line">        &#125;</div><div class="line">        if(num &gt; 0)&#123;</div><div class="line">            thing.w = num * thing.w;</div><div class="line">            thing.p = num * thing.p;</div><div class="line">            things.push_back(thing);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //0-1背包</div><div class="line">    vector&lt;vector&lt;long long&gt; &gt; dp(things.size() + 1, vector&lt;long long&gt;(w + 1,0));</div><div class="line">    for(int i = 0; i &lt; things.size();i++)&#123;</div><div class="line">        for(int j = 0; j &lt;= w;j++)&#123;</div><div class="line">            if(j &lt; things[i].w)&#123;</div><div class="line">                dp[i + 1][j] = dp[i][j];</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                dp[i + 1][j] = max(dp[i][j],dp[i][j - things[i].w] + things[i].p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; dp[things.size()][w]&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划——由实践总结经验&lt;/p&gt;
&lt;h3 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基础题目&lt;ul&gt;
&lt;li&gt;矩阵取数问题&lt;/li&gt;
&lt;li&gt;最大子段和&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>My-Plan</title>
    <link href="http://yoursite.com/2017/09/11/My-Plan/"/>
    <id>http://yoursite.com/2017/09/11/My-Plan/</id>
    <published>2017-09-10T23:26:42.000Z</published>
    <updated>2017-09-10T16:11:48.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在大一的这个小学期，课不是很多，技术这一块也遇到了一些瓶颈，感觉自己都懂又感觉自己都不懂，看网上的教程，觉得自己掌握了，但要实际运用起来却又不是很遂心应手，自己也不知道自己现在是个什么情况。这跟自己当初学吉他有点相识之处啊，网上能看到的吉他教材啊、视频呀，自己看也能明白，但只要自己拿起吉他，就不知道要弹什么了，就是一种眼高手低的状态吧，跟现在学习的状态是一样一样的。</p>
<p>自己这几天也不做什么事，没课就跟老乡骑小黄车四处逛，长沙的公园都快被我们逛完了。自己也利用这几天也想了许多，总觉得自己走进了死胡同—-一直在学习，但从未使用学的东西。在高中学吉他那会，自己自以为是的觉得只要学会了所有的技巧，就能弹奏所有的曲子了，但事实证明这是错的，自己虽然懂得了所有的技巧，但并不懂得怎么在正确的时间使用，这也无济于事，就相当于没学过一样。所以，自己不能在犯同样的错误了，学了，还有使用，懂得去运用自己所学的东西也是学习的一部分…</p>
<p>So，这学期也不要学太多新的东西啦，重点要放在怎么使用自己学过的东西，在使用的过程中学习。</p>
<h3 id="My-Plan"><a href="#My-Plan" class="headerlink" title="My Plan"></a>My Plan</h3><ul>
<li>自己完成一些Java、JavaWeb项目 （参照亮剑Java（JavaWeb） 项目开发案例导航）</li>
<li>学习Linux，对服务器进行管理</li>
<li>学习数据结构，对算法的积累</li>
<li>…</li>
</ul>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p>大一整整一年，自己几乎把所有的时间都放在了技术的学习上，天真的以为只要技术牛逼就万事大吉了。经过这一年的摸索，发现自己真的很傻，事情并非如此。自己虽然是计算机专业，但并不是说自己的生活里就只能是代码，也不能就只把自己定义为码农、程序员，这不是自己的唯一的道路。坦白点，学程序无非就是为了赚钱。赚钱不只有写程序这一个办法，还有很多办法呢，自己的眼界要开阔，比如说可以炒炒股呀、卖点东西呀…</p>
<p>此外，程序不能是自己生活的全部，自己不能把自己的爱好丢了，虽然不能天天玩吉他了，但这并不代表每天都不玩了；虽然不能天天去打球、运动了，但并不代表每天都不去了…</p>
<p>以后要想有更多的机会，并不是会写程序就可以的，还要有其他的一些辅助技能，比如说语言啦、沟通能力啦、管理能力啦…这些都是很重要的东西，也是自己要提高的东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在大一的这个小学期，课不是很多，技术这一块也遇到了一些瓶颈，感觉自己都懂又感觉自己都不懂，看网上的教程，觉得自己掌握了，但要实际运用起来却又
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划从新手到专家</title>
    <link href="http://yoursite.com/2017/09/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E4%B8%93%E5%AE%B6/"/>
    <id>http://yoursite.com/2017/09/09/动态规划从新手到专家/</id>
    <published>2017-09-08T16:00:34.000Z</published>
    <updated>2017-09-10T16:18:53.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们遇到的问题中，有很大一部分可以用动态规划(简称DP)来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解题。 这篇文章是基于实例展开来讲的，因为干巴巴的理论实在不好理解。</p>
<p>注意：如果你对于其中某一节已经了解并且不想阅读它，没关系，直接跳过它即可。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>简介(入门)</p>
<p>什么是动态规划，我们要如何描述它?</p>
<p>动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。</p>
<p>现在让我们通过一个例子来了解一下DP的基本原理。</p>
<p>首先，我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。</p>
<p>“状态”代表什么及如何找到它?</p>
<p>“状态”用来描述该问题的子问题的解。</p>
<p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)</p>
<p>首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11) ？为什么要这么问呢? 两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。</p>
<p>好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。</p>
<p>OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。</p>
<p>上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”， 这个状态是怎么找出来的呢？我在另一篇文章 动态规划之背包问题(一)中写过： 根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p>
<p>d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值;</p>
<p>有了状态和状态转移方程，这个问题基本上也就解决了。当然了，Talk is cheap,show me the code!</p>
<p>  从上图可以得出，要凑够11元至少需要3枚硬币。</p>
<p>此外，通过追踪我们是如何从前一个状态值得到当前状态值的， 可以找到每一次我们用的是什么面值的硬币。比如，从上面的图我们可以看出， 最终结果d(11)=d(10)+1(面值为1)，而d(10)=d(5)+1(面值为5)，最后d(5)=d(0)+1 (面值为5)。所以我们凑够11元最少需要的3枚硬币是：1元、5元、5元。</p>
<h3 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h3><p>上面讨论了一个非常简单的例子。现在让我们来看看对于更复杂的问题， 如何找到状态之间的转移方式(即找到状态转移方程)。 为此我们要引入一个新词叫递推关系来将状态联系起来(说的还是状态转移方程)</p>
<p>OK，上例子，看看它是如何工作的。</p>
<p>一个序列有N个数：A<a href="./images/sum.png" title="sum">1</a>,A[2],…,A[N]，求出最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)</p>
<p>正如上面我们讲的，面对这样一个问题，我们首先要定义一个“状态”来代表它的子问题， 并且找到它的解。注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。</p>
<p>让我们沿用“入门”一节里那道简单题的思路来一步步找到“状态”和“状态转移方程”。 假如我们考虑求A<a href="./images/sum.png" title="sum">1</a>,A[2],…,A[i]的最长非降子序列的长度，其中i&lt;N， 那么上面的问题变成了原问题的一个子问题(问题规模变小了，你可以让i=1,2,3等来分析) 然后我们定义d(i)，表示前i个数中以A[i]结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p>
<p>为了方便理解我们是如何找到状态转移方程的，我先把下面的例子提到前面来讲。 如果我们要求的这N个数的序列是：</p>
<p>5，3，4，8，6，7<br>根据上面找到的状态，我们可以得到：（下文的最长非降子序列都用LIS表示）</p>
<p>前1个数的LIS长度d(1)=1(序列：5)<br>前2个数的LIS长度d(2)=1(序列：3；3前面没有比3小的)<br>前3个数的LIS长度d(3)=2(序列：3，4；4前面有个比它小的3，所以d(3)=d(2)+1)<br>前4个数的LIS长度d(4)=3(序列：3，4，8；8前面比它小的有3个数，所以 d(4)=max{d(1),d(2),d(3)}+1=3)<br>OK，分析到这，我觉得状态转移方程已经很明显了，如果我们已经求出了d(1)到d(i-1)， 那么d(i)可以用下面的状态转移方程得到：</p>
<p>d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;=A[i]<br>用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。</p>
<p>Talk is cheap, show me the code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int lis(int A[], int n)&#123;</div><div class="line">    int *d = new int[n];</div><div class="line">    int len = 1;</div><div class="line">    for(int i=0; i&lt;n; ++i)&#123;</div><div class="line">        d[i] = 1;</div><div class="line">        for(int j=0; j&lt;i; ++j)</div><div class="line">            if(A[j]&lt;=A[i] &amp;&amp; d[j]+1&gt;d[i])</div><div class="line">                d[i] = d[j] + 1;</div><div class="line">        if(d[i]&gt;len) len = d[i];</div><div class="line">    &#125;</div><div class="line">    delete[] d;</div><div class="line">    return len;</div><div class="line">&#125;</div><div class="line">int main()&#123;</div><div class="line">    int A[] = &#123;</div><div class="line">        5, 3, 4, 8, 6, 7</div><div class="line">    &#125;;</div><div class="line">    cout&lt;&lt;lis(A, 6)&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该算法的时间复杂度是O(n^2 )，并不是最优的解法。 还有一种很巧妙的算法可以将时间复杂度降到O(nlogn)，网上已经有各种文章介绍它， 这里就不再赘述。传送门： LIS的O(nlogn)解法。 此题还可以用“排序+LCS”来解，感兴趣的话可自行Google。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我们遇到的问题中，有很大一部分可以用动态规划(简称DP)来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划之背包问题</title>
    <link href="http://yoursite.com/2017/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/09/06/动态规划之背包问题/</id>
    <published>2017-09-06T15:44:51.000Z</published>
    <updated>2017-09-06T07:55:15.399Z</updated>
    
    <content type="html"><![CDATA[<p>一切都要从一则故事说起。</p>
<p>话说有一哥们去森林里玩发现了一堆宝石，他数了数，一共有n个。 但他身上能装宝石的就只有一个背包，背包的容量为C。这哥们把n个宝石排成一排并编上号： 0,1,2,…,n-1。第i个宝石对应的体积和价值分别为V[i]和W[i] 。排好后这哥们开始思考： 背包总共也就只能装下体积为C的东西，那我要装下哪些宝石才能让我获得最大的利益呢？</p>
<p>OK，如果是你，你会怎么做？你斩钉截铁的说：动态规划啊！恭喜你，答对了。 那么让我们来看看，动态规划中最最最重要的两个概念： 状态和状态转移方程在这个问题中分别是什么。</p>
<p>我们要怎样去定义状态呢？这个状态总不能是凭空想象或是从天上掉下来的吧。 为了方便说明，让我们先实例化上面的问题。一般遇到n，你就果断地给n赋予一个很小的数， 比如n=3。然后设背包容量C=10，三个宝石的体积为5，4，3，对应的价值为20，10，12。 对于这个例子，我想智商大于0的人都知道正解应该是把体积为5和3的宝石装到背包里， 此时对应的价值是20+12=32。接下来，我们把第三个宝石拿走， 同时背包容量减去第三个宝石的体积（因为它是装入背包的宝石之一）， 于是问题的各参数变为：n=2，C=7，体积｛5，4｝，价值｛20，10｝。好了， 现在这个问题的解是什么？我想智商等于0的也解得出了：把体积为5的宝石放入背包 （然后剩下体积2，装不下第二个宝石，只能眼睁睁看着它溜走），此时价值为20。 这样一来，我们发现，n=3时，放入背包的是0号和2号宝石；当n=2时， 我们放入的是0号宝石。这并不是一个偶然，没错， 这就是传说中的“全局最优解包含局部最优解”（n=2是n=3情况的一个局部子问题）。 绕了那么大的圈子，你可能要问，这都哪跟哪啊？说好的状态呢？说好的状态转移方程呢？ 别急，它们已经呼之欲出了。</p>
<p>我们再把上面的例子理一下。当n=2时，我们要求的是前2个宝石， 装到体积为7的背包里能达到的最大价值；当n=3时，我们要求的是前3个宝石， 装到体积为10的背包里能达到的最大价值。有没有发现它们其实是一个句式！OK， 让我们形式化地表示一下它们， 定义d(i,j)为前i个宝石装到剩余体积为j的背包里能达到的最大价值。 那么上面两句话即为：d(2, 7)和d(3, 10)。这样看着真是爽多了， 而这两个看着很爽的符号就是我们要找的状态了。 即状态d(i,j)表示前i个宝石装到剩余体积为j的背包里能达到的最大价值。 上面那么多的文字，用一句话概括就是：根据子问题定义状态！你找到子问题， 状态也就浮出水面了。而我们最终要求解的最大价值即为d(n, C)：前n个宝石 （0,1,2…,n-1）装入剩余容量为C的背包中的最大价值。状态好不容易找到了， 状态转移方程呢？顾名思义，状态转移方程就是描述状态是怎么转移的方程（好废话！）。 那么回到例子，d(2, 7)和d(3, 10)是怎么转移的？来，我们来说说2号宝石 （记住宝石编号是从0开始的）。从d(2, 7)到d(3, 10)就隔了这个2号宝石。 它有两种情况，装或者不装入背包。如果装入，在面对前2个宝石时， 背包就只剩下体积7来装它们，而相应的要加上2号宝石的价值12， d(3, 10)=d(2, 10-3)+12=d(2, 7)+12；如果不装入，体积仍为10，价值自然不变了， d(3, 10)=d(2, 10)。记住，d(3, 10)表示的是前3个宝石装入到剩余体积为10 的背包里能达到的最大价值，既然是最大价值，就有d(3, 10)=max{ d(2, 10), d(2, 7)+12 }。好了，这条方程描述了状态d(i, j)的一些关系， 没错，它就是状态转移方程了。把它形式化一下：d(i, j)=max{ d(i-1, j), d(i-1,j-V[i-1]) + W[i-1] }。注意讨论前i个宝石装入背包的时候， 其实是在考查第i-1个宝石装不装入背包（因为宝石是从0开始编号的）。至此， 状态和状态转移方程都已经有了。接下来，直接上代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">    for(int j=0; j&lt;=C; ++j)&#123;</div><div class="line">        d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">        if(i&gt;0 &amp;&amp; j&gt;=V[i-1])  d[i][j] &gt;?= d[i-1][j-V[i-1]]+W[i-1];</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> i=0时，d(i, j)为什么为0呢？因为前0个宝石装入背包就是没东西装入，所以最大价值为0。 if语句里，j&gt;=V[i-1]说明只有当背包剩余体积j大于等于i-1号宝石的体积时， 我才考虑把它装进来的情况，不然d[i][j]就直接等于d[i-1][j]。i&gt;0不用说了吧， 前0个宝石装入背包的情况是边界，直接等于0，只有i&gt;0才有必要讨论， 我是装呢还是不装呢。简单吧，核心算法就这么一丁点，接下来上完整代码knapsack.cpp。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> /**0-1 knapsack d(i, j)表示前i个物品装到剩余容量为j的背包中的最大重量**/</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">#define MAXN 1000</div><div class="line">#define MAXC 100000</div><div class="line"></div><div class="line">int V[MAXN], W[MAXN];</div><div class="line">int d[MAXN][MAXC];</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);//重定向输入流</div><div class="line">	freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);//重定向输出流</div><div class="line">	int n, C;</div><div class="line">	while(scanf(&quot;%d %d&quot;, &amp;n, &amp;C) != EOF)&#123;</div><div class="line">		for(int i=0; i&lt;n; ++i)	scanf(&quot;%d %d&quot;, &amp;V[i], &amp;W[i]);</div><div class="line">		</div><div class="line">		for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">			for(int j=0; j&lt;=C; ++j)&#123;</div><div class="line">				d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">				if(i&gt;0 &amp;&amp; j&gt;=V[i-1])	d[i][j] &gt;?= d[i-1][j-V[i-1]]+W[i-1];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, d[n][C]);//最终求解的最大价值</div><div class="line">	&#125;</div><div class="line">	fclose(stdin);</div><div class="line">	fclose(stdout);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中freopen函数将标准输入流重定向到文件data.in， 这比运行程序时一点点手输要方便许多，将标准输出流重定向到data.out。 data.in中每组输入的第一行为宝石数量n及背包体积C，接下来会有n行的数据， 每行两个数对应的是宝石的体积及价值。本测试用例data.in如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">5 10</div><div class="line">4 9</div><div class="line">3 6</div><div class="line">5 1</div><div class="line">2 4</div><div class="line">5 1</div><div class="line">4 9</div><div class="line">4 20</div><div class="line">3 6</div><div class="line">4 20</div><div class="line">2 4</div><div class="line">5 10</div><div class="line">2 6</div><div class="line">2 3</div><div class="line">6 5</div><div class="line">5 4</div><div class="line">4 6</div></pre></td></tr></table></figure></p>
<p>data.out为算法输出结果，对应该测试用例，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">19</div><div class="line">40</div><div class="line">15</div></pre></td></tr></table></figure></p>
<p>好，至此我们解决了背包问题中最基本的0/1背包问题。等等，这时你可能要问， 我现在只知道背包能装入宝石的最大价值，但我还不知道要往背包里装入哪些宝石啊。嗯， 好问题！让我们先定义一个数组x，对于其中的元素为1时表示对应编号的宝石放入背包， 为0则不放入。让我们回到上面的例子，对于体积为5，4，3，价值为20，10，12的3个宝石 ，如何求得其对应的数组x呢？（明显我们目测一下就知道x={1 0 1}， 但程序可目测不出来）OK，让我们还是从状态说起。如果我们把2号宝石放入了背包， 那么是不是也就意味着，前3个宝石放入背包的最大价值要比前2个宝石放入背包的价值大， 即：d(3, 10)&gt;d(2, 10)。再用字母代替具体的数字 （不知不觉中我们就用了不完全归纳法哈），当d(i, j)&gt;d(i-1, j)时，x(i-1)=1;OK， 上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//输出打印方案</div><div class="line">int j = C;</div><div class="line">for(int i=n; i&gt;0; --i)&#123;</div><div class="line">    if(d[i][j] &gt; d[i-1][j])&#123;</div><div class="line">        x[i-1] = 1;</div><div class="line">        j = j - V[i-1];//装入第i-1个宝石后背包能装入的体积就只剩下j - V[i-1]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">for(int i=0; i&lt;n; ++i)  printf(&quot;%d &quot;, x[i]);</div></pre></td></tr></table></figure></p>
<p>好了，加入这部分内容，knapsack.cpp变为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**0-1 knapsack d(i, j)表示前i个物品装到剩余容量为j的背包中的最大重量**/</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">#define MAXN 1000</div><div class="line">#define MAXC 100000</div><div class="line"></div><div class="line">int V[MAXN], W[MAXN], x[MAXN];</div><div class="line">int d[MAXN][MAXC];</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);</div><div class="line">	freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);</div><div class="line">	int n, C;</div><div class="line">	while(scanf(&quot;%d %d&quot;, &amp;n, &amp;C) != EOF)&#123;</div><div class="line">		for(int i=0; i&lt;n; ++i)	scanf(&quot;%d %d&quot;, &amp;V[i], &amp;W[i]);</div><div class="line">		for(int i=0; i&lt;n; ++i)	x[i] = 0; //初始化打印方案</div><div class="line">		</div><div class="line">		for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">			for(int j=0; j&lt;=C; ++j)&#123;</div><div class="line">				d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">				if(i&gt;0 &amp;&amp; j&gt;=V[i-1])	d[i][j] &gt;?= d[i-1][j-V[i-1]]+W[i-1];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, d[n][C]);</div><div class="line">		</div><div class="line">		//输出打印方案</div><div class="line">		int j = C;</div><div class="line">		for(int i=n; i&gt;0; --i)&#123;</div><div class="line">			if(d[i][j] &gt; d[i-1][j])&#123;</div><div class="line">				x[i-1] = 1;</div><div class="line">				j = j - V[i-1];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		for(int i=0; i&lt;n; ++i)	printf(&quot;%d &quot;, x[i]);</div><div class="line">		printf(&quot;\n&quot;);</div><div class="line">	&#125;</div><div class="line">	fclose(stdin);</div><div class="line">	fclose(stdout);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>data.out输出结果变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">19</div><div class="line">1 1 0 1 0</div><div class="line">40</div><div class="line">1 0 1 0</div><div class="line">15</div><div class="line">1 1 0 0 1</div></pre></td></tr></table></figure></p>
<p>至此，好像该解决的问题都解决了。当一个问题找到一个放心可靠的解决方案后， 我们往往就要考虑一下是不是有优化方案了。为了保持代码的简洁， 我们暂且把宝石装包方案的求解去掉。该算法的时间复杂度是O(nC)， 即时间都花在两个for循环里了，这个应该是没办法再优化了。再看看空间复杂度， 数组d用来保存每个状态的值，空间复杂度为O(nC)； 数组V和W用来保存每个宝石的体积和价值，空间复杂度为O(n)。程序总的空间复杂度为 O(nC)，这个是可以进一步优化的。首先，我们先把数组V和W去掉， 因为它们没有保存的必要，改为一边读入一边计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int V = 0, W = 0;</div><div class="line">for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">    if(i&gt;0) scanf(&quot;%d %d&quot;, &amp;V,&amp;W);</div><div class="line">    for(int j=0; j&lt;=C;++j)&#123;</div><div class="line">        d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">        if(j&gt;=V &amp;&amp; i&gt;0) d[i][j] &gt;?= d[i-1][j-V]+W;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，接下来让我们继续压榨空间复杂度。保存状态值我们开了一个二维数组d， 在看过把一维数组V和W变为一个变量后，我们是不是要思考一下， 有没有办法将这个二维数组也压榨一下呢？换言之， 这个二维数组中的每个状态值我们真的有必要都保存么？ 让我们先来看一下以下的一张示意图（参照《算法竞赛入门经典》P169的图画的）<br><img src="./images/pic.png" alt="enter description here" title="pic"></p>
<p>由上面那一小段优化过后的代码可知，状态转移方程为：d(i, j)=max{ d(i-1, j), d(i-1, j-V)+W }，也就是在计算d(i, j)时我们用到了d(i-1,j)和d(i-1, j-V)的值。 如果我们只用一个一维数组d(0)～d(C)来保存状态值可以么？将i方向的维数去掉， 我们可以将原来二维数组表示为一维数据：d(i-1, j-V)变为d(j-V)， d(i-1, j)变为d(j)。当我们要计算d(i, j)时，只需要比较d(j)和d(j-V)+W的大小， 用较大的数更新d(j)即可。等等，如果我要计算d(i, j+1)，而它恰好要用到d(i-1, j)的值， 那么问题就出来了，因为你刚刚才把它更新为d(i, j)了。那么，怎么办呢？ 按照j递减的顺序即可避免这种问题。比如，你计算完d(i, j)， 接下来要计算的是d(i,j-1)，而它的状态转移方程为d(i, j-1)=max{ d(i-1, j-1), d(i-1, j-1-V)+W }，它不会再用到d(i-1,j)的值！所以， 即使该位置的值被更新了也无所谓。好，上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">memset(d, 0, sizeof(d));</div><div class="line">for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">    if(i&gt;0) scanf(&quot;%d %d&quot;, &amp;V,&amp;W);</div><div class="line">    for(int j=C;j&gt;=0; --j)&#123;</div><div class="line">        if(j&gt;=V &amp;&amp; i&gt;0) d[j] &gt;?= d[j-V]+W;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优化后的完整代码如下，此时空间复杂度仅为O(C)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**0-1 knapsack d(i, j)表示前i个物品装到剩余容量为j的背包中的最大重量**/</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cstdlib&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);</div><div class="line">	freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);</div><div class="line">	int n, C, V = 0, W = 0;</div><div class="line">	while(scanf(&quot;%d %d&quot;, &amp;n, &amp;C) != EOF)&#123;</div><div class="line">		int* d = (int*)malloc((C+1)*sizeof(int));</div><div class="line">		memset(d, 0, (C+1)*sizeof(int));</div><div class="line">		</div><div class="line">		for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">			if(i&gt;0)	scanf(&quot;%d %d&quot;, &amp;V, &amp;W);</div><div class="line">			for(int j=C; j&gt;=0; --j)&#123;</div><div class="line">				if(j&gt;=V &amp;&amp; i&gt;0)	d[j] &gt;?= d[j-V]+W;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, d[C]);</div><div class="line">		free(d);</div><div class="line">	&#125;</div><div class="line">	fclose(stdin);</div><div class="line">	fclose(stdout);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，背包问题暂时先讲这么多，以后接着讲。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一切都要从一则故事说起。&lt;/p&gt;
&lt;p&gt;话说有一哥们去森林里玩发现了一堆宝石，他数了数，一共有n个。 但他身上能装宝石的就只有一个背包，背包的容量为C。这哥们把n个宝石排成一排并编上号： 0,1,2,…,n-1。第i个宝石对应的体积和价值分别为V[i]和W[i] 。排好后这
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大二的一些改变</title>
    <link href="http://yoursite.com/2017/09/02/%E5%A4%A7%E4%BA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B9%E5%8F%98/"/>
    <id>http://yoursite.com/2017/09/02/大二的一些改变/</id>
    <published>2017-09-02T00:01:09.000Z</published>
    <updated>2017-09-01T16:29:33.774Z</updated>
    
    <content type="html"><![CDATA[<p>###<br>时间飞逝，转眼间，转眼间就大二了，看到大一新生报道的场景，仿佛看到了当初的自己—-那个带着无限的憧憬的少年。</p>
<p>是的，自己带着音乐的梦想、广交好友、说一口流利的英语等无限的纯真的想法来到这里，但不知为何一直都没有付诸行动，自己安慰自己说要忙专业的事情，觉得学好专业才是正确的事情，但也只有自己知道这是让自己内心好受一点的借口。</p>
<p>那么问题来了，什么才是正确的事情呢？在不知道答案的情况下，我要怎么选择呢？</p>
<p>在这个暑假，跟丰哥、日哥聚了一下，上一次见面好像是在高考后，算起来有一年不见了。丰哥买车了，日哥又重新开了一家琴行，大家都更上一层楼了，但在看看自己，在这一年里，自己在学校勉强不挂科，自己摸索着学习了一点网站的开发，就没什么其他能说的事情了，可悲。</p>
<p>这一年里，自己放下了吉他，也不再关心英语，能说话的朋友没几个，自己深知这样的大学生活不是自己想要的，但一直不知道要如何改变。不过，在这个暑假跟丰哥聊过之后，觉得计算机与音乐其实是可以结合在一起的，也谷歌到了一个新名词—-Computer  Music（王戈）。是的，计算机与音乐是可以联合起来的。我们深知计算机只是一个工具，一个帮助人们解决问题的工具，就像吉他是一个表现音乐的工具一样。我们要学的是怎么使用工具去解决实际的问题，而不是掌握工具。</p>
<p>丰哥还说了勤工俭学的事情，自己仔细算了算，大学这一年 确实是花了好多钱，学费高就不说了，自己还报名参加了外面的培训班，虽然自己知道这是正确的投资，但这一切都是建立在父母亲的辛苦之上的，不妥不妥。自己学吉他这么久了，没有用吉他来赚过一分钱，只有付出，没有任何回报….学了没有有，就等于没学，也是时候重新拿起吉他，以一个初学者的心态重新回忆，相信会有不同的收获。</p>
<p>一个人不能在同一个地方跌倒两次，所以自己摸索着学习的网站的开发的技能需要发挥出来，要能帮助自己，说白了，就是要得到回报。</p>
<p>还有就是朋友。自己参加了两个社团，吉他协会和排球协会，自己本来是有机会深入到核心团队的，但因为自己不是很把这些东西当回事，不是很上心，与协会里面的人只能说是认识，还不能是朋友的关系。在这一点上，自己需要改正，需要上心，只有我们把别人当成朋友，别人才能把自己当成朋友。</p>
<p>小智，就让你在大二遇见更好的你自己吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###&lt;br&gt;时间飞逝，转眼间，转眼间就大二了，看到大一新生报道的场景，仿佛看到了当初的自己—-那个带着无限的憧憬的少年。&lt;/p&gt;
&lt;p&gt;是的，自己带着音乐的梦想、广交好友、说一口流利的英语等无限的纯真的想法来到这里，但不知为何一直都没有付诸行动，自己安慰自己说要忙专业的事
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hibernate基础</title>
    <link href="http://yoursite.com/2017/08/12/Hibernate/"/>
    <id>http://yoursite.com/2017/08/12/Hibernate/</id>
    <published>2017-08-12T11:11:43.000Z</published>
    <updated>2017-09-01T16:39:51.022Z</updated>
    
    <content type="html"><![CDATA[<p>1.下载hibernate</p>
<pre><code>需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
</code></pre><p>2.解压hibernate</p>
<pre><code>下载后解压缩，得到一个hibernate-release-4.3.11.Final文件夹（我下载的hibernate版本是4.3.11），在hibernate-release-4.3.11.Final文件夹里有一个lib文件夹，里面放着hibernate的jar包。

例子中使用了lib下的required文件夹中的所有jar包。如图：



这些包的作用如下（待验证）：
</code></pre><p>包名<br>说明<br>antlr-2.7.7<br>可以接收词文法语言描述，并能产生识别这些语言的语句的程序，hibernate利用它实现hql到sql的转换。<br>dom4j-1.6.1<br>xml解析器，用来读写xml文件的。<br>hibernate-commons-annotations-4.0.5.Final<br>hibernate中支持注解开发的程序。<br>hibernate-core-4.3.11.Final<br>hibernate的核心程序。<br>hibernate-jpa-2.1-api-1.0.0.Final    hibernate对jap(java persistence API)规范的支持，可以理解为JAP是标准接口，hibernate是实现。<br>jandex-1.1.0.Final    用来检索注解(annotation)索引的程序，识别该对象是注解对象(待验证)？<br>javassist-3.18.1-GA    用来操作字节码的程序，可直接编辑和生成java字节码，以达到对.class文件的动态修改。<br>jboss-logging-3.1.3.GA    提供hibernate日志功能的程序(待验证)?<br>jboss-logging-annotations-1.2.0.Beta1    解析logging的注解模式程序(待验证)?<br>jboss-transaction-api_1.2_spec-1.0.0.Final    事务控制程序(待验证)?<br>3.导入hibernate的jar包</p>
<pre><code>创建一个JavaProject，引用上面图片中的jar包，这里需要另外一个jar包，由于我连接的是mysql数据库，所以需要在导入一个mysql-connector-java-5.1.7-bin.jar
</code></pre><p>4.新建一个测试用的java对象</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>public class User {</p>
<pre><code>public User() {
}

public User(String name, Date birthday) {
    this.name = name;
    this.birthday = birthday;
}

@Override
public String toString() {
    return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, birthday=&quot; + birthday
            + &quot;]&quot;;
}

public int getId() {
    return id;
}

public void setId(int id) {
    this.id = id;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public Date getBirthday() {
    return birthday;
}

public void setBirthday(Date birthday) {
    this.birthday = birthday;
}

private int id;
private String name;
private Date birthday;
</code></pre><p>}<br>    编写的java对象需要满足如下要素：</p>
<p>需要有一个无参的构造函数，因为在session.get时需要用到反射创建java对象；</p>
<p>需要提供一个id属性，对应数据库的主键；</p>
<p>需要为对象的其他属性提供get/set方法；</p>
<p>需要定义成非final的类，以便在hibernate进行延迟加载时为类创建代理；</p>
<p>如有必要保存到集合中，需要重equals方法和hashcode方法；</p>
<p>5.设置java对象与数据库的映射关系</p>
<pre><code>需要创建一个User.hbm.xml文件，编辑java对象与数据库的映射关系，格式如下：
</code></pre><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE hibernate-mapping PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN”<br>“<a href="http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-mapping><br>    <class name="cn.net.bysoft.lesson1.User" table="S_USER"><br>        <id name="id" type="integer" column="ID"><br>            <!-- 指定主键的生成方式，native是使用数据库本地的方式 --><br>            <generator class="native"></generator><br>        </id><br>        <property name="name" type="string" column="NAME"></property><br>        <property name="birthday" type="timestamp" column="BIRTHDAY"></property><br>    </class><br></hibernate-mapping><br>    该文件是用来配置java对象与数据表之间的映射关系的，其中需要留意的是id这个属性，generator来指定主键的生成方式，而native则代表是调用数据库本地的方式来生成主键，我使用的mysql数据库就会自动将id列设置成自增。</p>
<pre><code>主键具体有哪些生成方式，待接下来详细研究。
</code></pre><p>6.配置hibernate的配置信息</p>
<p>在src下创建一个hibernate.cfg.xml文件，格式如下：</p>
<p>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>    “-//Hibernate/Hibernate Configuration DTD 3.0//EN”<br>    “<a href="http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-configuration><br>    <session-factory><br>        <!-- 连接数据库的基本信息 --><br>        <property name="hibernate.connection.username">root</property><br>        <property name="hibernate.connection.password">root</property><br>        <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property><br>        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate4</property></session-factory></hibernate-configuration></p>
<pre><code>    &lt;!-- hibernate使用的数据库方言
         如果不知道可以去/hibernate-release-4.3.11.Final/project/etc/hibernate.properties
         中查找 --&gt;
    &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;
    &lt;!-- 是否在控制台显示sql语句 --&gt;
    &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否格式化显示的sql语句 --&gt;
    &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否自动生成数据表的策略,create代表每次启动程序都重新创建数据表 --&gt;
    &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;

    &lt;!-- 需要使用到的*.hbm.xml文件 --&gt;
    &lt;mapping resource=&quot;cn/net/bysoft/lesson1/User.hbm.xml&quot;/&gt;
&lt;/session-factory&gt;
</code></pre><p><br>    该文件需要注意的有两个地方，第一个是mapping属性，第二个是hibernate.hbm2ddl.auto这个属性。</p>
<pre><code>mapping属性用来配置*.hbm.xml的资源文件地址，这里需要注意的是没有用cn.net.bysoft.lession的形式，而是使用的&apos;/&apos;来描述目录位置。

接下来是自动执行ddl语句的设置(也就是hibernate.hbm2ddl.auto)参数有4个，分别是：
</code></pre><p>create</p>
<p>create为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来drop掉数据表，drop后重新create数据表；</p>
<p>create-drop</p>
<p>create-drop为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来create数据表。而每当sessionfactory被close时，会drop掉开始时create的数据表；</p>
<p>update</p>
<p>update为每次创建sessionfactory时，如果数据库中没有对应的表，则新建。</p>
<p>若已经新建过，则会判断*.hbm.xml文件的配置与建立好的数据表的结构是否相同。</p>
<p>如果相同则不去进行ddl的操作。</p>
<p>如果不同，则会根据*.hbm.xml文件中有变化的配置项去更新数据表，但不会删除数据表中已创建过的任何信息。</p>
<p>validate</p>
<p>validate为每次创建sessionfactory时，将用*.hbm.xml文件中的配置信息与现有的对应的数据表结构进行比较，若发现不同则抛出异常。</p>
<p>7.编写代码测试</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.hibernate.Transaction;<br>import org.hibernate.boot.registry.StandardServiceRegistry;<br>import org.hibernate.boot.registry.StandardServiceRegistryBuilder;<br>import org.hibernate.cfg.Configuration;<br>import org.junit.Test;</p>
<p>public class UserTest {</p>
<pre><code>@Test
public void test() {
    // 0.创建configuration对象，该对象保存着hibernate的配置信息和对象关系映射的信息。
    Configuration cfg = new Configuration().configure();
    // 1.创建sessionfactory对象
    StandardServiceRegistryBuilder builder = new StandardServiceRegistryBuilder().applySettings(cfg.getProperties());
    StandardServiceRegistry registry =  builder.build();
    SessionFactory sessionFactory = cfg.buildSessionFactory(registry); 
    // 2.创建session对象
    Session session = sessionFactory.openSession();
    // 3.开始事务
    Transaction transaction = session.beginTransaction();
    // 4.保存
    User user = new User(&quot;Jack&quot;, new Date());
    session.save(user);
    // 5.提交事务
    transaction.commit();
    // 6.关闭session对象
    session.close();
    // 7.关闭sessionfactory对象
    sessionFactory.close();
}
</code></pre><p>}<br>    上面这段代码中configuration对象用来保存则hibernate的配置信息，如hibernate.cfg.xml中的配置信息，和*.hbm.xml的映射信息。</p>
<pre><code>sessionfactory为创建session的工厂，它是线程安全的。一般建议一个项目中只有一个sessionfactory，因为创建sessionfactory非常费资源。

接下来是session对象，该对象是hibernate的核心，是一个单线程的对象，内部有session缓存。

对需要持久化的java对象的所有操作都用到了session。

常用的方法有get、load、save、update、saveorupdate、delete、begintransaction、isopen、flush、clear、evicto、close等等方法，接下来将会一个一个研究这些方法的使用。

这是执行这段代码后，控制台输出的内容：



创建了一张名为S_USER的数据表，并insert了一条数据。



到此位置，一个简单的hibernate环境就搭建好了。工程的目录结构如下：
</code></pre><p>1.下载hibernate</p>
<pre><code>需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
</code></pre><p>2.解压hibernate</p>
<pre><code>下载后解压缩，得到一个hibernate-release-4.3.11.Final文件夹（我下载的hibernate版本是4.3.11），在hibernate-release-4.3.11.Final文件夹里有一个lib文件夹，里面放着hibernate的jar包。

例子中使用了lib下的required文件夹中的所有jar包。如图：



这些包的作用如下（待验证）：
</code></pre><p>包名<br>说明<br>antlr-2.7.7<br>可以接收词文法语言描述，并能产生识别这些语言的语句的程序，hibernate利用它实现hql到sql的转换。<br>dom4j-1.6.1<br>xml解析器，用来读写xml文件的。<br>hibernate-commons-annotations-4.0.5.Final<br>hibernate中支持注解开发的程序。<br>hibernate-core-4.3.11.Final<br>hibernate的核心程序。<br>hibernate-jpa-2.1-api-1.0.0.Final    hibernate对jap(java persistence API)规范的支持，可以理解为JAP是标准接口，hibernate是实现。<br>jandex-1.1.0.Final    用来检索注解(annotation)索引的程序，识别该对象是注解对象(待验证)？<br>javassist-3.18.1-GA    用来操作字节码的程序，可直接编辑和生成java字节码，以达到对.class文件的动态修改。<br>jboss-logging-3.1.3.GA    提供hibernate日志功能的程序(待验证)?<br>jboss-logging-annotations-1.2.0.Beta1    解析logging的注解模式程序(待验证)?<br>jboss-transaction-api_1.2_spec-1.0.0.Final    事务控制程序(待验证)?<br>3.导入hibernate的jar包</p>
<pre><code>创建一个JavaProject，引用上面图片中的jar包，这里需要另外一个jar包，由于我连接的是mysql数据库，所以需要在导入一个mysql-connector-java-5.1.7-bin.jar
</code></pre><p>4.新建一个测试用的java对象</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>public class User {</p>
<pre><code>public User() {
}

public User(String name, Date birthday) {
    this.name = name;
    this.birthday = birthday;
}

@Override
public String toString() {
    return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, birthday=&quot; + birthday
            + &quot;]&quot;;
}

public int getId() {
    return id;
}

public void setId(int id) {
    this.id = id;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public Date getBirthday() {
    return birthday;
}

public void setBirthday(Date birthday) {
    this.birthday = birthday;
}

private int id;
private String name;
private Date birthday;
</code></pre><p>}<br>    编写的java对象需要满足如下要素：</p>
<p>需要有一个无参的构造函数，因为在session.get时需要用到反射创建java对象；</p>
<p>需要提供一个id属性，对应数据库的主键；</p>
<p>需要为对象的其他属性提供get/set方法；</p>
<p>需要定义成非final的类，以便在hibernate进行延迟加载时为类创建代理；</p>
<p>如有必要保存到集合中，需要重equals方法和hashcode方法；</p>
<p>5.设置java对象与数据库的映射关系</p>
<pre><code>需要创建一个User.hbm.xml文件，编辑java对象与数据库的映射关系，格式如下：
</code></pre><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE hibernate-mapping PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN”<br>“<a href="http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-mapping><br>    <class name="cn.net.bysoft.lesson1.User" table="S_USER"><br>        <id name="id" type="integer" column="ID"><br>            <!-- 指定主键的生成方式，native是使用数据库本地的方式 --><br>            <generator class="native"></generator><br>        </id><br>        <property name="name" type="string" column="NAME"></property><br>        <property name="birthday" type="timestamp" column="BIRTHDAY"></property><br>    </class><br></hibernate-mapping><br>    该文件是用来配置java对象与数据表之间的映射关系的，其中需要留意的是id这个属性，generator来指定主键的生成方式，而native则代表是调用数据库本地的方式来生成主键，我使用的mysql数据库就会自动将id列设置成自增。</p>
<pre><code>主键具体有哪些生成方式，待接下来详细研究。
</code></pre><p>6.配置hibernate的配置信息</p>
<p>在src下创建一个hibernate.cfg.xml文件，格式如下：</p>
<p>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>    “-//Hibernate/Hibernate Configuration DTD 3.0//EN”<br>    “<a href="http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-configuration><br>    <session-factory><br>        <!-- 连接数据库的基本信息 --><br>        <property name="hibernate.connection.username">root</property><br>        <property name="hibernate.connection.password">root</property><br>        <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property><br>        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate4</property></session-factory></hibernate-configuration></p>
<pre><code>    &lt;!-- hibernate使用的数据库方言
         如果不知道可以去/hibernate-release-4.3.11.Final/project/etc/hibernate.properties
         中查找 --&gt;
    &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;
    &lt;!-- 是否在控制台显示sql语句 --&gt;
    &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否格式化显示的sql语句 --&gt;
    &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否自动生成数据表的策略,create代表每次启动程序都重新创建数据表 --&gt;
    &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;

    &lt;!-- 需要使用到的*.hbm.xml文件 --&gt;
    &lt;mapping resource=&quot;cn/net/bysoft/lesson1/User.hbm.xml&quot;/&gt;
&lt;/session-factory&gt;
</code></pre><p><br>    该文件需要注意的有两个地方，第一个是mapping属性，第二个是hibernate.hbm2ddl.auto这个属性。</p>
<pre><code>mapping属性用来配置*.hbm.xml的资源文件地址，这里需要注意的是没有用cn.net.bysoft.lession的形式，而是使用的&apos;/&apos;来描述目录位置。

接下来是自动执行ddl语句的设置(也就是hibernate.hbm2ddl.auto)参数有4个，分别是：
</code></pre><p>create</p>
<p>create为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来drop掉数据表，drop后重新create数据表；</p>
<p>create-drop</p>
<p>create-drop为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来create数据表。而每当sessionfactory被close时，会drop掉开始时create的数据表；</p>
<p>update</p>
<p>update为每次创建sessionfactory时，如果数据库中没有对应的表，则新建。</p>
<p>若已经新建过，则会判断*.hbm.xml文件的配置与建立好的数据表的结构是否相同。</p>
<p>如果相同则不去进行ddl的操作。</p>
<p>如果不同，则会根据*.hbm.xml文件中有变化的配置项去更新数据表，但不会删除数据表中已创建过的任何信息。</p>
<p>validate</p>
<p>validate为每次创建sessionfactory时，将用*.hbm.xml文件中的配置信息与现有的对应的数据表结构进行比较，若发现不同则抛出异常。</p>
<p>7.编写代码测试</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.hibernate.Transaction;<br>import org.hibernate.boot.registry.StandardServiceRegistry;<br>import org.hibernate.boot.registry.StandardServiceRegistryBuilder;<br>import org.hibernate.cfg.Configuration;<br>import org.junit.Test;</p>
<p>public class UserTest {</p>
<pre><code>@Test
public void test() {
    // 0.创建configuration对象，该对象保存着hibernate的配置信息和对象关系映射的信息。
    Configuration cfg = new Configuration().configure();
    // 1.创建sessionfactory对象
    StandardServiceRegistryBuilder builder = new StandardServiceRegistryBuilder().applySettings(cfg.getProperties());
    StandardServiceRegistry registry =  builder.build();
    SessionFactory sessionFactory = cfg.buildSessionFactory(registry); 
    // 2.创建session对象
    Session session = sessionFactory.openSession();
    // 3.开始事务
    Transaction transaction = session.beginTransaction();
    // 4.保存
    User user = new User(&quot;Jack&quot;, new Date());
    session.save(user);
    // 5.提交事务
    transaction.commit();
    // 6.关闭session对象
    session.close();
    // 7.关闭sessionfactory对象
    sessionFactory.close();
}
</code></pre><p>}<br>    上面这段代码中configuration对象用来保存则hibernate的配置信息，如hibernate.cfg.xml中的配置信息，和*.hbm.xml的映射信息。</p>
<pre><code>sessionfactory为创建session的工厂，它是线程安全的。一般建议一个项目中只有一个sessionfactory，因为创建sessionfactory非常费资源。

接下来是session对象，该对象是hibernate的核心，是一个单线程的对象，内部有session缓存。

对需要持久化的java对象的所有操作都用到了session。

常用的方法有get、load、save、update、saveorupdate、delete、begintransaction、isopen、flush、clear、evicto、close等等方法，接下来将会一个一个研究这些方法的使用。

这是执行这段代码后，控制台输出的内容：



创建了一张名为S_USER的数据表，并insert了一条数据。



到此位置，一个简单的hibernate环境就搭建好了。工程的目录结构如下：
</code></pre><p>配置对象<br>配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。</p>
<p>数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。<br>类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。<br>SessionFactory 对象<br>配置对象被用于创造一个 SessionFactory 对象，使用提供的配置文件为应用程序依次配置 Hibernate，并允许实例化一个会话对象。SessionFactory 是一个线程安全对象并由应用程序所有的线程所使用。</p>
<p>SessionFactory 是一个重量级对象所以通常它都是在应用程序启动时创造然后留存为以后使用。每个数据库需要一个 SessionFactory 对象使用一个单独的配置文件。所以如果你使用多种数据库那么你要创造多种 SessionFactory 对象。</p>
<p>Session 对象<br>一个会话被用于与数据库的物理连接。Session 对象是轻量级的，并被设计为每次实例化都需要与数据库的交互。持久对象通过 Session 对象保存和检索。</p>
<p>Session 对象不应该长时间保持开启状态因为它们通常情况下并非线程安全，并且它们应该按照所需创造和销毁。</p>
<p>Transaction 对象<br>一个事务代表了与数据库工作的一个单元并且大部分 RDBMS 支持事务功能。在 Hibernate 中事务由底层事务管理器和事务（来自 JDBC 或者 JTA）处理。</p>
<p>这是一个选择性对象，Hibernate 应用程序可能不选择使用这个接口，而是在自己应用程序代码中管理事务。</p>
<p>Query 对象<br>Query 对象使用 SQL 或者 Hibernate 查询语言（HQL）字符串在数据库中来检索数据并创造对象。一个查询的实例被用于连结查询参数，限制由查询返回的结果数量，并最终执行查询。</p>
<p>Criteria 对象<br>Criteria 对象被用于创造和执行面向规则查询的对象来检索对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.下载hibernate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.解压hibernate&lt;/p&gt;
&lt;pre&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
