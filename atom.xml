<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-17T16:38:12.180Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python|python正则表达式</title>
    <link href="http://yoursite.com/2018/10/18/python-python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/18/python-python正则表达式/</id>
    <published>2018-10-17T23:57:33.000Z</published>
    <updated>2018-10-17T16:38:12.180Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>转:<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832260566c26442c671fa489ebc6fe85badda25cd000" target="_blank" rel="external">廖雪峰的官方网站|正则表达式</a></li>
<li>转:<a href="https://cuiqingcai.com/5530.html" target="_blank" rel="external">Python3网络爬虫开发实战</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;转:&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/001374738125095c955c
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python|flask简单用</title>
    <link href="http://yoursite.com/2018/10/17/python-flask%E7%AE%80%E5%8D%95%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/17/python-flask简单用/</id>
    <published>2018-10-16T23:56:41.000Z</published>
    <updated>2018-10-16T15:57:18.959Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nginx-Gunicorn部署Flask项目"><a href="#nginx-Gunicorn部署Flask项目" class="headerlink" title="nginx+Gunicorn部署Flask项目"></a>nginx+Gunicorn部署Flask项目</h3><p><a href="https://juejin.im/post/5a5c1825f265da3e3e33bf70" target="_blank" rel="external">部署</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;nginx-Gunicorn部署Flask项目&quot;&gt;&lt;a href=&quot;#nginx-Gunicorn部署Flask项目&quot; class=&quot;headerlink&quot; title=&quot;nginx+Gunicorn部署Flask项目&quot;&gt;&lt;/a&gt;nginx+Gunicorn部署F
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python|pytest单元测试</title>
    <link href="http://yoursite.com/2018/10/17/python-pytest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/10/17/python-pytest单元测试/</id>
    <published>2018-10-16T23:54:37.000Z</published>
    <updated>2018-10-16T16:40:39.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pytest的fixture"><a href="#pytest的fixture" class="headerlink" title="pytest的fixture"></a>pytest的fixture</h3><ul>
<li>将fixture作为函数参数</li>
<li><p>使用fixture的依赖注入</p>
</li>
<li><p>转:<a href="https://blog.csdn.net/hekaiyou/article/details/79242391" target="_blank" rel="external">pytest的fixture</a></p>
</li>
<li>转:<a href="https://www.jianshu.com/p/552c3f1e9946" target="_blank" rel="external">Pytest - 进阶功能fixture</a></li>
<li>转:<a href="http://www.testclass.net/pytest/parametrize_fixture/" target="_blank" rel="external">参数化的Fixture</a></li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>转:<a href="http://ningning.today/2016/11/22/python/flask-unittest/" target="_blank" rel="external">flask项目单元测试实践</a></li>
<li>转:<a href="http://ningning.today/2016/08/27/python/python%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" target="_blank" rel="external">python单元测试</a></li>
<li>转:<a href="http://www.testclass.net/tags/pytest/" target="_blank" rel="external">pytest系列教程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;pytest的fixture&quot;&gt;&lt;a href=&quot;#pytest的fixture&quot; class=&quot;headerlink&quot; title=&quot;pytest的fixture&quot;&gt;&lt;/a&gt;pytest的fixture&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;将fixture作为函数参数&lt;/
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python|SQLAlchemy之Relationship</title>
    <link href="http://yoursite.com/2018/10/14/python-SQLAlchemy%E4%B9%8BRelationship/"/>
    <id>http://yoursite.com/2018/10/14/python-SQLAlchemy之Relationship/</id>
    <published>2018-10-13T23:21:12.000Z</published>
    <updated>2018-10-13T17:04:30.241Z</updated>
    
    <content type="html"><![CDATA[<h3 id="relationship"><a href="#relationship" class="headerlink" title="relationship"></a><code>relationship</code></h3><p>简单来说, <code>relationship</code>函数是<code>sqlalchemy</code>对关系之间提供的一种便利的调用方式, backref参数则对关系提供反向引用的声明。假如没有relationship，我们只能像下面这样调用关系数据：给定参数User.name,获取该user的addresses。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def get_addresses_from_user(user_name):</div><div class="line">    user = session.query(User).filter_by(name=user_name).first()</div><div class="line">    addresses = session.query(Address).filter_by(user_id=user.id).all()</div><div class="line">    return addresses</div></pre></td></tr></table></figure></p>
<p>如果在User中使用relationship定义addresses属性的话，<code>addresses = relationship(&#39;Address&#39;)</code>,则我们可以直接在User对象中通过addresses属性获得指定用户的所有地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def get_addresses_from_user(user_name):</div><div class="line">    user = session.query(User).filter_by(name=user_name).first()</div><div class="line">    return user.addresses</div></pre></td></tr></table></figure></p>
<p>注意，在上面的addresses属性中我们并没有定义backref属性,所以我们可以通过User对象获取所拥有的地址，但是不能通过Address对象获取到所属的用户。</p>
<h3 id="backref"><a href="#backref" class="headerlink" title="backref"></a><code>backref</code></h3><p>简单地说就是: <code>backref</code>用于在关系另一端的类中快捷地创建一个指向当前类对象的属性, 而当需要对那个属性指定参数时使用 <code>db.backref()</code></p>
<p>在上例中，在<code>user</code>的<code>addresses</code>属性中我们并没有定义<code>backref</code>属性,所以我们可以通过User对象获取所拥有的地址，但是不能通过Address对象获取到所属的用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; u = User()</div><div class="line">&gt;&gt;&gt; u.addresses</div><div class="line">[]</div><div class="line">&gt;&gt;&gt; a = Address()</div><div class="line">&gt;&gt;&gt; a.user</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: &apos;Address&apos; object has no attribute &apos;user&apos;</div></pre></td></tr></table></figure>
<p>但是当我们有从Address对象获取所属用户的需求时，backref参数就派上用场了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">addresses = relationship(&apos;Address&apos;, backref=&apos;user&apos;)</div><div class="line">&gt;&gt;&gt; a = Address()</div><div class="line">&gt;&gt;&gt; a.user</div></pre></td></tr></table></figure></p>
<p>大致原理应该就是sqlalchemy在运行时对Address对象动态的设置了一个指向所属User对象的属性，这样就能在实际开发中使逻辑关系更加清晰，代码更加简洁了。</p>
<p>转:<a href="https://www.zhihu.com/question/38456789" target="_blank" rel="external">知乎</a></p>
<h3 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a><code>lazy</code></h3><p>lazy 决定了 SQLAlchemy 什么时候从数据库中加载数据:，有如下四个值:(其实还有个noload不常用)</p>
<ul>
<li><p>select: (which is the default) means that SQLAlchemy will load the data as necessary in one go using a standard select statement.</p>
</li>
<li><p>joined: tells SQLAlchemy to load the relationship in the same query as the parent using a JOIN statement.</p>
</li>
<li><p>subquery: works like ‘joined’ but instead SQLAlchemy will use a subquery.</p>
</li>
<li><p>dynamic : is special and useful if you have many items. Instead of loading the items SQLAlchemy will return another query object which you can further refine before loading the items. This is usually what you want if you expect more than a handful of items for this relationship</p>
</li>
</ul>
<p>通俗了说，<code>select</code>就是访问到属性的时候，就会全部加载该属性的数据。<code>joined</code>则是在对关联的两个表进行join操作，从而获取到所有相关的对象。<code>dynamic</code>则不一样，在访问属性的时候，并没有在内存中加载数据，而是返回一个<code>query对象</code>, 需要执行相应方法才可以获取对象，比如<code>.all()</code>.</p>
<p>转:<a href="https://blog.csdn.net/qq_34146899/article/details/52559747" target="_blank" rel="external">flask-sqlalchemy中 backref lazy的参数实例解释和选择</a><br>转:<a href="https://blog.csdn.net/bestallen/article/details/52601457" target="_blank" rel="external">SQLalchemy relationship之lazy属性 学习笔记</a></p>
<p>转:<a href="https://www.xncoding.com/2016/03/07/python/sqlalchemy02.html" target="_blank" rel="external">SQLAlchemy进阶</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;relationship&quot;&gt;&lt;a href=&quot;#relationship&quot; class=&quot;headerlink&quot; title=&quot;relationship&quot;&gt;&lt;/a&gt;&lt;code&gt;relationship&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;简单来说, &lt;code&gt;relat
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python|init.py</title>
    <link href="http://yoursite.com/2018/10/08/python-init-py/"/>
    <id>http://yoursite.com/2018/10/08/python-init-py/</id>
    <published>2018-10-08T08:10:15.000Z</published>
    <updated>2018-10-08T00:58:38.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近在用python写项目，老搞不清楚python里面的包，模块的概念，今天系统学习下。</p>
<p><a href="https://www.cnblogs.com/Lands-ljk/p/5880483.html" target="_blank" rel="external">Python <strong>init</strong>.py 作用详解</a><br><a href="https://juejin.im/post/5aa0ba38f265da2395308dbd" target="_blank" rel="external">python模块详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;最近在用python写项目，老搞不清楚python里面的包，模块的概念，今天系统学习下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://w
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>数据库|关于索引</title>
    <link href="http://yoursite.com/2018/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2018/07/20/数据库-关于索引/</id>
    <published>2018-07-20T14:59:10.000Z</published>
    <updated>2018-07-20T08:15:16.108Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/6T5YxejFwwm6G93rb6PawA" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></p>
<p><a href="https://www.kancloud.cn/kancloud/theory-of-mysql-index/41846" target="_blank" rel="external">看云</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6T5YxejFwwm6G93rb6PawA&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>干货|单片机学习历程</title>
    <link href="http://yoursite.com/2018/07/13/%E5%B9%B2%E8%B4%A7-%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/07/13/干货-单片机学习历程/</id>
    <published>2018-07-12T16:38:02.000Z</published>
    <updated>2018-07-12T09:29:29.805Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://wiki.jikexueyuan.com/project/mcu-tutorial-one/" target="_blank" rel="external">单片机教程(一)</a></p>
<p><a href="http://wiki.jikexueyuan.com/list/microcontrollers/" target="_blank" rel="external">单片机</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/mcu-tutorial-one/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;单片机教程(一)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.j
    
    </summary>
    
      <category term="干货" scheme="http://yoursite.com/categories/%E5%B9%B2%E8%B4%A7/"/>
    
    
      <category term="干货" scheme="http://yoursite.com/tags/%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP中的无限极分类、无限嵌套评论</title>
    <link href="http://yoursite.com/2018/07/07/PHP-PHP%E4%B8%AD%E7%9A%84%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB%E3%80%81%E6%97%A0%E7%BA%BF%E5%B5%8C%E5%A5%97%E8%AF%84%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/07/07/PHP-PHP中的无限极分类、无线嵌套评论/</id>
    <published>2018-07-07T14:08:59.000Z</published>
    <updated>2018-07-07T06:26:53.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>无限级的分类在平常的开发中是常见的需求，并且在不少面试题中都会碰到。不管你做什么项目，应该都碰到过类似的问题。下面，我们就使用递归的思想，实战一把。</p>
<h3 id="无线分类"><a href="#无线分类" class="headerlink" title="无线分类"></a>无线分类</h3><p>首先，看下我们的表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `categories` (</div><div class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</div><div class="line">  `categoryName` varchar(100) NOT NULL,</div><div class="line">  `parentCategory` int(11) DEFAULT &apos;0&apos;,</div><div class="line">  `sortInd` int(11) NOT NULL,</div><div class="line">  PRIMARY KEY (`id`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;</div><div class="line"></div><div class="line"></div><div class="line">INSERT INTO `categories` VALUES (1, &apos;First&apos;, 0, 0);</div><div class="line">INSERT INTO `categories` VALUES (2, &apos;Second&apos;, 1, 0);</div><div class="line">INSERT INTO `categories` VALUES (3, &apos;Third&apos;, 1, 0);</div><div class="line">INSERT INTO `categories` VALUES (4, &apos;Fourth&apos;, 3, 0);</div><div class="line">INSERT INTO `categories` VALUES (5, &apos;Fifth&apos;, 4, 0);</div><div class="line">INSERT INTO `categories` VALUES (6, &apos;Sixth&apos;, 5, 0);</div><div class="line">INSERT INTO `categories` VALUES (7, &apos;Seventh&apos;, 6, 0);</div><div class="line">INSERT INTO `categories` VALUES (8, &apos;Eighth&apos;, 7, 0);</div><div class="line">INSERT INTO `categories` VALUES (9, &apos;Nineth&apos;, 1, 0);</div><div class="line">INSERT INTO `categories` VALUES (10, &apos;Tenth&apos;, 2, 0);</div></pre></td></tr></table></figure>
<p>下面 我们直接看代码实现。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$dsn = <span class="string">"mysql:host=127.0.0.1;port=3306;dbname=test;charset=UTF8;"</span>;</div><div class="line">$username = <span class="string">'root'</span>;</div><div class="line">$password = <span class="string">'admin'</span>;</div><div class="line">$pdo = <span class="keyword">new</span> PDO($dsn, $username, $password);</div><div class="line">$sql = <span class="string">'SELECT * FROM `categories` ORDER BY `parentCategory`, `sortInd`'</span>;</div><div class="line">$result = $pdo-&gt;query($sql, PDO::FETCH_OBJ);</div><div class="line">$categories = [];</div><div class="line"><span class="keyword">foreach</span> ($result <span class="keyword">as</span> $category) &#123;</div><div class="line">    $categories[$category-&gt;parentCategory][] = $category;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCategoryTree</span><span class="params">($categories, $n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>($categories[$n])) &#123;</div><div class="line">        <span class="keyword">foreach</span> ($categories[$n] <span class="keyword">as</span> $category) &#123;</div><div class="line">            <span class="keyword">echo</span> str_repeat(<span class="string">'-'</span>, $n) . $category-&gt;categoryName . PHP_EOL;</div><div class="line">            showCategoryTree($categories, $category-&gt;id);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">showCategoryTree($categories, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>可以看到，我们首先获取到了所有的数据，然后按照父级ID归类。这是一个非常棒的数据结构。想象一下，我们把展示顶级目录下所有子目录的问题分解成了展示自己的类目标题和展示数据中parentCategory为当前目录id的子目录，然后使用开始递归调用。最后的输出是这个样子的。</p>
<p><img src="../images/php.png" alt=""></p>
<h3 id="无限嵌套评论"><a href="#无限嵌套评论" class="headerlink" title="无限嵌套评论"></a>无限嵌套评论</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `comments` (</div><div class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</div><div class="line">  `comment` varchar(500) NOT NULL,</div><div class="line">  `username` varchar(50) NOT NULL,</div><div class="line">  `datetime` datetime NOT NULL,</div><div class="line">  `parentID` int(11) NOT NULL,</div><div class="line">  `postID` int(11) NOT NULL,</div><div class="line">  PRIMARY KEY (`id`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=latin1;</div></pre></td></tr></table></figure>
<p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$dsn = &quot;mysql:host=127.0.0.1;port=3306;dbname=test;charset=UTF8;&quot;;</div><div class="line">$username = &apos;root&apos;;</div><div class="line">$password = &apos;admin&apos;;</div><div class="line">$pdo = new PDO($dsn, $username, $password);</div><div class="line">$sql = &apos;SELECT * FROM `comments` WHERE `postID` = :id ORDER BY `parentId`, `datetime`&apos;;</div><div class="line">$stmt = $pdo-&gt;prepare($sql);</div><div class="line">$stmt-&gt;setFetchMode(PDO::FETCH_OBJ);</div><div class="line">$stmt-&gt;execute([&apos;:id&apos; =&gt; 1]);</div><div class="line">$result = $stmt-&gt;fetchAll();</div><div class="line">$comments = [];</div><div class="line">foreach ($result as $comment) &#123;</div><div class="line">    $comments[$comment-&gt;parentID][] = $comment;</div><div class="line">&#125;</div><div class="line">function showComments(array $comments, $n)</div><div class="line">&#123;</div><div class="line">    if (isset($comments[$n])) &#123;</div><div class="line">        foreach ($comments[$n] as $comment) &#123;</div><div class="line">            echo str_repeat(&apos;-&apos;, $n) . $comment-&gt;comment . PHP_EOL;</div><div class="line">            showComments($comments, $comment-&gt;id);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">showComments($comments, 0);</div></pre></td></tr></table></figure></p>
<p><a href="https://juejin.im/post/5b3e1fa55188251b134e54aa?utm_source=gold_browser_extension" target="_blank" rel="external">PHP中的无限级分类、无限嵌套评论</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;无限级的分类在平常的开发中是常见的需求，并且在不少面试题中都会碰到。不管你做什么项目，应该都碰到过类似的问题。下面，我们就使用递归的思想，实
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>UNIX编程|信号集</title>
    <link href="http://yoursite.com/2018/07/06/UNIX%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7%E9%9B%86/"/>
    <id>http://yoursite.com/2018/07/06/UNIX编程-信号集/</id>
    <published>2018-07-05T19:32:01.000Z</published>
    <updated>2018-07-06T07:01:50.155Z</updated>
    
    <content type="html"><![CDATA[<h3 id="信号传递过程"><a href="#信号传递过程" class="headerlink" title="信号传递过程"></a>信号传递过程</h3><p>信号源为目标进程产生了一个信号,然后由内核来决定是否要将该信号传递给目标进程。从信号产生到传递给目标进程的流程图如下图所示：</p>
<p><img src="/images/Unix-信号集-01.png" alt=""></p>
<p>进程可以阻塞信号的传递。当信号源为目标进程产生了一个信号之后,内核会执行依次执行下面操作,</p>
<ol>
<li><p>如果目标进程设置了忽略该信号,则内核直接将该信号丢弃。</p>
</li>
<li><p>如果目标进程没有阻塞该信号,则内核将该信号传递给目标进程,由目标进程执行相对应操作。</p>
</li>
<li><p>如果目标进程设置阻塞该信号,则内核将该信号放到目标进程的阻塞信号列表中,等待目标进程对该类型信号的下一步设置。若目标进程后续设置忽略该信号,则内核将该信号从目标进程的阻塞信号列表中移除并丢弃。若目标进程对该信号解除了阻塞,内核将该信号传递给目标进程进行相对应的操作。</p>
</li>
</ol>
<p>在信号产生到信号传递给目标进程之间的时间间隔内,我们称该<strong>信号为未决的(pending)</strong>。</p>
<p>每个进程都有一个<strong>信号屏蔽字(signal mask)</strong>,它规定了当前要阻塞传递给该进程的信号集。对于每种可能的信号,信号屏蔽字中都有一位与之对应。</p>
<h3 id="信号集及其操作"><a href="#信号集及其操作" class="headerlink" title="信号集及其操作"></a>信号集及其操作</h3><p>POSIX.1 定义了一个数据类型sigset_t,用于表示信号集。另外,头文件 signal.h 提供了下列五个处理信号集的函数。</p>
<p>函数 <code>sigemptyset</code> 初始化由 set 指向的信号集,清除其中所有信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int sigemptyset(sigset_t *set);</div><div class="line"></div><div class="line">返回值:若成功则返回0,若出错则返回-1</div></pre></td></tr></table></figure>
<p>函数 <code>sigfillset</code> 初始化由 set 指向的信号集,使其包含所有信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int sigfillset(sigset_t *set);</div><div class="line">返回值:若成功则返回0,若出错则返回-1</div></pre></td></tr></table></figure>
<p>函数<code>sigaddset</code> 将一个信号 signo 添加到现有信号集 set 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int sigaddset(sigset_t *set, int signo);</div><div class="line">返回值:若成功则返回0,若出错则返回-1</div></pre></td></tr></table></figure>
<p>函数 <code>sigdelset</code> 将一个信号 signo 从信号集 set 中删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int sigdelset(sigset_t *set, int signo);</div><div class="line">返回值:若成功则返回0,若出错则返回-1</div></pre></td></tr></table></figure>
<p>函数<code>sigismember</code>判断指定信号 signo 是否在信号集 set 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int sigismember(const sigset_t *set, int signo);</div><div class="line">返回值:若真则返回1,若假则返回0,若出错则返回-1</div></pre></td></tr></table></figure>
<p>函数 <code>sigprocmask</code>可以检测或者设置进程的信号屏蔽字。</p>
<p><code>task_struct</code>结构有一个<code>blocked</code> 成员[业界称之为“信号屏蔽字”]，它指定了进程阻塞的信号，被阻塞的信号将不能被递送给进程，直到进程解除阻塞。在信号被阻塞时，内核将其放置到待决列表上。如果同一个信号在阻塞期间被发送了多次，则在待决列表中只放置一次。也就是说，不管发送了多少相同的信号，在进程删除阻塞后，都只会接收到一个信号。调用函数sigprocmask 可以检测或更改其信号屏蔽字。在调用 sigprocmask 后如果有任何未决的、不再阻塞的信号，则在 sigprocmask 返回前，至少会将其中一个信号递送给该进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   #include &lt;signal.h&gt;  </div><div class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oset);  </div><div class="line">   返回值:若成功则返回0,若出错则返回-1</div></pre></td></tr></table></figure></p>
<p>如果oset是非空指针，则读取进程的当前信号屏蔽字并保存到oset中。如果set是非空指针，则更改进程的信号屏蔽字，参数how指示如何更改。如果oset和set都是非空指针，则先将原来的信号屏蔽字备份到oset里，然后根据set和how参数更改信号屏蔽字。假设当前的信号屏蔽字为mask，下表说明了how参数的可选值:</p>
<table>
<thead>
<tr>
<th>how</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIG_BLOCK</td>
<td>set包含了我们希望添加到当前信号屏蔽字的信号，相当于 <strong>mask=mask l set</strong></td>
</tr>
<tr>
<td>SIG_UNBLOCK</td>
<td>set包含了我们希望从当前信号屏蔽字中解除阻塞的信号，相当于<strong>mask=mask&amp;~set</strong></td>
</tr>
<tr>
<td>SIG_SETMASK</td>
<td>设置当前信号屏蔽字为set所指向的值，相当于mask=set</td>
</tr>
</tbody>
</table>
<p>下面我们来看一个例子:在下面的程序文件中先调用 <code>sigprocmask</code> 设置阻塞信号 SIGALRM,然后调用 <code>alarm(2)</code>设置一个两秒钟的闹钟 [两秒钟之后将向当前进程产生一个 SIGALRM 信号]。在睡眠 4 秒钟之后[此时应该已经产生了 SIGALRM 信号],调用 sigprocmask 函数解除对信号SIGALRM 的阻塞。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"received SIGALRM\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">sigset_t</span> sigset;</div><div class="line"></div><div class="line">  sigemptyset(&amp;sigset);</div><div class="line">  sigaddset(&amp;sigset, SIGALRM);</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;sigset, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sigprocmask error: %s\n"</span>, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (signal(SIGALRM, sig_alrm) &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"signal error: %s\n"</span>, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  alarm(<span class="number">2</span>);</div><div class="line">  sleep(<span class="number">4</span>);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"before unblock sigprocmask\n"</span>);</div><div class="line">  <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;sigset, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sigprocmask SIG_UNBLOCK error: %s\n"</span>, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"before exit\n"</span>);</div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/LAB-shlab/<span class="built_in">test</span>$ gcc sigset.c -o sigset</div><div class="line">ubuntu@VM-162-156-ubuntu:~/LAB-shlab/<span class="built_in">test</span>$ ./sigset | cat </div><div class="line">before unblock sigprocmask</div><div class="line">received SIGALRM</div><div class="line">before <span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p>从上面的执行输出,我们看到信号 SIGALRM 是在调用 sigprocmask函 数 执 行 unblock 之 后 才 被 传 递 给 当 前 进 程 进 行 处 理 的。 如 果 我 们 将sigprocmaskdemo.c 中的sigprocemask(SIG_BLOCK, &amp;sigset, NULL) 注释掉,编译执行,生成如下结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/LAB-shlab/<span class="built_in">test</span>$ gcc sigset.c -o sigset</div><div class="line">ubuntu@VM-162-156-ubuntu:~/LAB-shlab/<span class="built_in">test</span>$ ./sigset | cat </div><div class="line">received SIGALRM</div><div class="line">before unblock sigprocmask</div><div class="line">before <span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p>sigpending读取当前进程的未决信号集，通过set参数传出。调用成功则返回0，出错则返回-1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;signal.h&gt;</span></div><div class="line">int sigpending(sigset_t *<span class="built_in">set</span>);</div><div class="line">返回值:若成功则返回0,若出错则返回-1</div></pre></td></tr></table></figure>
<p>下面我们来看一个例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="comment">#include &lt;unistd.h&gt;</span></div><div class="line"><span class="comment">#include &lt;string.h&gt;</span></div><div class="line"><span class="comment">#include &lt;errno.h&gt;</span></div><div class="line"><span class="comment">#include &lt;signal.h&gt;</span></div><div class="line"></div><div class="line">void alrm_is_pending(const char *str)</div><div class="line">&#123;</div><div class="line">  sigset_t pendingsigset;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%s: "</span>, str);</div><div class="line">  <span class="keyword">if</span> (sigpending(&amp;pendingsigset) &lt; 0) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sigpending error: %s\n"</span>, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(-1);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (sigismember(&amp;pendingsigset, SIGALRM)) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"SIGALRM is pending\n"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"SIGALRM is not pending\n"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">  sigset_t sigset;</div><div class="line"></div><div class="line">  sigemptyset(&amp;sigset);</div><div class="line">  sigaddset(&amp;sigset, SIGALRM);</div><div class="line">  <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;sigset, NULL) &lt; 0) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sigprocmask error: %s\n"</span>, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(-1);</div><div class="line">  &#125;</div><div class="line">  alrm_is_pending(<span class="string">"before alarm"</span>);</div><div class="line">  alarm(2);</div><div class="line">  sleep(4);</div><div class="line">  alrm_is_pending(<span class="string">"after alarm"</span>);</div><div class="line">  <span class="built_in">exit</span>(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从下面的运行结果,我们看到调用 <code>alarm</code> 函数产生信号 SIGALRM 之后,该信号在 sigpending 函数的 set 参数指向的信号集中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/LAB-shlab/<span class="built_in">test</span>$ gcc pending.c -o pending</div><div class="line">ubuntu@VM-162-156-ubuntu:~/LAB-shlab/<span class="built_in">test</span>$ ./pending | cat</div><div class="line">before alarm: SIGALRM is not pending</div><div class="line">after alarm: SIGALRM is pending</div></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/lienhua34/p/4072417.html" target="_blank" rel="external">UNIX环境编程学习笔记（24）——信号处理进阶学习之信号集和进程信号屏蔽字</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;信号传递过程&quot;&gt;&lt;a href=&quot;#信号传递过程&quot; class=&quot;headerlink&quot; title=&quot;信号传递过程&quot;&gt;&lt;/a&gt;信号传递过程&lt;/h3&gt;&lt;p&gt;信号源为目标进程产生了一个信号,然后由内核来决定是否要将该信号传递给目标进程。从信号产生到传递给目标进程的流
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="unix" scheme="http://yoursite.com/tags/unix/"/>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>UNIX编程|信号量</title>
    <link href="http://yoursite.com/2018/07/05/UNIX%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://yoursite.com/2018/07/05/UNIX编程-信号量/</id>
    <published>2018-07-05T10:47:56.000Z</published>
    <updated>2018-07-06T08:24:42.858Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>信号是软件中断，很比较重要的应用程序都需要处理信号。信号提供了一种处理异步事件的方法，例如，中断用户键入中断键，则会通过信号机制停止一个程序，或及早终止管道中的下一个程序。</p>
<p>每个信号都有一个名字, 这些名字都以三个字符 SIG 开头。 例如,SIGABRT是夭折信号, 当进程调用 abort 函数时产生这种信号。SIGALRM 是闹钟信号,当由 alarm 函数设置的计时器超时后产生此信号。在 UNIX 系统中,这些信号都定义在头文件 <signal.h> 中,并且都是以一个正整数来表示(信号编号)。通过在 shell 中运行命令 kill -l 可以查看当前系统所执行的所有信号。</signal.h></p>
<p>每一个信号对应一个正整数，定义在头文件<signal.h>中。</signal.h></p>
<p>没有信号对应整数0，kill函数使用信号编号0表示一种特殊情况，所以信号编号0又叫做空信号（null signal）。</p>
<p>下面的各种情况会产生一个信号：</p>
<ul>
<li><p>当用户在终端按下特定的键时，会产生信号。例如，当用户按下DELETE按键（或Control-C）时，会产生一个中断信号（interrupt signal，SIGINIT），该信号使得一个运行中的程序终止。</p>
</li>
<li><p>硬件异常可以产生信号。会引发硬件异常的情况如除以0，非法内存引用（invalid memory reference）等。这种情况会被硬件检测到，并通知内核，然后内核产生相应的信号通知对应的运行进程。例如，当一个进程执行了一个非法的内存引用，会触发SIGSEGV信号。 </p>
</li>
<li><p>kill函数允许当前进程向其他的进程或者进程组发送任意的信号。当然，这种方法存在限制：我们必须是信号接收进程的所有者，或者我们必须是超级用户（superuser）。</p>
</li>
<li><p>kill命令的作用和kill函数类似。这个命令多用户杀死后台进程。</p>
</li>
<li><p>软件异常可以根据不同的条件产生不同的信号。例如：网络连接中接受的数据超出边界时，会触发SIGURG信号。</p>
</li>
</ul>
<p>对于进程来说，信号是随机产生的，所以进程不能简单地根据检测某个变量是否改变来判断信号是否发生，而应该告诉内核<strong>“当这个信号发生时，做下面的这些事情”</strong>。</p>
<p>我们告诉内核当某个信号发生时做的事情叫做信号处理函数。信号处理函数有三种功能可供选择：</p>
<ul>
<li><strong>忽略该信号</strong>。该行为适用于大部分的信号，除了两个信号不能被忽略：<code>SIGKILL</code>和<code>SIGSTOP</code>。这两个信号不能被忽略，是因为其作用是为内核和超级用户提供了一种杀死或者暂停进程的万无一失的方法（a surefire way）。</li>
<li><strong>捕获该信号</strong>。当某个信号发生时，我们告诉进程去执行我们的一段程序。在该程序中，我们可以做任何操作来处理该种情况。两个信号SIGKILL和SIGSTOP不可以被捕获。</li>
<li><strong>执行默认的信号处理程序</strong>。每个信号都有一个默认的处理程序，而大部分的信号默认处理程序都是终止该进程。</li>
</ul>
<p><img src="/images/Unix-信号-02.jpg" alt=""></p>
<p>如果信号已被发送但是未被接收，那么处于等待状态<code>(pending)</code>，<strong>同类型的信号至多只会有一个待处理信号(pending signal)</strong>，一定要注意这个特性，因为内部实现机制不可能提供较复杂的数据结构，所以<strong>信号的接收并不是一个队列</strong>。比如说进程有一个 <code>SIGCHLD</code> 信号处于等待状态，那么之后进来的 <code>SIGCHLD</code>信号都会被直接扔掉。</p>
<p>当然，<strong>进程也可以阻塞特定信号的接收，但信号的发送并不受控制，所以被阻塞的信号仍然可以被发送，不过直到进程取消阻塞该信号之后才会被接收。</strong><code>内核用等待(pending)位向量和阻塞(blocked)位向量来维护每个进程的信号相关状态</code>。</p>
<h3 id="信号在内核中的表示"><a href="#信号在内核中的表示" class="headerlink" title="信号在内核中的表示"></a>信号在内核中的表示</h3><p>信号在内核中的表示：<br><img src="/images/Unix-信号-01.png" alt=""></p>
<p>每个信号都有两个标志位分别表示阻塞和未决，还有一个函数指针表示处理动作。信号产生时，内核在进程控制块中设置该信号的未决标志，直到信号递达才清除该标志。</p>
<p>在上图的例子中：</p>
<ul>
<li>SIGHUP信号未阻塞也未产生过，当它递达时执行默认处理动作。</li>
<li>SIGINT信号产生过，但正在被阻塞，所以暂时不能递达。虽然它的处理动作是忽略，但在没有解除阻塞之前不能忽略这个信号，因为进程仍有机会改变处理动作之后再解除阻塞。</li>
<li>SIGQUIT信号未产生过，一旦产生SIGQUIT信号将被阻塞，它的处理动作是用户自定义函数sighandler。</li>
</ul>
<p><strong>如果在进程解除对某信号的阻塞之前这种信号产生过多次，将如何处理？</strong></p>
<p>POSIX.1允许系统递送该信号一次或多次。从上图来看，每个信号只有一个bit的未决标志，非0即1，不记录该信号产生了多少次，阻塞标志也是这样表示的。<strong>因此，未决和阻塞标志可以用相同的数据类型sigset_t来存储，sigset_t称为信号集，这个类型可以表示每个信号的“有效”或“无效”状态，在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞，而在未决信号集中“有效”和“无效”的含义是该信号是否处于未决状态。</strong></p>
<p>阻塞信号集也叫做当前进程的<strong>信号屏蔽字（Signal Mask）</strong>，这里的“屏蔽”应该理解为阻塞而不是忽略。</p>
<h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><p>说了那么多，信号接收和处理使用哪个系统api呢？unix系统信号机制最简单的借口是<code>signal函数</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo,<span class="keyword">void</span>(*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</div></pre></td></tr></table></figure>
<p>返回值：若成功则返回信号以前的处理配置，出错返回SIG_ERR;</p>
<p>其中,参数 func 的值可以是:</p>
<ul>
<li>常 量SIG_IGN, 向 内 核 表 示 忽 略 此 信 号 (有 两 个 信 号 SIGKILL 和SIGSTOP 不可忽略,调用 signal 函数会报错)。</li>
<li>常量SIG_DFL,表示执行信号的系统默认动作。</li>
<li>一个函数指针,表示信号发生时执行该函数进行处理,这个函数称为<strong>信号处理程序</strong>。信号处理函数接收一个 int 类型的信号值参数,无返回值。</li>
</ul>
<p>signal 信号的返回值也是一个函数指针,指向该信号之前的信号处理程序。</p>
<p>看个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (signal(SIGUSR1, sig_usr) == SIG_ERR) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"can't catch SIGUSR1: %s\n"</span>, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (signal(SIGUSR2, sig_usr) == SIG_ERR) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"can't catch SIGUSR2: %s\n"</span>, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">    pause();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (signo == SIGUSR1) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"received SIGUSR1\n"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGUSR2) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"received SIGUSR2\n"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"received signal: %d\n"</span>, signo);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="向进程发送信号"><a href="#向进程发送信号" class="headerlink" title="向进程发送信号"></a>向进程发送信号</h3><p>UNIX 系统提供了两个函数 <code>kill</code> 和 <code>raise</code> 来产生信号。kill 函数将信号发送给指定的进程或进程组。raise 函数则允许进程向自身发送信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line">两个函数返回值:若成功则返回<span class="number">0</span>,若出错则返回<span class="number">-1</span></div></pre></td></tr></table></figure>
<p>调用 raise(signo) 等价于 kill(getpid(), signo)。</p>
<p>kill 函数的 pid 参数有 4 种不同情况:</p>
<ol>
<li><p><code>pid&gt;0</code> 将信号发送给进程 ID 为 pid 的进程。</p>
</li>
<li><p><code>pid==0</code> 将信号发送给与发送进程属于同一个进程组的所有进程,而且发送进程具有向这些进程发送信号的权限。</p>
</li>
</ol>
<p>3.<code>pid&lt;0</code>将信号发送给其进程组 ID 等于 pid 的绝对值的所有进程,而且发送进程具有向这些进程发送信号的权限。</p>
<p>4.<code>pid==-1</code> 将信号发送给发送进程有权限向他们发送信号的系统上的所有进程。</p>
<p>上面有两点需要说明一下:(1)“所有进程”不包括系统进程集;(2)发送进程是超级用户,或者发送进程的实际或有效用户 ID 等于接收进程的实际或有效用户 ID 才具有发送信号权限。</p>
<p>下面来看个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">pid_t</span> pid;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (signal(SIGUSR1, sig_usr) == SIG_ERR) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"can't catch SIGUSR1: %s\n"</span>, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (signal(SIGUSR2, sig_usr) == SIG_ERR) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"can't catch SIGUSR2: %s\n"</span>, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"fork error: %s\n"</span>, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</div><div class="line">    pause();</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"process %d creates a child process %d\n"</span>, getpid(), pid);</div><div class="line"></div><div class="line">  sleep(<span class="number">1</span>);</div><div class="line">  kill(pid, SIGUSR1);</div><div class="line">  waitpid(pid, <span class="literal">NULL</span>);</div><div class="line">  raise(SIGUSR2);</div><div class="line"></div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (signo == SIGUSR1) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"process %d received SIGUSR1\n"</span>, getpid());</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGUSR2) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"process %d received SIGUSR2\n"</span>, getpid());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"process %d received signal: %d\n"</span>, getpid(), signo);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 <code>kill.c</code> 程序文件中,父进程为信号 <code>SIGUSR1</code> 和<code>SIGUSR2</code>设置了信号处理程序<code>sig_us</code>r。然后调用 <code>fork</code>创建一个子进程,子进程的信号 <code>SIGUSR1</code> 和 <code>SIGUSR2</code>的信号处理程序继承父进程的,同样是sig_usr[除非子进程调用了 <code>exec</code> 函数,子进程中这两个信号的信号处理动作才会设置为系统默认]。父进程调用 kill 函数向子进程发送信号 SIGUSR1,而调用 raise 函数向自身发送信号 SIGUSR2. </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/LAB-shlab/<span class="built_in">test</span>$ gcc kill.c -o <span class="built_in">kill</span></div><div class="line">ubuntu@VM-162-156-ubuntu:~/LAB-shlab/<span class="built_in">test</span>$ ./<span class="built_in">kill</span> | cat</div><div class="line">process 21764 creates a child process 21766</div><div class="line">process 21764 received SIGUSR2</div><div class="line">process 21766 received SIGUSR1</div></pre></td></tr></table></figure>
<p>通过上面的运行结果,可以看到父进程 21764 创建了子进程 21766,父进程 21764 捕获了信号 SIGUSR2,子进程捕获了信号 SIGUSR1。实际运行结果与预期结果相符合。</p>
<h3 id="sigaction-函数"><a href="#sigaction-函数" class="headerlink" title="sigaction 函数"></a>sigaction 函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</div></pre></td></tr></table></figure>
<p>◆ signum：要操作的信号。<br>◆ act：要设置的对信号的新处理方式。<br>◆ oldact：原来对信号的处理方式。<br>◆ 返回值：0 表示成功，-1 表示有错误发生。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> 类型用来描述对信号的处理，定义如下：</span></div><div class="line"><span class="title">struct</span> <span class="title">sigaction</span></div><div class="line">&#123;</div><div class="line"> <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</div><div class="line"> <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</div><div class="line"> <span class="keyword">sigset_t</span>  sa_mask;</div><div class="line"> <span class="keyword">int</span>       sa_flags;</div><div class="line"> <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这个结构体中，成员 sa_handler 是一个函数指针，其含义与 signal 函数中的信号处理函数类似。成员sa_sigaction 则是另一个信号处理函数，它有三个参数，可以获得关于信号的更详细的信息。当 sa_flags 成员的值包含了 SA_SIGINFO 标志时，系统将使用 sa_sigaction 函数作为信号处理函数，否则使用sa_handler 作为信号处理函数。</p>
<p>sa_flags 成员用于指定信号处理的行为，它可以是一下值的“按位或”组合。</p>
<p>◆ SA_RESTART：使被信号打断的系统调用自动重新发起。<br>◆ SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。<br>◆ SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程。<br>◆ SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。<br>◆ SA_RESETHAND：信号处理之后重新设置为默认的处理方式。<br>◆ SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。</p>
<p>re_restorer 成员则是一个已经废弃的数据域，不要使用。</p>
<p>下面用一个例程来说明 sigaction 函数的使用，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signum)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(signum == SIGUSR1)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"SIGUSR1 received\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(signum == SIGUSR2)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"SIGUSR2 received\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"signal %d received\n"</span>, signum);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</div><div class="line">    <span class="keyword">int</span>  n;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa_usr</span>;</span></div><div class="line">    sa_usr.sa_flags = <span class="number">0</span>;</div><div class="line">    sa_usr.sa_handler = sig_usr;   <span class="comment">//信号处理函数</span></div><div class="line">    </div><div class="line">    sigaction(SIGUSR1, &amp;sa_usr, <span class="literal">NULL</span>);</div><div class="line">    sigaction(SIGUSR2, &amp;sa_usr, <span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"My PID is %d\n"</span>, getpid());</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>((n = read(STDIN_FILENO, buf, <span class="number">511</span>)) == <span class="number">-1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(errno == EINTR)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"read is interrupted by signal\n"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            buf[n] = <span class="string">'\0'</span>;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d bytes read: %s\n"</span>, n, buf);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例程中使用 sigaction 函数为 SIGUSR1 和 SIGUSR2 信号注册了处理函数，然后从标准输入读入字符。程序运行后首先输出自己的 PID，如：<br> <code>My PID is 8888</code></p>
<p>这时如果从另外一个终端向进程发送 SIGUSR1 或 SIGUSR2 信号，用类似如下的命令：<code>kill -USR1 8888</code></p>
<p>则程序将继续输出如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SIGUSR1 received</div><div class="line">read is interrupted by signal</div><div class="line">``` </div><div class="line"></div><div class="line">这说明用 sigaction 注册信号处理函数时，不会自动重新发起被信号打断的系统调用。如果需要自动重新发起，则要设置 SA_RESTART 标志，比如在上述例程中可以进行类似一下的设置：</div></pre></td></tr></table></figure></p>
<p>sa_usr.sa_flags = SA_RESTART;<br>```</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;信号是软件中断，很比较重要的应用程序都需要处理信号。信号提供了一种处理异步事件的方法，例如，中断用户键入中断键，则会通过信号机制停止一个程序
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="unix" scheme="http://yoursite.com/tags/unix/"/>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP图像处理类</title>
    <link href="http://yoursite.com/2018/07/03/PHP-PHP%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/07/03/PHP-PHP图像处理类/</id>
    <published>2018-07-03T13:17:24.000Z</published>
    <updated>2018-07-03T05:21:24.723Z</updated>
    
    <content type="html"><![CDATA[<p>下面介绍一个图像处理类，可用于添加文字、图片水印及压缩…</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span></span></div><div class="line">&#123;    </div><div class="line">    <span class="keyword">private</span> $info;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> $image;</div><div class="line">    <span class="keyword">public</span> $type;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($src)</span></span></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;info=getimagesize($src);</div><div class="line">        <span class="keyword">$this</span>-&gt;type=image_type_to_extension(<span class="keyword">$this</span>-&gt;info[<span class="string">'2'</span>],<span class="keyword">false</span>);</div><div class="line">        $fun=<span class="string">"imagecreatefrom&#123;$this-&gt;type&#125;"</span>;</div><div class="line">        <span class="keyword">$this</span>-&gt;image=$fun($src);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 文字水印</div><div class="line">     * <span class="doctag">@param</span>  [type]  $font     字体</div><div class="line">     * <span class="doctag">@param</span>  [type]  $content  内容</div><div class="line">     * <span class="doctag">@param</span>  [type]  $size     文字大小</div><div class="line">     * <span class="doctag">@param</span>  [type]  $col      文字颜色（四元数组）</div><div class="line">     * <span class="doctag">@param</span>  array   $location 位置 </div><div class="line">     * <span class="doctag">@param</span>  integer $angle    倾斜角度</div><div class="line">     * <span class="doctag">@return</span> [type]           </div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fontMark</span><span class="params">($font,$content,$size,$col,$location,$angle=<span class="number">0</span>)</span></span>&#123;</div><div class="line">        $col=imagecolorallocatealpha(<span class="keyword">$this</span>-&gt;image, $col[<span class="string">'0'</span>], $col[<span class="string">'1'</span>], $col[<span class="string">'2'</span>],$col[<span class="string">'3'</span>]);</div><div class="line">        imagettftext(<span class="keyword">$this</span>-&gt;image, $size, $angle, $location[<span class="string">'0'</span>], $location[<span class="string">'1'</span>], $col,$font,$content);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 图片水印</div><div class="line">     * <span class="doctag">@param</span>  [type] $imageMark 水印图片地址</div><div class="line">     * <span class="doctag">@param</span>  [type] $dst       水印图片在原图片中的位置</div><div class="line">     * <span class="doctag">@param</span>  [type] $pct       透明度</div><div class="line">     * <span class="doctag">@return</span> [type]            </div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">imageMark</span><span class="params">($imageMark,$dst,$pct)</span></span>&#123;</div><div class="line">        $info2=getimagesize($imageMark);</div><div class="line">        $type=image_type_to_extension($info2[<span class="string">'2'</span>],<span class="keyword">false</span>);</div><div class="line">        $func2=<span class="string">"imagecreatefrom"</span>.$type;</div><div class="line">        $water=$func2($imageMark);</div><div class="line">        $dst_x = <span class="keyword">$this</span>-&gt;info[<span class="string">'0'</span>] - $info2[<span class="string">'0'</span>] - $dst[<span class="number">0</span>];</div><div class="line">        $dst_y = <span class="keyword">$this</span>-&gt;info[<span class="string">'1'</span>] - $info2[<span class="string">'1'</span>] - $dst[<span class="number">1</span>];</div><div class="line">        imagecopymerge(<span class="keyword">$this</span>-&gt;image, $water, $dst_x, $dst_y, <span class="number">0</span>, <span class="number">0</span>, $info2[<span class="string">'0'</span>], $info2[<span class="string">'1'</span>], $pct);</div><div class="line">        imagedestroy($water);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 压缩图片</div><div class="line">     * <span class="doctag">@param</span>  [type] $thumbSize 压缩图片大小</div><div class="line">     * <span class="doctag">@return</span> [type]            [description]</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">thumb</span><span class="params">($thumbSize)</span></span>&#123;</div><div class="line">        $imageThumb=imagecreatetruecolor($thumbSize[<span class="number">0</span>], $thumbSize[<span class="number">1</span>]);</div><div class="line">        imagecopyresampled($imageThumb, <span class="keyword">$this</span>-&gt;image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, $thumbSize[<span class="number">0</span>], $thumbSize[<span class="number">1</span>], <span class="keyword">$this</span>-&gt;info[<span class="string">'0'</span>], <span class="keyword">$this</span>-&gt;info[<span class="string">'1'</span>]);</div><div class="line">        imagedestroy(<span class="keyword">$this</span>-&gt;image);</div><div class="line">        <span class="keyword">$this</span>-&gt;image=$imageThumb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 裁剪图片</div><div class="line">     * <span class="doctag">@param</span>  [type] $cutSize  裁剪大小</div><div class="line">     * <span class="doctag">@param</span>  [type] $location 裁剪位置</div><div class="line">     * <span class="doctag">@return</span> [type]           [description]</div><div class="line">    */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">cut</span><span class="params">($cutSize,$location)</span></span>&#123;</div><div class="line">        $imageCut=imagecreatetruecolor($cutSize[<span class="number">0</span>],$cutSize[<span class="number">1</span>]);</div><div class="line"></div><div class="line">        imagecopyresampled($imageCut,<span class="keyword">$this</span>&gt;image,<span class="number">0</span>,<span class="number">0</span>,$location[<span class="number">0</span>],$location[<span class="number">1</span>],$cutSize[<span class="number">0</span>],$cutSize[<span class="number">1</span>],$cutSize[<span class="number">0</span>],$cutSize[<span class="number">1</span>]);</div><div class="line">        imagedestroy(<span class="keyword">$this</span>-&gt;image);</div><div class="line">        <span class="keyword">$this</span>-&gt;image=$imageCut;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 展现图片</div><div class="line">     * <span class="doctag">@return</span> [type] [description]</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span>&#123;</div><div class="line">        header(<span class="string">"content-type:"</span>.<span class="keyword">$this</span>-&gt;info[<span class="string">'mime'</span>]);</div><div class="line"></div><div class="line">        $funn=<span class="string">"image"</span>.<span class="keyword">$this</span>-&gt;type;</div><div class="line"></div><div class="line">        $funn(<span class="keyword">$this</span>-&gt;image);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 保存图片</div><div class="line">    * <span class="doctag">@param</span>  [type] $newname 新图片名</div><div class="line">    * <span class="doctag">@return</span> [type]          [description]</div><div class="line">    */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span><span class="params">($newname)</span></span>&#123;</div><div class="line">        <span class="comment">// header("content-type:".$this-&gt;info['mime']);</span></div><div class="line">        $funn=<span class="string">"image"</span>.<span class="keyword">$this</span>-&gt;type;</div><div class="line">        $funn(<span class="keyword">$this</span>-&gt;image,$newname.<span class="string">'.'</span>.<span class="keyword">$this</span>-&gt;type);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面介绍一个开源图片处理框架：<code>Grafika</code>。</p>
<p><a href="https://kosinix.github.io/grafika/index.html" target="_blank" rel="external">Grafika</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面介绍一个图像处理类，可用于添加文字、图片水印及压缩…&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;li
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Linux|shell编程了解一下</title>
    <link href="http://yoursite.com/2018/06/29/Linux-shell%E7%BC%96%E7%A8%8B%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/06/29/Linux-shell编程了解一下/</id>
    <published>2018-06-28T16:00:01.000Z</published>
    <updated>2018-06-29T10:05:57.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><strong>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁</strong>。Shell 既是一种命令语言，又是一种程序设计语言。</p>
<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>
<h3 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h3><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。 Shell 编程跟 python、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<h4 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h4><p>输入一些代码，第一行一般是这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">echo &quot;Hello World !</div></pre></td></tr></table></figure>
<p><code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。<br><code>echo</code>命令用于向窗口输出文本。 </p>
<h4 id="运行-Shell-脚本有两种方法："><a href="#运行-Shell-脚本有两种方法：" class="headerlink" title="运行 Shell 脚本有两种方法："></a>运行 Shell 脚本有两种方法：</h4><ul>
<li>作为可执行程序</li>
<li>作为解释器参数</li>
</ul>
<h3 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h3><p>定义变量时，变量名不加美元符号（<code>$</code>，PHP语言中变量需要），如：</p>
<p><code>me=&quot;wuduozhi&quot;</code></p>
<p>注意，<strong>变量名和等号之间不能有空格</strong>，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
<ul>
<li><p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</p>
</li>
<li><p>中间不能有空格，可以使用下划线（_）。</p>
</li>
<li><p>不能使用标点符号。</p>
</li>
<li><p>不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
</li>
</ul>
<p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls /etc`</div><div class="line">or</div><div class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(ls /etc)</div></pre></td></tr></table></figure>
<p>以上语句将 /etc 下目录的文件名循环出来。</p>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">me=&quot;小智&quot;</div><div class="line">echo $me</div><div class="line">echo $&#123;me&#125;</div></pre></td></tr></table></figure>
<p>变量名外面的花括号是可选的，加不加都行，<strong>加花括号是为了帮助解释器识别变量的边界</strong>，比如下面这种情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> skill <span class="keyword">in</span> Ada Coffe Action Java; <span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"I am good at <span class="variable">$&#123;skill&#125;</span>Script"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<p><strong>推荐给所有变量加上花括号，这是个好的编程习惯。</strong> </p>
<h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 <code>readonly 命令</code>可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<p>下面的例子尝试更改只读变量，结果报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">myUrl=&quot;http://wuduozhi.me&quot;</div><div class="line">readonly myUrl</div><div class="line">myUrl=&quot;http://www.baidu.com&quot;</div></pre></td></tr></table></figure>
<p>运行脚本，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/bin/sh: NAME: This variable is read only.</div></pre></td></tr></table></figure>
<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>使用 <code>unset</code> 命令可以删除变量。语法：</p>
<p><code>unset variable_name</code></p>
<h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p> 运行shell时，会同时存在三种变量：</p>
<ol>
<li><p><strong>局部变量</strong> : 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</p>
</li>
<li><p><strong>环境变量</strong> : 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</p>
</li>
<li><p><strong>shell变量</strong> : shell变量是由<code>shell程序</code>设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。</p>
</li>
</ol>
<h4 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h4><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用<code>单引号</code>，也可以用<code>双引号</code>，也可以<code>不用引号</code>。<strong>单双引号的区别跟PHP类似。 </strong></p>
<p><strong>单引号</strong></p>
<p><code>str=&#39;this is a string&#39;</code></p>
<p>单引号字符串的限制：</p>
<ul>
<li><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</p>
</li>
<li><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</p>
</li>
</ul>
<p><strong>双引号</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">me=&apos;小智e&apos;</div><div class="line"></div><div class="line">str=&quot;Hello, I know you are \&quot;$me\&quot;! \n&quot;</div></pre></td></tr></table></figure>
<p>双引号的优点：</p>
<ul>
<li><p>双引号里可以有变量</p>
</li>
<li><p>双引号里可以出现转义字符</p>
</li>
</ul>
<h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">me=<span class="string">"小智"</span></div><div class="line"></div><div class="line">greeting=<span class="string">"hello, "</span><span class="variable">$me</span><span class="string">" !"</span></div><div class="line"></div><div class="line">greeting_1=<span class="string">"hello, <span class="variable">$&#123;me&#125;</span> !"</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span> <span class="variable">$greeting_1</span></div></pre></td></tr></table></figure>
<h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">string=<span class="string">"abcd"</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#输出 4</span></div></pre></td></tr></table></figure>
<h4 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h4><p>提取字符串与python的<code>切片</code>操作有点类似，以下实例从字符串第 2 个字符开始截取 4 个字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">string=<span class="string">"runoob is a great site"</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:4&#125;</span> <span class="comment"># 输出 unoo</span></div></pre></td></tr></table></figure>
<h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><p>查找字符 “i 或 s” 的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">string=&quot;runoob is a great company&quot;</div><div class="line"></div><div class="line">echo `expr index &quot;$string&quot; is`  # 输出 8</div></pre></td></tr></table></figure>
<h3 id="Shell-传递参数"><a href="#Shell-传递参数" class="headerlink" title="Shell 传递参数"></a>Shell 传递参数</h3><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<code>$n</code>。n 代表一个数字，<code>$1</code> 为执行脚本的第一个参数，<code>$2</code> 为执行脚本的第二个参数，以此类推…… 当n&gt;=10时，需要使用<code>${n}</code>来获取参数。</p>
<p>实例</p>
<p>以下实例我们向脚本传递三个参数，并分别输出，其中 <code>$0</code> 为执行的文件名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">echo &quot;Shell 传递参数实例！&quot;;</div><div class="line"></div><div class="line">echo &quot;执行的文件名：$0&quot;;</div><div class="line"></div><div class="line">echo &quot;第一个参数为：$1&quot;;</div><div class="line"></div><div class="line">echo &quot;第二个参数为：$2&quot;;</div><div class="line"></div><div class="line">echo &quot;第三个参数为：$3&quot;;</div></pre></td></tr></table></figure>
<p>Shell 传递参数实例！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ ./test.sh 1 2 3</div><div class="line"></div><div class="line">执行的文件名：./test.sh</div><div class="line"></div><div class="line">第一个参数为：1</div><div class="line"></div><div class="line">第二个参数为：2</div><div class="line"></div><div class="line">第三个参数为：3</div></pre></td></tr></table></figure>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数。</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#!/bin/bash</div><div class="line">echo &quot;Shell 传递参数实例！&quot;;</div><div class="line">echo &quot;第一个参数为：$1&quot;;</div><div class="line">echo &quot;参数个数为：$#&quot;;</div><div class="line">echo &quot;传递的参数作为一个字符串显示：$*&quot;;</div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh </div><div class="line">$ ./test.sh 1 2 3</div><div class="line"></div><div class="line">Shell 传递参数实例！</div><div class="line">第一个参数为：1</div><div class="line">参数个数为：3</div><div class="line">传递的参数作为一个字符串显示：1 2 3</div></pre></td></tr></table></figure>
<p><code>$*</code>与<code>$@</code> 区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 <code>&quot;$*&quot;</code> 等价于 “1 2 3”（传递了一个参数），而 <code>&quot;$@&quot;</code> 等价于 “1” “2” “3”（传递了三个参数）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#!/bin/bash</div><div class="line">echo &quot;-- \$* 演示 ---&quot;</div><div class="line">for i in &quot;$*&quot;; do</div><div class="line">    echo $i</div><div class="line">done</div><div class="line"></div><div class="line">echo &quot;-- \$@ 演示 ---&quot;</div><div class="line">for i in &quot;$@&quot;; do</div><div class="line">    echo $i</div><div class="line">done</div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh </div><div class="line">$ ./test.sh 1 2 3</div><div class="line">-- $* 演示 ---</div><div class="line">1 2 3</div><div class="line">-- $@ 演示 ---</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure>
<h3 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h3><p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。</p>
<p>与大部分编程语言类似，数组元素的下标由0开始。</p>
<p><strong>Shell 数组用括号来表示，元素用”空格”符号分割开</strong>，语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array=(value1 ... valuen)</div></pre></td></tr></table></figure>
<h4 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h4><p>读取数组元素值的一般格式是：</p>
<p><code>${array_name[index]}</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">my_array=(A B &quot;C&quot; D)</div><div class="line"></div><div class="line">echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;</div><div class="line">echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;</div><div class="line">echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;</div><div class="line">echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;</div></pre></td></tr></table></figure>
<h4 id="获取数组中的所有元素"><a href="#获取数组中的所有元素" class="headerlink" title="获取数组中的所有元素"></a>获取数组中的所有元素</h4><p>使用<code>@</code> 或<code>*</code> 可以获取数组中的所有元素，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#!/bin/bash</div><div class="line">my_array[0]=A</div><div class="line">my_array[1]=B</div><div class="line">my_array[2]=C</div><div class="line">my_array[3]=D</div><div class="line"></div><div class="line">echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;</div><div class="line">echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ ./test.sh</div><div class="line"></div><div class="line">数组的元素为: A B C D</div><div class="line">数组的元素为: A B C D</div></pre></td></tr></table></figure>
<h4 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h4><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">my_array[0]=A</div><div class="line"></div><div class="line">my_array[1]=B</div><div class="line"></div><div class="line">my_array[2]=C</div><div class="line"></div><div class="line">my_array[3]=D</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">echo &quot;数组元素个数为: $&#123;#my_array[*]&#125;&quot;</div><div class="line"></div><div class="line">echo &quot;数组元素个数为: $&#123;#my_array[@]&#125;&quot;</div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ chmod +x test.sh </div><div class="line"></div><div class="line">$ ./test.sh</div><div class="line"></div><div class="line">数组元素个数为: 4</div><div class="line"></div><div class="line">数组元素个数为: 4</div></pre></td></tr></table></figure>
<h3 id="Shell-基本运算符"><a href="#Shell-基本运算符" class="headerlink" title="Shell 基本运算符"></a>Shell 基本运算符</h3><p>Shell 和其他编程语言一样，支持多种运算符，包括：</p>
<ul>
<li><p>算数运算符</p>
</li>
<li><p>关系运算符</p>
</li>
<li><p>布尔运算符</p>
</li>
<li><p>字符串运算符</p>
</li>
<li><p>文件测试运算符</p>
</li>
</ul>
<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>
<p><strong>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 </strong></p>
<p>expr的常用运算符：</p>
<ul>
<li><p>加法运算：<code>+</code></p>
</li>
<li><p>减法运算：<code>-</code></p>
</li>
<li><p>乘法运算：<code>\*</code></p>
</li>
<li><p>除法运算：<code>/</code></p>
</li>
<li><p>求摸（取余）运算：<code>%</code></p>
</li>
</ul>
<p>例如，两个数相加(注意<strong>使用的是反引号 ` 而不是单引号 ‘ )</strong>，反引号表示的是命令替换，与<code>$()</code>作用一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">val=`expr 2 + 2`</div><div class="line"></div><div class="line">echo &quot;两数之和为 : $val&quot;</div></pre></td></tr></table></figure>
<p>两点注意：</p>
<ul>
<li><p>表达式和运算符之间要有空格，例如 <code>2+2</code> 是不对的，必须写成<code>2 + 2</code>，这与我们熟悉的大多数编程语言不一样。</p>
</li>
<li><p>完整的表达式要被 <code>`` </code> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</p>
</li>
</ul>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td><code>expr $a + $b</code> 结果为 30。</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td><code>expr $a - $b</code> 结果为 -10。</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td><code>expr $a \* $b</code> 结果为  200。</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td><code>expr $b / $a</code> 结果为 2。</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td><code>expr $b % $a</code> 结果为 0。</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
<td>a=$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td>==</td>
<td>相等</td>
<td>用于比较两个数字，相同则返回 true。     [ $a == $b ] 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>不相等</td>
<td>用于比较两个数字，不相同则返回 true。     [ $a != $b ] 返回 true。</td>
</tr>
</tbody>
</table>
<p>注意：<strong>条件表达式要放在方括号之间，并且要有空格</strong>，例如: <code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code>。乘号(*)前边必须加反斜杠()才能实现乘法运算。</p>
<p>算术运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">a=10</div><div class="line"></div><div class="line">b=20</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">val=`expr <span class="variable">$a</span> + <span class="variable">$b</span>`</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"a + b : <span class="variable">$val</span>"</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">val=`expr <span class="variable">$a</span> - <span class="variable">$b</span>`</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"a - b : <span class="variable">$val</span>"</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">val=`expr <span class="variable">$a</span> \* <span class="variable">$b</span>`</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"a * b : <span class="variable">$val</span>"</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">val=`expr <span class="variable">$b</span> / <span class="variable">$a</span>`</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"b / a : <span class="variable">$val</span>"</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">val=`expr <span class="variable">$b</span> % <span class="variable">$a</span>`</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"b % a : <span class="variable">$val</span>"</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</div><div class="line"></div><div class="line"><span class="keyword">then</span></div><div class="line"></div><div class="line">   <span class="built_in">echo</span> <span class="string">"a 等于 b"</span></div><div class="line"></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</div><div class="line"></div><div class="line"><span class="keyword">then</span></div><div class="line"></div><div class="line">   <span class="built_in">echo</span> <span class="string">"a 不等于 b"</span></div><div class="line"></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>检测两个数是否相等，相等返回 true。</td>
<td><code>[ $a -eq $b ]</code>返回 false。</td>
</tr>
<tr>
<td>-ne</td>
<td>检测两个数是否不相等，不相等返回 true。</td>
<td><code>[ $a -ne $b ]</code> 返回 true。</td>
</tr>
<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td><code>[ $a -gt $b ]</code> 返回 false。</td>
</tr>
<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td><code>[ $a -lt $b ]</code>返回 true。</td>
</tr>
<tr>
<td>-ge</td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td><code>[ $a -ge $b ]</code> 返回 false。</td>
</tr>
<tr>
<td>-le</td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td><code>[ $a -le $b ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<p>关系运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">a=10</div><div class="line">b=20</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -eq <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -eq <span class="variable">$b</span> : a 等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -eq <span class="variable">$b</span>: a 不等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ne <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ne <span class="variable">$b</span>: a 不等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ne <span class="variable">$b</span> : a 等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -gt <span class="variable">$b</span>: a 大于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -gt <span class="variable">$b</span>: a 不大于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt <span class="variable">$b</span>: a 小于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt <span class="variable">$b</span>: a 不小于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ge <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ge <span class="variable">$b</span>: a 大于或等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ge <span class="variable">$b</span>: a 小于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -le <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -le <span class="variable">$b</span>: a 小于或等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -le <span class="variable">$b</span>: a 大于 b"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">10 -eq 20: a 不等于 b</div><div class="line">10 -ne 20: a 不等于 b</div><div class="line">10 -gt 20: a 不大于 b</div><div class="line">10 -lt 20: a 小于 b</div><div class="line">10 -ge 20: a 小于 b</div><div class="line">10 -le 20: a 小于或等于 b</div></pre></td></tr></table></figure>
<h4 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h4><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td><code>[ ! false ]</code> 返回 true。</td>
</tr>
<tr>
<td>-o</td>
<td>或运算，有一个表达式为 true 则返回 true。</td>
<td><code>[ $a -lt 20 -o $b -gt 100 ]</code>返回 true。</td>
</tr>
<tr>
<td>-a</td>
<td>与运算，两个表达式都为 true 才返回 true。</td>
<td><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td>
</tr>
</tbody>
</table>
<p>布尔运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">a=10</div><div class="line">b=20</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span> : a 不等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span>: a 等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -a <span class="variable">$b</span> -gt 15 ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 true"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 false"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -o <span class="variable">$b</span> -gt 100 ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 或 <span class="variable">$b</span> 大于 100 : 返回 true"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 或 <span class="variable">$b</span> 大于 100 : 返回 false"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 5 -o <span class="variable">$b</span> -gt 100 ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 5 或 <span class="variable">$b</span> 大于 100 : 返回 true"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 5 或 <span class="variable">$b</span> 大于 100 : 返回 false"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">10 != 20 : a 不等于 b</div><div class="line">10 小于 100 且 20 大于 15 : 返回 true</div><div class="line">10 小于 100 或 20 大于 100 : 返回 true</div><div class="line">10 小于 5 或 20 大于 100 : 返回 false</div></pre></td></tr></table></figure>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>逻辑的 AND</td>
<td><code>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</code>返回 false</td>
</tr>
<tr>
<td>11</td>
<td>逻辑的 OR</td>
<td><code>[[ $a -lt 100 ll $b -gt 100 ]]</code> 返回 true</td>
</tr>
</tbody>
</table>
<p><strong>逻辑运算符下的测试需要用 <code>[[ ]]</code>。</strong></p>
<p>逻辑运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">a=10</div><div class="line">b=20</div><div class="line"></div><div class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -lt 100 &amp;&amp; <span class="variable">$b</span> -gt 100 ]]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"返回 true"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"返回 false"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -lt 100 || <span class="variable">$b</span> -gt 100 ]]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"返回 true"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"返回 false"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">返回 false</div><div class="line">返回 true</div></pre></td></tr></table></figure>
<h4 id="条件测试命令-test"><a href="#条件测试命令-test" class="headerlink" title="条件测试命令 test"></a>条件测试命令 <code>test</code></h4><p><img src="/images/shell编程-01.png" alt=""></p>
<h3 id="Shell-流程控制"><a href="#Shell-流程控制" class="headerlink" title="Shell 流程控制"></a>Shell 流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> condition</div><div class="line"><span class="keyword">then</span></div><div class="line">    command1 </div><div class="line">    command2</div><div class="line">    ...</div><div class="line">    commandN </div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<h4 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h4><p>if else 语法格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if condition</div><div class="line">then</div><div class="line">    command1 </div><div class="line"></div><div class="line">    command2</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    commandN</div><div class="line">else</div><div class="line">    command</div><div class="line">fi</div></pre></td></tr></table></figure>
<h4 id="if…else-if…else"><a href="#if…else-if…else" class="headerlink" title="if…else-if…else"></a>if…else-if…else</h4><p>if else-if else 语法格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">if condition1</div><div class="line">then</div><div class="line">    command1</div><div class="line">elif condition2 </div><div class="line">then </div><div class="line">    command2</div><div class="line">else</div><div class="line">    commandN</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">a=10</div><div class="line"></div><div class="line">b=20</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"a 等于 b"</span></div><div class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"a 大于 b"</span></div><div class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"a 小于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"没有符合的条件"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>if else语句经常与test命令结合使用，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">num1=$[2*3]</div><div class="line"></div><div class="line">num2=$[1+5]</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq $[num2]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'两个数字相等!'</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'两个数字不相等!'</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>for循环一般格式为： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</div><div class="line"><span class="keyword">do</span></div><div class="line">    command1</div><div class="line">    command2</div><div class="line">    ...</div><div class="line">    commandN</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p> 写成一行：</p>
<p><code>for var in item1 item2 ... itemN; do command1; command2… done;</code></p>
<p>当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。<strong>in列表可以包含替换、字符串和文件名。</strong></p>
<p>in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p>
<p>例如，顺序输出当前列表中的数字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">for</span> loop <span class="keyword">in</span> 1 2 3 4 5</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"The value is: <span class="variable">$loop</span>"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>顺序输出字符串中的字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">for</span> str <span class="keyword">in</span> <span class="string">'This is a string'</span></div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$str</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><code>This is a string</code></p>
<p>在shell中，for循环还能这样来写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">for</span>((assignment;condition:next));<span class="keyword">do</span></div><div class="line">    command_1;</div><div class="line">    command_2;</div><div class="line">    commond_..;</div><div class="line"><span class="keyword">done</span>;</div></pre></td></tr></table></figure>
<p>如上所示，这里的 for 循环与 C 中的相似，但并不完全相同。</p>
<p>通常情况下 shell 变量调用需要加 <code>$</code>,但是 for 的 <code>(( ))</code> 中不需要,下面来看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>((i=1;i&lt;=5;i++));<span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"这是第 <span class="variable">$i</span> 次调用"</span>;</div><div class="line"><span class="keyword">done</span>;</div></pre></td></tr></table></figure>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">while</span> condition</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">command</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">int=1</div><div class="line"></div><div class="line">while(( $int&lt;=5 ))</div><div class="line">do</div><div class="line">    echo $int</div><div class="line">    let &quot;int++&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>使用中使用了 <code>Bash let</code> 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。</p>
<p><code>let</code> 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。</p>
<p><code>let arg [arg ...]</code></p>
<p>arg：要执行的表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="built_in">let</span> a=5+4</div><div class="line"><span class="built_in">let</span> b=9-3 </div><div class="line"><span class="built_in">echo</span> <span class="variable">$a</span> <span class="variable">$b</span></div></pre></td></tr></table></figure>
<p>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<ctrl-d>结束循环。 </ctrl-d></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line"></div><div class="line"></div><div class="line">echo &apos;按下 &lt;CTRL-D&gt; 退出&apos;</div><div class="line"></div><div class="line">echo -n &apos;输入你最喜欢的网站名: &apos;</div><div class="line"></div><div class="line">while read FILM</div><div class="line">do</div><div class="line">    echo &quot;是的！$FILM 是一个好网站&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>无限循环语法格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">while :</div><div class="line">do</div><div class="line">    command</div><div class="line">done</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">while true</div><div class="line">do</div><div class="line">    command</div><div class="line">done</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for (( ; ; ))</div></pre></td></tr></table></figure>
<h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><p>ntil 循环执行一系列命令直至条件为 true 时停止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">until condition</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">command</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p>
<p>以下实例我们使用 until 命令来输出 0 ~ 9 的数字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">a=0</div><div class="line"></div><div class="line">until [ ! <span class="variable">$a</span> -lt 10 ]</div><div class="line"><span class="keyword">do</span></div><div class="line">   <span class="built_in">echo</span> <span class="variable">$a</span></div><div class="line">   a=`expr <span class="variable">$a</span> + 1`</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></div><div class="line">模式1)</div><div class="line">    command1</div><div class="line">    command2</div><div class="line">    ...</div><div class="line">    commandN</div><div class="line">    ;;</div><div class="line"></div><div class="line">模式2）</div><div class="line">    command1</div><div class="line">    command2</div><div class="line">    ...</div><div class="line">    commandN</div><div class="line">    ;;</div><div class="line"></div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure>
<p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 <code>;;</code>。</p>
<p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 </p>
<p>下面的脚本提示输入1到4，与每一种模式进行匹配：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">'输入 1 到 4 之间的数字:'</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">'你输入的数字为:'</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> aNum</div><div class="line"><span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></div><div class="line">    1)  <span class="built_in">echo</span> <span class="string">'你选择了 1'</span></div><div class="line">    ;;</div><div class="line">    2)  <span class="built_in">echo</span> <span class="string">'你选择了 2'</span></div><div class="line">    ;;</div><div class="line">    3)  <span class="built_in">echo</span> <span class="string">'你选择了 3'</span></div><div class="line">    ;;</div><div class="line">    4)  <span class="built_in">echo</span> <span class="string">'你选择了 4'</span></div><div class="line">    ;;</div><div class="line">    *)  <span class="built_in">echo</span> <span class="string">'你没有输入 1 到 4 之间的数字'</span></div><div class="line">    ;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure>
<p>输入不同的内容，会有不同的结果，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">输入 1 到 4 之间的数字:</div><div class="line">你输入的数字为:</div><div class="line">3</div><div class="line">你选择了 3</div></pre></td></tr></table></figure>
<h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p>
<p>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> :</div><div class="line"><span class="keyword">do</span></div><div class="line">   <span class="built_in">echo</span> -n <span class="string">"输入 1 到 5 之间的数字:"</span></div><div class="line"></div><div class="line">    <span class="built_in">read</span> aNum</div><div class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></div><div class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">"你输入的数字为 <span class="variable">$aNum</span>!"</span></div><div class="line">        ;;</div><div class="line">        *) <span class="built_in">echo</span> <span class="string">"你输入的数字不是 1 到 5 之间的! 游戏结束"</span></div><div class="line">            <span class="built_in">break</span></div><div class="line">        ;;</div><div class="line">   <span class="keyword">esac</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。 </p>
<p>对上面的例子进行修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> :</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> -n <span class="string">"输入 1 到 5 之间的数字: "</span></div><div class="line">    <span class="built_in">read</span> aNum</div><div class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></div><div class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">"你输入的数字为 <span class="variable">$aNum</span>!"</span></div><div class="line">        ;;</div><div class="line">        *) <span class="built_in">echo</span> <span class="string">"你输入的数字不是 1 到 5 之间的!"</span></div><div class="line">            <span class="built_in">continue</span></div><div class="line">            <span class="built_in">echo</span> <span class="string">"游戏结束"</span></div><div class="line">        ;;</div><div class="line">    <span class="keyword">esac</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 <code>echo &quot;游戏结束&quot;</code>永远不会被执行。</p>
<h3 id="shell中-与-还有-的区别"><a href="#shell中-与-还有-的区别" class="headerlink" title="shell中$(( )) 与 $( ) 还有${ }的区别"></a>shell中<code>$(( ))</code> 与 <code>$( )</code> 还有<code>${ }</code>的区别</h3><ul>
<li><p><code>$( )</code> 与 <code>`` </code> (反引号)在 bash shell 中，<code>$( )</code> 与 <code>`` </code> (反引号) 都是用来做命令替换用<code>(command substitution)</code>的。</p>
</li>
<li><p><code>${ }</code> 用来作变量替换。</p>
</li>
<li><p><code>$(( ))</code> 是用来作整数运算的。 在 $(( )) 中的变量名称，可于其前面加 $ 符号来替换，也可以不用。</p>
</li>
</ul>
<p>事实上，单纯用 <code>(( ))</code> 也可重定义变量值，或作 testing：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# echo $((2*3))</div><div class="line">6</div><div class="line">[root@localhost ~]# a=5;b=7;c=2</div><div class="line">[root@localhost ~]# echo $((a+b*c))</div><div class="line">19</div><div class="line">[root@localhost ~]# echo $(($a+$b*$c))</div><div class="line">19</div><div class="line">[root@localhost ~]# a=5;b=7</div><div class="line"></div><div class="line">[root@localhost ~]# ((a++))</div><div class="line"></div><div class="line">[root@localhost ~]# echo $a</div><div class="line">6</div><div class="line">[root@localhost ~]# ((a--));echo $a</div><div class="line">5</div><div class="line">[root@localhost ~]# ((a&lt;b));echo $?</div><div class="line">0</div><div class="line">[root@localhost ~]# ((a&gt;b));echo $?</div><div class="line"></div><div class="line">1</div></pre></td></tr></table></figure>
<p>常见的用于 <code>(( ))</code> 的测试符号有如下这些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt; ：小于</div><div class="line">&gt; ：大于</div><div class="line">&lt;=：小于或等于</div><div class="line">&gt;=：大于或等于</div><div class="line">==：等于</div><div class="line">!=：不等于</div></pre></td></tr></table></figure>
<h3 id="Shell-函数"><a href="#Shell-函数" class="headerlink" title="Shell 函数"></a>Shell 函数</h3><p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p>
<p>shell中函数的定义格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[ <span class="keyword">function</span> ] funname [()]</div><div class="line">&#123;</div><div class="line">    action;</div><div class="line">    [<span class="built_in">return</span> int;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li><p>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</p>
</li>
<li><p>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)</p>
</li>
</ol>
<p>下面的例子定义了一个函数并进行调用： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">myFun</span></span>()&#123;</div><div class="line">    <span class="built_in">echo</span> <span class="string">"这是我的第一个 shell 函数!"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">echo</span> <span class="string">"-----函数开始执行-----"</span></div><div class="line">myFun</div><div class="line"><span class="built_in">echo</span> <span class="string">"-----函数执行完毕-----"</span></div></pre></td></tr></table></figure>
<p>下面定义一个带有return语句的函数： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">myFun</span></span>()&#123;</div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"这个函数会对输入的两个数字进行相加运算..."</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"输入第一个数字: "</span></div><div class="line"></div><div class="line">    <span class="built_in">read</span> aNum</div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"输入第二个数字: "</span></div><div class="line"></div><div class="line">    <span class="built_in">read</span> anotherNum</div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"两个数字分别为 <span class="variable">$aNum</span> 和 <span class="variable">$anotherNum</span> !"</span></div><div class="line"></div><div class="line">    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">muFun</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"输入的两个数字之和为 $? !"</span></div></pre></td></tr></table></figure>
<p>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</p>
<p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 </p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数…</p>
<p>带参数的函数示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"第一个参数为 <span class="variable">$1</span> !"</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"第二个参数为 <span class="variable">$2</span> !"</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 <span class="variable">$10</span> !"</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 <span class="variable">$&#123;10&#125;</span> !"</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"第十一个参数为 <span class="variable">$&#123;11&#125;</span> !"</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"参数总数有 <span class="variable">$#</span> 个!"</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"作为一个字符串输出所有参数 $* !"</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</div></pre></td></tr></table></figure>
<p>注意，<code>$10</code> 不能获取第十个参数，获取第十个参数需要<code>${10}</code>。<strong>当n&gt;=10时，需要使用<code>${n}</code>来获取参数。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁&lt;/strong&gt;。Shell 既是一种命令语言，
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|虚拟存储器</title>
    <link href="http://yoursite.com/2018/06/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://yoursite.com/2018/06/22/深入理解计算机系统-虚拟存储器/</id>
    <published>2018-06-21T19:46:49.000Z</published>
    <updated>2018-06-21T14:13:50.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>你是否疑惑过为什么两个进程可以拥有同一个地址，明明某个地址处的物理内存只有一块啊。这其实是系统提供的一种对主存的一种抽象，叫做虚拟存储器。它为每个进程提供了一个大的、一致的、和私有的地址空间。虚拟存储器提供了三个重要的能力：</p>
<ol>
<li>将主存作为一个存储在磁盘上的地址空间的缓存。</li>
<li>为每个进程提供一致的地址空间。</li>
<li>保护每个进程的地址空间不被其他进程破坏。</li>
</ol>
<h3 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h3><p>计算机系统的主存被组织成一个有M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址(physical address)。在这种简单的结构中，CPU要访问存储器，最简单的方式就是使用存储器的物理地址，也成为<strong>物理寻址</strong>。</p>
<p><img src="/images/虚拟存储器-02.png" alt=""></p>
<p>当然还有另一种寻址方式，<strong>虚拟寻址</strong>。CPU生成一个虚拟地址来访问主存，这个虚拟地址经过地址翻译生成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。就像异常处理一样，地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做存储器管理单元(Memory Management Unit，MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理。</p>
<p><img src="/images/虚拟存储器-01.png" alt=""></p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>地址空间(adress space)是一个非整数地址的有序集合：{0,1,2,…}。</p>
<p>如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间(linear address space)。在一个带虚拟存储器的系统中，CPU从一个有N = 2 ^ n个地址空间中生成虚拟地址，这个地址空间称为<strong>虚拟地址空间(virtual address space)</strong>：{0,1,2,3,…,N-1}。</p>
<p>一个地址空间的大小是由表示最大地址所需要的倍数来描述的。例如，一个包含N=2^n个地址的虚拟地址空间叫做一个n位地址空间。现在系统典型地支持32位或者64位虚拟地址空间。</p>
<p>一个系统还有一个<strong>物理地址空间(physical addresss space)</strong>，它与系统中物理存储器的M字节相对应：{0,1,2,…M-1}。</p>
<p>地址空间的概念是很重要的，因为它清楚地区分了<strong>数据对象(字节)</strong>和它们的<strong>属性(地址)</strong>。一旦认识到了这种区别，那么我们就可以将其推广，<strong>允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间</strong>。这就是虚拟存储器的基本思想。主存中每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
<h3 id="内存是磁盘的Cache"><a href="#内存是磁盘的Cache" class="headerlink" title="内存是磁盘的Cache"></a>内存是磁盘的Cache</h3><p>概念上而言，虚拟存储器被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。磁盘上的数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘(较低层)上的数据被分割成块，这些块作为磁盘和主存(较高层)之间的传输单元。VM系统通过将虚拟存储器分割称为<strong>虚拟页(Vitual Page，VP)</strong>的大小固定的块来处理这个问题。每个虚拟页的大小为P = 2 ^ n字节。类似地，物理存储器被分割为<strong>物理页(Physical Page，PP)</strong>，大小也为P字节(物理页也称为<strong>页帧(page frame))</strong>。</p>
<p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p>
<ul>
<li>未分配的：VM系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。(没有调用malloc或者mmap的)</li>
<li>缓存的：当前缓存在物理存储中的已分配页。(已经调用malloc和mmap的，在程序中正在引用的)</li>
<li>未缓存的：没有缓存在物理存储器中的已分配页。(已经调用malloc和mmap的，在程序中还没有被引用的)</li>
</ul>
<p><img src="/images/虚拟存储器-03.png" alt=""></p>
<p>上图中，虚拟页0和3还没有被分配，因此在磁盘上还不存在。虚拟页1、4和6被缓存在物理存储器中。页2、5和7已经被分配了，但是当前并未缓存在主存中，只存在于磁盘中。</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到DRAM中，替换这个牺牲页。</p>
<p>这些功能是由许多软硬件联合提供的，包括操作系统软件，MMU(存储器管理单元)中地址翻译硬件和一个存放在物理存储器中叫做<strong>页表(page table)</strong>的数据结构，页表将虚拟页映射到物理页。<strong>页表就是一个页表条目(Page Table Entry，PTE)的数组。</strong>为了简化，设PTE由一个有效位和一个n位地址字段组成。设置了有效位表明虚拟页为已缓存的，地址指向DRAM中相应物理页的起始位置；未设置有效位且地址为空表明虚拟页未分配，否则地址指向磁盘上虚拟页的起始位置。</p>
<p><img src="/images/虚拟存储器-04.png" alt=""></p>
<p>当CPU读取的字在某一虚拟页，且该页已缓存，则称为<strong>页命中</strong>。DRAM缓存不命中称为<strong>缺页</strong>，它触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序选择一个牺牲页，如果该页已经被修改，内核将它写回磁盘，然后内核更新页并返回，异常处理程序返回时会重新启动导致缺页的指令。</p>
<p>在磁盘和存储器之间传送页称为<strong>交换或页面调度</strong>。现代系统采用<strong>按需页面</strong>调度的策略，即当有不命中发生时才换入页面。</p>
<p>局部性原理使程序引用的页面趋向于在一个较小的活动页面集合上工作，该集合称为工作集（常驻集合）。通常虚拟存储器系统工作得很好，但如果工作集的大小超出了物理存储器的大小，那么程序会产生颠簸，即页面不断换进换出。</p>
<p>操作系统为每个进程都提供了一个独立的页表，即一个独立的虚拟地址空间。多个虚拟页面可以映射到同一个共享物理页面上。这带来了很多好处：</p>
<ul>
<li><p>简化链接。独立的地址空间使进程可以为它的存储器映像使用相同的基本格式，而不管代码和数据在物理存储器的实际存放位置。Linux进程的存储器映像可以见前面章节。文本区、栈、共享库、操作系统代码和数据总是从固定的位置开始。</p>
</li>
<li><p>简化共享。独立的地址空间提供了一个管理用户进程和操作系统自身之间共享的一致机制。操作系统将不同进程中的一些虚拟页映射到相同的物理页来使它们共享这部分代码。</p>
</li>
<li><p>简化存储器分配。虚拟存储器是一个向用户进程分配额外存储器的机制。页面可以随机地分散在物理存储器中。</p>
</li>
<li><p>简化加载。虚拟存储器简化了加载可执行文件和已共享目标文件，只需将虚拟页标识为无效的（未缓存）并将PTE指向目标文件的适当位置。实际中加载器并不从磁盘复制数据到存储器，而是在页面被引用时再按需调度。</p>
</li>
</ul>
<p><img src="/images/虚拟存储器-05.png" alt=""></p>
<p>虚拟存储器也可以提供对存储器的访问保护，可以通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问。指令违反许可条件时，CPU触发一个一般保护故障的异常，Linux将它报告为段错误。</p>
<h5 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h5><p>如下图，当CPU读包含在VP2中的虚拟存储器的一个字时，会怎么样呢？从图中，我们知道VP2是被缓存在DRAM中的。地址翻译硬件将虚拟地址作为一个索引来定位<code>PTE2</code>，并从存储器中读取PTE2的的内容。因为设置了有效位，那么地址翻译硬件就知道VP2是缓存在存储器中的了，所以使用PTE2的内容来构造物理地址。</p>
<p><img src="/images/虚拟存储器-06.png" alt=""></p>
<h5 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h5><p>还是刚刚的图，如果CPU访问VP3，我们知道VP3的内容不再DRAM中，那么会发生什么呢？这时会触发一个<strong>缺页异常</strong>。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如下图，选择了PP3中的VP4。</p>
<p><img src="/images/虚拟存储器-07.png" alt=""></p>
<p>如果VP4已经被修改了，那么内核就会将它拷贝回磁盘。无论哪种情况，内核都会修改VP4的页表条目（如上图），反映出VP4已经被换出，不在缓存在内存中的事实。接下来，内核从磁盘拷贝VP3到主存中的PP3，更新VP3的页表条目，然后返回，重启导致缺页的指令。此时，VP3已经在内存中，就会发生页命中。</p>
<h5 id="页分配"><a href="#页分配" class="headerlink" title="页分配"></a>页分配</h5><p>下图展示了操作系统分配一个新的虚拟存储页后对我们页表的影响。例如，当我们调用alloc时，在磁盘上创建空间并更新页表的VP5，让它指向磁盘上一个新的页面。同时，我们也能发现，刚分配的空间，并没有立即在内存中分配空间，只是在页表里添加了一个磁盘的映射。</p>
<p><img src="/images/虚拟存储器-08.png" alt=""></p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>地址翻译是N元素虚拟地址空间（VAS）的元素和M元素物理地址空间（PAS）的元素之间的映射 <code>MAP:VAS-&gt; PAS U Φ</code>。</p>
<ul>
<li>MAP(A) = A’，若虚拟地址A处的数据在物理地址A’处。</li>
<li>MAP(A) = Φ，若虚拟地址A处的数据不在物理存储器中。</li>
</ul>
<p><img src="/images/虚拟存储器-09.png" alt=""></p>
<p>CPU中的<code>页表基址寄存器（PTBR）</code>指向当前页表。n位的虚拟地址包含p位的<code>VPO（虚拟页面偏移</code>）和<code>n-p位的VPN（虚拟页号）</code>两部分，MMU利用<code>VPN</code>选择<code>PTE</code>，将PTE中的<code>PPN（物理页号</code>）和虚拟地址中的<code>VPO</code>串联，得到相应的物理地址。<code>PPO（物理页面偏移）</code>和<code>VPO</code>是相同的。</p>
<h4 id="页命中-1"><a href="#页命中-1" class="headerlink" title="页命中"></a>页命中</h4><p>下图展示了当页命中时，CPU硬件执行的步骤：</p>
<ol>
<li>CPU生成虚拟地址，传送给MMU。</li>
<li>MMU生成PTE地址，向高速缓存/主存请求它。</li>
<li>高速缓存/主存向MMU返回PTE。</li>
<li>MMU构造物理地址，传送给高速缓存/主存。</li>
<li>高速缓存/主存返回所请求的数据。</li>
</ol>
<p><img src="/images/虚拟存储器-10.png" alt=""></p>
<h4 id="缺页-1"><a href="#缺页-1" class="headerlink" title="缺页"></a>缺页</h4><p><img src="/images/虚拟存储器-11.png" alt=""></p>
<p>缺页时，硬件和系统内核协作：</p>
<ol>
<li>和页面命中时前三步相同。</li>
<li>PTE有效位为0，MMU触发异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。 </li>
<li>缺页处理程序确定物理存储器中的牺牲页，若该页已被修改，把它页面换出到磁盘。 </li>
<li>缺页处理程序调入新的页面，更新存储器中的PTE。 </li>
<li>缺页处理程序返回到原来的进程，重新启动导致缺页的指令。重新发送给MMU，页面命中。</li>
</ol>
<h4 id="cache和虚拟存储器的结合"><a href="#cache和虚拟存储器的结合" class="headerlink" title="cache和虚拟存储器的结合"></a>cache和虚拟存储器的结合</h4><p>现在我们将虚拟存储器和之前学过的cache结合起来。高速缓存通常是物理寻址的，地址翻译发生在高速缓存查找之前。所以一次访问的过程如下图：</p>
<p><img src="/images/虚拟存储器-12.png" alt=""></p>
<h4 id="利用TLB加速地址翻译"><a href="#利用TLB加速地址翻译" class="headerlink" title="利用TLB加速地址翻译"></a>利用TLB加速地址翻译</h4><p>为消除查找PTE的开销，在MMU中包含一个PTE的小缓存，称为<strong>TLB（翻译后备缓冲器）</strong>，它是一个小的虚拟寻址的缓存，每行保存一个单个PTE组成的块。TLB有高度的相联性。</p>
<p>若TLB有T = 2^t个组，TLB索引（TLBI）由VPN的t个最低位组成，TLB标记（TLBT）由VPN的剩余的位组成。如下图：</p>
<p><img src="/images/虚拟存储器-13.png" alt=""></p>
<h5 id="TLB命中"><a href="#TLB命中" class="headerlink" title="TLB命中"></a>TLB命中</h5><p>下图展示了TLB命中时的访问步骤：</p>
<ol>
<li>CPU生成虚拟地址，传送给MMU。</li>
<li>MMU从TLB取出相应的PTE</li>
<li>MMU构造物理地址，传送给高速缓存/主存。</li>
<li>高速缓存/主存返回所请求的数据。</li>
</ol>
<p><img src="/images/虚拟存储器-14.png" alt=""></p>
<h5 id="TLB不命中"><a href="#TLB不命中" class="headerlink" title="TLB不命中"></a>TLB不命中</h5><p>当TLB不命中时，MMU需要从L1cache中取出相应的PTE（如下图），新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p>
<p><img src="/images/虚拟存储器-15.png" alt=""></p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>对于32位地址空间、4KB的页面，若PTE为4字节，则页表会达到4MB，64位的地址空间的页表就更加庞大。实际中的系统使用多级页表来压缩页表。这样只有一级页表才需要总在主存中。</p>
<p>k级页表的地址翻译中，虚拟地址被划分为k个VPN和1个VPO。第k级页表中的PTE指向物理页面的PPN。</p>
<p><img src="/images/虚拟存储器-17.png" alt=""></p>
<p>多级页表下的TLB地址组成：</p>
<p><img src="/images/虚拟存储器-16.png" alt=""></p>
<p>讲述到这里，虚拟存储器的内容几乎讲完啦，下面我们用一个图来总结这一切：</p>
<p><img src="/images/虚拟存储器-18.png" alt=""></p>
<h3 id="一些商业系统示例"><a href="#一些商业系统示例" class="headerlink" title="一些商业系统示例"></a>一些商业系统示例</h3><p>在Pentium存储器系统中，有32位地址空间、4KB的页大小、TLB、L1、L2为4路组相联：</p>
<ul>
<li>指令TLB：32个条目、8组。</li>
<li>数据TLB：64个条目、16组。</li>
<li>L1 i-cache和d-cache：16KB、128组、32B块大小。</li>
<li>L2高速缓存：128KB ~ 2MB、32B块大小。</li>
</ul>
<p>Pentium系统使用两级页表，第一级页表称为页面目录，包含1024个32位的PDE（页面目录条目），PDE指向二级页表，每个二级页表包含1024个32位的PTE，PTE指向物理存储器或磁盘上的页面。每个进程有唯一的页面目录和页表集合，页表可以换进换出，页表目录和已分配页面的相关页表常驻存储器。PDBR（页面目录基址寄存器）指向页表目录的起始位置。</p>
<p><img src="/images/虚拟存储器-19.png" alt=""></p>
<p>在Linux系统中，虚拟存储器中位于 0xc0000000 之上的部分为内核虚拟存储器，它包含内核的代码和数据，部分区域映射到所有进程共享的物理页面，其他区域包含每个进程不同的数据。同时，虚拟存储器被组织成区域（段）的集合，区域是已分配的连续组块，以某种方式相关联。不属于某区域的虚拟页是不存在的，不能被引用。区域允许了虚拟地址空间有间隙。</p>
<p><img src="/images/虚拟存储器-20.png" alt=""></p>
<p>内核为每个进程维护一个任务结构 task_struct ，结构中包含运行进程所需的信息。其中一个条目指向 mm_struct ，它描述了虚拟存储器的当前状态。其中两个字段， pgd 指向页面目录表的基址， mmap 指向 vm_area_struct 链表。每个 vm_area_struct 描述当前虚拟地址空间的一个区域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** &lt;linux/mm_types.h&gt; */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;         <span class="comment">/* 区域开始处 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;           <span class="comment">/* 区域结束处 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span> <span class="comment">/* 链表中下一个区域结构 */</span></div><div class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;          <span class="comment">/* 区域内所有页面的读写权限 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;         <span class="comment">/* 区域内的页面是共享的还是私有的, ... */</span></div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="地址翻译示例"><a href="#地址翻译示例" class="headerlink" title="地址翻译示例"></a>地址翻译示例</h3><p>下面，我们来完成一个端到端的地址翻译示例，来综合刚刚讲的内容。</p>
<p>首先，我们做出如下假设：</p>
<ul>
<li>存储器按字节寻址</li>
<li>存储器访问是针对一字节的字的（不是4字节的字）</li>
<li>虚拟地址是14位长的 (n=14)</li>
<li>物理地址是12位长的 (m=12)</li>
<li>页面大小是64字节的 (P=64)</li>
<li>TLB是四路组相连的，总共有16个条目</li>
<li>L1 d-cache是物理寻址、直接映射的，行大小为4字节，总共有16个组</li>
</ul>
<p>下面是相应的虚拟地址和物理地址的格式。</p>
<p><img src="/images/虚拟存储器-21.png" alt=""></p>
<p>下面是讲解例子要使用的小存储器系统的一个快照，包括TLB、页表的一部分和Cahce。</p>
<ul>
<li>TLB地址格式和TLB快照：</li>
</ul>
<p><img src="/images/虚拟存储器-22.png" alt=""></p>
<ul>
<li>页表的部分快照：</li>
</ul>
<p><img src="/images/虚拟存储器-23.png" alt=""></p>
<ul>
<li>cahce快照</li>
</ul>
<p><img src="/images/虚拟存储器-24.png" alt=""></p>
<h4 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h4><p>现在，让我们看看当CPU执行一条读地址<code>0x03d4</code>处字节的加载指令会发生什么。</p>
<p>首先，我们先分析虚拟地址：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>虚拟地址</td>
<td>0x03d4</td>
</tr>
<tr>
<td>二进制表示</td>
<td>00-0011-1101-0100</td>
</tr>
<tr>
<td>VPN</td>
<td>0000-1111 -&gt; 0x0f</td>
</tr>
<tr>
<td>VPO</td>
<td>01-0100 -&gt; 0x14</td>
</tr>
<tr>
<td>TLBI</td>
<td>11 -&gt; 0x03</td>
</tr>
<tr>
<td>TLBT</td>
<td>000011 -&gt; 0x03</td>
</tr>
</tbody>
</table>
<p>从虚拟地址中，我们分解出 <code>VPN</code>,然后得到TLB的 <code>TLBI</code>好<code>TLBT</code> ,接着，我们检查TLB，看它是否因为前面的某个存储器引用，缓存了PTE<code>0x0f</code>的一个拷贝。很幸运，我们找到了，如下图：</p>
<p><img src="/images/虚拟存储器-25.png" alt=""></p>
<p>我们得到了<code>PPN (0x0D)</code> ,返回给MMU。现在，MMU就有了形成物理地址所需要的所有东西了：将来自PTE的<code>PPN (0x0D)</code>和来自虚拟地址的 <code>VPO(0x14)</code>拼接起来，得到了<strong>物理地址 <code>0x354</code></strong>。</p>
<p>接下来，我们分析下物理地址：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理地址</td>
<td>0x345</td>
</tr>
<tr>
<td>二进制表示</td>
<td>0011-0101-0100</td>
</tr>
<tr>
<td>CO</td>
<td>0x0</td>
</tr>
<tr>
<td>CI</td>
<td>0x05</td>
</tr>
<tr>
<td>CT</td>
<td>0x0d</td>
</tr>
<tr>
<td>PPN</td>
<td>0x0d</td>
</tr>
<tr>
<td>PPO</td>
<td>0x14</td>
</tr>
</tbody>
</table>
<p>幸运女神在一次光临我们，我们在cache中找到了地址<code>0x354</code>的拷贝，如下图：</p>
<p><img src="/images/虚拟存储器-26.png" alt=""></p>
<p>所以从cache中读出偏移量CO处的数据字节<code>0x36</code>，并将它返回给MMU，随后MMC返回给CPU。</p>
<p>当然，我们不可能都这么幸运，每次都能在缓存中找到拷贝。</p>
<ul>
<li>如果在TLB中没有缓存，那么MMU就需要从主存的页表中取出相应的PTE。</li>
<li>如果页表中的PTE是无效的，需要产生一个缺页异常，然后内核调入合适的页面。</li>
<li>如果cache中没有缓存，需要根据物理地址到主存中取数据。</li>
</ul>
<p><a href="http://www.yeolar.com/note/2012/03/29/virtual-memory/" target="_blank" rel="external">Linux系统学习笔记：虚拟存储器</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;你是否疑惑过为什么两个进程可以拥有同一个地址，明明某个地址处的物理内存只有一块啊。这其实是系统提供的一种对主存的一种抽象，叫做虚拟存储器。它
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>python|Multiprocessing多进程</title>
    <link href="http://yoursite.com/2018/06/21/python-Multiprocessing%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/06/21/python-Multiprocessing多进程/</id>
    <published>2018-06-20T23:47:38.000Z</published>
    <updated>2018-06-23T02:10:16.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要使用python多进程？"><a href="#为什么要使用python多进程？" class="headerlink" title="为什么要使用python多进程？"></a>为什么要使用python多进程？</h3><p>因为python使用全局解释器锁(GIL)，他会将进程中的线程序列化，也就是多核cpu实际上并不能达到并行提高速度的目的，而使用多进程则是不受限的，所以实际应用中都是推荐多进程的。</p>
<p>如果每个子进程执行需要消耗的时间非常短（执行+1操作等），这不必使用多进程，因为进程的启动关闭也会耗费资源。</p>
<p>当然使用多进程往往是用来处理CPU密集型（科学计算）的需求，如果是IO密集型（文件读取，爬虫等）则可以使用多线程去处理。</p>
<h3 id="multiprocessing常用组件及功能"><a href="#multiprocessing常用组件及功能" class="headerlink" title="multiprocessing常用组件及功能"></a>multiprocessing常用组件及功能</h3><p>创建管理进程模块：</p>
<ul>
<li>Process（用于创建进程模块）</li>
<li>Pool（用于创建管理进程池）</li>
<li>Queue（用于进程通信，资源共享）</li>
<li>Value，Array（用于进程通信，资源共享）</li>
<li>Pipe（用于管道通信）</li>
<li>Manager（用于资源共享）</li>
</ul>
<p>同步子进程模块：</p>
<ul>
<li>Condition</li>
<li>Event</li>
<li>Lock</li>
<li>RLock</li>
<li>Semaphore</li>
</ul>
<h4 id="Process模块"><a href="#Process模块" class="headerlink" title="Process模块"></a>Process模块</h4><p>Process模块用来创建子进程，是Multiprocessing核心模块，使用方式与Threading类似，可以实现多进程的创建，启动，关闭等操作。</p>
<p>构造方法：</p>
<ul>
<li>Process([group [, target [, name [, args [, kwargs]]]]])</li>
<li>group: 线程组，目前还没有实现，库引用中提示必须是None；</li>
<li>target: 要执行的方法；</li>
<li>name: 进程名；</li>
<li>args/kwargs: 要传入方法的参数。</li>
</ul>
<p>实例方法：</p>
<ul>
<li>is_alive()：返回进程是否在运行。</li>
<li>join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。</li>
<li>start()：进程准备就绪，等待CPU调度。</li>
<li>run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。</li>
<li>terminate()：不管任务是否完成，立即停止工作进程。</li>
</ul>
<p>属性：</p>
<ul>
<li>authkey</li>
<li>daemon：和线程的setDeamon功能一样（将父进程设置为守护进程，当父进程结束时，子进程也结束）。</li>
<li>exitcode(进程在运行时为None、如果为–N，表示被信号N结束）。</li>
<li>name：进程名字。</li>
<li>pid：进程号。</li>
</ul>
<h4 id="使用Process创建子进程"><a href="#使用Process创建子进程" class="headerlink" title="使用Process创建子进程"></a>使用Process创建子进程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process  <span class="comment">#导入Process模块 </span></div><div class="line"><span class="keyword">import</span> os  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(name)</span>:</span></div><div class="line">	<span class="string">'''</span></div><div class="line">	函数输出当前进程ID，以及其父进程ID。</div><div class="line">	此代码应在Linux下运行，因为windows下os模块不支持getppid()</div><div class="line">	'''</div><div class="line">    <span class="keyword">print</span> <span class="string">"Process ID： %s"</span> % (os.getpid())  </div><div class="line">    <span class="keyword">print</span> <span class="string">"Parent Process ID： %s"</span> % (os.getppid())  </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </div><div class="line">	<span class="string">'''</span></div><div class="line">	windows下，创建进程的代码一下要放在main函数里面</div><div class="line">	''' </div><div class="line">    proc = Process(target=test, args=(<span class="string">'nmask'</span>,))  </div><div class="line">    proc.start()  </div><div class="line">    proc.join()</div></pre></td></tr></table></figure>
<h4 id="使用Process类继承创建子进程"><a href="#使用Process类继承创建子进程" class="headerlink" title="使用Process类继承创建子进程"></a>使用Process类继承创建子进程</h4><p>通过继承Process类，修改run函数代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></div><div class="line"><span class="string">'''</span></div><div class="line">继承Process类，类似threading.Thread</div><div class="line">'''</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></div><div class="line">        super(MyProcess, self).__init__()</div><div class="line">        <span class="comment">#multiprocessing.Process.__init__(self)</span></div><div class="line">        self.arg = arg</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    重构run函数</div><div class="line">    '''</div><div class="line">        <span class="keyword">print</span> <span class="string">'nMask'</span>, self.arg</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        p = MyProcess(i)</div><div class="line">        p.start()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    	p.join()</div></pre></td></tr></table></figure>
<p>重点讲两个方法：<code>run</code> 和<code>join</code></p>
<ul>
<li>run：如果在创建Process对象的时候不指定target，那么就会默认执行Process的run方法</li>
<li>join方法:阻塞当前进程，直到调用join方法的那个进程执行完，再继续执行当前进程。</li>
</ul>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>.Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行它。在共享资源时，只能使用Multiprocessing.Manager类，而不能使用Queue或者Array。</p>
<p>Pool类用于需要执行的目标很多，而手动限制进程数量又太繁琐时，如果目标少且不用控制进程数量则可以用Process类。</p>
<p>构造方法</p>
<ul>
<li>Pool([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])</li>
<li>processes ：使用的工作进程的数量，如果processes是None那么使用 os.cpu_count()返回的数量。</li>
<li>initializer： 如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)</li>
<li>maxtasksperchild：工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。</li>
<li>context: 用在制定工作进程启动时的上下文，一般使用 multiprocessing.Pool() 或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context。</li>
</ul>
<p>实例方法</p>
<ul>
<li>apply_async(func[, args[, kwds[, callback]]]) 它是非阻塞。</li>
<li>apply(func[, args[, kwds]])是阻塞的。</li>
<li>close() 关闭pool，使其不在接受新的任务。</li>
<li>terminate() 关闭pool，结束工作进程，不在处理未完成的任务。</li>
<li>join() 主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。</li>
</ul>
<h4 id="Pool使用方法"><a href="#Pool使用方法" class="headerlink" title="Pool使用方法"></a>Pool使用方法</h4><h5 id="Pool-map函数"><a href="#Pool-map函数" class="headerlink" title="Pool+map函数"></a>Pool+map函数</h5><p>说明：此写法缺点在于只能通过map向函数传递一个参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">print</span> i</div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	lists=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">	pool=Pool(processes=<span class="number">2</span>) <span class="comment">#定义最大的进程数</span></div><div class="line">	pool.map(test,lists)        <span class="comment">#p必须是一个可迭代变量。</span></div><div class="line">	pool.close()</div><div class="line">	pool.join()</div></pre></td></tr></table></figure>
<h5 id="异步进程池（非阻塞）"><a href="#异步进程池（非阻塞）" class="headerlink" title="异步进程池（非阻塞）"></a>异步进程池（非阻塞）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">from multiprocessing import Pool</div><div class="line">def test(i):</div><div class="line">    print i</div><div class="line">if __name__==&quot;__main__&quot;:</div><div class="line">	pool = Pool(processes=10)</div><div class="line">	for i  in xrange(500):</div><div class="line">		&apos;&apos;&apos;</div><div class="line">		For循环中执行步骤：</div><div class="line">		（1）循环遍历，将500个子进程添加到进程池（相对父进程会阻塞）</div><div class="line">		（2）每次执行10个子进程，等一个子进程执行完后，立马启动新的子进程。（相对父进程不阻塞）</div><div class="line">		</div><div class="line">		apply_async为异步进程池写法。</div><div class="line">		异步指的是启动子进程的过程，与父进程本身的执行（print）是异步的，而For循环中往进程池添加子进程的过程，与父进程本身的执行却是同步的。</div><div class="line">		&apos;&apos;&apos;</div><div class="line">	    pool.apply_async(test, args=(i,)) #维持执行的进程总数为10，当一个进程执行完后启动一个新进程.       </div><div class="line">	print “test”</div><div class="line">	pool.close()</div><div class="line">	pool.join()</div></pre></td></tr></table></figure>
<p>执行顺序：For循环内执行了2个步骤，第一步：将500个对象放入进程池（阻塞）。第二步：同时执行10个子进程（非阻塞），有结束的就立即添加，维持10个子进程运行。（apply_async方法的会在执行完for循环的添加步骤后，直接执行后面的print语句，而apply方法会等所有进程池中的子进程运行完以后再执行后面的print语句）</p>
<p>注意：调用join之前，先调用close或者terminate方法，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束。</p>
<h5 id="同步进程池（阻塞）"><a href="#同步进程池（阻塞）" class="headerlink" title="同步进程池（阻塞）"></a>同步进程池（阻塞）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(p)</span>:</span></div><div class="line">       <span class="keyword">print</span> p</div><div class="line">       time.sleep(<span class="number">3</span>)</div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	pool = Pool(processes=<span class="number">10</span>)</div><div class="line">	<span class="keyword">for</span> i  <span class="keyword">in</span> xrange(<span class="number">500</span>):</div><div class="line">	<span class="string">'''</span></div><div class="line">	实际测试发现，for循环内部执行步骤：</div><div class="line">	（1）遍历500个可迭代对象，往进程池放一个子进程</div><div class="line">	（2）执行这个子进程，等子进程执行完毕，再往进程池放一个子进程，再执行。（同时只执行一个子进程）</div><div class="line">	for循环执行完毕，再执行print函数。</div><div class="line">	'''</div><div class="line">	    pool.apply(test, args=(i,))   <span class="comment">#维持执行的进程总数为10，当一个进程执行完后启动一个新进程.</span></div><div class="line">	<span class="keyword">print</span> “test”</div><div class="line">	pool.close()</div><div class="line">	pool.join()</div></pre></td></tr></table></figure>
<p>说明：for循环内执行的步骤顺序，往进程池中添加一个子进程，执行子进程，等待执行完毕再添加一个子进程…..等500个子进程都执行完了，再执行print “test”。（从结果来看，并没有多进程并发）</p>
<h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h3><p>在使用多进程的过程中，最好不要使用共享资源，如果非得使用，则请往下看。Multiprocessing类中共享资源可以使用3种方式，分别是<code>Queue</code>，<code>Array</code>，<code>Manager</code>。这三个都是Multiprocessing自带的组件，使用起来也非常方便。</p>
<p>注意：<strong>普通的全局变量是不能被子进程所共享的，只有通过Multiprocessing组件构造的数据结构可以被共享。</strong></p>
<h4 id="Queue类"><a href="#Queue类" class="headerlink" title="Queue类"></a>Queue类</h4><p>使用Multiprocessing.Queue类，共享资源（share memory）（只适用Process类）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(queue)</span>:</span>  </div><div class="line">    queue.put(<span class="string">"Hello World"</span>)  </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    q = Queue()  </div><div class="line">    p = Process(target=test, args=(q,))  <span class="comment">#需要将q对象传递给子进程</span></div><div class="line">    p.start()</div><div class="line">    <span class="keyword">print</span> q.get()</div></pre></td></tr></table></figure>
<p>缺点：不能再Pool进程池中使用</p>
<h4 id="Array、Value类"><a href="#Array、Value类" class="headerlink" title="Array、Value类"></a>Array、Value类</h4><p>使用Multiprocessing.Array类，共享资源（share memory）（只适用于Process类）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Array</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</div><div class="line">        a[i] = -a[i]</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    arr = Array(<span class="string">'i'</span>, range(<span class="number">10</span>))</div><div class="line">    p = Process(target=test, args=(arr))  <span class="comment">#需要将arr对象传递给子进程</span></div><div class="line">    p.start()</div><div class="line">    p.join()</div><div class="line">    <span class="keyword">print</span> arr[:]</div></pre></td></tr></table></figure>
<p>缺点：无法与Pool一起使用。</p>
<h4 id="Manager类"><a href="#Manager类" class="headerlink" title="Manager类"></a>Manager类</h4><p>使用Multiprocessing.Manager类，共享资源。（可以适用Pool类）</p>
<p>说明：由于windows操作系统下，创建Multiprocessing类对象代码一定要放在main()函数下，而linux不需要，因此这里区分2个版本。</p>
<p>实例目的：父进程在执行子进程的过程中，同步判断一个公共资源值，如果满足条件则结束所有进程。</p>
<p>linux版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from multiprocessing import Manager,Pool</div><div class="line">lists=Manager().list()    ##定义可被子进程共享的全局变量lists</div><div class="line">def test(i):</div><div class="line">     print i</div><div class="line">     lists.append(i)</div><div class="line">if __name__==&quot;__main__&quot;:</div><div class="line">    pool=Pool()</div><div class="line">    for i in xrange(10000000):</div><div class="line">    	&apos;&apos;&apos;</div><div class="line">    	判断如果lists长度大于0，则不再往进程池中添加进程。</div><div class="line">    	&apos;&apos;&apos;</div><div class="line">        if len(lists)&lt;=0:</div><div class="line">            pool.apply_async(test,args=(i,))</div><div class="line">        else:</div><div class="line">            break</div><div class="line">     pool.close()</div><div class="line">     pool.join()</div></pre></td></tr></table></figure>
<p>优点：可以跟Pool一起用，且速度比较快。</p>
<p>windows版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(i,lists)</span>:</span></div><div class="line">     <span class="keyword">print</span> i</div><div class="line">     lists.append(i)</div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">    pool=Pool()</div><div class="line">    lists=Manager().list() <span class="comment">#Manager类实例化代码只能写在main()函数里面</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10000000</span>):</div><div class="line">        <span class="keyword">if</span> len(lists)&lt;=<span class="number">0</span>:</div><div class="line">        	<span class="string">'''</span></div><div class="line">        	在创建子进程时，需要将lists对象传入，不然无法共享。</div><div class="line">        	'''</div><div class="line">            pool.apply_async(test,args=(i,lists))<span class="comment">##需要将lists对象传递给子进程，这里比较耗资源，原因可能是因为Manager类是基于通信的。</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>说明：与linux版本代码相比，windows下代码将lists的引用放在了main()之后，因为windows下只能在main函数下引用多进程。而在实例化子进程时，必须把Manager对象传递给子进程，否则lists无法被共享，而这个过程会消耗巨大资源，因此性能很差。<br>缺点：速度很慢，因此在windows下想要提前结束所有进程，可以使用获取返回值的方式</p>
<h3 id="子进程返回值"><a href="#子进程返回值" class="headerlink" title="子进程返回值"></a>子进程返回值</h3><p>在实际使用多进程的时候，可能需要获取到子进程运行的返回值。如果只是用来存储，则可以将返回值保存到一个数据结构中；如果需要判断此返回值，从而决定是否继续执行所有子进程，则会相对比较复杂。另外在Multiprocessing中，可以利用Process与Pool创建子进程，这两种用法在获取子进程返回值上的写法上也不相同。</p>
<h4 id="初级用法（Pool）"><a href="#初级用法（Pool）" class="headerlink" title="初级用法（Pool）"></a>初级用法（Pool）</h4><p>目的：存储子进程返回值</p>
<p>说明：如果只是单纯的存储子进程返回值，则可以使用Pool的apply_async异步进程池；当然也可以使用Process，用法与threading中的相同，这里只介绍前者。</p>
<p>实例：当进程池中所有子进程执行完毕后，输出每个子进程的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># -*- coding=utf-8 -*-</div><div class="line">from multiprocessing import Pool</div><div class="line">def test(p):     </div><div class="line">    return p</div><div class="line">if __name__==&quot;__main__&quot;:</div><div class="line">    pool = Pool(processes=10)</div><div class="line">    result=[]</div><div class="line">    for i  in xrange(50000):</div><div class="line">       &apos;&apos;&apos;</div><div class="line">       for循环执行流程：</div><div class="line">       （1）添加子进程到pool，并将这个对象（子进程）添加到result这个列表中。（此时子进程并没有运行）</div><div class="line">       （2）执行子进程（同时执行10个）</div><div class="line">       &apos;&apos;&apos;</div><div class="line">       result.append(pool.apply_async(test, args=(i,)))#维持执行的进程总数为10，当一个进程执行完后添加新进程.       </div><div class="line">    pool.close()</div><div class="line">    pool.join()</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    遍历result列表，取出子进程对象，访问get()方法，获取返回值。（此时所有子进程已执行完毕）</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    for i in result:</div><div class="line">        print i.get()</div></pre></td></tr></table></figure>
<h4 id="高级用法（Pool）"><a href="#高级用法（Pool）" class="headerlink" title="高级用法（Pool）"></a>高级用法（Pool）</h4><p>目的：父进程实时获取子进程返回值，以此为标记结束所有进程。</p>
<p>实例（一）<br>执行子进程的过程中，不断获取返回值并校验，如果返回值为True则结果所有进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># -*- coding=utf-8 -*-</div><div class="line">from multiprocessing import Pool</div><div class="line">import Queue</div><div class="line">import time</div><div class="line">def test(p):</div><div class="line">    time.sleep(0.001)</div><div class="line">    if p==10000:</div><div class="line">        return True</div><div class="line">    else:</div><div class="line">        return False</div><div class="line">if __name__==&quot;__main__&quot;:</div><div class="line">    pool = Pool(processes=10)</div><div class="line">    q=Queue.Queue()</div><div class="line">    for i  in xrange(50000):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        将子进程对象存入队列中。</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        q.put(pool.apply_async(test, args=(i,)))#维持执行的进程总数为10，当一个进程执行完后添加新进程.       </div><div class="line">    &apos;&apos;&apos;</div><div class="line">    因为这里使用的为pool.apply_async异步方法，因此子进程执行的过程中，父进程会执行while，获取返回值并校验。</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    while 1:</div><div class="line">        if q.get().get():</div><div class="line">            pool.terminate() #结束进程池中的所有子进程。</div><div class="line">            break</div><div class="line">    pool.close()</div><div class="line">    pool.join()</div></pre></td></tr></table></figure>
<p>说明：总共要执行50000个子进程（并发数量为10），当其中一个子进程返回True时，结束进程池。因为使用了apply_async为异步进程，因此在执行完for循环的添加子进程操作后（只是添加并没有执行完所有的子进程），可以直接执行while代码，实时判断子进程返回值是否有True，有的话结束所有进程。</p>
<p>优点：不必等到所有子进程结束再结束程序，只要得到想要的结果就可以提前结束，节省资源。</p>
<p>不足：当需要执行的子进程非常大时，不适用，因为for循环在添加子进程时，要花费很长的时间，虽然是异步，但是也需要等待for循环添加子进程操作结束才能执行while代码，因此会比较慢。</p>
<p>实例（二）<br>多线程+多进程，添加执行子进程的过程中，不断获取返回值并校验，如果返回值为True则结果所有进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># -*- coding=utf-8 -*-</div><div class="line">from multiprocessing import Pool</div><div class="line">import Queue</div><div class="line">import threading</div><div class="line">import time</div><div class="line">def test(p):</div><div class="line">    time.sleep(0.001)</div><div class="line">    if p==10000:</div><div class="line">        return True</div><div class="line">    else:</div><div class="line">        return False</div><div class="line">if __name__==&quot;__main__&quot;:</div><div class="line">    result=Queue.Queue() #队列</div><div class="line">    pool = Pool(10)</div><div class="line">    def pool_th():</div><div class="line">        for i  in xrange(50000000): ##这里需要创建执行的子进程非常多</div><div class="line">            try:</div><div class="line">                result.put(pool.apply_async(test, args=(i,)))</div><div class="line">            except:</div><div class="line">                break</div><div class="line">    def result_th():</div><div class="line">        while 1:</div><div class="line">            a=result.get().get() #获取子进程返回值</div><div class="line">            if a:</div><div class="line">                pool.terminate() #结束所有子进程</div><div class="line">                break</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    利用多线程，同时运行Pool函数创建执行子进程，以及运行获取子进程返回值函数。</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    t1=threading.Thread(target=pool_th)</div><div class="line">    t2=threading.Thread(target=result_th)</div><div class="line">    t1.start()</div><div class="line">    t2.start()</div><div class="line">    t1.join()</div><div class="line">    t2.join()</div><div class="line">    pool.join()</div></pre></td></tr></table></figure>
<p>执行流程：利用多线程，创建一个执行pool_th函数线程，一个执行result_th函数线程，pool_th函数用来添加进程池，开启进程执行功能函数并将子进程对象存入队列，而result_th()函数用来不停地从队列中取子进程对象，调用get（）方法获取返回值。等发现其中存在子进程的返回值为True时，结束所有进程，最后结束线程。</p>
<p>优点：弥补了实例（一）的不足，即使for循环的子进程数量很多，也能提高性能，因为for循环与判断子进程返回值同时进行。</p>
<p><a href="https://thief.one/2016/11/23/Python-multiprocessing/" target="_blank" rel="external">【Multiprocessing系列】Multiprocessing基础</a><br><a href="https://thief.one/2016/11/24/Multiprocessing%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%BF%94%E5%9B%9E%E5%80%BC/" target="_blank" rel="external">http://thief.one/2016/11/24/Multiprocessing子进程返回值/ </a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要使用python多进程？&quot;&gt;&lt;a href=&quot;#为什么要使用python多进程？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用python多进程？&quot;&gt;&lt;/a&gt;为什么要使用python多进程？&lt;/h3&gt;&lt;p&gt;因为python使用全局解释
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python|python中的一些妙招</title>
    <link href="http://yoursite.com/2018/06/16/python-python%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A6%99%E6%8B%9B/"/>
    <id>http://yoursite.com/2018/06/16/python-python中的一些妙招/</id>
    <published>2018-06-16T15:58:25.000Z</published>
    <updated>2018-06-23T03:19:13.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近准备入坑python,但又不想从基础的学起，又深知要想掌握一门语言，需要了解其的特性，所以以此文来记录日常发现的一些特性。</p>
<h3 id="python-中的-1"><a href="#python-中的-1" class="headerlink" title="python 中的[::-1]"></a>python 中的[::-1]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> rang(<span class="number">10</span>)涉及的数字倒序输出：</div><div class="line"></div><div class="line">　　<span class="keyword">for</span> value <span class="keyword">in</span> rang(<span class="number">10</span>)[::<span class="number">-1</span>]涉及的数字倒序输出：</div></pre></td></tr></table></figure>
<p>这个是python的slice notation的特殊用法。</p>
<p><code>a = [0,1,2,3,4,5,6,7,8,9]</code><br><code>b = a[i:j]</code> 表示复制a[i]到a[j-1]，以生成新的list对象<br><code>b = a[1:3]</code>那么，b的内容是 [1,2]<br>当i缺省时，默认为0，即 a[:3]相当于 a[0:3]<br>当j缺省时，默认为len(alist), 即a[1:]相当于a[1:10]<br>当i,j都缺省时，a[:]就相当于完整复制一份a了。</p>
<p><code>b = a[i:j:s]</code>这种格式呢，i,j与上面的一样，但s表示步进，缺省为1.<br>所以a[i:j:1]相当于a[i:j]<br>当s&lt;0时，i缺省时，默认为-1. j缺省时，默认为-len(a)-1<br>所以<code>a[::-1]</code>相当于 <code>a[-1:-len(a)-1:-1]</code>，也就是从最后一个元素到第一个元素复制一遍。所以你看到一个倒序的东东。</p>
<h3 id="Python函数-int"><a href="#Python函数-int" class="headerlink" title="Python函数 int()"></a>Python函数 <code>int()</code></h3><p>int(x, [base])</p>
<p>作用：</p>
<p>将一个数字或base类型的字符串转换成整数。</p>
<p>int(x=0)</p>
<p>int(x, base=10)，base缺省值为10，也就是说不指定base的值时，函数将x按十进制处理。</p>
<p>注：</p>
<ol>
<li><p>x 可以是数字或字符串，但是base被赋值后 x 只能是字符串</p>
</li>
<li><p>x 作为字符串时必须是 base 类型，也就是说 x 变成数字时必须能用 base 进制表示</p>
</li>
</ol>
<p>实例：</p>
<ol>
<li><p>x 是数字的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 int(3.14)            # 3</div><div class="line">2 int(2e2)             # 200</div><div class="line">3 int(100, 2)          # 出错，base 被赋值后函数只接收字符串</div></pre></td></tr></table></figure>
</li>
<li><p>x 是字符串的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 int(&apos;23&apos;, 16)      # 35</div><div class="line">2 int(&apos;Pythontab&apos;, 8)      # 出错，Pythontab不是个8进制数</div></pre></td></tr></table></figure>
</li>
<li><p>base 可取值范围是 2~36，囊括了所有的英文字母(不区分大小写)，十六进制中F表示15，那么G将在二十进制中表示16，依此类推….Z在三十六进制中表示35</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 int(&apos;FZ&apos;, 16)      # 出错，FZ不能用十六进制表示</div><div class="line">2 int(&apos;FZ&apos;, 36)      # 575</div></pre></td></tr></table></figure>
</li>
<li><p>字符串 0x 可以出现在十六进制中，视作十六进制的符号，同理 0b 可以出现在二进制中，除此之外视作数字 0 和字母 x</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int(&apos;0x10&apos;, 16)  # 16，0x是十六进制的符号</div><div class="line">int(&apos;0x10&apos;, 17)  # 出错，&apos;0x10&apos;中的 x 被视作英文字母 x</div><div class="line">int(&apos;0x10&apos;, 36)  # 42804，36进制包含字母 x</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Python函数-bin"><a href="#Python函数-bin" class="headerlink" title="Python函数 bin()"></a>Python函数 <code>bin()</code></h3><p>描述</p>
<p>bin() 返回一个整数 int 或者长整数 long int 的二进制表示。<br>语法</p>
<p>以下是 bin() 方法的语法:</p>
<p>bin(x)</p>
<p>参数</p>
<pre><code>x -- int 或者 long int 数字
</code></pre><p>返回值:字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = bin(3) </div><div class="line">&gt;&gt;&gt; b</div><div class="line">&apos;0b11&apos;</div><div class="line">&gt;&gt;&gt; type(b) #获取b的类型</div><div class="line">&lt;class &apos;str&apos;&gt;</div></pre></td></tr></table></figure>
<h3 id="Python-join-方法"><a href="#Python-join-方法" class="headerlink" title="Python join()方法"></a>Python join()方法</h3><p>描述</p>
<p>Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。<br>语法</p>
<p>join()方法语法：</p>
<pre><code>str.join(sequence)
</code></pre><p>参数</p>
<pre><code>sequence -- 要连接的元素序列。
</code></pre><p>返回值：返回通过指定字符连接序列中元素后生成的新字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line">str = <span class="string">"-"</span>;</div><div class="line">seq = (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>); <span class="comment"># 字符串序列</span></div><div class="line"><span class="keyword">print</span> str.join( seq );</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a-b-c</div></pre></td></tr></table></figure>
<h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>
<p>举个例子，要生成<code>list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>可以用<code>list(range(1, 11))</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; list(range(1, 11))</div><div class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</div></pre></td></tr></table></figure></p>
<p>但如果要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>怎么做？方法一是循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = []</div><div class="line">&gt;&gt;&gt; for x in range(1, 11):</div><div class="line">...    L.append(x * x)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; L</div><div class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></pre></td></tr></table></figure></p>
<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</div><div class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></pre></td></tr></table></figure></p>
<p>写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</div><div class="line">[4, 16, 36, 64, 100]</div></pre></td></tr></table></figure></p>
<p>还可以使用两层循环，可以生成全排列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</div><div class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</div></pre></td></tr></table></figure></p>
<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到</div><div class="line">&gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录</div><div class="line">[&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;]</div></pre></td></tr></table></figure></p>
<p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</div><div class="line">&gt;&gt;&gt; for k, v in d.items():</div><div class="line">...     print(k, &apos;=&apos;, v)</div><div class="line">...</div><div class="line">y = B</div><div class="line">x = A</div><div class="line">z = C</div></pre></td></tr></table></figure></p>
<p>因此，列表生成式也可以使用两个变量来生成list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</div><div class="line">&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()]</div><div class="line">[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</div></pre></td></tr></table></figure></p>
<p>最后把一个list中所有的字符串变成小写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]</div><div class="line">&gt;&gt;&gt; [s.lower() for s in L]</div><div class="line">[&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;]</div></pre></td></tr></table></figure></p>
<h3 id="python-range-xrange-区别"><a href="#python-range-xrange-区别" class="headerlink" title="python  range() xrange() 区别"></a>python  range() xrange() 区别</h3><p><code>range()函数</code>：</p>
<p>函数说明：<code>range([start,] stop[, step])</code>，根据start与stop指定的范围以及step设定的步长，生成一个序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; #一个参数的range()</div><div class="line">...</div><div class="line">&gt;&gt;&gt; range(10)</div><div class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line">&gt;&gt;&gt; #两个参数的range()</div><div class="line">...</div><div class="line">&gt;&gt;&gt; range(1,20)</div><div class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</div><div class="line">&gt;&gt;&gt; #带步长的range()函数</div><div class="line">...</div><div class="line">&gt;&gt;&gt; range(1,20,2)</div><div class="line">[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</div></pre></td></tr></table></figure>
<p><code>xrange()函数</code><br>函数说明：用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; xrange(10)</div><div class="line">xrange(10)</div><div class="line">&gt;&gt;&gt; list(xrange(10))</div><div class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line">&gt;&gt;&gt; xrange(1,10)</div><div class="line">xrange(1, 10)</div><div class="line">&gt;&gt;&gt; list(xrange(1,10))</div><div class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line">&gt;&gt;&gt; xrange(1,20,2)</div><div class="line">xrange(1, 21, 2)</div><div class="line">&gt;&gt;&gt; list(xrange(1,21,2))</div><div class="line">[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = range(0,100)</div><div class="line">&gt;&gt;&gt; print type(b)</div><div class="line">&lt;type &apos;list&apos;&gt;</div><div class="line">&gt;&gt;&gt; print b</div><div class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</div><div class="line">&gt;&gt;&gt; print b[0],b[10]</div><div class="line">0 10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = xrange(1,100)</div><div class="line">&gt;&gt;&gt; print type(c)</div><div class="line">&lt;type &apos;xrange&apos;&gt;</div><div class="line">&gt;&gt;&gt; print c</div><div class="line">xrange(1, 100)</div><div class="line">&gt;&gt;&gt; print c[1],c[2]</div><div class="line">2 3</div></pre></td></tr></table></figure>
<p>由上面的示例可以知道：要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间，这两个基本上都是在循环的时候用，可以说是延迟执行的。</p>
<p>range会直接生成一个list对象,而xrange则不会直接生成一个list，而是每次调用返回其中的一个值。所以xrange做循环的性能比range好，尤其是返回很大的时候，尽量用xrange吧，除非你是要返回一个列表。</p>
<h3 id="python-name-‘main‘-的作用"><a href="#python-name-‘main‘-的作用" class="headerlink" title="python name = ‘main‘ 的作用"></a>python <strong>name</strong> = ‘<strong>main</strong>‘ 的作用</h3><p>很多新手刚开始学习python的时候经常会看到python 中<code>__name__ = \&#39;__main__\&#39;</code> 这样的代码，可能很多新手一开始学习的时候都比较疑惑，python 中<code>__name__ = &#39;__main__&#39;</code> 的作用，到底干嘛的？</p>
<p>有句话经典的概括了这段代码的意义：</p>
<p>“Make a script both importable and executable” ,意思就是说让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。</p>
<p>这句话，可能一开始听的还不是很懂。下面举例说明：</p>
<p>先写一个模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#module.py</div><div class="line">def main():</div><div class="line">  print &quot;we are in %s&quot;%__name__</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">  main()</div></pre></td></tr></table></figure></p>
<p>这个函数定义了一个main函数，我们执行一下该py文件发现结果是打印出”we are in <strong>main</strong>“,说明我们的if语句中的内容被执行了，调用了main()：</p>
<p>但是如果我们从另我一个模块导入该模块，并调用一次main()函数会是怎样的结果呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#anothermodle.py</div><div class="line">from module import main</div><div class="line">main()</div></pre></td></tr></table></figure></p>
<p>其执行的结果是：we are in module</p>
<p>但是没有显示”we are in <strong>main</strong>“,也就是说模块<strong>name</strong> = ‘<strong>main</strong>‘ 下面的函数没有执行。</p>
<p>这样既可以让“模块”文件运行，也可以被其他模块引入，而且不会执行函数2次。这才是关键。</p>
<p>总结一下：</p>
<p>这是特殊的与模块相关的技巧，可把文件作为成模块导入，并以独立式程序的形式运行。每个模块都有个名为<code>__name__</code>的内置属性，python会自动设置该属性：</p>
<p>a、如果文件是以顶层程序文件执行，在启动时，<code>__name__</code>就会设置为字符串”<strong>main</strong>“；</p>
<p>b、如果文件被导入，<code>__name__</code>就会改设成客户端所了解的模块名。</p>
<p>结果就是模块可以检测自己的<code>__name__</code>，来确定它是在执行还是在导入。</p>
<p>这个功能还有一个用处：<strong>调试代码的时候，在<code>”if __name__ == &#39;__main__&#39;“</code>中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;最近准备入坑python,但又不想从基础的学起，又深知要想掌握一门语言，需要了解其的特性，所以以此文来记录日常发现的一些特性。&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>干货|如何设计安全的api接口</title>
    <link href="http://yoursite.com/2018/06/14/%E5%B9%B2%E8%B4%A7-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%89%E5%85%A8%E7%9A%84api%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/06/14/干货-如何设计安全的api接口/</id>
    <published>2018-06-13T23:26:42.000Z</published>
    <updated>2018-06-13T16:16:10.863Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.nsfocus.net/rest-api-d/esign-safety" target="_blank" rel="external">REST API 安全设计指南</a><br><a href="https://www.cnblogs.com/codelir/p/5327462.html" target="_blank" rel="external">开放api接口签名验证</a><br><a href="https://www.xncoding.com/2016/07/29/web/form.html" target="_blank" rel="external">防止表单重复提交</a><br><a href="https://mrxf.github.io/2017/09/25/using-the-jwt-for-api-to-add-authentication/" target="_blank" rel="external">前后端分离的身份认证(一)：JSON WEB TOKEN介绍</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.nsfocus.net/rest-api-d/esign-safety&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;REST API 安全设计指南&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnbl
    
    </summary>
    
      <category term="干货" scheme="http://yoursite.com/categories/%E5%B9%B2%E8%B4%A7/"/>
    
    
      <category term="干货" scheme="http://yoursite.com/tags/%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>干货|理解OAuth 2.0</title>
    <link href="http://yoursite.com/2018/06/12/%E5%B9%B2%E8%B4%A7-%E7%90%86%E8%A7%A3OAuth-2-0/"/>
    <id>http://yoursite.com/2018/06/12/干货-理解OAuth-2-0/</id>
    <published>2018-06-12T12:27:44.000Z</published>
    <updated>2018-06-12T05:34:56.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OAuth2-0是什么"><a href="#OAuth2-0是什么" class="headerlink" title="OAuth2.0是什么"></a>OAuth2.0是什么</h3><p>OAuth2.0是什么——豆瓣和QQ的故事</p>
<p>OAuth简单说就是一种授权的协议，只要授权方和被授权方遵守这个协议去写代码提供服务，那双方就是实现了OAuth模式。</p>
<p>举个例子，你想登录豆瓣去看看电影评论，但你丫的从来没注册过豆瓣账号，又不想新注册一个再使用豆瓣，怎么办呢？不用担心，豆瓣已经为你这种懒人做了准备，用你的qq号可以授权给豆瓣进行登录，请看。</p>
<p><a href="https://www.cnblogs.com/flashsun/p/7424071.html" target="_blank" rel="external">一张图搞定OAuth2.0</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">理解OAuth 2.0</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OAuth2-0是什么&quot;&gt;&lt;a href=&quot;#OAuth2-0是什么&quot; class=&quot;headerlink&quot; title=&quot;OAuth2.0是什么&quot;&gt;&lt;/a&gt;OAuth2.0是什么&lt;/h3&gt;&lt;p&gt;OAuth2.0是什么——豆瓣和QQ的故事&lt;/p&gt;
&lt;p&gt;OAuth
    
    </summary>
    
      <category term="干货" scheme="http://yoursite.com/categories/%E5%B9%B2%E8%B4%A7/"/>
    
    
      <category term="干货" scheme="http://yoursite.com/tags/%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|链接器</title>
    <link href="http://yoursite.com/2018/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5%E5%99%A8/"/>
    <id>http://yoursite.com/2018/06/05/深入理解计算机系统-链接器/</id>
    <published>2018-06-04T19:41:08.000Z</published>
    <updated>2018-06-05T10:49:21.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>链接（Linking）是把各种代码和数据部分收集起来并组合成为一个单一文件的过程。</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>个简单的C语言的例子：</p>
<p>main.c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">int</span> buf[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	swap();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>swap.c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> buf[];</div><div class="line"></div><div class="line"><span class="keyword">int</span> *bufp0 = &amp;buf[<span class="number">0</span>];</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> *bufp1;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    bufp1 = &amp;buf[<span class="number">1</span>];</div><div class="line">    temp = *bufp0;</div><div class="line">    *bufp0 = *bufp1;</div><div class="line">    *bufp1 = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unix&gt; gcc -O2 -g -o p main.c swap.c</div><div class="line">unix&gt; ./p</div></pre></td></tr></table></figure></p>
<p>这个方法就是使用了静态链接。</p>
<p><img src="/images/链接-01.png" alt=""></p>
<p>首先，把源代码分别使用Translators(cpp)进行预处理。</p>
<p><code>cpp [other args] main.c /tmp/main.i</code><br>接下来，驱动程序运行C编译器(cc1)，把main.i翻译为ASCII汇编语言文件main.s</p>
<p><code>cc1 –O2 [other args] /tmp/main.i main.c -o /tmp/main.s</code><br>然后，运行汇编器(as)，把main.s翻译成一个可重定位目标文件(relocatable object file) main.o</p>
<p><code>as [other args] /tmp/main.s -o /tmp/main.o</code><br>最后，运行连接器程序(ld)，把main.o和swap.o以及一些必要的系统文件结合起来，创建一个可执行目标文件(executable object file)m。</p>
<p><code>ld [system obj files and args] /tmp/main.o /tmp/swap.o -o p</code></p>
<p>要需要运行可执行文件m，只需要在shell中输入它的名字就可以运行了。</p>
<p><code>$ ./p</code></p>
<p>shell会调用一个叫做加载器的函数，它拷贝可执行文件m中的代码和数据到存储器，然后转移控制到这个程序的开头。</p>
<h3 id="为什么要用链接"><a href="#为什么要用链接" class="headerlink" title="为什么要用链接"></a>为什么要用链接</h3><p><code>模块化</code></p>
<ul>
<li>程序不用写成一个巨大的源文件，而是可以分成多个更小、更好管理的源文件（模块）</li>
<li>可以创建一些公用的函数库，例如数学库、标准C库等</li>
</ul>
<p><code>效率(Efficiency)</code></p>
<ul>
<li>时间上: 分别编译<ul>
<li> 修改一个源文件，重新编译，然后重新链接</li>
<li> 不必重编译其他源文件</li>
</ul>
</li>
<li>空间上: 使用库 ，无需包含共享库所有代码<ul>
<li> 常用的函数可以聚合到单个文件</li>
<li> 而可执行文件和运行时的内存中只包含它们实际调用的函数的代码，不需要包含整个共享库</li>
</ul>
</li>
</ul>
<p>当程序很小的时候，效率就不会成为一个重要的问题。但是当一个程序大到包含千千万万个模块，那么每次编译都需要把所有的代码都编译一遍吗？这未免太夸张了。对于一个操作系统级别的程序，整体编译一遍会特别耗时间。使用了链接之后，就不必重新编译所有的文件。</p>
<h3 id="链接做什么"><a href="#链接做什么" class="headerlink" title="链接做什么"></a>链接做什么</h3><p><code>符号解析(Symbol resolution)</code></p>
<ul>
<li><p>程序中有定义和引用的符号 (包括变量和函数等)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;…&#125; <span class="comment">/* 定义符号swap */</span></div><div class="line">swap(); <span class="comment">/* 引用符号swap */</span></div><div class="line"><span class="keyword">int</span> *xp = &amp;x; <span class="comment">/* 定义符号 xp, 引用符号 x */</span></div></pre></td></tr></table></figure>
</li>
<li><p>编译器将符号的定义储存在一个符号表（symbol table）中</p>
<ul>
<li>符号表是一个结构数组</li>
<li>每个条目包含符号的名称、长度和位置信息</li>
</ul>
</li>
<li>链接器将每个符号的引用都与一个符号定义关联起来</li>
</ul>
<p><code>重定位</code></p>
<ul>
<li><p>将多个代码段与数据段分别合并为一个统一的代码段和数据段（从地址0开始）</p>
</li>
<li><p>将.o文件中的每个符号从相对位置重新定位到可执行文件中的最终绝对内存位置</p>
</li>
<li><p>将这些符号在符号表中的位置信息更新为重定位后的位置信息</p>
</li>
</ul>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><ul>
<li>静态链接器(UNIX ld 程序)<br> 输入：一组可重定位的目标文件<br> 输出：一个完全链接的可以加载运行的可执</li>
</ul>
<h4 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h4><p>下图展示了一个典型的ELF可重定位目标文件的格式：</p>
<p><img src="/images/链接-02.png" alt="ELF"></p>
<ul>
<li><p>.text：已编译程序的机器代码。</p>
</li>
<li><p>.rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。</p>
</li>
<li><p>.data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。</p>
</li>
<li><p>.bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。</p>
</li>
<li><p>.symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。</p>
</li>
<li><p>.rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。</p>
</li>
<li><p>.rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。</p>
</li>
<li><p>.debug：一个调试符号表，其有些表目是程序中定义的局部变量和类型定义，有些表目是程序中定义和引用的全局变量，有些是原始的C源文件。只有以-g选项调用编译驱动程序时，才会得到这张表。</p>
</li>
<li><p>.line：原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译驱动程序时，才会得到这张表。</p>
</li>
<li><p>.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。</p>
</li>
</ul>
<h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>每个可重定位目标模块m都有一个符号表，它包含了在m中定义和引用的所有符号。有三种链接器符号：</p>
<ul>
<li>Global symbols（模块内部定义的全局符号）<ul>
<li>由模块m定义并能被其他模块引用的符号。例如，非static C函数和非static的C全局变量（指不static的全局变量）</li>
<li>如，main.c 中的全局变量名buf</li>
</ul>
</li>
<li>External symbols（外部定义的全局符号）<ul>
<li>由其他模块定义并被模块m引用的全局符号</li>
<li>如，main.c 中的函数名swap</li>
</ul>
</li>
<li>Local symbols（本模块的本地符号）<ul>
<li>仅由模块m定义和引用的本地符号。例如，在模块m中定义的带static的C函数和全局变量</li>
<li>如，swap.c 中的static变量名bufp1</li>
</ul>
</li>
</ul>
<p>需要注意的是：链接器本地符号不是指程序中的局部变量（分配在栈中的临时性变量）,链接器不关心这种局部变量。</p>
<p><img src="/images/链接-03.png" alt="符号例子"></p>
<h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>符号表（.symtab节）中每个条目的结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    int name; /*指向符号对应字符串在strtab表中的偏移*/</div><div class="line">    int value; /*在对应section中的偏移量，可执行文件中是虚拟地址*/</div><div class="line">    int size; /*符号对应目标所占字节数*/</div><div class="line">    char type: 4, /*符号对应目标的类型：数据、函数、节、源文件名*/</div><div class="line">         binding: 4; /*符号对应目标是本地符号还是全局符号*/</div><div class="line">    char reserved;</div><div class="line">    char section; /*符号对应目标所在的section的节头表索引，或伪节*/</div><div class="line">&#125; Elf_Symbol;</div></pre></td></tr></table></figure></p>
<p>三个伪节：ABS表示不该被重定位；UNDEF表示未定义；COMMON表示未初始化数据（.bss），此时，value表示对齐要求，size给出最小大小。</p>
<p>下面是main.o的符号表：</p>
<p><img src="/images/链接-04.png" alt="main符号表"></p>
<p>buf是main.o中第3节（.data）偏移为0的符号，是全局变量，占8B； main是第1节（.text）偏移为0的符号，是全局函数，占18B； swap是main.o中未定义的符号，不知道类型和大小，全局的（在其他模块定义）。</p>
<p>下面是swap.o的符号表：</p>
<p><img src="/images/链接-05.png" alt="swap符号表"></p>
<h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><p>目的：将每个模块中引用的符号与某个目标模块中的定义符号建立关联。</p>
<ul>
<li><p>每个定义符号在代码段或数据段中都被分配了存储空间，将引用符号与对应定义符号建立关联后，就可在重定位时将引用符号的地址重定位为相关联的定义符号的地址。</p>
</li>
<li><p>本地符号在本模块内定义并引用，因此，其解析较简单，只要与本模块内唯一的定义符号关联即可。</p>
</li>
<li><p>全局符号（外部定义的、内部定义的）的解析涉及多个模块，故较复杂</p>
</li>
</ul>
<p>“符号的定义”其实质是什么？是指符号被分配了虚拟地址空间。</p>
<ul>
<li>符号为函数名即指其代码所在区；</li>
<li>符号为变量即指其占的静态数据区</li>
</ul>
<h5 id="全局符号处理的问题"><a href="#全局符号处理的问题" class="headerlink" title="全局符号处理的问题"></a>全局符号处理的问题</h5><ul>
<li>编译器遇到一个不在当前模块定义的符号<ul>
<li>生成一个链接器符号表，交给链接器处理</li>
<li>链接器如果在所有输入模块中找不到这个被引用的符号,链接器输出错误信息并终止</li>
</ul>
</li>
<li>多个目标文件可能定义相同的符号<ul>
<li>链接器标志一个错误，输出错误信息并终止</li>
<li>或按某种方法选择一个定义，抛弃其他定义</li>
</ul>
</li>
<li>编译器 、 汇编器和链接器之间协作进行处理</li>
<li>程序员不清楚这个流程会带来麻烦]</li>
</ul>
<p>程序的全局符号不是强符号就是弱符号:</p>
<ul>
<li>Strong:函数名和已初始化的全局变量名是强符号</li>
<li>Weak:未初始化的全局变量名是弱符号</li>
</ul>
<p><img src="/images/链接-06.png" alt=""></p>
<p>符号解析的例子：</p>
<p><img src="/images/链接-07.png" alt=""></p>
<p><code>链接器的符号解析规则</code></p>
<ul>
<li>Rule 1: 强符号不能多次定义<ul>
<li>强符号只能被定义一次，否则链接错误</li>
</ul>
</li>
<li>Rule 2: 强符号覆盖同名的弱符号（若一个符号被定义为一次强符号和多次弱符号，则按强符号定义为准）<ul>
<li>对弱符号的引用被解析为其同名的强符号</li>
</ul>
</li>
<li>Rule 3: 若有多个弱符号定义，则选择其中任意一个<ul>
<li>使用命令 gcc –fno-common链接时，会告诉链接器在遇到多个弱符号定义的全局符号时输出一条警告信息。</li>
</ul>
</li>
</ul>
<p>多重定义符号的解析示例:</p>
<p><img src="/images/链接-08.png" alt=""></p>
<p>避免多重定义全局符号的建议：</p>
<ul>
<li>尽量避免使用全局变量</li>
<li>一定需要用的话，就按以下规则使用<br> 尽量使用本地变量（static）<br> 全局变量要赋初值<br> 外部全局变量要使用extern</li>
</ul>
<p>多重定义全局变量会造成一些意想不到的错误，而且是默默发生的，编译系统不会警告，并会在程序执行很久后才能表现出来，且远离错误引发处。特别是在一个具有几百个模块的大型软件中，这类错误很难修正。</p>
<p>大部分程序员并不了解链接器如何工作，因而养成良好的编程习惯是非常重要的。</p>
<h4 id="与静态链接库链接"><a href="#与静态链接库链接" class="headerlink" title="与静态链接库链接"></a>与静态链接库链接</h4><p><code>静态库 (.a archive files)</code></p>
<ul>
<li>通过索引将所有相关的可重定位目标文件（目标模块）打包为一个单独的文件，称为静态库 ，也称为存档（archive）</li>
<li>增强链接器，使其试图通过查找一个或多个存档的符号来解析无法解析的外部引用</li>
<li>如果存档中某个成员文件解析了引用，就将该成员文件链接到可执行文件（链接器只拷贝静态库里被程序引用的目标模块）</li>
<li>在gcc命令行中无需显示指定C标准库libc.a(默认库)</li>
</ul>
<h5 id="静态库的创建"><a href="#静态库的创建" class="headerlink" title="静态库的创建"></a>静态库的创建</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unix&gt; gcc –c atoi.c printf.c … random.c</div><div class="line">unix&gt; ar rs libc.a atoi.o printf.o … random.o</div></pre></td></tr></table></figure>
<p><img src="/images/链接-09.png" alt=""></p>
<p>为了使我们对库的理解更加深刻，假设我们想在一个叫做libvector.a的链接库中提供addvec.c和multvec.c的向量处理程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* addvec.c */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y,<span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">	z[i] = x[i] + y[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* multvec.c */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">multvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y,<span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">	z[i] = x[i] * y[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了创建该库，我们使用AR工具，具体操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unix&gt; gcc -c addvec.c multvec.c</div><div class="line">unix&gt; ar rcs libvector.a addvec.o multvec.o</div></pre></td></tr></table></figure>
<p>为了使用这个库，我们编写一个应用，如下main2.c：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* main2.c */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    addvec(x, y, z, <span class="number">2</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"z = [%d %d]\n"</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*vector.h*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y,<span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">multvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y,<span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span> </span>;</div></pre></td></tr></table></figure>
<p>我们编译这个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">unix&gt; gcc –O2 –c main2.c</div><div class="line">unix&gt; gcc –static –o p2 main2.o ./libvector.a</div><div class="line">unix&gt; ./p2</div><div class="line">z = [4 6]</div></pre></td></tr></table></figure>
<p><code>-static</code>参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标程序，它可以加载到存储器并执行，在加载时无需更进一步的链接。下图描述了这个过程：</p>
<p><img src="/images/链接-10.png" alt=""></p>
<h5 id="链接器使用静态库解析外部引用的过程"><a href="#链接器使用静态库解析外部引用的过程" class="headerlink" title="链接器使用静态库解析外部引用的过程"></a>链接器使用静态库解析外部引用的过程</h5><ul>
<li>从左到右扫描命令行中的可重定位目标文件（.o文件）和存档文件（.a 文件）</li>
<li>所有.c文件会被链接器自动翻译成.o文件</li>
<li>链接器在扫描过程中维护三个集合<ul>
<li>可重定位目标文件<code>集合E</code> ：集合中所有文件最终会被合并以组成可执行文件</li>
<li>未解析的符号的<code>集合U</code>：引用了但尚未定义的符号</li>
<li>已定义的符号<code>集合D</code>：前面输入文件中已定义的所有符号</li>
</ul>
</li>
<li>E、U、D初始为空</li>
</ul>
<h5 id="链接器解析外部引用的算法"><a href="#链接器解析外部引用的算法" class="headerlink" title="链接器解析外部引用的算法"></a>链接器解析外部引用的算法</h5><p>对每个命令行输入文件f，判断是目标文件还是存档</p>
<ul>
<li>f 是目标文件<ul>
<li>链接器把f添加到E，修改U和D来反映f中的符号定义和引用</li>
<li>继续下一个输入文件</li>
</ul>
</li>
<li>f 是存档文件<ul>
<li>链接器尝试匹配U中未解析符号和存档文件中成员定义符号</li>
<li>如果在存档成员m，定义了一个符号解析U中的引用，将m加入到E，修改U和D来反映m中的符号定义和引用</li>
<li>对存档文件所有成员目标文件反复进行上述过程，直到U和D不再发<br>生变化</li>
<li>不包含在E中的成员目标文件被直接丢弃</li>
<li>链接器继续处理下一个输入文件</li>
</ul>
</li>
<li>完成命令行上输入文件的扫描<ul>
<li>如果U是非空，链接器输出错误并终止；</li>
<li>如果U为空，合并E中所有目标文件，构建输出可执行文件；</li>
</ul>
</li>
</ul>
<h5 id="链接顺序问题"><a href="#链接顺序问题" class="headerlink" title="链接顺序问题"></a>链接顺序问题</h5><p><img src="/images/链接-11.png" alt=""></p>
<h3 id="重定位与动态链接"><a href="#重定位与动态链接" class="headerlink" title="重定位与动态链接"></a>重定位与动态链接</h3><p>符号解析完成后，可进行重定位工作，由两步组成：</p>
<ul>
<li>对节和符号定义进行重定位<ul>
<li>将集合E的所有目标模块中相同的节合并成新的聚合节，并将运行时的虚拟地址赋给每个新节中所有定义的符号。</li>
<li>例如，所有.text节合并作为可执行文件中的.text节，并为每个.text节确定在新.text节中的绝对地址，从而为其中定义的函数确定首地址（含有多个函数时），进而确定每条指令的地址。</li>
<li>完成这一步后，每条指令和每个全局变量都有唯一的运行时地址。</li>
</ul>
</li>
<li>对节中的符号引用进行重定位<ul>
<li>修改.text节和.data节中对每个符号的引用（指向正确的运行时地址）。</li>
<li>需要用到在.rel_data和.rel_text节中保存的重定位信息。</li>
</ul>
</li>
</ul>
<p>下图是链接的目的：</p>
<p><img src="/images/链接-12.png" alt=""></p>
<h4 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h4><p>当汇编器生成一个目标模块时，它并不知道数据和代码最终将存放在存储器的什么位置，也不知道当前模块引用的任何外部定义的函数或全局变量的位置。汇编器遇到对位置未知的目标引用时，生成一个<code>重定位条目</code>，已初始化数据引用的重定位条目在<code>.rel_data</code>节中,指令中引用的重定位条目在<code>.rel_text</code>节中。</p>
<p>ELF中重定位条目的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </div><div class="line">    <span class="keyword">int</span> offset;     <span class="comment">/* offset of the reference to relocate */</span> </div><div class="line">    <span class="keyword">int</span> symbol:<span class="number">24</span>,  <span class="comment">/* symbol the reference should point to */</span> </div><div class="line">	type:<span class="number">8</span>;     <span class="comment">/* relocation type */</span> </div><div class="line">&#125; Elf32_Rel</div></pre></td></tr></table></figure>
<p>有两种最基本的重定位类型（11种重定位类型）</p>
<ul>
<li><code>R_386_PC32</code>: 使用32位PC相对地址的引用，PC为下条指令地址</li>
<li><code>R_386_32</code>: 使用32位绝对地址</li>
</ul>
<p>在main.o的<code>.rel_text</code>节中有重定位条目:</p>
<p><img src="/images/链接-13.png" alt=""></p>
<p>说明在<code>.text</code>节中偏移为0x7的地方需重定位,引用的符号为swap,按PC相对地址方式修改。</p>
<h5 id="重定位算法伪代码"><a href="#重定位算法伪代码" class="headerlink" title="重定位算法伪代码"></a>重定位算法伪代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">foreach section s &#123;</div><div class="line">   foreach relocation entry r &#123;</div><div class="line">   refptr = s + r.offset; <span class="comment">/* ptr to reference to be relocated*/</span></div><div class="line">   <span class="comment">/* relocate a pc-relative reference*/</span></div><div class="line">   <span class="keyword">if</span> ( r.type == R_386_PC32) &#123;</div><div class="line">       refaddr = ADDR(s) + r.offset; <span class="comment">/*ref’s run-time address*/</span></div><div class="line">       *refptr = (<span class="keyword">unsigned</span>)(ADDR(r.symbol) + *refptr – refaddr);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">/*relocate an absolute reference */</span></div><div class="line">  <span class="keyword">if</span> ( r.type == R_386_32)</div><div class="line">      *refptr = (<span class="keyword">unsigned</span>) (ADDR(r.symbol)+ *refptr);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>算法描述 ：</p>
<ul>
<li>1-2 行 ： 在每个节s 及其关联的重定位条目r 上迭代执行</li>
<li>节s 是字节数组 ， 运行时地址为ADDR(s), 重定位条目r 是Elf32_Rel结构 ， 运行时地址为ADDR(r.symbol)</li>
<li>3 行 ： 计算需要被重定位的引用的数组s 中的地址</li>
<li>5-9 行 ： 使用PC 相对定位寻址计算重定位地址</li>
<li>11-31 行 ：使用绝对寻址计算重定位地址</li>
</ul>
<p>下面让我们来看看main.o重定位前的样子：</p>
<p><img src="/images/链接-14.png" alt=""></p>
<p>从上图中，我们知道：</p>
<ul>
<li>main的定义在.text节中偏移为0处开始，占0x12B</li>
<li>buf的定义在.data节中偏移为0处开始，占8B</li>
<li>在rel_text节中的重定位条目为：<code>r_offset=0x7</code>,<code>r_sym=swap</code>,<code>r_type=R_386_PC32</code>，objdump出来后为<code>“7: R_386_PC32 swap”</code></li>
</ul>
<p>main.o的符号表：</p>
<p><img src="/images/链接-15.png" alt=""></p>
<p>swap是main.o的符号表中第10项，是未定义符号，类型和大小未知，并是全局符号，故在其他模块中定义。</p>
<p>用命令<code>readelf -r main.o</code>或者<code>objdump -r -j .text main.o</code>可以查看目标文件中的重定位信息：偏移值/重定位类型/引用符号。</p>
<p><img src="/images/链接-16.png" alt=""></p>
<h5 id="R-386-PC32-的重定位方式-相对引用"><a href="#R-386-PC32-的重定位方式-相对引用" class="headerlink" title="R_386_PC32 的重定位方式( 相对引用)"></a><code>R_386_PC32</code> 的重定位方式( 相对引用)</h5><p>假定：</p>
<p>ADDR(s) = ADDR(.text) = <code>0x80483b4</code></p>
<p>由于mian函数在<code>.text</code>的起始位置，所以 ADDR(main) = <code>0x80483b4</code>;同时swap紧跟main后，所以swap起始地址: ADDR(swap) = <code>0x80483b4</code>+<code>0x12</code>=<code>0x80483c6</code>,(main占0x12字节)，但是在4字节边界对齐的情况下，ADDR(swap) = <code>0x80483c8</code>。</p>
<p>则重定位后call指令的机器代码是什么？</p>
<ul>
<li>call转移目标地址 = PC+偏移地址，PC=<code>0x80483b4</code>+<code>0x07</code> - init</li>
<li>PC = <code>0x80483b4</code>+<code>0x07</code>-<code>(-4)</code>= <code>0x80483bf</code></li>
<li>重定位值 = 偏移地址 = 转移目标地址-PC=0x80483c8-0x80483bf=0x9</li>
<li>重定位后call指令的机器代码为“e8 09 00 00 00 ” (小端表示)</li>
</ul>
<p>可以总结，PC相对地址方式下，重定位值计算公式为：</p>
<p><img src="/images/链接-17.png" alt=""></p>
<p>main.o中.data和.rel.data节内容：</p>
<p><img src="/images/链接-18.png" alt=""></p>
<p>buf定义在.data节中偏移为0处，占8B，没有需重定位的符号。</p>
<p>swap.o中.data和.rel.data节内容：</p>
<p><img src="/images/链接-19.png" alt=""></p>
<p><img src="/images/链接-20.png" alt=""></p>
<p>bufp0定义在.data节中偏移为0处，占4B，初值为0x0。重定位节<code>.rel.data</code>中有一个重定位表项：<code>r_offset=0x0</code>,<code>r_sym=buf</code>,<code>r_type=R_386_32</code>，OBJDUMP工具解释后显示为<code>“0：R_386_32 buf”</code></p>
<p> swap.o中的符号表中:</p>
<p><img src="/images/链接-21.png" alt=""></p>
<p>buf是swap.o的符号表中第10项，是未定义符号，类型和大小未知，并是全局符号，故在其他模块中定义。</p>
<p>用命令<code>readelf -r swap.o</code>或者<code>objdump -r -j .data swap.o</code>可以查看目标文件中的重定位信息：偏移值/重定位类型/引用符号。</p>
<p><img src="/images/链接-22.png" alt=""></p>
<h5 id="R-386-32-的重定位方式"><a href="#R-386-32-的重定位方式" class="headerlink" title="R_386_32 的重定位方式"></a><code>R_386_32</code> 的重定位方式</h5><p>假定：buf在运行时的存储地址 <code>ADDR(buf)=0x8049454</code></p>
<p>则重定位后，bufp0的地址及内容变为什么？</p>
<ul>
<li>buf和bufp0同属于.data节，故在可执行文件中它们被合并</li>
<li>bufp0紧接在buf后，故地址为0x8049454+8= 0x804945c</li>
<li>因是R_386_32方式，故bufp0内容为buf的绝对地址<code>0x8049454</code>，即“54 94 04 08”</li>
</ul>
<p>可执行目标文件p中.data节的内容:</p>
<p><img src="/images/链接-23.png" alt=""></p>
<p>swap.o重定位信息：</p>
<p><img src="/images/链接-24.png" alt=""></p>
<p><img src="/images/链接-25.png" alt=""></p>
<p>重定位后的可执行程序 (.text)：</p>
<p><img src="/images/链接-26.png" alt=""></p>
<h3 id="可执行目标格式"><a href="#可执行目标格式" class="headerlink" title="可执行目标格式"></a>可执行目标格式</h3><p><img src="/images/链接-27.png" alt=""></p>
<h3 id="可执行目标文件的存储器映像"><a href="#可执行目标文件的存储器映像" class="headerlink" title="可执行目标文件的存储器映像"></a>可执行目标文件的存储器映像</h3><p><img src="/images/链接-28.png" alt=""></p>
<h3 id="加载时的动态链接"><a href="#加载时的动态链接" class="headerlink" title="加载时的动态链接"></a>加载时的动态链接</h3><ul>
<li>静态链接库的缺点:<ul>
<li>存储可执行程序中可能存在同一段公共代码的多个拷贝。（例如： 每个c程序都有c标准库）</li>
<li>多个进程的虚拟存储空间可能有同一段代码的多个拷贝.</li>
<li>对系统库的小的修改都需要每个应用程序显式重新链接</li>
</ul>
</li>
</ul>
<p>现代解决方法: 共享库</p>
<pre><code>- 包含数据和代码的目标文件在加载或执行时动态链接到应用程序中
- 也叫动态链接库, 包括DLLs, .so files
</code></pre><p><img src="/images/链接-29.png" alt=""></p>
<p>为了构造上图中向量运算的的示例程序的共享库libvector.so ,我们调用编译器，给链接器如下特殊指令：</p>
<p><code>unix&gt; gcc -shared -fPIC -o libvector.so addvec.c multvec.c</code></p>
<p><code>-fPIC</code>告诉编译器生成与位置无关的代码，<code>-shared</code>告诉链接器创建一个共享的目标文件。</p>
<p><img src="/images/链接-30.png" alt=""></p>
<p>动态库创建好了，然后我们进行链接到我们的程序中：</p>
<p><code>unix&gt; gcc -o p2 main2.c ./libvector.so</code></p>
<p>这样就创建了一个可执行目标文件p2,而此文件的形式使得它在运行时可以和 libvector.so 链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后程序加载时，动态完成链接过程。</p>
<p>还有一点是需要知道的：<strong>没有任何libvector.so的代码和数据节真的被拷贝到可执行文件p2中。反之，链接器只拷贝了一些重定位和符号表信息，它们使得在运行是可以解析对libvector.so中代码和数据的引用。</strong></p>
<h4 id="运行时的动态链接"><a href="#运行时的动态链接" class="headerlink" title="运行时的动态链接"></a>运行时的动态链接</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *handle;</div><div class="line">    <span class="keyword">void</span> (*addvec)(<span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span>);</div><div class="line">    <span class="keyword">char</span> *error; </div><div class="line"></div><div class="line">    <span class="comment">/* dynamically load the shared library that contains addvec() */</span></div><div class="line">    handle = dlopen(<span class="string">"./libvector.so"</span>, RTLD_LAZY);</div><div class="line">    <span class="keyword">if</span> (!handle) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* get a pointer to the addvec() function we just loaded */</span></div><div class="line">    addvec = dlsym(handle, <span class="string">"addvec"</span>);</div><div class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, error);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Now we can call addvec() it just like any other function */</span></div><div class="line">    addvec(x, y, z, <span class="number">2</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"z = [%d %d]\n"</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    <span class="comment">/* unload the shared library */</span></div><div class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dlopen</code>以指定模式打开指定的动态连接库文件，并返回一个句柄给调用进程，dlerror返回出现的错误，<code>dlsym</code>通过句柄和连接符名称获取函数名或者变量名，    dlclose    来卸载打开的库。 dlopen打开模式如下：</p>
<ul>
<li>RTLD_LAZY 暂缓决定，等有需要时再解出符号 </li>
<li>RTLD_NOW 立即决定，返回前解除所有未决定的符号。</li>
</ul>
<p>我们通过以下命令编译我们的这个程序：</p>
<p><code>unix&gt; gcc -rdynamic -o2 -o p3 dll.c -ldl</code></p>
<p><img src="/images/链接-31.png" alt=""></p>
<p>下面我们通过ldd命令来看看p2，p3所需要的共享库：</p>
<p><img src="/images/链接-32.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h3&gt;&lt;p&gt;链接（Linking）是把各种代码和数据部分收集起来并组合成为一个单一文件的过程。&lt;/p&gt;
&lt;h4 id=&quot;一个例子&quot;&gt;&lt;a
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP的类自动加载机制</title>
    <link href="http://yoursite.com/2018/06/04/PHP-PHP%E7%9A%84%E7%B1%BB%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/06/04/PHP-PHP的类自动加载机制/</id>
    <published>2018-06-03T19:06:12.000Z</published>
    <updated>2018-06-03T14:24:24.453Z</updated>
    
    <content type="html"><![CDATA[<p>在PHP开发过程中，如果希望从外部引入一个class，通常会使用include和require方法，去把定义这个class的文件包含进来。这个在小规模开发的时候，没什么大问题。但在大型的开发项目中，这么做会产生大量的require或者include方法调用，这样不因降低效率，而且使得代码难以维护，况且require_once的代价很大。</p>
<p>在PHP5之前，各个PHP框架如果要实现类的自动加载，一般都是按照某种约定自己实现一个遍历目录，自动加载所有符合约定规则的文件的类或函数。 当然，PHP5之前对面向对象的支持并不是太好，类的使用也没有现在频繁。 在PHP5后，当加载PHP类时，如果类所在文件没有被包含进来，或者类名出错，Zend引擎会自动调用<code>__autoload</code> 函数。此函数需要用户自己实现<code>__autoload</code>函数。 在PHP5.1.2版本后，可以使用<code>spl_autoload_register</code>函数自定义自动加载处理函数。当没有调用此函数，默认情况下会使用SPL自定义的<code>spl_autoload</code>函数。</p>
<h4 id="autoload示例"><a href="#autoload示例" class="headerlink" title="__autoload示例"></a><code>__autoload</code>示例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($class_name)</span> </span>&#123;  </div><div class="line">   <span class="keyword">echo</span> <span class="string">'__autload class:'</span>, $class_name, <span class="string">'&lt;br /&gt;'</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">new</span> Demo();</div></pre></td></tr></table></figure>
<p>以上的代码在最后会输出：__autload class:Demo。<br>并在此之后报错显示： Fatal error: Class ‘Demo’ not found</p>
<p>我们一般使用_autoload自动加载类如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($class_name)</span> </span>&#123;  </div><div class="line">   <span class="keyword">echo</span> <span class="string">'__autload class:'</span>, $class_name, <span class="string">'&lt;br /&gt;'</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">new</span> Demo();</div></pre></td></tr></table></figure>
<p>我们可以看出_autoload至少要做三件事情:</p>
<ul>
<li>第一件事是根据类名确定类文件名</li>
<li>第二件事是确定类文件所在的磁盘路径[在我们的例子是最简单的情况，类与调用它们的PHP程序文件在同一个文件夹下]</li>
<li>第三件事是将类从磁盘文件中加载到系统中。</li>
</ul>
<p>第三步最简单，只需要使用include/require即可。要实现第一步，第二步的功能，必须在开发时约定类名与磁盘文件的映射方法，只有这样我们才能根据类名找到它对应的磁盘文件。 </p>
<p>因此，当有大量的类文件要包含的时候，我们只要确定相应的规则，然后在<code>__autoload()</code>函数中，将类名与实际的磁盘文件对应起来，就可以实现lazy loading的效果。从这里我们也可以看出<code>__autoload()</code>函数的实现中最重要的是类名与实际的磁盘文件映射规则的实现。 </p>
<p>但现在问题来了，假如在一个系统的实现中，假如需要使用很多其它的类库，这些类库可能是由不同的开发工程师开发，其类名与实际的磁盘文件的映射规则不尽相同。这时假如要实现类库文件的自动加载，就必须在<code>__autoload()</code>函数中将所有的映射规则全部实现，因此<code>__autoload()</code>函数有可能会非常复杂，甚至无法实现。最后可能会导致<code>__autoload()</code>函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。在这种情况下，在PHP5引入SPL标准库,一种新的解决方案，即<code>spl_autoload_register()</code>函数。</p>
<h4 id="spl-autoload-register-函数"><a href="#spl-autoload-register-函数" class="headerlink" title="spl_autoload_register()函数"></a>spl_autoload_register()函数</h4><p><strong>此函数的功能就是把函数注册至SPL的<code>__autoload</code>函数栈中，并移除系统默认的<code>__autoload()</code>函数</strong>。下面的例子可以看出：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($class_name)</span> </span>&#123;  </div><div class="line">    <span class="keyword">echo</span> <span class="string">'__autload class:'</span>, $class_name, <span class="string">'&lt;br /&gt;'</span>;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">classLoader</span><span class="params">($class_name)</span> </span>&#123;  </div><div class="line">    <span class="keyword">echo</span> <span class="string">'SPL load class:'</span>, $class_name, <span class="string">'&lt;br /&gt;'</span>;  </div><div class="line">&#125;  </div><div class="line">spl_autoload_register(<span class="string">'classLoader'</span>);  </div><div class="line"><span class="keyword">new</span> Test();<span class="comment">//结果：SPL load class:Test</span></div></pre></td></tr></table></figure>
<p>语法：<code>bool  spl_autoload_register ( [callback $autoload_function] )</code>   接受两个参数：一个是添加到自动加载栈的函数，另外一个是加载器不能找到这个类时是否抛出异常的标志。第一个参数是可选的，并且默认指向<code>spl_autoload()</code>函数，这个函数会自动在路径中查找具有小写类名和.php扩展或者.ini扩展名，或者任何注册到<code>spl_autoload_extensions()</code>函数中的其它扩展名的文件。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalssLoader</span>     </span></div><div class="line">&#123;     </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">loader</span><span class="params">($classname)</span>     </span></div><div class="line">    &#123;     </div><div class="line">        $class_file = strtolower($classname).<span class="string">".php"</span>;     </div><div class="line">        <span class="keyword">if</span> (file_exists($class_file))&#123;     </div><div class="line">            <span class="keyword">require_once</span>($class_file);     </div><div class="line">        &#125;     </div><div class="line">    &#125;     </div><div class="line">&#125;      </div><div class="line"><span class="comment">// 方法为静态方法     </span></div><div class="line">spl_autoload_register(<span class="string">'CalssLoader::loader'</span>);      </div><div class="line">$test = <span class="keyword">new</span> Test();</div></pre></td></tr></table></figure></p>
<p>一旦调用<code>spl_autoload_register()</code>函数，当调用未定义类时，系统会按顺序调用注册到<code>spl_autoload_register()</code>函数的所有函数，而不是自动调用<code>__autoload()</code>函数。如果要避免这种情况，需采用一种更加安全的<code>spl_autoload_register()</code>函数的初始化调用方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">false</span> === spl_autoload_functions())&#123;      </div><div class="line">    <span class="keyword">if</span>(function_exists(<span class="string">'__autoload'</span>))&#123;      </div><div class="line">        spl_autoload_registe(<span class="string">'__autoload'</span>,<span class="keyword">false</span>);      </div><div class="line">    &#125;      </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><code>spl_autoload_functions()</code>函数会返回已注册函数的一个数组,如果SPL自动加载栈还没有被初始化,它会返回布尔值false。然后，检查是否有一个名为<code>__autoload()</code>的函数存在,如果存在，可以将它注册为自动加载栈中的第一个函数，从而保留它的功能。之后，可以继续注册自动加载函数。</p>
<p>还可以调用<code>spl_autoload_register()</code>函数以注册一个回调函数,而不是为函数提供一个字符串名称。如提供一个如<code>array(&#39;class&#39;,&#39;method&#39;)</code>这样的数组,使得可以使用某个对象的方法。</p>
<p>下一步，通过调用<code>spl_autoload_call(&#39;className&#39;)</code>函数，可以手动调用加载器，而不用尝试去使用那个类。这个函数可以和函数<code>class_exists(&#39;className&#39;,false)</code>组合在一起使用以尝试去加载一个类，并且在所有的自动加载器都不能找到那个类的情况下失败。 </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(spl_autoload_call(<span class="string">'className'</span>) &amp;&amp; class_exists(<span class="string">'className'</span>,<span class="keyword">false</span>))&#123;      </div><div class="line">    </div><div class="line">  &#125; <span class="keyword">else</span> &#123;      </div><div class="line">    </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>SPL自动加载功能是由<code>spl_autoload()</code> ,<code>spl_autoload_register()</code>, <code>spl_autoload_functions()</code> ,<code>spl_autoload_extensions()</code>和<code>spl_autoload_call()</code>函数提供的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在PHP开发过程中，如果希望从外部引入一个class，通常会使用include和require方法，去把定义这个class的文件包含进来。这个在小规模开发的时候，没什么大问题。但在大型的开发项目中，这么做会产生大量的require或者include方法调用，这样不因降低效率
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>大学|BAT之路</title>
    <link href="http://yoursite.com/2018/06/03/%E5%A4%A7%E5%AD%A6-BAT%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/06/03/大学-BAT之路/</id>
    <published>2018-06-03T00:43:58.000Z</published>
    <updated>2018-06-02T17:15:16.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>今天胡哥叫了分来来自百度、阿里巴巴、腾讯[BAT] 的学长回来开一场主题为“BAT之路”的分享会，自己还是VIP专属座位呢，很荣幸了。</p>
<p><img src="/images/BAT之路.jpg" alt=""></p>
<h3 id="弦歌-蓝杰学长"><a href="#弦歌-蓝杰学长" class="headerlink" title="弦歌.蓝杰学长"></a>弦歌.蓝杰学长</h3><p>胡鹏威学长即是弦歌的，也是蓝杰的，自己跟学长的经历有点类似了，但相比之下，还是学长经历丰富一点：</p>
<ul>
<li>大二开始实习</li>
<li>创业</li>
<li>金山云</li>
<li>百度</li>
<li>腾讯</li>
</ul>
<p><img src="/images/BAT之路--胡鹏威.jpg" alt=""></p>
<p>这里还是要谢谢学长一下：之前学长有帮忙内推过百度，同时，还指导修改简历，很感动了，虽然最后结局并没有那么美好。自己也有做的不对的地方，事后也应该问一下学长自己为什么没有过，原因在哪里。同时，也可以继续请学长帮忙内推其他部门。记下了。</p>
<p>说到自己，自己暑假也有一个去深信服实习机会，但暑假有小学期，然后自己就犹豫要不要去？今天听了学长的分享，自己下决心了：去！！第一份实习挺难找的，同时，深信服也是一家不错的公司了，听说伙食还很好，没什么理由不去。</p>
<p><strong>如果不能一步到达目的地，那就远的那条路，只要到达了就好了。</strong>学长毕业时，没被腾讯选中，进入自己理想的公司，但是学长先后去了很多公司，58，搜狐，百度，然后才去腾讯，最终还是去了自己想去的公司。是的，我们可能不是那些幸运儿，能一步到达我们想要去的公司，但是我们可以先去其他的公司，把其当做跳板，像跳一跳那样，一步一步去到我们想要去的地方。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;今天胡哥叫了分来来自百度、阿里巴巴、腾讯[BAT] 的学长回来开一场主题为“BAT之路”的分享会，自己还是VIP专属座位呢，很荣幸了。&lt;/p
    
    </summary>
    
      <category term="college" scheme="http://yoursite.com/categories/college/"/>
    
    
      <category term="college" scheme="http://yoursite.com/tags/college/"/>
    
  </entry>
  
</feed>
