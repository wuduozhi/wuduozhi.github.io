<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-20T16:40:46.325Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python|urllib2的一个简单案例</title>
    <link href="http://yoursite.com/2018/03/21/python-urllib2%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B/"/>
    <id>http://yoursite.com/2018/03/21/python-urllib2的一个简单案例/</id>
    <published>2018-03-20T23:50:24.000Z</published>
    <updated>2018-03-20T16:40:46.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络爬虫的概念"><a href="#网络爬虫的概念" class="headerlink" title="网络爬虫的概念"></a>网络爬虫的概念</h3><p>网络爬虫（Web Spider）是一种自动获取网页内容的程序，是搜索引擎的重要组成部分。 初次深入了解爬虫的概念是在吴军博士的《数学之美》中，其中描述互联网本质上就是一张无形的大网，我们可以把每一个网页当做网中的节点，超链接作为连接节点的弧。这样网络爬虫就可以从任何一个网页出发，通过图的遍历算法，自动的访问每一个网页并将它们存起来。</p>
<p>实际上程序的目的都是代替人来完成大量的重复操作，爬虫亦是如此。假设现有一个需求是需要获取<a href="http://news.upc.edu.cn/sdyw" target="_blank" rel="external">中国石油大学新闻网</a>的所有新闻标题及发布日期来进行统计分析，那么用人来实现这个需求需要大概以下几个步骤。</p>
<ol>
<li>通过浏览器访问中国石油大学新闻网。</li>
<li>根据网页内容分析出哪些地方是我们需要获取的标题和日期。</li>
<li>将获取的数据存储到文件中。</li>
<li>跳转到下一页重复执行2和3步骤直到所有内容获取完毕。</li>
</ol>
<p>接下来我们就会按照以上思路用Python编写一个简单的爬虫。</p>
<h3 id="llib2抓取网页内容"><a href="#llib2抓取网页内容" class="headerlink" title="llib2抓取网页内容"></a>llib2抓取网页内容</h3><p>网页抓取就是把URL地址指定的网络资源读取出来，保存到本地。相当于我们平时在浏览器中通过网址浏览网页，只不过我们看到的是解析过的页面效果，而程序获取到的是源代码等资。 Python的标准库和组件非常强大，可以处理包括数学计算、网络传输、正则表达式等诸多操作。urllib2就是使用各种协议打开url的一个扩展包。最简单的方法就是调用urlopen的方法，比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import urllib2</div><div class="line"></div><div class="line">url=&quot;http://news.upc.edu.cn/sdyw/&quot;</div><div class="line">response=urllib2.urlopen(url)</div><div class="line">html=response.read()</div><div class="line">print html</div></pre></td></tr></table></figure></p>
<p>运行以上代码，可以得到以下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/loose.dtd&quot;&gt;</div><div class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</div><div class="line">&lt;title&gt;中国石油大学新闻网&lt;/title&gt;</div><div class="line">&lt;meta name=&quot;keywords&quot; content=&apos;石大门户网,石大资讯,石大新闻,中国石油大学新闻网,创造太阳网,石油之光&apos; /&gt;</div><div class="line">&lt;!--省略以下运行结果--&gt;</div></pre></td></tr></table></figure></p>
<p>我们在浏览器中打开该网址，右键选择查看源代码发现和输出的内容是一致的，这时我们第一步已经完成了。</p>
<h3 id="正则表达式返回匹配信息"><a href="#正则表达式返回匹配信息" class="headerlink" title="正则表达式返回匹配信息"></a>正则表达式返回匹配信息</h3><p>第二步中分析出哪些信息是我们需要的信息这个过程对于人来说非常简单，但是对于电脑就没那么容易了，这里需要引入正则表达式的概念。</p>
<blockquote>
<p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p>
</blockquote>
<p>简而言之，正则表达式就是为了处理相对复杂的文本查询或替换。 我们在新闻标题上单击右键，选择查看元素，这样Chrome浏览器下方就会出现开发者工具，并定位新闻标题所在HTML的位置。</p>
<p><img src="/images/python-urllib2实践-01.jpg" alt="查找结果" title="python-urllib2实践-01"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;/sdyw/2014/04/17/15361630123.shtml&quot; target=&quot;_blank&quot;&gt;1项目入选团中央学校共青团重点工作创新试点&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>我们分析HTML可以得知&lt;a href=”/sdyw/是标题的固定前缀，2014/04/17是新闻发布日期，15361630123.shtml是随机生成的静态页面名称。1项目入选团中央学校共青团重点工作创新试点是我们需要获取的新闻标题，最后以结尾，实现代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*- </div><div class="line">import urllib2</div><div class="line">import re</div><div class="line"># 1.获取访问页面的HMTL</div><div class="line">url=&quot;http://news.upc.edu.cn/sdyw/&quot;</div><div class="line">response=urllib2.urlopen(url)</div><div class="line">html=response.read()</div><div class="line"># 2.根据正则表达式抓取特定内容</div><div class="line">r=re.compile(r&apos;&lt;a href=&quot;/sdyw/(?P&lt;Date&gt;.&#123;10&#125;).*&quot; target=&quot;_blank&quot;&gt;(?P&lt;Title&gt;.+)&lt;/a&gt;&apos;)</div><div class="line">news=r.findall(html)</div><div class="line">print news</div></pre></td></tr></table></figure>
<p>在上方加入import re来导入python自带的正则表达式模块，通过re.compile(strPattern[, flag])方法将字符串形式的正则表达式编译为Pattern对象，第二个参数flag是匹配模式，我们此处省略填写。</p>
<p>正则表达式字符串开头有一个前缀r，r是raw(原始)的意思。因为在表示字符串中有一些转义符，如表示回车’\n’。如果要表示\需要写为’\‘。但如果我就是需要表示一个’\’+’n’，不用r方式要写为:’\n’。但使用r方式则为r’\n’这样清晰多了。</p>
<p>固定字符串<a href="/sdyw/后跟了一个用括号包起来的字符串(?P<Date>.{10})，(?P<name>...) 是定义一个命名组，(?P=name)则是对命名组的逆向引用。而后面的.匹配任意除换行符" \n"以外的字符。.{10}匹配10个任意字符，<a="" highlight="" plain"=""><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for i in range(len(news)):</div><div class="line">    date=news[i][0]</div><div class="line">    title=news[i][3]</div><div class="line">    print title+&quot; &quot;+date</div></pre></td></tr></table>
<h4 id="遍历所有新闻页面"><a href="#遍历所有新闻页面" class="headerlink" title="遍历所有新闻页面"></a>遍历所有新闻页面</h4><p>上一节我们获取到了第一页的新闻数据，但是我们的目的是需要获取所有的内容。 那我们跳转到其他分页看看有没有什么规律可循。通过分析发现，第一页的url为http://news.upc.edu.cn/sdyw/List_171.shtml，第二页的url为http://news.upc.edu.cn/sdyw/List_170.shtml,最后一页的url为http://news.upc.edu.cn/sdyw/List_1.shtml。那么遍历所有新闻页面获取内容这件事就变的非常简单了，直接通过for循环就可以实现，废话不说了，直接上代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*- </div><div class="line">import urllib2</div><div class="line">import re</div><div class="line">import MySQLdb as mdb</div><div class="line"></div><div class="line">if __name__==&quot;__main__&quot;:</div><div class="line">    url=&quot;http://news.upc.edu.cn/sdyw/List_&quot;</div><div class="line">    con=mdb.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;Python&apos;,charset=&apos;utf8&apos;)</div><div class="line">    with con:</div><div class="line">        for x in xrange(1,171):</div><div class="line">            response=urllib2.urlopen(url+str(x)+&apos;.shtml&apos;)</div><div class="line">            html=response.read()</div><div class="line">            r=re.compile(r&apos;&lt;a href=&quot;/sdyw/(?P&lt;Date&gt;.&#123;10&#125;).*&quot; target=&quot;_blank&quot;&gt;(?P&lt;Title&gt;.+)&lt;/a&gt;&apos;)</div><div class="line">            news=r.findall(html)</div><div class="line">            curs=con.cursor()</div><div class="line">            for i in range(len(news)):</div><div class="line">                date=news[i][0]</div><div class="line">                title=news[i][5]</div><div class="line">                curs.execute(&quot;INSERT INTO news2(PublishDate,Title) VALUES(%s,%s)&quot;,(date,title))</div><div class="line">                print title+&quot; &quot;+date</div></pre></td></tr></table></figure></p>
<p>到此，本文已经结束了，短短的20行代码就可以实现一个简单的爬虫，这就是Python的魅力。</p>
<p>  [3]: /images/python-urllib2实践-01.jpg “python-urllib2实践-01</p>
</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;网络爬虫的概念&quot;&gt;&lt;a href=&quot;#网络爬虫的概念&quot; class=&quot;headerlink&quot; title=&quot;网络爬虫的概念&quot;&gt;&lt;/a&gt;网络爬虫的概念&lt;/h3&gt;&lt;p&gt;网络爬虫（Web Spider）是一种自动获取网页内容的程序，是搜索引擎的重要组成部分。 初次深入了
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>安全|谈谈如何防范短信验证码被攻击</title>
    <link href="http://yoursite.com/2018/03/21/%E5%AE%89%E5%85%A8-%E8%B0%88%E8%B0%88%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A2%AB%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/03/21/安全-谈谈如何防范短信验证码被攻击/</id>
    <published>2018-03-20T23:30:15.000Z</published>
    <updated>2018-03-20T15:44:08.625Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在写个项目，需要发送验证验证手机号，之前的接口设计是只需要发送电话号码过来，后台验证电话号码的正确性，就发送验证码。</p>
<p>殊不知这样设计存在巨大的安全隐患。如果短信验证码接口和页面不做任何限制，黑客很容易利用一些恶意的短信轰炸软件对接口进行攻击，不停的对同一个号码或者N个号码重复发送验证码短信。</p>
<p>短信验证码被攻击，不仅会对用户造成骚扰，引起投诉，更会浪费你的短信余额，降低品牌形象。</p>
<h3 id="如何防范短信验证码被攻击？"><a href="#如何防范短信验证码被攻击？" class="headerlink" title="如何防范短信验证码被攻击？"></a>如何防范短信验证码被攻击？</h3><h4 id="图形验证码"><a href="#图形验证码" class="headerlink" title="图形验证码"></a>图形验证码</h4><p>大部分短信轰炸脚本基于网页爬虫，图形验证码可以简单粗暴的防御这类刷码行为。</p>
<p><img src="/images/web安全-短信验证-01.png" alt="图片验证" title="web安全-短信验证-01"></p>
<h4 id="记录、比对IP和手机号码，做频率限制，过滤空IP头"><a href="#记录、比对IP和手机号码，做频率限制，过滤空IP头" class="headerlink" title="记录、比对IP和手机号码，做频率限制，过滤空IP头"></a>记录、比对IP和手机号码，做频率限制，过滤空IP头</h4><p>用户请求验证码时，记录请求的IP和手机号码，并对发送频率做限制，例如每分钟/单个IP/单个手机号仅能请求一次。如果脚本无法获取用户的真实IP，请直接过滤这类请求。</p>
<h4 id="在-SUBMAIL-设置验证码模板的单日请求上线"><a href="#在-SUBMAIL-设置验证码模板的单日请求上线" class="headerlink" title="在 SUBMAIL 设置验证码模板的单日请求上线"></a>在 SUBMAIL 设置验证码模板的单日请求上线</h4><p>设置验证码模板的单日请求上限，设置一个合适的数值，这样每个手机号码单日超过这个上线的数量的验证码请求会被SUBMAIL直接过滤。</p>
<h4 id="设置-IP-白名单"><a href="#设置-IP-白名单" class="headerlink" title="设置 IP 白名单"></a>设置 IP 白名单</h4><p>设置IP白名单，保护您的APPID不被非法劫持后滥用,只允许名单内的ip请求能得到相应。</p>
<h4 id="SUBMAIL-主动防御机制"><a href="#SUBMAIL-主动防御机制" class="headerlink" title="SUBMAIL 主动防御机制"></a>SUBMAIL 主动防御机制</h4><p>如上述3种方法还不能完全防御，您也不用担心，因为SUBMAIL为短信验证码接口植入了主动防御的机制，提供了更强大的保护措施。SUBMAIL 主动防御机制会在以下3种情况中被触发：</p>
<ol>
<li>空号率触发安全机制：当用户请求发送的手机号码空号率达到一定的百分比之后，触发防御机制；</li>
<li>手机号码高频率请求触发安全机制：当单个手机号高频率的请求验证码时，到达一定比例，触发防御机制；</li>
<li>历史黑名单命中率触发安全机制：当命中历史黑名单到达一定比例时，触发防御机制；</li>
</ol>
<p>SUBMAIL 主动防御机制被触发后，将会自动设置合适的安全级别，防御恶意请求。例如非常请求仅能获取3次验证码，如超过3次，将会被列入临时保护黑名单。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在写个项目，需要发送验证验证手机号，之前的接口设计是只需要发送电话号码过来，后台验证电话号码的正确性，就发送验证码。&lt;/p&gt;
&lt;p&gt;殊不
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>pyhon|网络urllib2模块</title>
    <link href="http://yoursite.com/2018/03/20/pyhon-%E7%BD%91%E7%BB%9Curllib2%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/03/20/pyhon-网络urllib2模块/</id>
    <published>2018-03-19T23:10:34.000Z</published>
    <updated>2018-03-20T15:46:13.377Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分分钟扒一个网页下来"><a href="#分分钟扒一个网页下来" class="headerlink" title="分分钟扒一个网页下来"></a>分分钟扒一个网页下来</h3><p>怎样扒网页呢？其实就是根据URL来获取它的网页信息，虽然我们在浏览器中看到的是一幅幅优美的画面，但是其实是由浏览器解释才呈现出来的，实质它 是一段HTML代码，加 JS、CSS，如果把网页比作一个人，那么HTML便是他的骨架，JS便是他的肌肉，CSS便是它的衣服。所以最重要的部分是存在于HTML中的，下面我 们就写个例子来扒一个网页下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import  urllib2</div><div class="line">response  =  urllib2.urlopen(&quot;http://www.baidu.com&quot;)</div><div class="line">print  response.read()</div></pre></td></tr></table></figure></p>
<p>是的你没看错，真正的程序就两行，把它保存成 demo.py，进入该文件的目录，执行如下命令查看运行结果，感受一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python demo.py</div></pre></td></tr></table></figure></p>
<p><img src="/images/python-urllib2-01.png" alt="爬虫--html" title="python-urllib2-01"></p>
<h3 id="分析扒网页的方法"><a href="#分析扒网页的方法" class="headerlink" title="分析扒网页的方法"></a>分析扒网页的方法</h3><p>那么我们来分析这两行代码，第一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response  =  urllib2.urlopen(&quot;http://www.baidu.com&quot;)</div></pre></td></tr></table></figure></p>
<p>首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，当然你也可以把HTTP换做FTP,FILE,HTTPS 等等，只是代表了一种[访问控制]协议，urlopen一般接受三个参数，它的参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">urlopen(url, data, timeout)</div></pre></td></tr></table></figure></p>
<p>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。</p>
<p>第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT</p>
<p>第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print response.read()</div></pre></td></tr></table></figure></p>
<p>response对象有一个read方法，可以返回获取到的网页内容。</p>
<p>如果不加read直接打印会是什么？答案如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addinfourl at 139728495260376 whose fp = socket._fileobject object at 0x7f1513fb3ad0&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>直接打印出了该对象的描述，所以记得一定要加read方法，否则它不出来内容可就不怪我咯！</p>
<h3 id="构造Requset"><a href="#构造Requset" class="headerlink" title="构造Requset"></a>构造Requset</h3><p>其实上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。比如上面的两行代码，我们可以这么改写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import  urllib2</div><div class="line"></div><div class="line">request  =  urllib2.Request(&quot;http://www.baidu.com&quot;)</div><div class="line"></div><div class="line">response  =  urllib2.urlopen(request)</div><div class="line"></div><div class="line">print  response.read()</div></pre></td></tr></table></figure></p>
<p>运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，[服务器]响应请求得到应答，这样显得逻辑上清晰明确。</p>
<h3 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h3><p>上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。最常见的情况是什么？对了，就是登录注册的时候呀。</p>
<p>把数据用户名和密码传送到一个URL，然后你得到服务器处理之后的响应，这个该怎么办？下面让我来为小伙伴们揭晓吧！</p>
<p>数据传送分为POST和GET两种方式，两种方式有什么区别呢？</p>
<p>最重要的区别是GET方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。</p>
<h4 id="POST方式："><a href="#POST方式：" class="headerlink" title="POST方式："></a>POST方式：</h4><p>上面我们说了data参数是干嘛的？对了，它就是用在这里的，我们传送的数据就是这个参数data，下面[演示]一下POST方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import  urllib</div><div class="line"></div><div class="line">import  urllib2</div><div class="line"></div><div class="line">values  =  &#123;&quot;username&quot;:&quot;1016903103@qq.com&quot;,&quot;password&quot;:&quot;XXXX&quot;&#125;</div><div class="line"></div><div class="line">data  =  urllib.urlencode(values)</div><div class="line"></div><div class="line">url  =  &quot;https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&quot;</div><div class="line"></div><div class="line">request  =  urllib2.Request(url,data)</div><div class="line"></div><div class="line">response  =  urllib2.urlopen(request)</div><div class="line"></div><div class="line">print  response.read()</div></pre></td></tr></table></figure></p>
<p>我们引入了urllib库，现在我们模拟登陆CSDN，当然上述代码可能登陆不进去，因为还要做一些设置头部header的工作，或者还有一些参数 没有设置全，还没有提及到在此就不写上去了，在此只是说明登录的原理。我们需要定义一个字典，名字为values，参数我设置了username和 password，下面利用urllib的urlencode方法将字典编码，命名为data，构建request时传入两个参数，url和data，运 行程序，即可实现登陆，返回的便是登陆后呈现的页面内容。当然你可以自己搭建一个[服务器]来测试一下。</p>
<p>注意上面字典的定义方式还有一种，下面的写法是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import  urllib</div><div class="line"></div><div class="line">import  urllib2</div><div class="line"></div><div class="line">values  =  &#123;&#125;</div><div class="line"></div><div class="line">values[&apos;username&apos;]  =  &quot;1016903103@qq.com&quot;</div><div class="line"></div><div class="line">values[&apos;password&apos;]  =  &quot;XXXX&quot;</div><div class="line"></div><div class="line">data  =  urllib.urlencode(values)</div><div class="line"></div><div class="line">url  =  &quot;http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&quot;</div><div class="line"></div><div class="line">request  =  urllib2.Request(url,data)</div><div class="line"></div><div class="line">response  =  urllib2.urlopen(request)</div><div class="line"></div><div class="line">print  response.read()</div></pre></td></tr></table></figure></p>
<p>以上方法便实现了POST方式的传送</p>
<h4 id="GET方式："><a href="#GET方式：" class="headerlink" title="GET方式："></a>GET方式：</h4><p>至于GET方式我们可以直接把参数写到网址上面，直接构建一个带参数的URL出来即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import  urllib</div><div class="line"></div><div class="line">import  urllib2</div><div class="line"></div><div class="line">values=&#123;&#125;</div><div class="line"></div><div class="line">values[&apos;username&apos;]  =  &quot;1016903103@qq.com&quot;</div><div class="line"></div><div class="line">values[&apos;password&apos;]=&quot;XXXX&quot;</div><div class="line"></div><div class="line">data  =  urllib.urlencode(values)</div><div class="line"></div><div class="line">url  =  &quot;http://passport.csdn.net/account/login&quot;</div><div class="line"></div><div class="line">geturl  =  url  +  &quot;?&quot;+data</div><div class="line"></div><div class="line">request  =  urllib2.Request(geturl)</div><div class="line"></div><div class="line">response  =  urllib2.urlopen(request)</div><div class="line"></div><div class="line">print  response.read()</div></pre></td></tr></table></figure></p>
<p>你可以print geturl，打印输出一下url，发现其实就是原来的url加？然后加编码后的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://passport.csdn.net/account/login?username=1016903103%40qq.com&amp;password=XXXX</div></pre></td></tr></table></figure></p>
<p>和我们平常GET访问方式一模一样，这样就实现了数据的GET方式传送。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分分钟扒一个网页下来&quot;&gt;&lt;a href=&quot;#分分钟扒一个网页下来&quot; class=&quot;headerlink&quot; title=&quot;分分钟扒一个网页下来&quot;&gt;&lt;/a&gt;分分钟扒一个网页下来&lt;/h3&gt;&lt;p&gt;怎样扒网页呢？其实就是根据URL来获取它的网页信息，虽然我们在浏览器中看到的
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>工具|使用Markdowm写PPT</title>
    <link href="http://yoursite.com/2018/03/19/%E5%B7%A5%E5%85%B7-%E4%BD%BF%E7%94%A8Markdowm%E5%86%99PPT/"/>
    <id>http://yoursite.com/2018/03/19/工具-使用Markdowm写PPT/</id>
    <published>2018-03-19T10:41:53.000Z</published>
    <updated>2018-03-19T09:16:15.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Landslide是基于Google的html5slides的一个Slide生成工具，可以将markdown, ReST 或者 textile文件转化成HTML5的slide。该转化支持内联模式，即生成一个具有完整功能的HTML文件，将依赖的css等东西放入其中，很容易用来分享。</p>
<ol>
<li>安装：该工具是用python写成的，使用pip工具安装。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install landslide</div></pre></td></tr></table></figure>
</li>
</ol>
<p>也可以使用源码安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/adamzap/landslide.git</div><div class="line">$ cd landslide</div><div class="line">$ python setup.py build</div><div class="line">$ sudo python setup.py install</div></pre></td></tr></table></figure></p>
<ol>
<li>书写你的md文件，以下是官方提供的测试用例，可以生成这个页面，或者参考我的源码和这里的演示效果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># Landslide</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line"># Overview</div><div class="line"></div><div class="line">Generate HTML5 slideshows from markdown, ReST, or textile.</div><div class="line"></div><div class="line">![python](http://i.imgur.com/bc2xk.png)</div><div class="line"></div><div class="line">Landslide is primarily written in Python, but it&apos;s themes use:</div><div class="line"></div><div class="line">- HTML5</div><div class="line">- Javascript</div><div class="line">- CSS</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line"># Code Sample</div><div class="line"></div><div class="line">Landslide supports code snippets</div><div class="line"></div><div class="line">    !python</div><div class="line">    def log(self, message, level=&apos;notice&apos;):</div><div class="line">        if self.logger and not callable(self.logger):</div><div class="line">            raise ValueError(u&quot;Invalid logger set, must be a callable&quot;)</div><div class="line"></div><div class="line">        if self.verbose and self.logger:</div><div class="line">            self.logger(message, level)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ landslide file.md -i -o &gt; name_you_like.html</div></pre></td></tr></table></figure></p>
<p>将markdown文本file.md转化成你的slide文件name_you_like.html。参数-i是为了将所有依赖文件（如css）整合到这一个文件中，让你能够简单的分享和移动该slide。-o参数是讲输出重定向到标准输出流，再用&gt; file来指定保存的文件名，也可以不使用该参数生成默认文件名presentation.html。</p>
<ol>
<li>在浏览器中打开生成的HTML文件就可以看到你的PPT了，效果酷炫，还支持各种快捷键。以下列出了一些常用的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">h:      展示帮助</div><div class="line">← →:    上/下一张幻灯片</div><div class="line">ESC:    展示目录</div><div class="line">n:      显示当前是第几张幻灯片</div><div class="line">b:      屏幕全黑</div><div class="line">e:      使当前幻灯片最大化</div><div class="line">3:      展示伪3D效果</div><div class="line">c:      取消显示前后幻灯片预览，只显示当前幻灯片</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="使用PrinceXML生成PDF"><a href="#使用PrinceXML生成PDF" class="headerlink" title="使用PrinceXML生成PDF"></a>使用PrinceXML生成PDF</h3><p>PrinceXML是一款将html转换为pdf的工具，提供免费带水印版试用。</p>
<p>下载地址：</p>
<blockquote>
<p><a href="http://www.princexml.com/download/" target="_blank" rel="external">http://www.princexml.com/download/</a></p>
</blockquote>
<p>选择对应版本解压后执行脚本安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sh insatll.sh</div></pre></td></tr></table></figure></p>
<p>指定路径安装完毕后即可使用prince命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ prince test.html -o test.pdf</div></pre></td></tr></table></figure>
<p>即可生成需要的PDF PPT文件。</p>
<p><a href="https://www.jianshu.com/p/e063303317cb" target="_blank" rel="external">用Markdown写一个极客范儿的PPT</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Landslide是基于Google的html5slides的一个Slide生成工具，可以将markdown, ReST 或者 textil
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>python|python的运行的原理</title>
    <link href="http://yoursite.com/2018/03/19/python-python%E7%9A%84%E8%BF%90%E8%A1%8C%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/03/19/python-python的运行的原理/</id>
    <published>2018-03-18T23:37:05.000Z</published>
    <updated>2018-03-18T16:02:43.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>先从一个简单的例子说起，包含了两个文件 foo.py 和 demo.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[foo.py]</div><div class="line">def add(a, b):</div><div class="line">    return a + b</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[demo.py]</div><div class="line">import foo</div><div class="line">a = [1, &apos;python&apos;]</div><div class="line">a = &apos;a string&apos;</div><div class="line">def func():</div><div class="line">    a = 1</div><div class="line">    b = 257</div><div class="line">    print(a + b)</div><div class="line">print(a)</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    func()</div><div class="line">    foo.add(1, 2)</div></pre></td></tr></table></figure>
<p>执行这个程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python demo.py</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a string</div><div class="line">258</div></pre></td></tr></table></figure></p>
<p>同时，该文件目录多出一个 foo.pyc 文件，如果是 Python 3，会多出一个 <strong>pycache</strong> 文件夹，.pyc 文件会在这个文件夹中。</p>
<h4 id="背后的魔法"><a href="#背后的魔法" class="headerlink" title="背后的魔法"></a>背后的魔法</h4><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>Python 将 .py 文件视为一个 module，这些 module 中，有一个主 module，也就是程序运行的入口。在这个例子中，主 module 是 demo.py。</p>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>执行 python demo.py 后，将会启动 Python 的解释器，然后将 demo.py 编译成一个字节码对象 PyCodeObject。</p>
<p>有的人可能会很好奇，编译的结果不应是 pyc 文件吗，就像 Java 的 class 文件，那为什么是一个对象呢，这里稍微解释一下。</p>
<p><strong>在 Python 的世界中，一切都是对象，函数也是对象，类型也是对象，类也是对象</strong>（类属于自定义的类型，在 Python 2.2 之前，int, dict 这些内置类型与类是存在不同的，在之后才统一起来，全部继承自 object），甚至连编译出来的字节码也是对象，.pyc 文件是字节码对象（PyCodeObject）在硬盘上的表现形式。</p>
<p>在运行期间，编译结果也就是 PyCodeObject 对象，只会存在于内存中，而当这个模块的 Python 代码执行完后，就会将编译结果保存到了 pyc 文件中，这样下次就不用编译，直接加载到内存中。<strong>pyc 文件只是 PyCodeObject 对象在硬盘上的表现形式</strong>。</p>
<p>这个 PyCodeObject 对象包含了 Python 源代码中的字符串，常量值，以及通过语法解析后编译生成的字节码指令。PyCodeObject 对象还会存储这些字节码指令与原始代码行号的对应关系，这样当出现异常时，就能指明位于哪一行的代码。</p>
<h5 id="pyc-文件"><a href="#pyc-文件" class="headerlink" title="pyc 文件"></a>pyc 文件</h5><p>一个 pyc 文件包含了三部分信息：Python 的 magic number、pyc 文件创建的时间信息，以及 PyCodeObject 对象。</p>
<p>magic number 是 Python 定义的一个整数值。一般来说，不同版本的 Python 实现都会定义不同的 magic number，这个值是用来保证 Python 兼容性的。比如要限制由低版本编译的 pyc 文件不能让高版本的 Python 程序来执行，只需要检查 magic number 不同就可以了。由于不同版本的 Python 定义的字节码指令可能会不同，如果不做检查，执行的时候就可能出错。</p>
<p>下面所示的代码可以来创建 pyc 文件，使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python generate_pyc.py module_name</div></pre></td></tr></table></figure></p>
<p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python generate_pyc.py demo</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[generate_pyc.py]</div><div class="line">import imp</div><div class="line">import sys</div><div class="line">def generate_pyc(name):</div><div class="line">    fp, pathname, description = imp.find_module(name)</div><div class="line">    try:</div><div class="line">        imp.load_module(name, fp, pathname, description)    </div><div class="line">    finally:</div><div class="line">        if fp:</div><div class="line">            fp.close()</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    generate_pyc(sys.argv[1])</div></pre></td></tr></table></figure>
<h5 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h5><p>为什么 pyc 文件也称作字节码文件？因为这些文件存储的都是一些二进制的字节数据，而不是能让人直观查看的文本数据。</p>
<p>Python 标准库提供了用来生成代码对应字节码的工具 dis。dis 提供一个名为 dis 的方法，这个方法接收一个 code 对象，然后会输出 code 对象里的字节码指令信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s = open(&apos;demo.py&apos;).read()</div><div class="line">co = compile(s, &apos;demo.py&apos;, &apos;exec&apos;)</div><div class="line">import dis</div><div class="line">dis.dis(co)</div></pre></td></tr></table></figure></p>
<p>执行上面这段代码可以输出 demo.py 编译后的字节码指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">1           0 LOAD_CONST               0 (-1)</div><div class="line">             3 LOAD_CONST               1 (None)</div><div class="line">             6 IMPORT_NAME              0 (foo)</div><div class="line">             9 STORE_NAME               0 (foo)</div><div class="line"> 3          12 LOAD_CONST               2 (1)</div><div class="line">            15 LOAD_CONST               3 (u&apos;python&apos;)</div><div class="line">            18 BUILD_LIST               2</div><div class="line">            21 STORE_NAME               1 (a)</div><div class="line"> 4          24 LOAD_CONST               4 (u&apos;a string&apos;)</div><div class="line">            27 STORE_NAME               1 (a)</div><div class="line"> 6          30 LOAD_CONST               5 (&lt;code object func at 00D97650, file &quot;demo.py&quot;, line 6&gt;)</div><div class="line">            33 MAKE_FUNCTION            0</div><div class="line">            36 STORE_NAME               2 (func)</div><div class="line">11          39 LOAD_NAME                1 (a)</div><div class="line">            42 PRINT_ITEM          </div><div class="line">            43 PRINT_NEWLINE       </div><div class="line">13          44 LOAD_NAME                3 (__name__)</div><div class="line">            47 LOAD_CONST               6 (u&apos;__main__&apos;)</div><div class="line">            50 COMPARE_OP               2 (==)</div><div class="line">            53 POP_JUMP_IF_FALSE       82</div><div class="line">14          56 LOAD_NAME                2 (func)</div><div class="line">            59 CALL_FUNCTION            0</div><div class="line">            62 POP_TOP             </div><div class="line">15          63 LOAD_NAME                0 (foo)</div><div class="line">            66 LOAD_ATTR                4 (add)</div><div class="line">            69 LOAD_CONST               2 (1)</div><div class="line">            72 LOAD_CONST               7 (2)</div><div class="line">            75 CALL_FUNCTION            2</div><div class="line">            78 POP_TOP             </div><div class="line">            79 JUMP_FORWARD             0 (to 82)</div><div class="line">       &gt;&gt;   82 LOAD_CONST               1 (None)</div><div class="line">            85 RETURN_VALUE</div></pre></td></tr></table></figure>
<h5 id="Python-虚拟机"><a href="#Python-虚拟机" class="headerlink" title="Python 虚拟机"></a>Python 虚拟机</h5><p>demo.py 被编译后，接下来的工作就交由 Python 虚拟机来执行字节码指令了。Python 虚拟机会从编译得到的 PyCodeObject 对象中依次读入每一条字节码指令，并在当前的上下文环境中执行这条字节码指令。我们的程序就是通过这样循环往复的过程才得以执行。</p>
<h5 id="import-指令"><a href="#import-指令" class="headerlink" title="import 指令"></a>import 指令</h5><p>demo.py 的第一行代码是 import foo。import 指令用来载入一个模块，另外一个载入模块的方法是 from xx import yy。用 from 语句的好处是，可以只复制需要的符号变量到当前的命名空间中（关于命名空间将在后面介绍）。</p>
<p>前文提到，当已经存在 pyc 文件时，就可以直接载入而省去编译过程。但是代码文件的内容会更新，如何保证更新后能重新编译而不入旧的 pyc 文件呢。答案就在 pyc 文件中存储的创建时间信息。当执行 import 指令的时候，如果已存在 pyc 文件，Python 会检查创建时间是否晚于代码文件的修改时间，这样就能判断是否需要重新编译，还是直接载入了。如果不存在 pyc 文件，就会先将 py 文件编译。</p>
<h5 id="绝对引入和相对引入"><a href="#绝对引入和相对引入" class="headerlink" title="绝对引入和相对引入"></a>绝对引入和相对引入</h5><p>前文已经介绍了 import foo 这行代码。这里隐含了一个问题，就是 foo 是什么，如何找到 foo。这就属于 Python 的模块引入规则，这里不展开介绍，可以参考 pep-0328。</p>
<h5 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h5><p>接下来，执行到 a = [1, ‘python’]，这是一条赋值语句，定义了一个变量 a，它对应的值是 [1, ‘python’]。这里要解释一下，变量是什么呢？</p>
<blockquote>
<p>变量是一个存储位置和一个关联的符号名字，这个存储位置包含了一些已知或未知的量或者信息。</p>
</blockquote>
<p>变量实际上是一个字符串的符号，用来关联一个存储在内存中的对象。在 Python 中，会使用 dict（就是 Python 的 dict 对象）来存储变量符号（字符串）与一个对象的映射。</p>
<p>那么赋值语句实际上就是用来建立这种关联，在这个例子中是将符号 a 与一个列表对象 [1, ‘python’] 建立映射。</p>
<p>紧接着的代码执行了 a = ‘a string’，这条指令则将符号 a 与另外一个字符串对象 a string 建立了映射。今后对变量 a 的操作，将反应到字符串对象 a string 上。</p>
<h5 id="def-指令"><a href="#def-指令" class="headerlink" title="def 指令"></a>def 指令</h5><p>我们的 Python 代码继续往下运行，这里执行到一条 def func()，从字节码指令中也可以看出端倪 MAKE_FUNCTION。没错这条指令是用来创建函数的。<strong>Python 是动态语言，def 实际上是执行一条指令，用来创建函数（class 则是创建类的指令），而不仅仅是个语法关键字。</strong>函数并不是事先创建好的，而是执行到的时候才创建的。</p>
<p>def func() 将会创建一个名称为 func 的函数对象。实际上是先创建一个函数对象，然后将 func 这个名称符号绑定到这个函数上。</p>
<blockquote>
<p>Python 中是无法实现 C 和 Java 中的重载的，因为重载要求函数名要相同，而参数的类型或数量不同，但是 Python 是通过变量符号（如这里的 func）来关联一个函数，当我们用 def 语句再次创建一个同名的函数时，这个变量名就绑定到新的函数对象上了。</p>
</blockquote>
<h5 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h5><p>继续看函数 func 里面的代码，这时又有一条赋值语句 a = 1。变量 a 现在已经变成了第三种类型，它现在是一个整数了。那么 Python 是怎么实现动态类型的呢？答案就藏在具体存储的对象上。变量 a 仅仅只是一个符号（实际上是一个字符串对象），类型信息是存储在对象上的。在 Python 中，对象机制的核心是类型信息和引用计数（引用计数属于垃圾回收的部分）。</p>
<blockquote>
<p>用 type(a)，可以输出 a 的类型，这里是 int</p>
</blockquote>
<p>b = 257 跳过，我们直接来看看 print(a + b)，print 是输出函数，这里略过。这里想要探究的是 a + b。</p>
<p>因为 a 和 b 并不存储类型信息，因此当执行 a + b 的时候就必须先检查类型，比如 1 + 2 和 “1” + “2” 的结果是不一样的。</p>
<p>看到这里，我们就可以想象一下执行一句简单的 a + b，Python 虚拟机需要做多少繁琐的事情了。首先需要分别检查 a 和 b 所对应对象的类型，还要匹配类型是否一致（1 + “2” 将会出现异常），然后根据对象的类型调用正确的 + 函数（例如数值的 + 或字符串的 +），而 CPU 对于上面这条语句只需要执行 ADD 指令（还需要先将变量 MOV 到寄存器）。</p>
<h5 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 (namespace)"></a>命名空间 (namespace)</h5><p>在介绍上面的这些代码时，还漏掉了一个关键的信息就是命名空间。在 Python 中，类、函数、module 都对应着一个独立的命名空间。而一个独立的命名空间会对应一个 PyCodeObject 对象，所以上面的 demo.py 文件编译后会生成两个 PyCodeObject，只是在 demo.py 这个 module 层的 PyCodeObject 中通过一个变量符号 func 嵌套了一个函数的 PyCodeObject。</p>
<p>命名空间的意义，就是用来确定一个变量符号到底对应什么对象。命名空间可以一个套一个地形成一条命名空间链，Python 虚拟机在执行的过程中，会有很大一部分时间消耗在从这条命名空间链中确定一个符号所对应的对象是什么。</p>
<p>在 Python中，命名空间是由一个 dict 对象实现的，它维护了（name，obj）这样的关联关系。</p>
<p>说到这里，再补充一下 import foo 这行代码会在 demo.py 这个模块的命名空间中，创建一个新的变量名 foo，foo 将绑定到一个 PyCodeObject 对象，也就是 foo.py 的编译结果。</p>
<h5 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir 函数"></a>dir 函数</h5><p>Python 的内置函数 dir 可以用来查看一个命名空间下的所有名字符号。一个用处是查看一个命名空间的所有属性和方法（这里的命名空间就是指类、函数、module）。</p>
<p>比如，查看当前的命名空间，可以使用 dir()，查看 sys 模块，可以使用 dir(sys)。</p>
<h5 id="LEGB-规则"><a href="#LEGB-规则" class="headerlink" title="LEGB 规则"></a>LEGB 规则</h5><p>Python 使用 LEGB 的顺序来查找一个符号对应的对象</p>
<blockquote>
<p>locals -&gt; enclosing function -&gt; globals -&gt; builtins</p>
</blockquote>
<p>locals，当前所在命名空间（如函数、模块），函数的参数也属于命名空间内的变量</p>
<p>enclosing，外部嵌套函数的命名空间（闭包中常见）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def fun1(a):</div><div class="line">    def fun2():</div><div class="line">        # a 位于外部嵌套函数的命名空间</div><div class="line">        print(a)</div></pre></td></tr></table></figure></p>
<p>globals，全局变量，函数定义所在模块的命名空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = 1</div><div class="line">def fun():</div><div class="line">    # 需要通过 global 指令来声明全局变量</div><div class="line">    global a</div><div class="line">    # 修改全局变量，而不是创建一个新的 local 变量</div><div class="line">    a = 2</div></pre></td></tr></table></figure>
<p>builtins，内置模块的命名空间。Python 在启动的时候会自动为我们载入很多内置的函数、类，比如 dict，list，type，print，这些都位于 <strong>builtins</strong> 模块中，可以使用 dir(<strong>builtins</strong>) 来查看。这也是为什么我们在没有 import 任何模块的情况下，就能使用这么多丰富的函数和功能了。</p>
<p>介绍完命名空间，就能理解 print(a) 这行代码输出的结果为什么是 a string 了。</p>
<h5 id="内置属性-name"><a href="#内置属性-name" class="headerlink" title="内置属性 name"></a>内置属性 <strong>name</strong></h5><p>现在到了解释 if <strong>name</strong> == ‘<strong>main</strong>‘ 这行代码的时候了。当 Python 程序启动后，Python 会自动为每个模块设置一个属性 <strong>name</strong> 通常使用的是模块的名字，也就是文件名，但唯一的例外是主模块，主模块将会被设置为 <strong>main</strong>。利用这一特性，就可以做一些特别的事。比如当该模块以主模块来运行的时候，可以运行测试用例。而当被其他模块 import 时，则只是乖乖的，提供函数和功能就好。</p>
<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>demo.py 这个例子并没有用到多线程，但还是有必要提一下。</p>
<p>在提到多线程的时候，往往要关注线程如何同步，如何访问共享资源。Python 是通过一个全局解释器锁 GIL（Global Interpreter Lock）来实现线程同步的。当 Python 程序只有单线程时，并不会启用 GIL，而当用户创建了一个 thread 时，表示要使用多线程，Python 解释器就会自动激活 GIL，并创建所需要的上下文环境和数据结构。</p>
<p>Python 字节码解释器的工作原理是按照指令的顺序一条一条地顺序执行，Python 内部维护着一个数值，这个数值就是 Python 内部的时钟，如果这个数值为 N，则意味着 Python 在执行了 N 条指令以后应该立即启动线程调度机制，可以通过下面的代码获取这个数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">sys.getcheckinterval() # 100</div></pre></td></tr></table></figure></p>
<p>线程调度机制将会为线程分配 GIL，获取到 GIL 的线程就能开始执行，而其他线程则必须等待。由于 GIL 的存在，Python 的多线程性能十分低下，无法发挥多核 CPU 的优势，性能甚至不如单线程。因此如果你想用到多核 CPU，一个建议是使用多进程。</p>
<h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><p>在讲到垃圾回收的时候，通常会使用引用计数的模型，这是一种最直观，最简单的垃圾收集技术。Python 同样也使用了引用计数，但是引用计数存在这些缺点：</p>
<ul>
<li>频繁更新引用计数会降低运行效率</li>
<li>引用计数无法解决循环引用问题<br>Python 在引用计数机制的基础上，使用了主流垃圾收集技术中的标记——清除和分代收集两种技术。</li>
</ul>
<p><a href="https://www.restran.net/2015/10/22/how-python-code-run/" target="_blank" rel="external">谈谈 Python 程序的运行原理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简单的例子&quot;&gt;&lt;a href=&quot;#简单的例子&quot; class=&quot;headerlink&quot; title=&quot;简单的例子&quot;&gt;&lt;/a&gt;简单的例子&lt;/h3&gt;&lt;p&gt;先从一个简单的例子说起，包含了两个文件 foo.py 和 demo.py&lt;/p&gt;
&lt;figure class=&quot;hi
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法|分支法</title>
    <link href="http://yoursite.com/2018/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%88%86%E6%94%AF%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/16/计算机算法-分支法/</id>
    <published>2018-03-16T10:26:41.000Z</published>
    <updated>2018-03-18T16:06:27.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h3 id="一些案例"><a href="#一些案例" class="headerlink" title="一些案例"></a>一些案例</h3><h4 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h4><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>直观地说，将数组两头边界视为负无穷大，则 不小于 两边的数就是一个峰。如下图所示，7、6、9都是此数组的峰。</p>
<p><img src="./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E6%B3%95-01.png" alt="一维数组" title="计算机算法-分治法-01"></p>
<p>方案1.1 由定义出发，遍历所有元素即可，由于只要求找一个峰，找到即结束。易知最坏情况（即只有最后一个元素满足条件）的复杂度为(n)。</p>
<p>算法优化<br>注意到问题的要求，并不需要找到所有的峰，而方案1.1在最坏情况下遍历所有元素的消耗与寻找所有的峰等同，所以很有可能做了无用功。</p>
<p>注意到数组有峰的性质，只要子数组两端的元素仍然不小于其外侧相邻的元素，这样的性质就能在子数组中得到保持，我们采取二分的方法，这里用伪代码表示：</p>
<p>方案1.2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FIND_PEAK(A)</div><div class="line">    n=A.length</div><div class="line">    if A[n/2]&gt;=A[n/2-1] and A[n/2]&gt;=A[n/2+1]</div><div class="line">        return n/2</div><div class="line">    else if A[n/2]&lt;A[n/2-1]</div><div class="line">        return FIND_PEAK(A[1..n/2-1])</div><div class="line">    else</div><div class="line">        return FIND_PEAK(A[n/2+1..n])</div></pre></td></tr></table></figure></p>
<p>这也就是说，取中间的元素，如果它本身就是峰，就结束；否则哪边的元素比中间大哪半边就必然有峰（用证明1的方法可得到验证）。如此递归，最坏复杂度降为(log n)。</p>
<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>二维数组的峰值是这样的：</p>
<p><img src="./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E6%B3%95-02.png" alt="二维数组" title="计算机算法-分治法-02"></p>
<p>先铺垫一下，再看「峰」的本质：由定义易知这里的峰和函数中的峰，或极值是相似的。即最值一定是极值，而极值不一定是最值。</p>
<p><strong>方案1</strong>：当然，我们的基本思路是将二元寻峰问题化归为一元寻峰问题。考虑寻找每一列的峰值。</p>
<p><img src="./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E6%B3%95-03.png" alt="方案一" title="计算机算法-分治法-03"></p>
<p>如这张图所示，我们用橙色标记出了由优化后的寻找一维数组的峰值得到的每列一个峰值。然而下一步好像却没有什么好的方法继续寻找全局峰值。</p>
<p>红色标记展示了一种失败的方法，即在纵向寻峰的基础上再在该行横向寻峰，得到6。它显然不符合峰的定义。</p>
<p>注意到无论如何在一行或一列中寻找局部峰值，我们总无法保证它不小于相邻行列的数，我们就不得不在某些步骤上诉诸先前所讨论的最值了。</p>
<p><strong>方案二：找到全局最大值。</strong></p>
<p>由于数组是无序的，这种方案的复杂度只能是(m*n)，这不是我们希望看到的。</p>
<p>自然地，优化的方法仍然是分治法。我们的目标是找到一个必定存在全局峰值的子数组。</p>
<p>我们依旧从中间一列下手。然而我们这次寻找的是这一列的最大值，而非一个峰。仍然以上张图为例，我们找到的还是5。由于右边的6&gt;5，我们将范围缩小到右半边。然后递归处理。</p>
<p>相比刚才的失败方法，区别在于找到5后我们不再把范围限定在这一行，而是整个右半边。</p>
<p>去掉无关的数据，得到下图：</p>
<p><img src="./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E6%B3%95-04.png" alt="方案二" title="计算机算法-分治法-04"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FIND_PEAK_2(A)</div><div class="line">    A[n/2][i] is max(A[n/2])</div><div class="line">    if A[n/2][i]&gt;=A[n/2-1][i] and A[n/2][i]&gt;=A[n/2+1][i]</div><div class="line">        return (n/2,i)</div><div class="line">    else if A[n/2][i]&lt;A[n/2-1][i]</div><div class="line">        return FIND_PEAK_2(A)[1..n/2-1]</div><div class="line">    else</div><div class="line">        return FIND_PEAK_2(A)[n/2+1..n]</div></pre></td></tr></table></figure>
<p>这种方案的最坏复杂度是(m*logn)。当然，根据(m,n)的大小，在实际操作时我们可以灵活选择从行或列着手。</p>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/" target="_blank" rel="external">MIT公开课</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;h3 id=&quot;一些案例&quot;&gt;&lt;a href=&quot;#一些案例&quot; class=&quot;headerlink&quot; title=&quot;一些案例&quot;&gt;&lt;/a&gt;一些案例&lt;/h
    
    </summary>
    
      <category term="计算机算法" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>工具|gcc的一些坑</title>
    <link href="http://yoursite.com/2018/03/16/%E5%B7%A5%E5%85%B7-gcc%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2018/03/16/工具-gcc的一些坑/</id>
    <published>2018-03-15T23:44:27.000Z</published>
    <updated>2018-03-15T16:00:13.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C 语言、Pascal 语言、COBOL语言，以及支持函数式编程和逻辑编程的 Mercury 语言，等等。而 GCC 也不再单只是 GNU C 语言编译器的意思了，而是变成了 GNU Compiler Collection 也即是 GNU 编译器家族的意思了。另一方面，说到 GCC 对于操作系统平台及硬件平台支持，概括起来就是一句话：无所不在</p>
<h3 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use?"></a>How to use?</h3><p>gcc说到底也就是一个工具，知道怎么用才是硬功夫。</p>
<h4 id="简单编译"><a href="#简单编译" class="headerlink" title="简单编译"></a>简单编译</h4><p>示例程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//test.c</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Hello World!\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序，一步到位的编译指令是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.c -o test</div></pre></td></tr></table></figure></p>
<p>实质上，上述编译过程是分为四个阶段进行的，即预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。</p>
<h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -E test.c -o test.i 或 gcc -E test.c</div></pre></td></tr></table></figure>
<p>可以输出test.i文件中存放着test.c经预处理之后的代码。打开test.i文件，看一看，就明白了。后面那条指令，是直接在命令行窗口中输出预处理后的代码.</p>
<p>gcc的-E选项，可以让编译器在预处理后停止，并输出预处理结果。在本例中，预处理结果就是将stdio.h 文件中的内容插入到test.c中了。</p>
<h5 id="编译为汇编代码-Compilation"><a href="#编译为汇编代码-Compilation" class="headerlink" title="编译为汇编代码(Compilation)"></a>编译为汇编代码(Compilation)</h5><p>预处理之后，可直接对生成的test.i文件编译，生成汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -S test.i -o test.s</div></pre></td></tr></table></figure></p>
<p>gcc的-S选项，表示在程序编译期间，在生成汇编代码后，停止，-o输出汇编代码文件。</p>
<h5 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly)"></a>汇编(Assembly)</h5><p>对于上一小节中生成的汇编代码文件test.s，gas汇编器负责将其编译为目标文件，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c test.s -o test.o</div></pre></td></tr></table></figure></p>
<h5 id="连接-Linking"><a href="#连接-Linking" class="headerlink" title="连接(Linking)"></a>连接(Linking)</h5><p>gcc连接器是gas提供的，负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p>
<p>对于上一小节中生成的test.o，将其与Ｃ标准输入输出库进行连接，最终生成程序test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.o -o test</div></pre></td></tr></table></figure></p>
<p>最后，在命令行窗口中，执行./test, 让它说HelloWorld吧！</p>
<h4 id="多个程序文件的编译"><a href="#多个程序文件的编译" class="headerlink" title="多个程序文件的编译"></a>多个程序文件的编译</h4><p>通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC能够很好地管理这些编译单元。假设有一个由test1.c和 test2.c两个源文件组成的程序，为了对它们进行编译，并最终生成可执行程序test，可以使用下面这条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test1.c test2.c -o test</div></pre></td></tr></table></figure></p>
<p>如果同时处理的文件不止一个，GCC仍然会按照预处理、编译和链接的过程依次进行。如果深究起来，上面这条命令大致相当于依次执行如下三条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -c test1.c -o test1.o</div><div class="line">gcc -c test2.c -o test2.o</div><div class="line">gcc test1.o test2.o -o test</div></pre></td></tr></table></figure></p>
<h4 id="检错"><a href="#检错" class="headerlink" title="检错"></a>检错</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -pedantic illcode.c -o illcode</div></pre></td></tr></table></figure>
<p><strong>-pedantic</strong>编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，<strong>-pedantic</strong>选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。</p>
<p>除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多的警告信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Wall illcode.c -o illcode</div></pre></td></tr></table></figure></p>
<p>GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Werror test.c -o test</div></pre></td></tr></table></figure></p>
<h4 id="库文件连接"><a href="#库文件连接" class="headerlink" title="库文件连接"></a>库文件连接</h4><p>开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。。虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。</p>
<p>例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so</p>
<p>其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib</p>
<h5 id="编译成可执行文件"><a href="#编译成可执行文件" class="headerlink" title="编译成可执行文件"></a>编译成可执行文件</h5><p>首先我们要进行编译test.c为目标文件，这个时候需要执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –c –I /usr/dev/mysql/include test.c –o test.o</div></pre></td></tr></table></figure></p>
<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p>最后我们把所有目标文件链接成可执行文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test</div></pre></td></tr></table></figure></p>
<p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。</p>
<h5 id="强制链接时使用静态链接库"><a href="#强制链接时使用静态链接库" class="headerlink" title="强制链接时使用静态链接库"></a>强制链接时使用静态链接库</h5><p>默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p>
<p>在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test</div></pre></td></tr></table></figure></p>
<p>静态库链接时搜索路径顺序：</p>
<ol>
<li>ld会去找GCC命令中的参数-L</li>
<li>再找gcc的环境变量LIBRARY_PATH</li>
<li>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</li>
</ol>
<p>动态链接时、执行时搜索路径顺序:</p>
<ol>
<li>编译目标代码时指定的动态库搜索路径</li>
<li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li>
<li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li>
<li>默认的动态库搜索路径/lib</li>
<li>默认的动态库搜索路径/usr/lib</li>
</ol>
<p>有关环境变量：<br>LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径<br>LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径</p>
<p><a href="http://www.cnblogs.com/ggjucheng/archive/2011/12/14/2287738.html" target="_blank" rel="external">gcc常用操作</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>面试|SpringMVC常见面试题</title>
    <link href="http://yoursite.com/2018/03/15/%E9%9D%A2%E8%AF%95-SpringMVC%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/15/面试-SpringMVC常见面试题/</id>
    <published>2018-03-14T19:15:46.000Z</published>
    <updated>2018-03-15T15:56:49.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="什么是Spring框架？Spring框架有哪些主要模块？"><a href="#什么是Spring框架？Spring框架有哪些主要模块？" class="headerlink" title="什么是Spring框架？Spring框架有哪些主要模块？"></a>什么是Spring框架？Spring框架有哪些主要模块？</h4><p>Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。</p>
<p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p>
<p><img src="/images/面试--Spring-01.png" alt="Spring模块" title="面试--Spring-01"></p>
<h4 id="使用Spring框架能带来哪些好处？"><a href="#使用Spring框架能带来哪些好处？" class="headerlink" title="使用Spring框架能带来哪些好处？"></a>使用Spring框架能带来哪些好处？</h4><p>下面列举了一些使用Spring框架带来的主要好处：</p>
<ul>
<li>Dependency Injection(DI) 方法使得构造器和JavaBean properties文件中的依赖关系一目了然。</li>
<li>与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。</li>
<li>Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。</li>
<li>Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li>要测试一项用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。</li>
<li>Spring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。</li>
<li>Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。</li>
</ul>
<h4 id="什么是控制反转-IOC-？什么是依赖注入？"><a href="#什么是控制反转-IOC-？什么是依赖注入？" class="headerlink" title="什么是控制反转(IOC)？什么是依赖注入？"></a>什么是控制反转(IOC)？什么是依赖注入？</h4><p>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。</p>
<p>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。</p>
<p>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？</p>
<p>在Java中依然注入有以下三种实现方式：</p>
<ol>
<li>构造器注入</li>
<li>Setter方法注入</li>
<li>接口注入</li>
</ol>
<h4 id="请解释下Spring框架中的IoC？"><a href="#请解释下Spring框架中的IoC？" class="headerlink" title="请解释下Spring框架中的IoC？"></a>请解释下Spring框架中的IoC？</h4><p>Spring中的 org.springframework.beans 包和 org.springframework.context包构成了Spring框架IoC容器的基础。</p>
<p>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。</p>
<p>org.springframework.beans.factory.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。</p>
<h4 id="谈谈你对spring-IOC和DI的理解，它们有什么区别？"><a href="#谈谈你对spring-IOC和DI的理解，它们有什么区别？" class="headerlink" title="谈谈你对spring IOC和DI的理解，它们有什么区别？"></a>谈谈你对spring IOC和DI的理解，它们有什么区别？</h4><p>IoC Inverse of Control 反转控制的概念，就是将原本在程序中手动创建UserService对象的控制权，交由Spring框架管理，简单说，就是创建UserService对象控制权被反转到了Spring框架</p>
<p>DI：Dependency Injection 依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件</p>
<p><img src="/images/面试--Spring-03.jpg" alt="Spring-Ioc" title="面试--Spring-03"></p>
<p><strong>[IoC 控制反转，指将对象的创建权，反转到Spring容器 ， DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入]</strong></p>
<h4 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h4><p>BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。</p>
<p>BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。</p>
<p>从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。</p>
<ul>
<li>提供了支持国际化的文本消息</li>
<li>统一的资源文件读取方式</li>
<li>已在监听器中注册的bean的事件</li>
</ul>
<p>以下是三种较常见的 ApplicationContext 实现方式：</p>
<p>1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</p>
<blockquote>
<p>ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p>
</blockquote>
<p>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。</p>
<blockquote>
<p>ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);</p>
</blockquote>
<p>3、XmlWebApplicationContext：由Web应用的XML文件读取上下文。</p>
<p>6、Spring有几种配置方式？<br>将Spring配置到应用开发中有以下三种方式：</p>
<p>基于XML的配置<br>基于注解的配置<br>基于Java的配置</p>
<h4 id="如何用基于XML配置的方式配置Spring？"><a href="#如何用基于XML配置的方式配置Spring？" class="headerlink" title="如何用基于XML配置的方式配置Spring？"></a>如何用基于XML配置的方式配置Spring？</h4><p>在Spring框架中，依赖和服务需要在专门的配置文件来实现，我常用的XML格式的配置文件。这些配置文件的格式通常用<beans>开头，然后一系列的bean定义和专门的应用配置选项组成。</beans></p>
<p>SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式）</p>
<p>Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line"> </div><div class="line">    &lt;!-- JSON Support --&gt;</div><div class="line">    &lt;bean name=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;/&gt;</div><div class="line">    &lt;bean name=&quot;jsonTemplate&quot; class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;/&gt;</div><div class="line"> </div><div class="line">    &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;/&gt;</div><div class="line"> </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>下面这个web.xml仅仅配置了DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;web-app&gt;</div><div class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</div><div class="line"> </div><div class="line">  &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;</div><div class="line">            &lt;servlet-class&gt;</div><div class="line">                org.springframework.web.servlet.DispatcherServlet</div><div class="line">            &lt;/servlet-class&gt;</div><div class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line"> </div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line"> </div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<h4 id="请解释Spring-Bean的生命周期？"><a href="#请解释Spring-Bean的生命周期？" class="headerlink" title="请解释Spring Bean的生命周期？"></a>请解释Spring Bean的生命周期？</h4><p>Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。</p>
<p>Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。</p>
<ol>
<li>初始化之后调用的回调方法。</li>
<li>销毁之前调用的回调方法。</li>
</ol>
<p>Spring框架提供了以下四种方式来管理bean的生命周期事件：</p>
<ul>
<li>InitializingBean和DisposableBean回调接口</li>
<li>针对特殊行为的其他Aware接口</li>
<li>Bean配置文件中的Custom init()方法和destroy()方法</li>
<li>@PostConstruct和@PreDestroy注解方式</li>
</ul>
<p>使用customInit()和 customDestroy()方法管理bean生命周期的代码样例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">    &lt;bean id=&quot;demoBean&quot; class=&quot;com.howtodoinjava.task.DemoBean&quot;</div><div class="line">            init-method=&quot;customInit&quot; destroy-method=&quot;customDestroy&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Bean注入属性有哪几种方式？"><a href="#Bean注入属性有哪几种方式？" class="headerlink" title="Bean注入属性有哪几种方式？"></a>Bean注入属性有哪几种方式？</h4><p><img src="/images/面试--Spring-04.jpg" alt="Bean注入方式" title="面试--Spring-04"></p>
<h4 id="什么是AOP，AOP的作用是什么？"><a href="#什么是AOP，AOP的作用是什么？" class="headerlink" title="什么是AOP，AOP的作用是什么？"></a>什么是AOP，AOP的作用是什么？</h4><p>面向切面编程（AOP）提供另外一种角度来思考程序结构，通过这种方式弥补了面向对象编程（OOP）的不足，除了类（classes）以外，AOP提供了切面。切面对关注点进行模块化，例如横切多个类型和对象的事务管理。</p>
<p>Spring的一个关键的组件就是AOP框架，可以自由选择是否使用AOP 提供声明式企业服务，特别是为了替代EJB声明式服务。最重要的服务是声明性事务管理，这个服务建立在Spring的抽象事物管理之上。允许用户实现自定义切面，用AOP来完善OOP的使用,可以把Spring AOP看作是对Spring的一种增强。</p>
<p><img src="/images/面试--Spring-05.jpg" alt="Spring-AOP" title="面试--Spring-05"></p>
<h4 id="Spring的核心类有哪些，各有什么作用？"><a href="#Spring的核心类有哪些，各有什么作用？" class="headerlink" title="Spring的核心类有哪些，各有什么作用？"></a>Spring的核心类有哪些，各有什么作用？</h4><ul>
<li>BeanFactory：产生一个新的实例，可以实现单例模式</li>
<li>BeanWrapper：提供统一的get及set方法</li>
<li>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="简单的谈一下SpringMVC的工作流程？"><a href="#简单的谈一下SpringMVC的工作流程？" class="headerlink" title="简单的谈一下SpringMVC的工作流程？"></a>简单的谈一下SpringMVC的工作流程？</h4><p><img src="/images/面试--Spring-02.jpg" alt="SpringMVC工作流程" title="面试--Spring-02"></p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet </li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。 </li>
<li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器 </li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li>
<li>Controller执行完成返回ModelAndView </li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet </li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器 </li>
<li>ViewReslover解析后返回具体View </li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li>
<li>DispatcherServlet响应用户</li>
</ol>
<p>总的来说，系统启动的时候根据配置文件创建spring的容器, 首先是发送http请求到核心控制器disPatherServlet，spring容器通过映射器去寻找业务控制器， 使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用ModelAndView进行视图转发，数据放在model中，用map传递数据进行页面显示。</p>
<h4 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h4><ol>
<li>在web.xml中加入：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
<p>以上可以解决post请求乱码问题。对于get请求中文参数出现乱码解决方法有两个：</p>
<ol>
<li><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>另外一种方法对参数进行重新编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>
<h4 id="SpringMVC与Struts2的主要区别？"><a href="#SpringMVC与Struts2的主要区别？" class="headerlink" title="SpringMVC与Struts2的主要区别？"></a>SpringMVC与Struts2的主要区别？</h4><ul>
<li>①springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li>
<li>②springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。 </li>
<li>③Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。 Jsp视图解析器默认使用jstl。</li>
</ul>
<p><a href="http://www.cnblogs.com/wang-meng/p/5701946.html" target="_blank" rel="external">Java面试大全</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h3&gt;&lt;h4 id=&quot;什么是Spring框架？Spring框架有哪些主要模块？&quot;&gt;&lt;a href=&quot;#什么是Spring
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>工具|虚拟机的一些坑</title>
    <link href="http://yoursite.com/2018/03/13/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2018/03/13/工具-虚拟机的一些坑/</id>
    <published>2018-03-13T09:25:11.000Z</published>
    <updated>2018-03-16T09:39:44.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="虚拟机的三种联网方式"><a href="#虚拟机的三种联网方式" class="headerlink" title="虚拟机的三种联网方式"></a>虚拟机的三种联网方式</h3><p>vmware为我们提供了三种网络工作模式，它们分别是：Bridged（桥接模式）、NAT（网络地址转换模式）、Host-Only（仅主机模式）。</p>
<p>打开vmware虚拟机，我们可以在选项栏的“编辑”下的“虚拟网络编辑器”中看到VMnet0（桥接模式）、VMnet1（仅主机模式）、VMnet8（NAT模式），那么这些都是有什么作用呢？其实，我们现在看到的VMnet0表示的是用于桥接模式下的虚拟交换机；VMnet1表示的是用于仅主机模式下的虚拟交换机；VMnet8表示的是用于NAT模式下的虚拟交换机。</p>
<p><img src="/images/工具--虚拟机-三种联网方式-01.png" alt="虚拟机三种联网方式" title="工具--虚拟机-三种联网方式-01"></p>
<p>同时，在主机上对应的有VMware Network Adapter VMnet1和VMware Network Adapter VMnet8两块虚拟网卡，它们分别作用于仅主机模式与NAT模式下。在“网络连接”中我们可以看到这两块虚拟网卡，如果将这两块卸载了，可以在vmware的“编辑”下的“虚拟网络编辑器”中点击“还原默认设置”，可重新将虚拟网卡还原。</p>
<p><img src="/images/工具--虚拟机-三种联网方式-02.png" alt="主机网卡" title="工具--虚拟机-三种联网方式-02"></p>
<p>小伙伴看到这里，肯定有疑问，为什么在真机上没有VMware Network Adapter VMnet0虚拟网卡呢？那么接下来，我们就一起来看一下这是为什么。</p>
<h4 id="Bridged（桥接模式）"><a href="#Bridged（桥接模式）" class="headerlink" title="Bridged（桥接模式）"></a>Bridged（桥接模式）</h4><p>什么是桥接模式？桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。  </p>
<p>在桥接模式下，虚拟机和宿主计算机处于同等地位，虚拟机就像是一台真实主机一样存在于局域网中。因此在桥接模式下，我们就要像对待其他真实计算机一样为其配置IP、网关、子网掩码等等。</p>
<p>其网络结构如下图所示：</p>
<p><img src="/images/工具--虚拟机-三种联网方式-03.png" alt="桥接" title="工具--虚拟机-三种联网方式-03"></p>
<p>接下来，我们就来实际操作，如何设置桥接模式。</p>
<p>首先，安装完系统之后，在开启系统之前，点击“编辑虚拟机设置”来设置网卡模式。</p>
<h5 id="How-to-do"><a href="#How-to-do" class="headerlink" title="How to do"></a>How to do</h5><ol>
<li>首先，安装完系统之后，在开启系统之前，点击“编辑虚拟机设置”来设置网卡模式。</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-04.png" alt="How-one" title="工具--虚拟机-三种联网方式-04"></p>
<ol>
<li>点击“网络适配器”，选择“桥接模式”，然后“确定”</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-05.png" alt="Hoe-two" title="工具--虚拟机-三种联网方式-05"></p>
<ol>
<li>在进入系统之前，我们先确认一下主机的ip地址、网关、DNS等信息。</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-06.png" alt="How-three" title="工具--虚拟机-三种联网方式-06"></p>
<ol>
<li>然后，进入系统编辑网卡配置文件，命令为vi /etc/sysconfig/network-scripts/ifcfg-eth0</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-07.png" alt="How-four" title="工具--虚拟机-三种联网方式-07"></p>
<ol>
<li>添加内容如下：</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-08.png" alt="How-five" title="工具--虚拟机-三种联网方式-08"></p>
<ol>
<li>编辑完成，保存退出，然后重启虚拟机网卡，使用ping命令ping外网ip，测试能否联网。</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-09.png" alt="How-six" title="工具--虚拟机-三种联网方式-09"></p>
<ol>
<li>能ping通外网ip，证明桥接模式设置成功。那主机与虚拟机之间的通信是否正常呢？我们就用远程工具来测试一下。</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-.png" alt="How-seven" title="工具--虚拟机-三种联网方式-"></p>
<p>主机与虚拟机通信正常。</p>
<p>这就是桥接模式的设置步骤，相信大家应该学会了如何去设置桥接模式了。桥接模式配置简单，但如果你的网络环境是ip资源很缺少或对ip管理比较严格的话，那桥接模式就不太适用了。</p>
<h4 id="NAT（地址转换模式）"><a href="#NAT（地址转换模式）" class="headerlink" title="NAT（地址转换模式）"></a>NAT（地址转换模式）</h4><p>刚刚我们说到，如果你的网络ip资源紧缺，但是你又希望你的虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。其网络结构如下图所示：</p>
<p><img src="/images/工具--虚拟机-三种联网方式-11.png" alt="NAT模式" title="工具--虚拟机-三种联网方式-11"></p>
<p>在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。那么我们会觉得很奇怪，为什么需要虚拟网卡VMware Network Adapter VMnet8呢？原来我们的VMware Network Adapter VMnet8虚拟网卡主要是为了实现主机与虚拟机之间的通信。在之后的设置步骤中，我们可以加以验证。</p>
<h4 id="How-to-do-1"><a href="#How-to-do-1" class="headerlink" title="How to do"></a>How to do</h4><ol>
<li><p>首先，设置虚拟机中NAT模式的选项，打开vmware，点击“编辑”下的“虚拟网络编辑器”，设置NAT参数及DHCP参数。<br><img src="/images/工具--虚拟机-三种联网方式-12.png" alt="How-one" title="工具--虚拟机-三种联网方式-12"><br><img src="/images/工具--虚拟机-三种联网方式-13.png" alt="How-two" title="工具--虚拟机-三种联网方式-13"><br><img src="/images/工具--虚拟机-三种联网方式-14.png" alt="How-three" title="工具--虚拟机-三种联网方式-14"></p>
</li>
<li><p>将虚拟机的网络连接模式修改成NAT模式，点击“编辑虚拟机设置”，然后点击“网络适配器”，选择“NAT模式”<br><img src="/images/工具--虚拟机-三种联网方式-15.png" alt="How-four" title="工具--虚拟机-三种联网方式-15"><br><img src="/images/工具--虚拟机-三种联网方式-6.png" alt="How-five" title="工具--虚拟机-三种联网方式-6"></p>
</li>
<li><p>然后开机启动系统，编辑网卡配置文件，命令为vi /etc/sysconfig/network-scripts/ifcfg-eth0<br><img src="/images/工具--虚拟机-三种联网方式-17.png" alt="How-six" title="工具--虚拟机-三种联网方式-17"><br><img src="/images/工具--虚拟机-三种联网方式-18.png" alt="How-seven" title="工具--虚拟机-三种联网方式-18"></p>
</li>
<li><p>编辑完成，保存退出，然后重启虚拟机网卡，动态获取ip地址，使用ping命令ping外网ip，测试能否联网。</p>
</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-19.png" alt="How-eight" title="工具--虚拟机-三种联网方式-19"></p>
<ol>
<li>之前，我们说过VMware Network Adapter VMnet8虚拟网卡的作用，那我们现在就来测试一下。</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-20.png" alt="How-nine" title="工具--虚拟机-三种联网方式-20"></p>
<p>如此看来，虚拟机能联通外网，确实不是通过VMware Network Adapter VMnet8虚拟网卡，那么为什么要有这块虚拟网卡呢？<br>之前我们就说VMware Network Adapter VMnet8的作用是主机与虚拟机之间的通信，接下来，我们就用远程连接工具来测试一下。</p>
<p><img src="/images/工具--虚拟机-三种联网方式-21.png" alt="How-ten" title="工具--虚拟机-三种联网方式-21"></p>
<p>然后，将VMware Network Adapter VMnet8启用之后，发现远程工具可以连接上虚拟机了。</p>
<p>那么，这就是NAT模式，利用虚拟的NAT设备以及虚拟DHCP服务器来使虚拟机连接外网，而VMware Network Adapter VMnet8虚拟网卡是用来与虚拟机通信的。</p>
<h4 id="Host-Only（仅主机模式）"><a href="#Host-Only（仅主机模式）" class="headerlink" title="Host-Only（仅主机模式）"></a>Host-Only（仅主机模式）</h4><p>ost-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。其网络结构如下图所示：</p>
<p><img src="/images/工具--虚拟机-三种联网方式-22.png" alt="enter description here" title="工具--虚拟机-三种联网方式-22"></p>
<p>通过上图，我们可以发现，如果要使得虚拟机能联网，我们可以将主机网卡共享给VMware Network Adapter VMnet1网卡，从而达到虚拟机联网的目的。</p>
<h3 id="Ubantu去掉图形界面"><a href="#Ubantu去掉图形界面" class="headerlink" title="Ubantu去掉图形界面"></a>Ubantu去掉图形界面</h3><ul>
<li><p>如果已经登录了图形界面，那么使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/gdm  stop  (旧版的ubuntu)  再次启动图形界面 （/etc/init.d/gdm  start）</div><div class="line">/etc/init.d/lightdm  stop(新版的ubuntu)  再次启动图形界面  （/etc/init.d/lightdm  start）</div></pre></td></tr></table></figure>
</li>
<li><p>如果想下次开机直接进入命令行：</p>
<ul>
<li><p>ubuntu 12.04默认的开机会进入一个图形界面，他是由lightdm进程来实现的。首先要做的，就是阻止这个lightdm的进程开机启动。 做法：</p>
<ul>
<li><p>查看文件/etc/init/rc-sysinit.conf，在第14行附近：确认“env DEFAULT_RUNLEVEL=2”。2是新装系统默认的，确保不被修改。</p>
</li>
<li><p>编辑文件 /etc/init/lightdm.conf，在第12行附近，原句“ and runlevel [!06]” 改为“ and runlevel [!026]”</p>
</li>
</ul>
</li>
<li><p>Ubuntu12.04启动直接进入字符界面：改GRUB 的配置文件(最好不要直接改 grub.conf)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/default/grub</div></pre></td></tr></table></figure>
<p>将GRUB_CMDLINE_LINUX_DEFAULT=”quiet splash”<br>替换为  GRUB_CMDLINE_LINUX_DEFAULT=”text”<br>保存后 sudo update-grub ，此时系统会更新grub.conf</p>
</li>
</ul>
</li>
</ul>
<h3 id="Ipv4下通过ISATAP隧道访问Ipv6网站"><a href="#Ipv4下通过ISATAP隧道访问Ipv6网站" class="headerlink" title="Ipv4下通过ISATAP隧道访问Ipv6网站"></a>Ipv4下通过ISATAP隧道访问Ipv6网站</h3><p>windows:</p>
<p>管理员权限cmd:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">netsh interface ipv6 isatap set router isatap.sjtu.edu.cn </div><div class="line">netsh interface ipv6 isatap set state enabled</div></pre></td></tr></table></figure></p>
<p>要恢复原样的话只要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">netsh interface ipv6 isatap set router default</div><div class="line">netsh interface ipv6 isatap set state default</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">清华大学        59.66.4.50 / isatap.tsinghua.edu.cn</div><div class="line">  </div><div class="line">北京邮电大学    211.68.71.43 / isatap.bupt.edu.cn</div><div class="line">  </div><div class="line">上海交通大学    202.120.58.150 / isatap.sjtu.edu.cn</div><div class="line">  </div><div class="line">平顶山大学      211.69.16.36 / 官网未提供域名 只提供ip</div><div class="line">  </div><div class="line">华中科技大学    218.199.111.9 / isatap.hust.edu.cn / 华中科技大学提供的cmd http://ncs.hust.edu.cn/download/intro/ipv6/IPv6.cmd</div><div class="line">  </div><div class="line">西安建筑科技大学 222.24.128.238 / isatap.xauat.edu.cn</div><div class="line">  </div><div class="line">河南工程学院 211.84.0.1</div><div class="line"></div><div class="line">湖南大学 210.43.96.186    210.43.96.182</div><div class="line"></div><div class="line">四川大学 202.115.39.98 / isatap.scu.edu.cn</div><div class="line"></div><div class="line">电子科大 202.115.255.242</div><div class="line"></div><div class="line">华南农业大学 isatap.scau.edu.cn</div><div class="line"></div><div class="line">中南财经政法大学 isatap.znufe.edu.cn</div><div class="line"></div><div class="line">厦门大学 210.34.219.13</div><div class="line"></div><div class="line">亚太电信 tb.ipv6.apol.com.tw</div></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/linjiaxin/p/6476480.html" target="_blank" rel="external">虚拟机三种联网方式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;虚拟机的三种联网方式&quot;&gt;&lt;a href=&quot;#虚拟机的三种联网方式&quot; class=&quot;headerlink&quot; title=&quot;虚拟机的三种联网方式&quot;&gt;&lt;/a&gt;虚拟机的三种联网方式&lt;/h3&gt;&lt;p&gt;vmware为我们提供了三种网络工作模式，它们分别是：Bridged（桥接模
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>工具|Vim操作</title>
    <link href="http://yoursite.com/2018/03/12/%E5%B7%A5%E5%85%B7-Vim%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/03/12/工具-Vim操作/</id>
    <published>2018-03-12T14:35:26.000Z</published>
    <updated>2018-03-14T11:23:42.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开始学习以前，我需要给你一些警告：</p>
<ul>
<li>学习vim在开始时是痛苦的。</li>
<li>需要时间</li>
<li>需要不断地练习，就像你学习一个乐器一样。</li>
<li>不要期望你能在3天内把vim练得比别的编辑器更有效率。</li>
<li>事实上，你需要2周时间的苦练，而不是3天。</li>
</ul>
<h3 id="开始攻关"><a href="#开始攻关" class="headerlink" title="开始攻关"></a>开始攻关</h3><h4 id="第一级-–-存活"><a href="#第一级-–-存活" class="headerlink" title="第一级 – 存活"></a>第一级 – 存活</h4><ol>
<li>安装 vim</li>
<li>启动 vim</li>
<li>什么也别干！请先阅读</li>
</ol>
<p>当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：</p>
<ol>
<li>启 动Vim后，vim在 Normal 模式下。</li>
<li>让我们进入 Insert 模式，请按下键 i 。(注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</li>
<li>此时，你可以输入文本了，就像你用“记事本”一样。</li>
<li>如果你想返回 Normal 模式，请按 ESC 键。</li>
</ol>
<p>现在，你知道如何在 Insert 和 Normal 模式下切换了。下面是一些命令，可以让你在 Normal 模式下幸存下来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">i → Insert 模式，按 ESC 回到 Normal 模式.</div><div class="line">x → 删当前光标所在的一个字符。</div><div class="line">:wq → 存盘 + 退出 (:w 存盘, :q 退出)   [注：:w 后可以跟文件名]</div><div class="line">dd → 删除当前行，并把删除的行存到剪贴板里</div><div class="line">p → 粘贴剪贴板</div><div class="line">推荐:</div><div class="line"></div><div class="line">hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。</div><div class="line">:help &lt;command&gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（陈皓注：退出帮助需要输入:q）</div></pre></td></tr></table></figure>
<p>你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p>
<p>当是，在你进入第二级时，需要再说一下 Normal 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 Ctrl 键，比如：Ctrl-C。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，在VIM的Normal模式下，所有的键就是功能键了。这个你需要知道。</p>
<p>标记:</p>
<ul>
<li>下面的文字中，如果是 Ctrl-λ我会写成 <c-λ>.</c-λ></li>
<li>以 : 开始的命令你需要输入 <enter>回车，例如 — 如果我写成 :q 也就是说你要输入 :q<enter>.</enter></enter></li>
</ul>
<h4 id="第二级-–-感觉良好"><a href="#第二级-–-感觉良好" class="headerlink" title="第二级 – 感觉良好"></a>第二级 – 感觉良好</h4><p>上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：[注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键]</p>
<h5 id="各种插入模式"><a href="#各种插入模式" class="headerlink" title="各种插入模式"></a>各种插入模式</h5><ul>
<li>a → 在光标后插入</li>
<li>o → 在当前行后插入一个新行</li>
<li>O → 在当前行前插入一个新行</li>
<li>cw → 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
<h5 id="简单的移动光标"><a href="#简单的移动光标" class="headerlink" title="简单的移动光标"></a>简单的移动光标</h5><ul>
<li>0 → 数字零，到行头</li>
<li>^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</li>
<li>$ → 到本行行尾</li>
<li>g_ → 到本行最后一个不是blank字符的位置。</li>
<li>/pattern → 搜索 pattern 的字符串（注：如果搜索出多个匹配，可按n键到下一个）</li>
</ul>
<h5 id="拷贝-粘贴-（注：p-P都可以，p是表示在当前位置之后，P表示在当前位置之前）"><a href="#拷贝-粘贴-（注：p-P都可以，p是表示在当前位置之后，P表示在当前位置之前）" class="headerlink" title="拷贝/粘贴 （注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）"></a>拷贝/粘贴 （注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）</h5><ul>
<li>P → 粘贴</li>
<li>yy → 拷贝当前行当行于 ddP</li>
</ul>
<h5 id="Undo-Redo"><a href="#Undo-Redo" class="headerlink" title="Undo/Redo"></a>Undo/Redo</h5><p>u → undo</p>
<p><c-r> → redo</c-r></p>
<h5 id="打开-保存-退出-改变文件-Buffer"><a href="#打开-保存-退出-改变文件-Buffer" class="headerlink" title="打开/保存/退出/改变文件(Buffer)"></a>打开/保存/退出/改变文件(Buffer)</h5><ul>
<li>:e <path to="" file=""></path> → 打开一个文件</li>
<li>:w → 存盘</li>
<li>:saveas <path to="" file=""></path> → 另存为 <path to="" file=""></path></li>
<li>:x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车)</li>
<li>:q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。</li>
<li>:bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）</li>
</ul>
<p>花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。</p>
<h4 id="第三级-–-更好，更强，更快"><a href="#第三级-–-更好，更强，更快" class="headerlink" title="第三级 – 更好，更强，更快"></a>第三级 – 更好，更强，更快</h4><p>先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。</p>
<h5 id="更好"><a href="#更好" class="headerlink" title="更好"></a>更好</h5><p>下面，让我们看一下vim是怎么重复自己的：</p>
<ul>
<li>. → (小数点) 可以重复上一次的命令</li>
<li>N<command> → 重复某个命令N次</li>
</ul>
<p>下面是一个示例，找开一个文件你可以试试下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2dd → 删除2行</div><div class="line">3p → 粘贴文本3次</div><div class="line">100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</div><div class="line">. → 重复上一个命令—— 100 “desu “.</div><div class="line">3. → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).</div></pre></td></tr></table></figure></p>
<h5 id="更强"><a href="#更强" class="headerlink" title="更强"></a>更强</h5><p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。</p>
<ul>
<li>NG → 到第 N 行 （注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</li>
<li>gg → 到第一行。（注：相当于1G，或 :1）</li>
<li>G → 到最后一行。</li>
<li>按单词移动：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">w → 到下一个单词的开头。</div><div class="line">e → 到下一个单词的结尾。</div><div class="line"></div><div class="line">如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个</div><div class="line">单词由字母，数字和下划线组成（陈皓注：程序变量）</div></pre></td></tr></table></figure>
</li>
</ul>
<p>下面，让我来说说最强的光标移动：</p>
<ul>
<li>% : 匹配括号移动，包括 (, {, [. （注：你需要把光标先移到括号上）</li>
<li><em>和#:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（</em>是下一个，#是上一个）</li>
</ul>
<p>相信我，上面这三个命令对程序员来说是相当强大的。</p>
<h5 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h5><p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：</p>
<p><start position=""><command><end position=""></end></start></p>
<p>例如 0y$ 命令意味着：</p>
<ul>
<li>0 → 先到行头</li>
<li>y → 从这里开始拷贝</li>
<li>$ → 拷贝到本行最后一个字符</li>
</ul>
<p>你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。</p>
<p>你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。</p>
<p>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p>
<ul>
<li>d (删除 )</li>
<li>v (可视化的选择)</li>
<li>gU (变大写)</li>
<li>gu (变小写)</li>
<li>等等</li>
</ul>
<p>[注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等]</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在开始学习以前，我需要给你一些警告：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习vim在开始时是痛苦的。&lt;/li&gt;
&lt;li&gt;需要时间&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Vim" scheme="http://yoursite.com/categories/Vim/"/>
    
    
  </entry>
  
  <entry>
    <title>Java|Tomcat基础知识</title>
    <link href="http://yoursite.com/2018/03/01/Java-Tomcat%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/03/01/Java-Tomcat基础知识/</id>
    <published>2018-03-01T10:54:42.000Z</published>
    <updated>2018-03-01T03:31:58.668Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>Tomcat简单的说就是一个运行JAVA的网络服务器，底层是Socket的一个程序，它也是JSP和Serlvet的一个容器。</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>如果你学过html，css，你会知道你写的页面只能自己访问，别人不能远程访问你写的页面，Tomcat就是提供能够让别人访问自己写的页面的一个程序。</p>
<p><img src="/images/Java-Tomcat-01.png" alt="Tomcat工作方式" title="Java-Tomcat-01"></p>
<p><img src="/images/Java-Tomcat-02.png" alt="URL" title="Java-Tomcat-02"></p>
<h3 id="Tomcat结构目录"><a href="#Tomcat结构目录" class="headerlink" title="Tomcat结构目录"></a>Tomcat结构目录</h3><p><img src="/images/Java-Tomcat-03.png" alt="目录结构" title="Java-Tomcat-03"></p>
<p>目录的简单介绍</p>
<ul>
<li>bin：启动和关闭tomcat的bat文件</li>
</ul>
<ul>
<li>conf：配置文件<ul>
<li>server.xml该文件用于配置server相关的信息，比如tomcat启动的端口号，配置主机(Host)</li>
<li>web.xml文件配置与web应用（web应用相当于一个web站点）</li>
<li>tomcat-user.xml配置用户名密码和相关权限.</li>
</ul>
</li>
<li>lib：该目录放置运行tomcat运行需要的jar包</li>
<li>logs：存放日志，当我们需要查看日志的时候，可以查询信息</li>
<li>webapps：放置我们的web应用</li>
<li>work工作目录：该目录用于存放jsp被访问后生成对应的server文件和.class文件</li>
</ul>
<h4 id="webapps目录的详细说明"><a href="#webapps目录的详细说明" class="headerlink" title="webapps目录的详细说明"></a>webapps目录的详细说明</h4><p>在webapps中建立了web1目录，下面放置我们的html文件，jsp文件，图片等等，则web1就被当做web应用管理起来。</p>
<p>例子：在webapps下创建一个web站点，在web站点下创建一个html文件，访问html文件</p>
<p><img src="/images/Java-Tomcat-04.png" alt="Hello World" title="Java-Tomcat-04"></p>
<p>web站点的目录是有规范的</p>
<p><img src="/images/Java-Tomcat-05.png" alt="Web目录规范" title="Java-Tomcat-05"></p>
<p>为什么要这样设置web站点目录呢？</p>
<ul>
<li>需求：我有多个html文件，想把其中的一个html文件作为我web站点的首页。</li>
<li>如果没有WEB-INF目录下的web.xml文件支持，是无法解决我的需求的</li>
<li>这个规范是约定熟成的。</li>
</ul>
<p>下面将web站点下的helloword2.xml文件作为站点的首页</p>
<ol>
<li>新建一个WEB-INF目录</li>
</ol>
<p><img src="/images/Java-Tomcat-06.png" alt="目录结构" title="Java-Tomcat-06"></p>
<ol>
<li>在WEB-INF目录下创建一个web.xml</li>
</ol>
<p><img src="/images/Java-Tomcat-07.png" alt="目录结构" title="Java-Tomcat-07"></p>
<ol>
<li>web.xml我们不可能会写，所以可以在webapps目录下其他的站点中抄一份过来【复制ROOT/WEB-INF/web.xml的文件到自己的站点中】</li>
<li>在web.xml中添加以下代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;welcome-file-list&gt;</div><div class="line">      &lt;welcome-file&gt;helloword2.html&lt;/welcome-file&gt;</div><div class="line">&lt;/welcome-file-list&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/images/Java-Tomcat-08.png" alt="web.xml文件" title="Java-Tomcat-08"></p>
<ol>
<li>访问web站点【helloword2.html已经是web站点的首页了，所以不需要指定资源访问了】</li>
</ol>
<p><img src="/images/Java-Tomcat-09.png" alt="Hello World" title="Java-Tomcat-09"></p>
<h3 id="配置虚拟目录"><a href="#配置虚拟目录" class="headerlink" title="配置虚拟目录"></a>配置虚拟目录</h3><h4 id="为什么需要配置虚拟目录"><a href="#为什么需要配置虚拟目录" class="headerlink" title="为什么需要配置虚拟目录"></a>为什么需要配置虚拟目录</h4><ul>
<li>如果把所有web站点的目录都放在webapps下，可能导致磁盘空间不够用，也不利于对web站点目录的管理【如果存在非常多的web站点目录】</li>
<li>把web站点的目录分散到其他磁盘管理就需要配置虚拟目录【默认情况下，只有webapps下的目录才能被Tomcat自动管理成一个web站点】</li>
<li>把web应用所在目录交给web服务器管理，这个过程称之为虚拟目录的映射</li>
</ul>
<h4 id="Method-One"><a href="#Method-One" class="headerlink" title="Method One"></a>Method One</h4><ol>
<li>在其他盘符下创建一个web站点目录，并创建WEB-INF目录和一个html文件。<br><img src="/images/Java-Tomcat-10.png" alt="Method One" title="Java-Tomcat-10"></li>
<li>找到Tomcat目录下/conf/server.xml文件<br><img src="/images/Java-Tomcat-11.png" alt="Method One" title="Java-Tomcat-11"></li>
<li>在server.xml中的节点下添加如下代码。path表示的是访问时输入的web项目名，docBase表示的是站点目录的绝对路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/images/Java-Tomcat-12.png" alt="Method One" title="Java-Tomcat-12"></p>
<ol>
<li>访问配置好的web站点<br><img src="/images/Java-Tomcat-13.png" alt="Method One" title="Java-Tomcat-13"></li>
</ol>
<h4 id="Method-Two"><a href="#Method-Two" class="headerlink" title="Method Two"></a>Method Two</h4><ol>
<li>进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。</li>
</ol>
<p><img src="/images/Java-Tomcat-14.png" alt="Method Two" title="Java-Tomcat-14"></p>
<ol>
<li><p>xml文件的代码如下，docBase是你web站点的绝对路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line">&lt;Context </div><div class="line">    docBase=&quot;D:\web1&quot; </div><div class="line">    reloadable=&quot;true&quot;&gt; </div><div class="line">&lt;/Context&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>访问web站点下的html资源</p>
</li>
</ol>
<p><img src="/images/Java-Tomcat-15.png" alt="Method Two" title="Java-Tomcat-15"></p>
<h3 id="设置虚拟主机"><a href="#设置虚拟主机" class="headerlink" title="设置虚拟主机"></a>设置虚拟主机</h3><h4 id="什么是虚拟主机？"><a href="#什么是虚拟主机？" class="headerlink" title="什么是虚拟主机？"></a>什么是虚拟主机？</h4><p>多个不同域名的网站共存于一个Tomcat中</p>
<h4 id="为什么需要用到虚拟主机？"><a href="#为什么需要用到虚拟主机？" class="headerlink" title="为什么需要用到虚拟主机？"></a>为什么需要用到虚拟主机？</h4><p>例子：我现在开发了4个网站，有4个域名。如果我不配置虚拟主机，一个Tomcat服务器运行一个网站，我就需要4台电脑才能把4个网站运行起来。</p>
<h4 id="配置虚拟主机的步骤"><a href="#配置虚拟主机的步骤" class="headerlink" title="配置虚拟主机的步骤"></a>配置虚拟主机的步骤</h4><ol>
<li>在tomcat的server.xml文件中添加主机名<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Host name=&quot;zhongfucheng&quot; appBase=&quot;D:\web1&quot;&gt;</div><div class="line">		&lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt;</div><div class="line">&lt;/Host&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/images/Java-Tomcat-16.png" alt="配置虚拟主机" title="Java-Tomcat-16"></p>
<ol>
<li>访问虚拟主机下的web站点</li>
</ol>
<p><img src="/images/Java-Tomcat-17.png" alt="配置虚拟主机" title="Java-Tomcat-17"></p>
<h3 id="Tomcat体系结构"><a href="#Tomcat体系结构" class="headerlink" title="Tomcat体系结构"></a>Tomcat体系结构</h3><p><img src="/images/Java-Tomcat-18.png" alt="Tomcat体系结构" title="Java-Tomcat-18"></p>
<h3 id="浏览器访问WEB资源的流程图"><a href="#浏览器访问WEB资源的流程图" class="headerlink" title="浏览器访问WEB资源的流程图"></a>浏览器访问WEB资源的流程图</h3><p><img src="/images/Java-Tomcat-19.png" alt="工作流程" title="Java-Tomcat-19"></p>
<blockquote>
<p>参考<br><a href="https://juejin.im/post/5a75b0be5188254e761781d7" target="_blank" rel="external">Tomcat就是这么简单</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h3&gt;&lt;p&gt;Tomcat简单的说就是一个运行JAVA的网络服务器，底层是Socket的一个程序，它也是JSP和Serlvet的一个容器。
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java|Servlet基础知识</title>
    <link href="http://yoursite.com/2018/03/01/Java-Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/03/01/Java-Servlet基础知识/</id>
    <published>2018-03-01T09:07:13.000Z</published>
    <updated>2018-03-01T02:48:02.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>Servlet实际上是ServerApplet–小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。与常用的协议，如DNS，TCP/IP，HTTP类似，Servlet是作为一整套规范存在的；同时作为J2EE标准的一部分，定义了javaweb开发的标准。Servlet制定了java处理WEB请求的一系列标准，我们只需要按照标准规定的去做就可以了。</p>
<p>实际上，无论是Struts2的FilterDispatcher还是SpringMvc的DispatcherServlet,其底层都是通过实现Sevlet或者Servlet类型的扩展【如：GenericServlet】来实现的。</p>
<p>Java Web服务器处理用户请求的基本过程：用户在客户端点击一个链接，浏览器会向Web应用服务器发送一个URL请求，该URL会指向一个servlet；Web容器看出这个请求指向某个servlet A，就会创建两个对象（HttpServletRequest和HttpServletResponse），并分配或创建一个线程，调用servlet A对应的service方法（上述请求和响应对象作为参数）；service根据HTTP请求区分出客户端发来的是GET还是POST请求，并调用对应的doGet()或doPost()方法；在doGet()或doPost()方法中进行业务逻辑的处理，处理完成后的结果通过响应对象返回写回给客户端。</p>
<p>而Servlet容器又是什么呢？各个请求总要找到对应的servlet吧？每个请求总有一些状态需要管理吧？好了，servlet容器就是干这个的，它负责初始化并创建这些servlet，将请求解析成具体的类等一系列操作。比如我们常见的tomcat就是使用范围最广的servlet容器，其他的还有Jetty、jboss等。</p>
<p><img src="/images/Java-Servlet-05.png" alt="Tomcat与Servlet的关系" title="Java-Servlet-05"></p>
<h3 id="How-it-work"><a href="#How-it-work" class="headerlink" title="How it work?"></a>How it work?</h3><p>要想更好地理解Servlet是怎工作的，我们需要问自己这些问题：<strong>Servlet是如何工作的？Servlet 如何实例化、共享变量、并进行多线程处理</strong>？</p>
<p>假设我有一个运行了大量 Servlet 的 web 服务器。通过 Servlet 之间传输信息得到 Servlet 上下文，并设置 session 变量。</p>
<p>现在，如果有两名或更多使用者向这个服务发送请求，接下来 session 变量会发生什么变化？究竟是所有用户都是用共同的变量？还是不同的用户使用的变量都不一样？如果是后者，服务器如何区分不同用户？</p>
<p>另一个相似的问题，如果有 <em>n</em> 名用户访问一个特定的 Servlet，那么该 Servlet 是仅在第一个用户首次访问的时候实例化，还是分别为每个用户实例化？</p>
<p>当然，要回答上面的问题，我们首先要知道一下的内容：</p>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>当 Servlet 容器（比如 Apache Tomcat）启动后，会部署和加载所有 web 应用。当web 应用被加载，Servlet 容器会创建一次 ServletContext，然后将其保存在服务器的内存中。web 应用的 web.xml 被解析，找到其中所有 servlet、filter 和 Listener 或 @WebServlet、@WebFilter 和 @WebListener 注解的内容，创建一次并保存到服务器的内存中。<strong>对于所有过滤器会立即调用 init()</strong>。当 Servlet 容器停止，将卸载所有 web 应用，调用所有初始化的 Servlet 和过滤器的 destroy() 方法，最后回收 ServletContext 和所有 Servlet、Filter 与 Listener 实例。</p>
<p>当问题中的 Servlet 配置的 load-on-startup 或者 @WebServlet(loadOnStartup) 设置了一个大于 0 的值，则同样会在启动的时候立即调用 init() 方法。“load-on-startup”中的值表示那些 Servlet 会以相同顺序初始化。如果配置的值相同，会遵循 web.xml 中指定的顺序或 @WebServlet 类加载的顺序。另外，如果不设置 “load-on-startup” 值，init() 方法只在第一次 HTTP 请求命中问题中的 Servlet 时才被调用。</p>
<h4 id="HttpServletRequest-与-HttpServletResponse"><a href="#HttpServletRequest-与-HttpServletResponse" class="headerlink" title="HttpServletRequest 与 HttpServletResponse"></a>HttpServletRequest 与 HttpServletResponse</h4><p>Servlet 容器附加在一个 web 服务上，这个 web 服务会在某个端口号上监听 HTTP 请求，在开发环境中这个端口通常为 8080，生产环境中通常为 80。当客户端（web 浏览器）发送了一个 HTTP 请求，Servlet 容器会创建新的 HttpServletRequest 和 HttpServletResponse 对象，传递给已创建好并且请求的 URL 匹配 url-pattern 的 Filter 和 Servlet 实例中的方法，所有工作都在同一个线程中处理。</p>
<p>request 对象可以访问所有该 HTTP 请求中的信息，例如 request header 和 request body。response 对象为你提供需要的控制和发送 HTTP 响应方法，例如设置 header 和 body（通常会带有 JSP 文件中的 HTML 内容）。提交并完成HTTP 响应后，将回收 request 和 response 对象。</p>
<h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><p>当用户第一次访问该 web 应用时，会通过 request.getSession() 第一次获得 HttpSession。之后 Servlet 容器将会创建 HttpSession，生成一个唯一的 ID（可以通过 session.getId() 获取）并储存在<strong>服务器内存</strong>中。然后 Servlet 容器在该次 HTTP 响应的 Set-Cookie 头部设置一个 Cookie，以 JSESSIONID 作为 Cookie 名字，那个唯一的 session ID 作为 Cookie 的值。</p>
<p>按照 HTTP cookie 规则（正常 web 浏览器和 web 服务端必须遵循的标准），当 cookie 有效时，要求客户端（浏览器）在后续请求的 Cookie 头中返回这个 cookie。使用浏览器内置的 HTTP 流量监控器，你可以查看它们（在 Chrome、Firefox23+、IE9+ 中按 F12，然后查看 Net/Network 标签）。Servlet 容器将会确定每个进入的 HTTP 请求的 Cookie 头中是否存在名为JSESSIONID 的 cookie，然后用它的值（session ID）从服务端内存中找到关联的 HttpSession。</p>
<p>你可以在 web.xml 中设置 session-timeout ，默认值为 30 分钟。超时到达之前 HttpSession 会一直存活。所以当客户端不再访问该 web 应用超过 30 分钟后，Servlet 容器就会回收这个 session。后续每个请求，即使指定 cookie 名称也不能再访问到相同的 session。Servlet 容器会创建一个新的 Cookie。</p>
<p>另一方面，客户端上的 session cookie 有一个默认存活时间，该事件和该浏览器实例运行时间一样长。所以，当客户端关闭该浏览器实例（所有标签和窗口）后，这个 session 就会被客户端回收。新浏览器实例不再发送与该 session 关联的 cookie。一个新的 request.getSession() 将会返回新的 HttpSession 并设置一个拥有新 session ID 的 cookie。</p>
<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><ul>
<li>ServletContext 与 web 应用存活时间一样长。它被所有 session 中的所有请求共享。</li>
<li>只要客户端一直与相同浏览器实例的web应用交互并且没有超时，HttpSession就会存在。</li>
<li>HttpServletRequest 和 HttpServletResponse 的存活时间为客户端发送完成到完整的响应（web 页面）到达的这段时间。不会被其他地方共享。</li>
<li>所有 Servlet、Filter 和 Listener 对象在 web 应用运行时都是活跃的。它们被所有 session 中的请求共享。</li>
<li>你设置在 HttpServletRequest、HttpServletResponse 和 HttpSession 中的所有属性在问题中的对象存活时都会一直保持存活。</li>
</ul>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>通过上述内容，我们知道Servlet 和 filter 被所有请求共享。那是 Java 的一个优点，使得多个不同线程（读取 HTTP 请求）可以使用同一个实例。否则为每个请求重新创建线程的开销实在过于昂贵。</p>
<p>但你应该也意识到永远不要将任何 request 或 session 域中的数据赋值给 servlet 或 filter 的实例变量。它将会被所有其他 session 中的所有请求共享。<strong>那是非线程安全的！</strong></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>我们先看一段简单的servlet请求响应的代码片段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//HelloServlet类</div><div class="line">public class HelloServlet extends HttpServlet&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</div><div class="line">        String name  = req.getParameter(&quot;name&quot;);</div><div class="line">        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);</div><div class="line">        PrintWriter printWriter = resp.getWriter();</div><div class="line">        printWriter.write(&quot;&lt;html&gt;&lt;head&gt;&lt;head&gt;&lt;body&gt;&lt;h1&gt;&quot;);</div><div class="line">        printWriter.write(&quot;Hello &quot;+name);</div><div class="line">        printWriter.write(&quot;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);</div><div class="line">        printWriter.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在web.xml注册此servlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;web-app version=&quot;3.0&quot;</div><div class="line">        xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</div><div class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;display-name&gt;wthfeng 的mvc练习项目&lt;/display-name&gt;</div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;com.wthfeng.mymvc.servlet.HelloServlet&lt;/servlet-class&gt;</div><div class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">      &lt;servlet-name&gt;hello&lt;/servlet-name&gt;</div><div class="line">      &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<p>启动项目，效果如下图所示：</p>
<p><img src="/images/Java-Servlet-01.png" alt="效果" title="Java-Servlet-01"></p>
<p>这样我们就写完了一个简单的servlet，有关这个例子，我们需要知道：</p>
<ol>
<li>编写Servlet必须继承HttpServlet或GenericServlet或直接实现Servlet接口。HttpServlet已经为我们封装了有关http请求的相关参数，一般情况下我们直接继承此类即可。</li>
<li>此servlet重写了doGet方法，也就是它可以响应/myprojectName/hello?name=xxx 的请求，并在页面打印xxx的内容。</li>
</ol>
<h4 id="Servlet的创建和初始化"><a href="#Servlet的创建和初始化" class="headerlink" title="Servlet的创建和初始化"></a>Servlet的创建和初始化</h4><p>好了，这些逻辑符合上面所说的，浏览器发出请求/hello，一个名为hello的 servlet被命中，接受请求处理后返回。这里我们再深入一些，为什么要把servlet的定义在web.xml中？web.xml又和servlet容器有什么关系？</p>
<p><strong>web.xml是web项目的入口文件。在项目启动过程中，servlet容器（如tomcat）会读取web.xml并进行相应配置以初始化该项目</strong>。</p>
<p>具体容器启动流程如下（以tomcat为例）：</p>
<ol>
<li><p>先解析tomcat路径下的conf/web.xml等web.xml文件,它们是全局web配置文件，做一些基本配置工作。如注册了default、jsp等servlet。</p>
</li>
<li><p>解析web.xml，将其各个配置项（包括servlet、filter、listener)经处理包装后设在Tomcat的Context容器中，一个 Web 应用对应一个 Context 容器。</p>
</li>
<li><p>创建servlet并初始化。load-on-startup大于1的servlet会在此时初始化。初始化servlet就是调用servlet的init方法。注意：若不设置 此 值，init() 方法只在第一次 HTTP 请求命中时才被调用。此时servlet容器就算启动了。</p>
</li>
</ol>
<p><strong>简而言之就是，web.xml是项目和servlet容器（服务器）关联的桥梁。通过在web.xml注册servlet、filter、listener等，使得项目具有处理特定请求的功能。</strong></p>
<p><img src="/images/Java-Servlet-06.png" alt="生命周期" title="Java-Servlet-06"></p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>在容器启动时，XXXServlet在JVM的管理下被实例化为一个对象，这时候它还不是servlet，需要在容器的管理下调用init()方法进行初始化，获得ServletConfig和ServletContext对象的引用后，才称为一个真正的Servlet。</p>
<p><img src="/images/Java-Servlet-02.png" alt="生命周期" title="Java-Servlet-02"></p>
<ol>
<li>init()<ul>
<li>何时调用？servlet实例创建后，并在servlet能为客户请求提供服务之前，容器需要通过init方法初始化servlet。</li>
<li>作用？初始化servlet实例，使之获得web容器的相关信息</li>
<li>是否会被覆盖？有可能</li>
</ul>
</li>
<li>service()<ul>
<li>何时调用？当一个客户请求到来时，容器会创建（或从线程池分配一个线程），并调用servlet的service方法</li>
<li>作用？这个方法会确定HTTP方法（GET or POST），并调用对应的servlet方法——doGet或doPost；</li>
<li>是否会被覆盖？可以，但是不会</li>
</ul>
</li>
<li>doGet()或doPost()<ul>
<li>何时调用？</li>
<li>作用？具体的业务逻辑</li>
<li>是否会被覆盖？至少要覆盖其中之一</li>
</ul>
</li>
</ol>
<p><strong>关键点：每个请求都在一个单独的线程中运行！</strong></p>
<p><img src="/images/Java-Servlet-04.png" alt="工作方式" title="Java-Servlet-04"></p>
<h3 id="Servlet的继承体系"><a href="#Servlet的继承体系" class="headerlink" title="Servlet的继承体系"></a>Servlet的继承体系</h3><ul>
<li>servlet接口：javax.servlet.Servlet，表示所有的Servlet都有这5个方法，其中init、service和destroy三个方法和servlet的生命周期有关</li>
<li>GenericServlet：javax.servlet.GenericServlet，这是一个抽象类，它实现了开发者需要的大部分基本servlet方法，大多数servlet的“servlet行为”都来自这个类；</li>
<li>HttpServlet：javax.servlet.http.HttpServlet，这也是一个抽象类，它实现了自己的service()方法，处理servlet的HTTP特性（service方法不仅仅只处理HTTP请求）。</li>
<li>MyTestServlet：这是开发者自己编写的处理类，一般只需要实现doGet()和doPost()方法。</li>
</ul>
<p><img src="/images/Java-Servlet-03.png" alt="继承体系" title="Java-Servlet-03"></p>
<h3 id="HTTP相关API"><a href="#HTTP相关API" class="headerlink" title="HTTP相关API"></a>HTTP相关API</h3><h4 id="HTTP请求的API"><a href="#HTTP请求的API" class="headerlink" title="HTTP请求的API"></a>HTTP请求的API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>getHeader()</td>
<td>可以获取首部信息，例如request.getHeader(“User-Agent”)可以获取客户端的平台和浏览器信息</td>
</tr>
<tr>
<td>getIntHeader()</td>
<td>如果首部信息中的“key/value”对中的value是int类型的，可以使用这个方法直接获取值而不需要显式类型转换</td>
</tr>
<tr>
<td>getCookies()</td>
<td>可以获取与请求相关的cookie</td>
</tr>
<tr>
<td>getSession()</td>
<td>可以获取与请求相关的会话</td>
</tr>
<tr>
<td>getMethod()</td>
<td>可以获取http方法</td>
</tr>
<tr>
<td>getInputStream()</td>
<td>可以获取请求的输入流</td>
</tr>
<tr>
<td>getParameter(String name)</td>
<td>可以获取HTTP请求的请求参数，对于GET请求，可以获取查询字符串中的数据、对于POST请求，可以获取请求体中的数据</td>
</tr>
<tr>
<td>getRemotePort()</td>
<td>获取客户端的端口号</td>
</tr>
<tr>
<td>getServerPort()</td>
<td>获取服务端接受请求的端口号（请求一开始发送服务端的哪个端口？）</td>
</tr>
<tr>
<td>getLocalPort()</td>
<td>获取服务端处理请求的端口号（请求最后是发送到服务端的哪个端口？）</td>
</tr>
</tbody>
</table>
<h4 id="HTTP响应的API"><a href="#HTTP响应的API" class="headerlink" title="HTTP响应的API"></a>HTTP响应的API</h4><p>大多数情况下，使用响应只是为了向客户发回数据。会对响应调用两个方法：setContentType()和getWriter()。在此之后，可以将HTML或其他内容写入到流。不过，你也可以使用响应设置首部、发送错误或增加Cookie。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>setContentType()</td>
<td>设置响应返回的MIME类型</td>
</tr>
<tr>
<td>getOutputStream()</td>
<td>获取HTTP输出字节流</td>
</tr>
<tr>
<td>getWriter()</td>
<td>获取HTTP输出字符流</td>
</tr>
<tr>
<td>addCookie(Cookie cookie)</td>
<td>给响应首部中增加cookie对象，注意这里不是增加“key/value”对</td>
</tr>
<tr>
<td>addHeader()</td>
<td>在响应首部中添加一个“key/value”对</td>
</tr>
<tr>
<td>setHeader()</td>
<td>在响应首部中设置一个“key/value”对；<strong>和addHeader()的区别是，如果响应首部中已经有对应的key存在，setHeader()会覆盖现有的值，而addHeder()会新增一个“key/value”对，使用时需要注意</strong>；</td>
</tr>
<tr>
<td>encodeRedirectURL()</td>
<td>对包含session ID的URL进行编码。<strong>使用场景：在浏览器不支持使用cookie跟踪会话时，可以使用URL重写（即将URL重定向到另一个URL，而这个URL的后面会带上session id传给客户端，这个URL在返回给客户端之前需要经过编码）</strong></td>
</tr>
<tr>
<td>sendError()</td>
<td>给客户端返回错误的响应（错误码、错误信息），在该方法被调用之后，就意味着响应已经被返回给客户端，也就不能再调用response的任何方法，否则会报IllegalStateException。</td>
</tr>
<tr>
<td>setStatus()</td>
<td>设置响应的状态码</td>
</tr>
<tr>
<td>sendRedirect()</td>
<td>用于URL重定向，告诉客户端去访问另一个URL来完成需求，如果location没有以“/”开头，则它是相对路径，容器会负责将这个相对路径转化成该web应用的绝对路径；否则容器会把它当做绝对路径处理。</td>
</tr>
</tbody>
</table>
<h4 id="重定向和请求派发"><a href="#重定向和请求派发" class="headerlink" title="重定向和请求派发"></a>重定向和请求派发</h4><ul>
<li>重定向是让浏览器访问新的URL完成工作，用户会在浏览器地址栏看到新的URL,通过httpServlet的sendDirect(String location)方法。</li>
<li>请求派发是服务端的工作，是当前servlet委托另外的servlet完成请求，并给客户端发回响应，用户的浏览器地址栏的URL没有改变,是通过requestDispatcher对象的forward(httpServletRequest req,HttpServletResponse res)方法来实现的。其中getRequestDispatcher方法的参数，必须以“／”开头，表示web的根目录，比如要<br>跳转：　“<a href="http://locahost:8080/servlet/servet/LifeCycleServlet" target="_blank" rel="external">http://locahost:8080/servlet/servet/LifeCycleServlet</a>“, 则参数为”/servlet/LifeCycleServlet”.</li>
</ul>
<h3 id="获取初始化参数"><a href="#获取初始化参数" class="headerlink" title="获取初始化参数"></a>获取初始化参数</h3><ol>
<li><p>在 web.xml中配置servlet时，可以配置一些初始化参数，在servlet可以通过servletConfig接口提供的接口获取这些参数。</p>
<ul>
<li><p>在web.xml中配置init-param 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;servlet&gt;</div><div class="line">        </div><div class="line">        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;&lt;!-- servlet的名字 --&gt;</div><div class="line">        &lt;servlet-class&gt;servlet.HelloServlet&lt;/servlet-class&gt;&lt;!-- servlet的具体类型，需要带包名 --&gt;</div><div class="line">        &lt;init-param&gt;</div><div class="line">            &lt;param-name&gt;username&lt;/param-name&gt;</div><div class="line">            &lt;param-value&gt;forezp&lt;/param-value&gt;</div><div class="line">        &lt;/init-param&gt;</div><div class="line">    &lt;/servlet&gt;</div></pre></td></tr></table></figure>
<ul>
<li>在servlet中获取</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class HelloServlet extends HttpServlet &#123;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void init() throws ServletException &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        super.init();</div><div class="line">        String name=this.getInitParameter(&quot;username&quot;);</div><div class="line">        System.out.println(name);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>+ 部署项目，访问helloServlet就可以看见在控制台打印了forezp
</code></pre><ol>
<li>也可以配置一些全局的参数:context-param.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;web-app version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee </div><div class="line">    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;</div><div class="line">    &lt;display-name&gt;&lt;/display-name&gt;</div><div class="line">    &lt;welcome-file-list&gt;</div><div class="line">        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;</div><div class="line">    &lt;/welcome-file-list&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;context-param&gt;</div><div class="line">        &lt;param-name&gt;haha&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;xixi&lt;/param-value&gt;</div><div class="line">    &lt;/context-param&gt;</div><div class="line">    </div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<pre><code>+ 获取方式：servlet中通过getServletContext()获取servletContext对象，使用ServletContext的getInitParameter()方法获取制定参数名来获取参数。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ServletContext servletContext=getServletConfig().getServletContext();</div><div class="line">String str=servletContext.getInitParameter(&quot;haha&quot;);</div><div class="line">System.out.println(str);</div></pre></td></tr></table></figure>
<h3 id="随便讲讲Filter和Listener"><a href="#随便讲讲Filter和Listener" class="headerlink" title="随便讲讲Filter和Listener"></a>随便讲讲Filter和Listener</h3><p>在有关web servlet的配置中，常能在web.xml看到filter、listener的配置。实际上，filter是过滤器，listener是监听器。这两项配置都是servlet中的重要部分。我们一一来看。</p>
<h4 id="fliter-过滤器"><a href="#fliter-过滤器" class="headerlink" title="fliter(过滤器)"></a>fliter(过滤器)</h4><p>先来个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class MyFilter implements Filter &#123;</div><div class="line"></div><div class="line">    private String param; </div><div class="line">     </div><div class="line">    //初始化方法，在容器启动时调用</div><div class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</div><div class="line">        //做一些初始化操作</div><div class="line">        param = filterConfig.getInitParameter(&quot;myParam&quot;);</div><div class="line">        System.out.println(&quot;filter:&quot;+param);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</div><div class="line">            throws IOException, ServletException &#123;</div><div class="line">        //处理请求</div><div class="line">        chain.doFilter(request,response); //调用下一个过滤器</div><div class="line">        //处理响应</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void destroy() &#123;</div><div class="line">      //在servlet销毁后销毁</div><div class="line">      //做一些销毁后的善后工作</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 web.xml中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> &lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;com.wthfeng.mymvc.filter.MyFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;myParam&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;myValue&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>配置后filter就会拦截所有servlet请求，需注意：</p>
<p>所有的filter在容器启动时即初始化。<br>filter的调用顺序为在web.xml中的定义顺序。若多余一个会形成过滤链依次处理。</p>
<h4 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener(监听器)"></a>Listener(监听器)</h4><p>servlet 监听器用于监听servlet容器中事件变化，当指定事件变化时，会触发注册该事件的监听器。监听器基于观察者模式。</p>
<p>Servlet监听器分为3类，分别用于监听ServletContent（Servlet上下文）、HttpSession（Session）,HttpRequest(Request)。</p>
<p>主要有以下几个类：</p>
<ul>
<li><p>ServletContextListener //监听Servlet容器创建销毁<br>ServletContextAttributeListener  //监听Servlet容器级别属性的添加及删除</p>
</li>
<li><p>HttpSessionListener  //监听Session创建销毁<br>HttpSessionAttributeListener //监听Session属性创建删除</p>
</li>
<li><p>ServletRequestListener  //监听请求创建及销毁<br>ServletRequestAttributeListener  //监听请求属性变化</p>
</li>
</ul>
<p>如我们常见的Spring项目中的如下片段，就是Spring的监听器。其实现了ServletContextListener，用于监听Servlet上下文，以便在项目初始化时加载Spring的必要配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> &lt;listener&gt;</div><div class="line">       &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Servlet-、Filter、Listerer-执行顺序"><a href="#Servlet-、Filter、Listerer-执行顺序" class="headerlink" title="Servlet 、Filter、Listerer 执行顺序"></a>Servlet 、Filter、Listerer 执行顺序</h4><p>分别了解了servlet、filter、listener后，来确定一下他们之间的执行顺序。我们已经知道，filter在servlet之前，那listener呢？</p>
<p>应该想到，监听器负责监听事件变化，应该有最先执行的权限，测试一下，我把上述三种都加了日志，打印结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//开启服务器并请求</div><div class="line">listener 容器初始化开始  //servletContent 监听器 contextInitialized()</div><div class="line">filter初始化        //filter init()</div><div class="line">初始化servlet       //servlet init()</div><div class="line">listener request初始化  // request 监听器requestInitialized()</div><div class="line">开始filter            //fiter doFilter() chain.doFilter前</div><div class="line">执行servlet        //servlet service()</div><div class="line">结束filter          //fiter doFilter() chain.doFilter后</div><div class="line">listener request销毁  //request 监听器 requestInitialized()</div><div class="line"></div><div class="line">//关闭服务器</div><div class="line">servlet销毁</div><div class="line">filter销毁</div><div class="line">listener 容器销毁</div></pre></td></tr></table></figure></p>
<p>从此我们可以得出结论：</p>
<ul>
<li>对于涉及3者的部分，顺序为 listener - filter - servlet</li>
<li>filter和servlet的初始化部分，先filter后servlet</li>
<li>销毁或结束顺序为加载顺序的反序</li>
</ul>
<blockquote>
<p>参考 </p>
<ul>
<li><a href="http://blog.wthfeng.com/javaweb/servlet/2017/04/30/Servlet%E5%92%8CServlet%E5%AE%B9%E5%99%A8/" target="_blank" rel="external">Servlet工作机制解析</a></li>
<li><a href="https://www.jianshu.com/p/fc7f31b664d5" target="_blank" rel="external">Servlet请求和响应</a></li>
<li><a href="https://www.jianshu.com/p/4d71ec3e1b99" target="_blank" rel="external">当Java遇见了Html–Servlet篇</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h3&gt;&lt;p&gt;Servlet实际上是ServerApplet–小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java|监听器基础</title>
    <link href="http://yoursite.com/2018/03/01/Java-%E7%9B%91%E5%90%AC%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/03/01/Java-监听器基础/</id>
    <published>2018-02-28T23:36:30.000Z</published>
    <updated>2018-02-28T16:21:07.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>这里有三个概念，<strong>监听的事件源</strong>，<strong>监听者</strong>，<strong>事件</strong>，举个栗子来说是这样的，警察抓小偷，警察是监听者，小偷是被监听的事件源，抓小偷这个动作就是事件，什么时候会抓小偷呢？在小偷偷东西的时候。<br>这个概念在前端开发中比较常用，但是在Java服务器端用的相对比较少，比如你在浏览网页的过程中，第一次进入并不会全部加载页面的信息，而是加载一部分，你向下浏览网页，网页才会加载，这也是监听的一种体现形式，你向下滑动网页的过程就是监听的事件源，加载网页就是事件，监听者就是服务器程序咯，可能这些用词不是太准确，但是也算是表达了这个意思。</p>
<p>JavaWeb中，监听的事件源有三个：</p>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><ul>
<li><p>ServletContextListener：用于对Servlet整个上下文进行监听（创建、销毁）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//上下文初始化</div><div class="line">public void contextInitialized(ServletContextEvent sce);</div><div class="line">//上下文销毁</div><div class="line">public void contextDestroyed(ServletContextEvent sce);</div><div class="line">//ServletContextEvent事件：取得一个ServletContext（application）对象</div><div class="line">public ServletContext getServletContext();</div></pre></td></tr></table></figure>
</li>
<li><p>ServletContextAttributeListener：对Servlet上下文属性的监听（增删改属性）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//增加属性</div><div class="line">public void attributeAdded(ServletContextAttributeEvent scab);</div><div class="line">//属性删除</div><div class="line">public void attributeRemoved(ServletContextAttributeEvent scab);</div><div class="line">//属性替换（第二次设置同一属性）</div><div class="line">public void attributeRepalced(ServletContextAttributeEvent scab);</div><div class="line">//ServletContextAttributeEvent事件：能取得设置属性的名称与内容</div><div class="line">//得到属性名称</div><div class="line">public String getName();</div><div class="line">//取得属性的值</div><div class="line">public Object getValue();</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><p>Session属于http协议下的内容，接口位于javax.servlet.http.*包下。</p>
<ul>
<li><p>HttpSessionListener接口：对Session的整体状态的监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//session创建</div><div class="line">public void sessionCreated(HttpSessionEvent se);</div><div class="line">//session销毁</div><div class="line">public void sessionDestroyed(HttpSessionEvent se);</div><div class="line">//HttpSessionEvent事件：</div><div class="line">//取得当前操作的session</div><div class="line">public HttpSession getSession();</div></pre></td></tr></table></figure>
</li>
<li><p>HttpSessionAttributeListener接口：对session的属性监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void attributeAdded(HttpSessionBindingEvent se);//增加属性</div><div class="line">public void attributeRemoved(HttpSessionBindingEvent se);//删除属性</div><div class="line">public void attributeReplaced(HttpSessionBindingEvent se);//替换属性</div><div class="line">//HttpSessionBindingEvent事件：</div><div class="line">public String getName();//取得属性的名称</div><div class="line">public Object getValue();//取得属性的值</div><div class="line">public HttpSession getSession();//取得当前的session</div></pre></td></tr></table></figure>
</li>
</ul>
<p>session的销毁有两种情况：</p>
<ul>
<li><p>session超时，web.xml配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;session-config&gt;</div><div class="line">    &lt;session-timeout&gt;120&lt;/session-timeout&gt;&lt;!--session120分钟后超时销毁--&gt;</div><div class="line">&lt;/session-config&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>手工使session失效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//使session失效方法。session.invalidate();</div><div class="line">public void invalidate();</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h4><ul>
<li><p>ServletRequestListener：用于对Request请求进行监听（创建、销毁）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void requestInitialized(ServletRequestEvent sre);//request初始化</div><div class="line">public void requestDestroyed(ServletRequestEvent sre);//request销毁</div><div class="line">//ServletRequestEvent事件：</div><div class="line">public ServletRequest getServletRequest();//取得一个ServletRequest对象</div><div class="line">public ServletContext getServletContext();//取得一个ServletContext（application）对象</div></pre></td></tr></table></figure>
</li>
<li><p>ServletRequestAttributeListener：对Request属性的监听（增删改属性）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void attributeAdded(ServletRequestAttributeEvent srae);//增加属性</div><div class="line">public void attributeRemoved(ServletRequestAttributeEvent srae);//属性删除</div><div class="line">public void attributeReplaced(ServletRequestAttributeEvent srae);//属性替换（第二次设置同一属性）</div><div class="line">//ServletRequestAttributeEvent事件：能取得设置属性的名称与内容</div><div class="line">public String getName();//得到属性名称</div><div class="line">public Object getValue();//取得属性的值</div></pre></td></tr></table></figure>
</li>
</ul>
<p>它都会监听什么呢？</p>
<ul>
<li>监听域对象的创建和销毁的监听器</li>
<li>监听域对象操作域属性的监听器</li>
<li>监听HttpSession的监听器</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * ServletContextListener实现类</div><div class="line"> * contextDestroyed() -- 在ServletContext对象被销毁前调用</div><div class="line"> * contextInitialized() --  -- 在ServletContext对象被创建后调用</div><div class="line"> * ServletContextEvent -- 事件类对象</div><div class="line"> *     该类有getServletContext()，用来获取ServletContext对象，即获取事件源对象</div><div class="line"> */</div><div class="line">public class MyServletContextListener implements ServletContextListener &#123;</div><div class="line">    public void contextDestroyed(ServletContextEvent evt) &#123;</div><div class="line">        System.out.println(&quot;销毁ServletContext对象&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void contextInitialized(ServletContextEvent evt) &#123;</div><div class="line">        System.out.println(&quot;创建ServletContext对象&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时，需要在web.xml中部署：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;listener&gt;</div><div class="line">    &lt;listener-class&gt;net.sailfish.listener.MyServletContextListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure>
<p><strong>需要注意的是</strong>：Listener配置信息必须在Filter和Servlet配置之前，Listener的初始化（ServletContentListener初始化）比Servlet和Filter都优先，而销毁比Servlet和Filter都慢。</p>
<p>总结一下：</p>
<ul>
<li>监听器要在web.xml中进行配置</li>
<li>监听器的方法都是类似的，这里列出的是域对象的创建和销毁的监听器</li>
<li>ServletContextListener在tomcat启动时创建，在tomcat关闭的时候销毁</li>
</ul>
<h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><p>Listener的应用实例</p>
<ul>
<li>利用HttpSessionListener统计最多在线用户人数</li>
<li>Spring使用ContextLoaderListener加载ApplicationContext配置信息</li>
<li>Spring使用Log4jConfigListener配置Log4j日志</li>
<li>Spring使用IntrospectorCleanupListener清理缓存</li>
</ul>
<h4 id="Listener应用实例"><a href="#Listener应用实例" class="headerlink" title="Listener应用实例"></a>Listener应用实例</h4><p>利用HttpSessionListener统计最多在线用户人数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import java.text.DateFormat;</div><div class="line">import java.text.SimpleDateFormat;</div><div class="line">import java.util.Date;</div><div class="line">import javax.servlet.ServletContext;</div><div class="line">import javax.servlet.http.HttpSessionEvent;</div><div class="line">import javax.servlet.http.HttpSessionListener;</div><div class="line">public class HttpSessionListenerImpl implements HttpSessionListener &#123;</div><div class="line">    public void sessionCreated(HttpSessionEvent event) &#123;</div><div class="line">        ServletContext app = event.getSession().getServletContext();</div><div class="line">        int count = Integer.parseInt(app.getAttribute(&quot;onLineCount&quot;).toString());</div><div class="line">        count++;</div><div class="line">        app.setAttribute(&quot;onLineCount&quot;, count);</div><div class="line">        int maxOnLineCount = Integer.parseInt(app.getAttribute(&quot;maxOnLineCount&quot;).toString());</div><div class="line">        if (count &gt; maxOnLineCount) &#123;</div><div class="line">            //记录最多人数是多少</div><div class="line">            app.setAttribute(&quot;maxOnLineCount&quot;, count);</div><div class="line">            DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">            //记录在那个时刻达到上限</div><div class="line">            app.setAttribute(&quot;date&quot;, df.format(new Date()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //session注销、超时时候调用，停止tomcat不会调用</div><div class="line">    public void sessionDestroyed(HttpSessionEvent event) &#123;</div><div class="line">        ServletContext app = event.getSession().getServletContext();</div><div class="line">        int count = Integer.parseInt(app.getAttribute(&quot;onLineCount&quot;).toString());</div><div class="line">        count--;</div><div class="line">        app.setAttribute(&quot;onLineCount&quot;, count);    </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Spring使用ContextLoaderListener加载ApplicationContext配置信息"><a href="#Spring使用ContextLoaderListener加载ApplicationContext配置信息" class="headerlink" title="Spring使用ContextLoaderListener加载ApplicationContext配置信息"></a>Spring使用ContextLoaderListener加载ApplicationContext配置信息</h4><p>ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。</p>
<p>ContextLoaderListener如何查找ApplicationContext.xml的配置位置以及配置多个xml：如果在web.xml中不写任何参数配置信息，默认的路径是”/WEB-INF/applicationContext.xml”，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml（在MyEclipse中把xml文件放置在src目录下）。如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;</div><div class="line">    &lt;!-- 采用的是通配符方式，查找WEB-INF/spring目录下xml文件。如有多个xml文件，以“,”分隔。 --&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;listener&gt;</div><div class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Spring使用Log4jConfigListener配置Log4j日志"><a href="#Spring使用Log4jConfigListener配置Log4j日志" class="headerlink" title="Spring使用Log4jConfigListener配置Log4j日志"></a>Spring使用Log4jConfigListener配置Log4j日志</h4><p>Spring使用Log4jConfigListener的好处：</p>
<ul>
<li>动态的改变记录级别和策略，不需要重启Web应用。</li>
<li>把log文件定在 /WEB-INF/logs/ 而不需要写绝对路径。因为系统把web目录的路径压入一个叫webapp.root的系统变量。这样写log文件路径时不用写绝对路径了。</li>
<li>可以把log4j.properties和其他properties一起放在/WEB-INF/ ，而不是Class-Path。</li>
<li>设置log4jRefreshInterval时间，开一条watchdog线程每隔段时间扫描一下配置文件的变化。</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;webAppRootKey&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;project.root&lt;/param-value&gt;&lt;!-- 用于定位log文件输出位置在web应用根目录下，log4j配置文件中写输出位置：log4j.appender.FILE.File=$&#123;project.root&#125;/logs/project.log --&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt;&lt;!-- 载入log4j配置文件 --&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;60000&lt;/param-value&gt;&lt;!--Spring刷新Log4j配置文件的间隔60秒,单位为millisecond--&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;listener&gt;</div><div class="line">    &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Spring使用IntrospectorCleanupListener清理缓存"><a href="#Spring使用IntrospectorCleanupListener清理缓存" class="headerlink" title="Spring使用IntrospectorCleanupListener清理缓存"></a>Spring使用IntrospectorCleanupListener清理缓存</h4><p>这个监听器的作用是在web应用关闭时刷新JDK的JavaBeans的Introspector缓存，以确保Web应用程序的类加载器以及其加载的类正确的释放资源。</p>
<p>如果JavaBeans的Introspector已被用来分析应用程序类，系统级的Introspector缓存将持有这些类的一个硬引用。因此，这些类和Web应用程序的类加载器在Web应用程序关闭时将不会被垃圾收集器回收！而IntrospectorCleanupListener则会对其进行适当的清理，已使其能够被垃圾收集器回收。</p>
<p>唯一能够清理Introspector的方法是刷新整个Introspector缓存，没有其他办法来确切指定应用程序所引用的类。这将删除所有其他应用程序在服务器的缓存的Introspector结果。</p>
<p>在使用Spring内部的bean机制时，不需要使用此监听器，因为Spring自己的introspection results cache将会立即刷新被分析过的JavaBeans Introspector cache，而仅仅会在应用程序自己的ClassLoader里面持有一个cache。虽然Spring本身不产生泄漏，注意，即使在Spring框架的类本身驻留在一个“共同”类加载器（如系统的ClassLoader）的情况下，也仍然应该使用使用IntrospectorCleanupListener。在这种情况下，这个IntrospectorCleanupListener将会妥善清理Spring的introspection cache。</p>
<p>应用程序类，几乎不需要直接使用JavaBeans Introspector，所以，通常都不是Introspector resource造成内存泄露。相反，许多库和框架，不清理Introspector，例如： Struts和Quartz。</p>
<p>需要注意的是一个简单Introspector泄漏将会导致整个Web应用程序的类加载器不会被回收！这样做的结果，将会是在web应用程序关闭时，该应用程序所有的静态类资源（比如：单实例对象）都没有得到释放。而导致内存泄露的根本原因其实并不是这些未被回收的类！</p>
<p>注意：IntrospectorCleanupListener应该注册为web.xml中的第一个Listener，在任何其他Listener之前注册，比如在Spring’s ContextLoaderListener注册之前，才能确保IntrospectorCleanupListener在Web应用的生命周期适当时机生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;listener&gt;&lt;!-- memory clean --&gt;</div><div class="line">    &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h3&gt;&lt;p&gt;这里有三个概念，&lt;strong&gt;监听的事件源&lt;/strong&gt;，&lt;strong&gt;监听者&lt;/strong&gt;，&lt;strong&gt;事
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java|过滤器基础</title>
    <link href="http://yoursite.com/2018/03/01/Java-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/03/01/Java-过滤器基础/</id>
    <published>2018-02-28T21:54:21.000Z</published>
    <updated>2018-02-28T16:32:17.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it?"></a>What is it?</h3><p>过滤器是Servlet的高级特性之一，也别把它想得那么高深，只不过是实现Filter接口的Java类罢了！</p>
<p>首先，我们来看看过滤器究竟Web容器的哪处:</p>
<p><img src="/images/Java-过滤器-01.png" alt="Java 过滤器" title="Java-过滤器-01"></p>
<p>上面的图我们可以发现，当浏览器发送请求给服务器的时候，先执行过滤器，然后才访问Web的资源。服务器响应Response，从Web资源抵达浏览器之前，也会途径过滤器。。</p>
<p><img src="/images/Java-过滤器-05.png" alt="Java 过滤器" title="Java-过滤器-05"></p>
<p>我们很容易发现，过滤器可以比喻成一张滤网。我们想想现实中的滤网可以做什么：在泡茶的时候，过滤掉茶叶。那滤网是怎么过滤茶叶的呢？规定大小的网孔，只要网孔比茶叶小，就可以实现过滤了！</p>
<p>引申在Web容器中，过滤器可以做：过滤一些敏感的字符串【规定不能出现敏感字符串】、避免中文乱码【规定Web资源都使用UTF-8编码】、权限验证【规定只有带Session或Cookie的浏览器，才能访问web资源】等等等，过滤器的作用非常大，只要发挥想象就可以有意想不到的效果</p>
<p>也就是说：当需要限制用户访问某些资源时、在处理请求时提前处理某些资源、服务器响应的内容对其进行处理再返回、我们就是用过滤器来完成的！</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>Filter功能</p>
<ul>
<li>在HttpServletRequest 到达 Servlet 之前，拦截客户的 HttpServletRequest 。根据需要检查 HttpServletRequest ，也可以修改HttpServletRequest 头和数据。</li>
<li>在HttpServletResponse 到达客户端之前，拦截HttpServletResponse 。根据需要检查 HttpServletResponse ，也可以修改HttpServletResponse头和数据。</li>
</ul>
<p>举例子来说明吧：</p>
<h4 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h4><p><strong>方法一</strong>：如果我没有用到过滤器：浏览器通过http请求发送数据给Servlet，如果存在中文，就必须指定编码，否则就会乱码！</p>
<p>jsp页面提交中文数据给Servlet处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/Demo1&quot; method=&quot;post&quot;&gt;</div><div class="line"></div><div class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</div><div class="line"></div><div class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</div><div class="line"></div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>Servlet没有指定编码的情况下，获取得到的是乱码：</p>
<p><img src="/images/Java-过滤器-02.png" alt="中文乱码" title="Java-过滤器-02"></p>
<p>也就是说：如果我每次接受客户端带过来的中文数据，在Serlvet中都要设定编码。这样代码的重复率太高了！！！！</p>
<p><strong>方法二</strong>：用过滤器解决中文乱码问题。有过滤器的情况就不一样了：只要我在过滤器中指定了编码，可以使全站的Web资源都是使用该编码，并且重用性是非常理想的！还有一个好处是：如果需要换另一种编码，只需要改变一处。</p>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>要使用过滤器，只要Java类实现了Filter接口就可以称为过滤器！Filter接口的方法也十分简单：</p>
<p><img src="/images/Java-过滤器-03.png" alt="实现接口" title="Java-过滤器-03"></p>
<p>其中init()和destory()方法就不用多说了，他俩跟Servlet是一样的。只有在Web服务器加载和销毁的时候被执行，只会被执行一次！</p>
<p>值得注意的是doFilter()方法,它有三个参数(ServletRequest,ServletResponse,FilterChain),从前两个参数我们可以发现：过滤器可以完成任何协议的过滤操作！</p>
<p>那FilterChain是什么东西呢？我们看看：</p>
<p><img src="/images/Java-过滤器-04.png" alt="enter description here" title="Java-过滤器-04"></p>
<p>FilterChain是一个接口，里面又定义了doFilter()方法。这究竟是怎么回事啊？？？？？？</p>
<p>FilterChain接口you容器实现，容器将其实例作为参数传入过滤器对象的doFilter()方法中。过滤器对象使用FilterChain对象调用过滤器链中的下一个过滤器，如果该过滤器是链中的最后一个过滤器，那么将调用目标资源。</p>
<p>我们可以这样理解：过滤器不单单只有一个，那么我们怎么管理这些过滤器呢？在Java中就使用了链式结构。把所有的过滤器都放在FilterChain里边，如果符合条件，就执行下一个过滤器（如果没有过滤器了，就执行目标资源）。</p>
<p>上面的话好像有点拗口，我们可以想象生活的例子：现在我想在茶杯上能过滤出石头和茶叶出来。石头在一层，茶叶在一层。所以茶杯的过滤装置应该有两层滤网。这个过滤装置就是FilterChain，过滤石头的滤网和过滤茶叶的滤网就是Filter。在石头滤网中，茶叶是属于下一层的，就把茶叶放行，让茶叶的滤网过滤茶叶。过滤完茶叶了，剩下的就是茶（茶就可以比喻成我们的目标资源）</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Filter开发两步走</p>
<ul>
<li>编写java类实现Filter接口，并实现其doFilter方法。</li>
<li>在 web.xml 文件中使用和元素对编写的filter类进行注册，并设置它所能拦截的资源。</li>
</ul>
<p>写一个简单的过滤器。</p>
<ol>
<li><p>实现Filter接口的Java类就被称作为过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class FilterDemo1 implements Filter &#123;</div><div class="line">	    public void destroy() &#123;</div><div class="line">	    &#125;</div><div class="line">	</div><div class="line">	    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line">	</div><div class="line">	        //执行这一句，说明放行（让下一个过滤器执行，如果没有过滤器了，就执行执行目标资源）</div><div class="line">	        chain.doFilter(req, resp);</div><div class="line">	    &#125;</div><div class="line">	</div><div class="line">	    public void init(FilterConfig config) throws ServletException &#123;</div><div class="line">	        </div><div class="line">	    &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>filter部署(过滤器和Servlet是一样的，需要部署到Web服务器上的。)</p>
<ul>
<li><p>第一种方式：在web.xml文件中配置</p>
<ul>
<li><p>filter<br><filter>用于注册过滤器</filter></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">      &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt;</div><div class="line">     &lt;filter-class&gt;FilterDemo1&lt;/filter-class&gt;</div><div class="line">     &lt;init-param&gt;</div><div class="line">	 &lt;param-name&gt;word_file&lt;/param-name&gt;	</div><div class="line">	 &lt;param-value&gt;/WEB-INF/word.txt&lt;/param-value&gt;</div><div class="line">     &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line"></div><div class="line">&lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空。</div><div class="line">&lt;filter-class&gt;元素用于指定过滤器的完整的限定类名。</div><div class="line">&lt;init-param&gt;元素用于为过滤器指定初始化参数，它的子元素指定参数的名字，&lt;param-value&gt;指定参数的值。在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。</div></pre></td></tr></table></figure>
</li>
<li><p>filter-mapping<br><filter-mapping>元素用于设置一个Filter 所负责拦截的资源。<br>一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径。</filter-mapping></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">    &lt;dispatcher&gt;REQUEST&lt;dispatcher&gt;</div><div class="line">&lt;/filter-mapping&gt;</div><div class="line"></div><div class="line">&lt;filter-name&gt;子元素用于设置filter的注册名称。该值必须是在元素中声明过的过滤器的名字</div><div class="line">&lt;url-pattern&gt;设置 filter 所拦截的请求路径(过滤器关联的URL样式)</div><div class="line">&lt;servlet-name&gt;指定过滤器所拦截的Servlet名称。</div><div class="line">&lt;dispatcher&gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&lt;dispatcher&gt; 子元素用来指定 Filter 对资源的多种调用方式进行拦截。</div></pre></td></tr></table></figure>
</li>
<li><p>dispatcher<br>子元素可以设置的值及其意义：</p>
<ul>
<li>REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。</li>
<li>INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li>
<li>FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li>
<li>ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li>
</ul>
</li>
</ul>
</li>
<li><p>第二种方式：通过注解配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@WebFilter(filterName = &quot;FilterDemo1&quot;,urlPatterns = &quot;/*&quot;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>上面的配置是“/*”，所有的Web资源都需要途径过滤器</p>
<p>如果想要部分的Web资源进行过滤器过滤则需要指定Web资源的名称即可！</p>
<h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><p>过滤器的应用场景</p>
<ul>
<li>执行目标资源之前做预处理工作，例如设置编码，这种试通常都会放行，只是在目标资源执行之前做一些准备工作；</li>
<li>通过条件判断是否放行，例如校验当前用户是否已经登录，或者用户IP是否已经被禁用；</li>
<li>在目标资源执行后，做一些后续的特殊处理工作，例如把目标资源输出的数据进行处理</li>
</ul>
<h4 id="编码过滤器"><a href="#编码过滤器" class="headerlink" title="编码过滤器"></a>编码过滤器</h4><p>目的：解决全站的乱码问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">      //将request和response强转成http协议的</div><div class="line">      HttpServletRequest httpServletRequest = (HttpServletRequest) req;</div><div class="line">      HttpServletResponse httpServletResponse = (HttpServletResponse) resp;</div><div class="line"></div><div class="line">      httpServletRequest.setCharacterEncoding(&quot;UTF-8&quot;);</div><div class="line">      httpServletResponse.setCharacterEncoding(&quot;UTF-8&quot;);</div><div class="line">      httpServletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);</div><div class="line">      </div><div class="line">      chain.doFilter(httpServletRequest, httpServletResponse);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="敏感词的过滤器"><a href="#敏感词的过滤器" class="headerlink" title="敏感词的过滤器"></a>敏感词的过滤器</h4><p>如果用户输入了敏感词（傻b、尼玛、操蛋等等不文明语言时），我们要将这些不文明用于屏蔽掉，替换成符号！<br>要实现这样的功能也很简单，用户输入的敏感词肯定是在getParameter()获取的，我们在getParameter()得到这些数据的时候，判断有没有敏感词汇，如果有就替换掉就好了！简单来说：就是要增强request对象</p>
<p><strong>增强request对象</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class MyDirtyRequest extends HttpServletRequestWrapper &#123;</div><div class="line">	</div><div class="line">	    HttpServletRequest request;</div><div class="line">	</div><div class="line">	    //定义一堆敏感词汇</div><div class="line">	    private List&lt;String&gt; list = Arrays.asList(&quot;傻b&quot;, &quot;尼玛&quot;, &quot;操蛋&quot;);</div><div class="line">	</div><div class="line">	    public MyDirtyRequest(HttpServletRequest request) &#123;</div><div class="line">	        super(request);</div><div class="line">	        this.request = request;</div><div class="line">	    &#125;</div><div class="line">	</div><div class="line">	    @Override</div><div class="line">	    public String getParameter(String name) &#123;</div><div class="line">	</div><div class="line">	        String value = this.request.getParameter(name);</div><div class="line">	</div><div class="line">	        if (value == null) &#123;</div><div class="line">	            return null;</div><div class="line">	        &#125;</div><div class="line">	</div><div class="line">	        //遍历list集合，看看获取得到的数据有没有敏感词汇</div><div class="line">	        for (String s : list) &#123;</div><div class="line">	</div><div class="line">	            if (s.equals(value)) &#123;</div><div class="line">	                value = &quot;*****&quot;;</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">	</div><div class="line">	        return value ;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>开发过滤器</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">       //将request和response强转成http协议的</div><div class="line">       HttpServletRequest httpServletRequest = (HttpServletRequest) req;</div><div class="line">       HttpServletResponse httpServletResponse = (HttpServletResponse) resp;</div><div class="line"></div><div class="line">       MyDirtyRequest dirtyRequest = new MyDirtyRequest(httpServletRequest);</div><div class="line"></div><div class="line">       //传送给目标资源的是被增强后的request对象</div><div class="line">       chain.doFilter(dirtyRequest, httpServletResponse);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="压缩资源过滤器"><a href="#压缩资源过滤器" class="headerlink" title="压缩资源过滤器"></a>压缩资源过滤器</h4><p>按照过滤器的执行顺序：执行完目标资源，过滤器后面的代码还会执行。所以，我们在过滤器中可以获取执行完目标资源后的response对象！<br>我们知道sun公司提供的response对象调用write()方法，是直接把数据返回给浏览器的。我们要想实现压缩的功能，write()方法就不能直接把数据写到浏览器上！<br>这和上面是类似的，过滤器传递给目标资源的response对象就需要被我们增强，使得目标资源调用writer()方法的时候不把数据直接写到浏览器上！</p>
<p><strong>增强response对象</strong></p>
<p>response对象可能会使用PrintWriter或者ServletOutputStream对象来调用writer()方法的，所以我们增强response对象的时候，需要把getOutputSteam和getWriter()重写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">class MyResponse extends HttpServletResponseWrapper&#123;</div><div class="line"></div><div class="line">    private ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</div><div class="line"></div><div class="line">    private PrintWriter printWriter ;</div><div class="line"></div><div class="line">    private HttpServletResponse response;</div><div class="line">    public MyResponse(HttpServletResponse response) &#123;</div><div class="line">        super(response);</div><div class="line">        this.response = response;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ServletOutputStream getOutputStream() throws IOException &#123;</div><div class="line"></div><div class="line">        //这个的ServletOutputSteam对象调用write()方法的时候，把数据是写在byteArrayOutputSteam上的</div><div class="line">        return new MyServletOutputStream(byteArrayOutputStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public PrintWriter getWriter() throws IOException &#123;</div><div class="line">        printWriter = new PrintWriter(new OutputStreamWriter(byteArrayOutputStream, this.response.getCharacterEncoding()));</div><div class="line"></div><div class="line">        return printWriter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public byte[] getBuffer() &#123;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line"></div><div class="line">            //防止数据在缓存中，要刷新一下！</div><div class="line">            if (printWriter != null) &#123;</div><div class="line">                printWriter.close();</div><div class="line">            &#125;</div><div class="line">            if (byteArrayOutputStream != null) &#123;</div><div class="line">                byteArrayOutputStream.flush();</div><div class="line">                return byteArrayOutputStream.toByteArray();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>过滤器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line"></div><div class="line"></div><div class="line">        HttpServletRequest request = (HttpServletRequest) req;</div><div class="line">        HttpServletResponse response = (HttpServletResponse) resp;</div><div class="line">        MyResponse myResponse = new MyResponse(response);</div><div class="line"></div><div class="line">        //把被增强的response对象传递进去，目标资源调用write()方法的时候就不会直接把数据写在浏览器上了</div><div class="line">        chain.doFilter(request, myResponse);</div><div class="line"></div><div class="line">        //得到目标资源想要返回给浏览器的数据</div><div class="line">        byte[] bytes = myResponse.getBuffer();</div><div class="line"></div><div class="line">        //输出原来的大小</div><div class="line">        System.out.println(&quot;压缩前：&quot;+bytes.length);</div><div class="line"></div><div class="line">        </div><div class="line">        //使用GZIP来压缩资源，再返回给浏览器</div><div class="line">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</div><div class="line">        GZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);</div><div class="line">        gzipOutputStream.write(bytes);</div><div class="line">        </div><div class="line">        //得到压缩后的数据</div><div class="line">        byte[] gzip = byteArrayOutputStream.toByteArray();</div><div class="line">        </div><div class="line">        System.out.println(&quot;压缩后：&quot; + gzip.length);</div><div class="line">        </div><div class="line">        //还要设置头，告诉浏览器，这是压缩数据！</div><div class="line">        response.setHeader(&quot;content-encoding&quot;, &quot;gzip&quot;);</div><div class="line">        response.setContentLength(gzip.length);</div><div class="line">        response.getOutputStream().write(gzip);</div><div class="line">     </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="HTML转义过滤器"><a href="#HTML转义过滤器" class="headerlink" title="HTML转义过滤器"></a>HTML转义过滤器</h4><p>只要把getParameter()获取得到的数据转义一遍，就可以完成功能了。</p>
<p><strong>增强request</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">class MyHtmlRequest extends HttpServletRequestWrapper&#123;</div><div class="line"></div><div class="line">    private HttpServletRequest request;</div><div class="line"></div><div class="line">    public MyHtmlRequest(HttpServletRequest request) &#123;</div><div class="line">        super(request);</div><div class="line">        this.request = request;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getParameter(String name) &#123;</div><div class="line"></div><div class="line">        String value = this.request.getParameter(name);</div><div class="line">        return this.Filter(value);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String Filter(String message) &#123;</div><div class="line">        if (message == null)</div><div class="line">            return (null);</div><div class="line"></div><div class="line">        char content[] = new char[message.length()];</div><div class="line">        message.getChars(0, message.length(), content, 0);</div><div class="line">        StringBuffer result = new StringBuffer(content.length + 50);</div><div class="line">        for (int i = 0; i &lt; content.length; i++) &#123;</div><div class="line">            switch (content[i]) &#123;</div><div class="line">                case &apos;&lt;&apos;:</div><div class="line">                    result.append(&quot;&amp;lt;&quot;);</div><div class="line">                    break;</div><div class="line">                case &apos;&gt;&apos;:</div><div class="line">                    result.append(&quot;&amp;gt;&quot;);</div><div class="line">                    break;</div><div class="line">                case &apos;&amp;&apos;:</div><div class="line">                    result.append(&quot;&amp;amp;&quot;);</div><div class="line">                    break;</div><div class="line">                case &apos;&quot;&apos;:</div><div class="line">                    result.append(&quot;&amp;quot;&quot;);</div><div class="line">                    break;</div><div class="line">                default:</div><div class="line">                    result.append(content[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return (result.toString());</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>过滤器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    HttpServletRequest request = (HttpServletRequest) req;</div><div class="line">    HttpServletResponse response = (HttpServletResponse) resp;</div><div class="line">    MyHtmlRequest myHtmlRequest = new MyHtmlRequest(request);</div><div class="line"></div><div class="line">    //传入的是被增强的request！</div><div class="line">    chain.doFilter(myHtmlRequest, response);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓存数据到内存中"><a href="#缓存数据到内存中" class="headerlink" title="缓存数据到内存中"></a>缓存数据到内存中</h4><p>在前面我们已经做过了，让浏览器不缓存数据【验证码的图片是不应该缓存的】。<br>现在我们要做的是：缓存数据到内存中【如果某个资源重复使用，不轻易变化，应该缓存到内存中】<br>这个和压缩数据的Filter非常类似的，因为让数据不直接输出给浏览器，把数据用一个容器（ByteArrayOutputSteam）存起来。如果已经有缓存了，就取缓存的。没有缓存就执行目标资源！</p>
<p><strong>增强response对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">class MyResponse extends HttpServletResponseWrapper &#123;</div><div class="line"></div><div class="line">    private ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</div><div class="line"></div><div class="line">    private PrintWriter printWriter ;</div><div class="line"></div><div class="line">    private HttpServletResponse response;</div><div class="line">    public MyResponse(HttpServletResponse response) &#123;</div><div class="line">        super(response);</div><div class="line">        this.response = response;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ServletOutputStream getOutputStream() throws IOException &#123;</div><div class="line"></div><div class="line">        //这个的ServletOutputSteam对象调用write()方法的时候，把数据是写在byteArrayOutputSteam上的</div><div class="line">        return new MyServletOutputStream(byteArrayOutputStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public PrintWriter getWriter() throws IOException &#123;</div><div class="line">        printWriter = new PrintWriter(new OutputStreamWriter(byteArrayOutputStream, this.response.getCharacterEncoding()));</div><div class="line"></div><div class="line">        return printWriter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public byte[] getBuffer() &#123;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line"></div><div class="line">            //防止数据在缓存中，要刷新一下！</div><div class="line">            if (printWriter != null) &#123;</div><div class="line">                printWriter.close();</div><div class="line">            &#125;</div><div class="line">            if (byteArrayOutputStream != null) &#123;</div><div class="line">                byteArrayOutputStream.flush();</div><div class="line">                return byteArrayOutputStream.toByteArray();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//增强ServletOutputSteam，让writer方法不把数据直接返回给浏览器</div><div class="line"></div><div class="line">class MyServletOutputStream extends ServletOutputStream &#123;</div><div class="line"></div><div class="line">    private ByteArrayOutputStream byteArrayOutputStream;</div><div class="line"></div><div class="line">    public MyServletOutputStream(ByteArrayOutputStream byteArrayOutputStream) &#123;</div><div class="line">        this.byteArrayOutputStream = byteArrayOutputStream;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //当调用write()方法的时候，其实是把数据写byteArrayOutputSteam上</div><div class="line">    @Override</div><div class="line">    public void write(int b) throws IOException &#123;</div><div class="line">        this.byteArrayOutputStream.write(b);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>过滤器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">    //定义一个Map集合，key为页面的地址，value为内存的缓存</div><div class="line">    Map&lt;String, byte[]&gt; map = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    HttpServletRequest request = (HttpServletRequest) req;</div><div class="line">    HttpServletResponse response = (HttpServletResponse) resp;</div><div class="line"></div><div class="line">    //得到客户端想要请求的资源</div><div class="line">    String uri = request.getRequestURI();</div><div class="line">    byte[] bytes = map.get(uri);</div><div class="line"></div><div class="line">    //如果有缓存，直接返回给浏览器就行了，就不用执行目标资源了</div><div class="line">    if (bytes != null) &#123;</div><div class="line">        response.getOutputStream().write(bytes);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //如果没有缓存，就让目标执行</div><div class="line">    MyResponse myResponse = new MyResponse(response);</div><div class="line">    chain.doFilter(request, myResponse);</div><div class="line"></div><div class="line">    //得到目标资源想要发送给浏览器的数据</div><div class="line">    byte[] b = myResponse.getBuffer();</div><div class="line"></div><div class="line">    //把数据存到集合中</div><div class="line">    map.put(uri, b);</div><div class="line"></div><div class="line">    //把数据返回给浏览器</div><div class="line">    response.getOutputStream().write(b);</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用Filter验证用户登录安全控制"><a href="#使用Filter验证用户登录安全控制" class="headerlink" title="使用Filter验证用户登录安全控制"></a>使用Filter验证用户登录安全控制</h4><p>先在web.xml配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;SessionFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;com.action.login.SessionFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;logonStrings&lt;/param-name&gt;&lt;!-- 对登录页面不进行过滤 --&gt;</div><div class="line">        &lt;param-value&gt;/project/index.jsp;login.do&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;includeStrings&lt;/param-name&gt;&lt;!-- 只对指定过滤参数后缀进行过滤 --&gt;</div><div class="line">        &lt;param-value&gt;.do;.jsp&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;redirectPath&lt;/param-name&gt;&lt;!-- 未通过跳转到登录界面 --&gt;</div><div class="line">        &lt;param-value&gt;/index.jsp&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;disabletestfilter&lt;/param-name&gt;&lt;!-- Y:过滤无效 --&gt;</div><div class="line">        &lt;param-value&gt;N&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;SessionFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
<p>接着编写FilterServlet.java：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">package com.action.login;</div><div class="line">import java.io.IOException;</div><div class="line">import javax.servlet.Filter;</div><div class="line">import javax.servlet.FilterChain;</div><div class="line">import javax.servlet.FilterConfig;</div><div class="line">import javax.servlet.ServletException;</div><div class="line">import javax.servlet.ServletRequest;</div><div class="line">import javax.servlet.ServletResponse;</div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line">import javax.servlet.http.HttpServletResponseWrapper;</div><div class="line">/**</div><div class="line"> *    判断用户是否登录,未登录则退出系统</div><div class="line"> */</div><div class="line">public class SessionFilter implements Filter &#123;</div><div class="line">    </div><div class="line">    public FilterConfig config;</div><div class="line">    </div><div class="line">    public void destroy() &#123;</div><div class="line">        this.config = null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static boolean isContains(String container, String[] regx) &#123;</div><div class="line">        boolean result = false;</div><div class="line">        for (int i = 0; i &lt; regx.length; i++) &#123;</div><div class="line">            if (container.indexOf(regx[i]) != -1) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</div><div class="line">        HttpServletRequest hrequest = (HttpServletRequest)request;</div><div class="line">        HttpServletResponseWrapper wrapper = new HttpServletResponseWrapper((HttpServletResponse) response);</div><div class="line">        </div><div class="line">        String logonStrings = config.getInitParameter(&quot;logonStrings&quot;);        // 登录登陆页面</div><div class="line">        String includeStrings = config.getInitParameter(&quot;includeStrings&quot;);    // 过滤资源后缀参数</div><div class="line">        String redirectPath = hrequest.getContextPath() + config.getInitParameter(&quot;redirectPath&quot;);// 没有登陆转向页面</div><div class="line">        String disabletestfilter = config.getInitParameter(&quot;disabletestfilter&quot;);// 过滤器是否有效</div><div class="line">        </div><div class="line">        if (disabletestfilter.toUpperCase().equals(&quot;Y&quot;)) &#123;    // 过滤无效</div><div class="line">            chain.doFilter(request, response);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        String[] logonList = logonStrings.split(&quot;;&quot;);</div><div class="line">        String[] includeList = includeStrings.split(&quot;;&quot;);</div><div class="line">        </div><div class="line">        if (!this.isContains(hrequest.getRequestURI(), includeList)) &#123;// 只对指定过滤参数后缀进行过滤</div><div class="line">            chain.doFilter(request, response);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (this.isContains(hrequest.getRequestURI(), logonList)) &#123;// 对登录页面不进行过滤</div><div class="line">            chain.doFilter(request, response);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        String user = ( String ) hrequest.getSession().getAttribute(&quot;useronly&quot;);//判断用户是否登录</div><div class="line">        if (user == null) &#123;</div><div class="line">            wrapper.sendRedirect(redirectPath);</div><div class="line">            return;</div><div class="line">        &#125;else &#123;</div><div class="line">            chain.doFilter(request, response);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</div><div class="line">        config = filterConfig;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样既可完成对用户所有请求，均要经过这个Filter进行验证用户登录</p>
<h4 id="Spring-Hibernate的OpenSessionInViewFilter控制session的开关"><a href="#Spring-Hibernate的OpenSessionInViewFilter控制session的开关" class="headerlink" title="Spring+Hibernate的OpenSessionInViewFilter控制session的开关"></a>Spring+Hibernate的OpenSessionInViewFilter控制session的开关</h4><p>当hibernate+spring配合使用的时候，如果设置了lazy=true（延迟加载）,那么在读取数据的时候，当读取了父数据后，hibernate 会自动关闭session，这样，当要使用与之关联数据、子数据的时候，系统会抛出lazyinit的错误，这时就需要使用spring提供的OpenSessionInViewFilter过滤器。</p>
<p>OpenSessionInViewFilter主要是保持Session状态直到request将全部页面发送到客户端，直到请求结束后才关闭session，这样就可以解决延迟加载带来的问题。</p>
<p>注意：OpenSessionInViewFilter配置要写在struts2的配置前面。因为tomcat容器在加载过滤器的时候是按照顺序加载的，如果配置文件先写的是struts2的过滤器配置，然后才是OpenSessionInViewFilter过滤器配置，所以加载的顺序导致，action在获得数据的时候session并没有被spring管理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;&lt;!-- lazy loading enabled in spring --&gt;</div><div class="line">    &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;org.springframework.orm.hibernate3.support.OpenSessionInViewFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;sessionFactoryBeanName&lt;/param-name&gt;&lt;!-- 可缺省。默认是从spring容器中找id为sessionFactory的bean，如果id不为sessionFactory，则需要配置如下，此处SessionFactory为spring容器中的bean。 --&gt;</div><div class="line">        &lt;param-value&gt;sessionFactory&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;singleSession&lt;/param-name&gt;&lt;!-- singleSession默认为true,若设为false则等于没用OpenSessionInView --&gt;</div><div class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<h3 id="FilterConfig接口"><a href="#FilterConfig接口" class="headerlink" title="FilterConfig接口"></a>FilterConfig接口</h3><p>用户在配置filter时，可以使用为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得以下内容：</p>
<pre><code>String getFilterName();//得到filter的名称。 
String getInitParameter(String name);//返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. 
Enumeration getInitParameterNames();//返回过滤器的所有初始化参数的名字的枚举集合。 
public ServletContext getServletContext();//返回Servlet上下文对象的引用。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What-is-it&quot;&gt;&lt;a href=&quot;#What-is-it&quot; class=&quot;headerlink&quot; title=&quot;What is it?&quot;&gt;&lt;/a&gt;What is it?&lt;/h3&gt;&lt;p&gt;过滤器是Servlet的高级特性之一，也别把它想得那么高深，只不过是实现
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>机器学习|2-逻辑回归</title>
    <link href="http://yoursite.com/2018/02/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-2-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2018/02/28/机器学习-2-逻辑回归/</id>
    <published>2018-02-28T10:54:56.000Z</published>
    <updated>2018-02-28T03:24:11.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分类-Classification"><a href="#分类-Classification" class="headerlink" title="分类(Classification)"></a>分类(Classification)</h3><p>和回归(Regression)一样，分类(Classification)问题也是机器学习里面很大的一块。</p>
<blockquote>
<p>分类问题是机器学习非常重要的一个组成部分，它的目标是根据已知样本的某些特征，判断一个新的样本属于哪种已知的样本类。</p>
</blockquote>
<p>其实常见的例子很多，判断一个邮件是否是垃圾邮件之类的，预测一个用户是否对我的商品感兴趣，以及图像处理里面对图像进行的分类。</p>
<p><img src="/images/机器学习-逻辑回归-01.jpg" alt="机器学习-逻辑回归" title="机器学习-逻辑回归-01"></p>
<p>分类问题有简单的二分类也有多分类。</p>
<h3 id="逻辑回归LR-Logistic-Regression"><a href="#逻辑回归LR-Logistic-Regression" class="headerlink" title="逻辑回归LR(Logistic Regression)"></a>逻辑回归LR(Logistic Regression)</h3><p>看到名字的时候你可能会有一些奇怪，为什么明明叫逻辑“回归”却用在分类问题上。虽然这个名字似乎指示着什么，但是逻辑回归实际上是分类算法。我猜它之所以这样命名是因为在它的学习方法上和线性回归相似，但是损失(loss)和梯度(gradient)函数的表达不同。特别的，逻辑回归使用 S型函数(sigmoid)而不是线性回归的连续输出。当我们深入到实现中去，我们会了解到更多。</p>
<p>首先我们先把逻辑回归放到一边，之前也说了逻辑回归是用来解决分类问题的，对于分类问题，我们实际上是希望得到一个分类器(Classifier)，当输入数据之后，这个分类器能给我预测这个数据属于某一类的概率，也就是说我们需要的是一个<strong>概率</strong>。</p>
<p>上一节我们介绍的线性回归，其输出的是预测值，其假设函数(Hypothesis Function)也就是输出预测值的函数是这样的。</p>
<p><img src="/images/机器学习-逻辑回归-02.jpg" alt="机器学习-逻辑回归" title="机器学习-逻辑回归-02"></p>
<p>而逻辑回归则是预测属于某一类的概率，所以我们让其假设函数是下面这个：</p>
<p><img src="/images/机器学习-逻辑回归-03.jpg" alt="机器学习-逻辑回归" title="机器学习-逻辑回归-03"></p>
<p>这个函数的意义其实是<strong>当输入为x时，输出y=1的概率</strong>，其实就是二分类问题里面是某个东西的概率。读者现在可能会对这个函数有所疑问，比如为什么是这个函数，这个留在后面会讨论。</p>
<p><img src="/images/机器学习-逻辑回归-04.jpg" alt="机器学习-逻辑回归" title="机器学习-逻辑回归-04"></p>
<blockquote>
<p>这里出现了条件概率，实际上就是指事件A在另外一个事件B已经发生条件下的发生概率。</p>
</blockquote>
<p>我们把这个函数g(z)叫做sigmoid函数，很明显这个函数的值域是0到1的开区间。接下来我们会详细介绍一下这个函数。</p>
<h4 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h4><p>Sigmoid函数的函数表达式如下:</p>
<p><img src="/images/机器学习-逻辑回归-05.jpg" alt="Sigmoid函数" title="机器学习-逻辑回归-05"></p>
<p><img src="/images/机器学习-逻辑回归-06.jpg" alt="Sigmoid函数图像" title="机器学习-逻辑回归-06"></p>
<h4 id="损失函数-Loss-Function"><a href="#损失函数-Loss-Function" class="headerlink" title="损失函数(Loss Function)"></a>损失函数(Loss Function)</h4><p>上一小节我们也说过，为了修正参数Θ我们需要有个手段来衡量当前参数Θ的优秀程度。损失函数(Loss Function)就是用来衡量假设函数(hypothesis function)的准确性。</p>
<p>对于逻辑回归来说，我们希望的是当预测概率约接近实际情况(0或1)的时候误差最小，而且不希望曲线是一条直线，而是对于越接近的地方变化越小，约远离的地方变化越大的函数。</p>
<p>下面就是逻辑回归的损失函数。</p>
<p><img src="/images/机器学习-逻辑回归-07.jpg" alt="损失函数" title="机器学习-逻辑回归-07"></p>
<p><img src="/images/机器学习-逻辑回归-08.jpg" alt="损失函数" title="机器学习-逻辑回归-08"></p>
<p>我们可以将函数合并一下，毕竟这种分段函数处理起来不是很舒服，其实就是下图这样，也很好理解，毕竟二分类训练数据y只有0和1两个值。</p>
<p><img src="/images/机器学习-逻辑回归-09.jpg" alt="enter description here" title="机器学习-逻辑回归-09"></p>
<p>这样我们就可以算出在一个训练集中基于当前参数Θ得到结果的误差了。</p>
<p><img src="/images/机器学习-逻辑回归-10.jpg" alt="enter description here" title="机器学习-逻辑回归-10"></p>
<h4 id="矢量化编程"><a href="#矢量化编程" class="headerlink" title="矢量化编程"></a>矢量化编程</h4><p>矢量化编程是提高算法速度的一种有效方法。为了提升特定数值运算操作（如矩阵相乘、矩阵相加、矩阵-向量乘法等）的速度，数值计算和并行计算的研究人员已经努力了几十年。矢量化编程的思想就是尽量使用这些被高度优化的数值运算操作来实现我们的学习算法。</p>
<p>换句话说就是尽量避免使用for循环，毕竟矩阵相乘这种场景非常适合并行计算，在巨量的数据面前性能收益非常明显。</p>
<p>如果刚刚的损失函数用矢量化编程的思想来表示的话</p>
<p><img src="/images/机器学习-逻辑回归-11.jpg" alt="矢量化编程" title="机器学习-逻辑回归-11"></p>
<p>如果一时不理解的话我先解释一下，我们先假设共m个数据，而这个模型中变量有n个。则矩阵h就是(m, n) X (n, 1)也就是(m,1)矩阵，矩阵h的意义就是这m个数据的预测值。<br>损失函数中y的转置为(1, m)，相乘后得到(1, 1)也就是一个值，这两个矩阵相乘的意义则是对应的预测值取对数乘以对应的实际值，最后加在一起。</p>
<blockquote>
<p>(m,n)表示维度为m行n列的矩阵，如果学过矩阵的乘法应该知道矩阵相乘(m, n) X (n, k)得到的矩阵是(m, k)</p>
</blockquote>
<h4 id="逻辑回归的梯度下降法-Gradient-Descent"><a href="#逻辑回归的梯度下降法-Gradient-Descent" class="headerlink" title="逻辑回归的梯度下降法(Gradient Descent)"></a>逻辑回归的梯度下降法(Gradient Descent)</h4><p>我们刚刚知道了怎么评价当前参数Θ的好坏，现在我们需要做的是使用梯度下降法来调整参数。</p>
<p><img src="/images/机器学习-逻辑回归-12.jpg" alt="" title="机器学习-逻辑回归-12"></p>
<p>依旧是对损失函数求偏导数，别忘记α是学习速率的意思。</p>
<p><img src="/images/机器学习-逻辑回归-13.jpg" alt="" title="机器学习-逻辑回归-13"></p>
<p>矢量化表示为</p>
<p><img src="/images/机器学习-逻辑回归-14.jpg" alt="" title="机器学习-逻辑回归-14"></p>
<h5 id="损失函数偏导数求解过程-选修"><a href="#损失函数偏导数求解过程-选修" class="headerlink" title="损失函数偏导数求解过程(选修)"></a>损失函数偏导数求解过程(选修)</h5><p><img src="/images/机器学习-逻辑回归-15.jpg" alt="损失函数偏导数求解过程" title="机器学习-逻辑回归-15"></p>
<h3 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h3><p>对于一个训练数据集，可视化后如下图所示。</p>
<p><img src="/images/机器学习-逻辑回归-16.jpg" alt="" title="机器学习-逻辑回归-16"></p>
<p>对于三个不同的分类器划分出的边界的三种情况，我们对其有不同的称呼.</p>
<p><img src="/images/机器学习-逻辑回归-17.jpg" alt="" title="机器学习-逻辑回归-17"></p>
<p>第一种，分类非常不准，这种我们叫欠拟合(underfitting)<br>第二种，分类得恰到好处，这种其实没有特别的称呼。<br>第三种，分类太过于契合训练数据了。这种我们称为过拟合(overfitting)<br>过拟合所产生的问题也很明显，它实在太过于契合训练集了，对于我们来说，第二个曲线才是我们想要的，过拟合的结果太过于契合训练数据，实用性可想而知的低。</p>
<p>而解决过拟合的方法主要有两种</p>
<ul>
<li>减少特征的数量，这个很好理解，更多的特征意味着划分出来的函数曲线可以越复杂。这个可以扩展到以后会讲的特征工程(Feature Engineering)</li>
<li>使用正则化项， 保持所有的特征，但是保证参数θj不会变得巨大。正则化项非常适合在我们拥有很多稍微有点用的特征的时候。</li>
</ul>
<h4 id="正则化项-regularizer"><a href="#正则化项-regularizer" class="headerlink" title="正则化项(regularizer)"></a>正则化项(regularizer)</h4><p>正则化项其实也叫惩罚项(penalty term)，其作用是减缓过拟合问题，其实就是在损失函数后面加一个含有各个Θ的项，这样做的目的是让Θ也参与损失函数的计算，这样由于我们需要求的是损失函数的最小值，这个项就会限制Θ的大小。</p>
<p>这个正则化项的目的其实是一个权衡，我们即希望参数Θ能在训练数据集上表现得比较好，又不希望参数Θ训练出来的值非常大而产生一些奇葩的划分曲线，就像下图这样的。</p>
<p><img src="/images/机器学习-逻辑回归-18.jpg" alt="过拟合" title="机器学习-逻辑回归-18"></p>
<blockquote>
<p>转载 <a href="https://juejin.im/post/5a40e8e46fb9a0450671dd2f" target="_blank" rel="external">https://juejin.im/post/5a40e8e46fb9a0450671dd2f</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分类-Classification&quot;&gt;&lt;a href=&quot;#分类-Classification&quot; class=&quot;headerlink&quot; title=&quot;分类(Classification)&quot;&gt;&lt;/a&gt;分类(Classification)&lt;/h3&gt;&lt;p&gt;和回归(Regr
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/machine/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习|1-线性回归</title>
    <link href="http://yoursite.com/2018/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-1-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2018/02/27/机器学习-1-线性回归/</id>
    <published>2018-02-26T18:37:58.000Z</published>
    <updated>2018-02-26T15:46:51.948Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<blockquote>
<p>机器学习(Machine Learning, ML)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p>
</blockquote>
<p>自己作为计算机专业的一员，在写了几个只要增删改查的项目后，发现自己对写代码这个活动不是很有兴趣了，有点厌倦了。现在业内人都在说人工智能、机器学习等高大尚的东西，起初自己认为这些东西不是本科生能掌握的东西，但接触后发现自己错了，也就是那么一回事。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章的主角是线性回归，也就是LR(Linear Regression)，是机器学习得基础算法。</p>
<p>回归(Regression)问题是机器学习里面很大的一块。</p>
<blockquote>
<p>统计学中，回归分析（regression analysis)指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。回归分析按照涉及的变量的多少，分为一元回归和多元回归分析；按照因变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析。</p>
</blockquote>
<p>不玩定义，直接上例子，设想一下这样的场景： 如果我现在有了一组(身高, 体重)的数据集，可以令身高为x值，体重为y值将其画在纸上，就和下图一样。</p>
<p><img src="/images/机器学习-线性回归-01.png" alt="机器学习-线性回归" title="机器学习-线性回归-01"></p>
<p>那么现在问题来了，假设我身高为1.8m，能不能预测出我的体重？这就是回归要解决的问题，我希望得到一个函数，我输入我的身高之后他能够帮我预测出我的体重。<br>在这个例子里，我假设身高和体重的关系是线性关系，所以假设模型是y=kx+b这种一次函数，为了确定变量k和b，我需要利用之前的数据去学习出这两个参数。<br>尽管上面的例子误差很大。因为体重的函数肯定不单单由身高这一个特征(feature)决定，而且即使只有身高一个特征，最佳函数也很可能不是一次函数。</p>
<h4 id="回归问题相关概念"><a href="#回归问题相关概念" class="headerlink" title="回归问题相关概念"></a>回归问题相关概念</h4><p>通常，这类预测问题可以用回归(regression)模型进行解决，回归模型定义了输入与输出的关系，输入即现有知识，而输出则为预测。<br>一个预测问题在回归模型下的解决步骤为：</p>
<ul>
<li>积累知识： 我们将储备的知识称之为训练集(Training Set)，毕竟预测是需要过去的数据作为参考的，这个很好理解。</li>
<li>学习：当我们有了数据的时候，我们就需要去学习这些数据，为什么说机器学习智能？因为当我告诉计算机我的模型是线性(一次函数)或其他类型的函数然后把数据直接倒进去之后它就能返回给我最后的函数(参数都训练好了)。</li>
<li>预测：学习完成后，当接受了新的数据（输入）后，我们就能通过学习阶段获得的对应关系来预测输出。</li>
</ul>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>这篇博客主要讲的是线性回归(Linear regression)，经过前言后大家也知道了，回归里面用到的函数有多种多样的，这个需要开发者自己去选择，这次先介绍最简单的线性回归(Linear regression)。</p>
<h4 id="线性回归LR-Linear-Regression"><a href="#线性回归LR-Linear-Regression" class="headerlink" title="线性回归LR(Linear Regression)"></a>线性回归LR(Linear Regression)</h4><p>从数学上来说，给定由d个属性描述的示例x=(x1;x2;…;xd),其中xi是x在第i个属性上的取值，线性模型试图学得一个通过属性的线性组合来进行预测的函数，即:</p>
<p><img src="/images/机器学习-线性回归-02.png" alt="机器学习-线性回归" title="机器学习-线性回归-02"></p>
<p>一般用向量形式:</p>
<p><img src="/images/机器学习-线性回归-03.png" alt="机器学习-线性回归" title="机器学习-线性回归-03"></p>
<p>好了，现在我们知道了线性回归模型的基本形式了，那么我们现在的任务就是要去学习出这个w向量和b这些参数的值，有了这个值我们才能去做预测。</p>
<p>一般来说，我们会给w和b一个初始值，然后我们去修正这些值来让这些值符合预期，那么我们怎么去修正这些值呢？我们需要一个<strong>损失函数</strong>(loss function)，这个函数用来指明我的预测值和训练数据实际值的差别。<br>那么这个损失函数(loss function)是什么，以及我们怎么用它来修正我们的参数w和b，看下面。</p>
<h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>不知道大家知不知道启发式搜索(Heuristically Search)？</p>
<blockquote>
<p>启发式搜索(Heuristically Search)又称为有信息搜索(Informed Search)，它是利用问题拥有的启发信息来引导搜索，达到减少搜索范围、降低问题复杂度的目的，这种利用启发信息的搜索过程称为启发式搜索。——百度百科</p>
</blockquote>
<p>举个例子，大一大二在大学里面的时候我是有单车的，晚上下课的时候在停车场里面经常忘记自己的车停在哪，要找半天才能找得到，这种就叫盲目搜索，广度优先搜索(BFS)和宽度优先搜索(DFS)都是盲目搜索。</p>
<p>那么如果我手里有个黑科技，能够告诉我我现在距离我的爱车多远，那么我是不是可以以此为依据，往距离逐渐减少的方向去搜索呢？这就是启发式搜索(Heuristically Search)，Astar(A*)寻路算法等就是启发式搜索。<br>启发式搜索与机器学习有一些概念是共通的，那么对于机器学习来说，我也同样需要一个和“距离我爱车多远”这样一个指标来判断我现在参数距离我最优参数有“多远”。我们可以统一的把这种东西叫做损失函数(loss function)</p>
<h4 id="损失函数-Loss-Function"><a href="#损失函数-Loss-Function" class="headerlink" title="损失函数(Loss Function)"></a>损失函数(Loss Function)</h4><p>我们给之前例子里的函数一个名字，叫假设函数(hypothesis function)，意为预估值函数。损失函数则是用来衡量假设函数(hypothesis function)的准确性，具体衡量指标有很多，这里我们和吴恩达教程里面一样采用平方差的方式计算。</p>
<p><img src="/images/机器学习-线性回归-04.png" alt="机器学习-线性回归" title="机器学习-线性回归-04"></p>
<p>其中函数J就是损失函数(为什么是J我好好奇)，函数h是假设函数，可以看到后面是平方差的平均值然后除以了个2。</p>
<blockquote>
<p>公式2*m里面的2其实就是为了后面求偏导的时候可以把分数消掉，没什么太大的实际意义。</p>
</blockquote>
<h4 id="梯度下降算法-Gradient-descent-algorithm"><a href="#梯度下降算法-Gradient-descent-algorithm" class="headerlink" title="梯度下降算法(Gradient descent algorithm)"></a>梯度下降算法(Gradient descent algorithm)</h4><p>既然我们现在知道了当前怎么评价当前参数的好坏，那么我怎么去修正参数让参数更好(损失函数的最小值)呢？</p>
<p>高中生都知道，在一元函数里面，导数的几何意义就是函数变化增加最快的方向。梯度其实类似，也是类似的，说白了就是一个向量，表示上升最快的方向。</p>
<p>那么我们就可以得到一个修正的公式，我们迭代这个公式许多次来修正参数。</p>
<p><img src="/images/机器学习-线性回归-05.png" alt="机器学习-线性回归" title="机器学习-线性回归-05"></p>
<p>这里是减号是因为梯度表示上升最快，所以用的是负梯度。</p>
<p>然后其中其中α表示学习速率(learning rate)，这个值越大每次修正的就越多，不过这个不是越高越好，如果太高了可能会一直在最低点“摆动”而无法收敛。也有的使用可变的学习速率，一开始设置较高，接近最低点的过程中逐渐降低。</p>
<p><img src="/images/机器学习-线性回归-06.png" alt="机器学习-线性回归" title="机器学习-线性回归-06"></p>
<p>接下来我们看一下求导之后的结果:</p>
<p><img src="/images/机器学习-线性回归-07.png" alt="机器学习-线性回归" title="机器学习-线性回归-07"></p>
<blockquote>
<p>这里有一点值得注意的是，在这个梯度下降中我们每次迭代都使用了所有的m个训练数据，这种也叫批量梯度下降法Batch Gradient Descent，BGD<br>这样每次迭代都将对m个样本进行计算，计算量大。所以有些优化方案，有兴趣的可以去看一下</p>
</blockquote>
<p>现在我们知道了如何去修正参数了，但我们实际上修正之后得到的是损失函数(loss function)的极小值而不一定是最小值.</p>
<p><img src="/images/机器学习-线性回归-08.png" alt="机器学习-线性回归" title="机器学习-线性回归-08"></p>
<p><img src="/images/机器学习-线性回归-09.png" alt="机器学习-线性回归" title="机器学习-线性回归-09"></p>
<ol>
<li>由于起始点(起始参数)的不同，最后可能得到的并不是全局的最优解(损失函数最小)。我说一下从西瓜书上看到的几个优化方法。</li>
<li>以多组不同的参数值初始化，反正就是找多个起点选最好的结果。</li>
<li>使用“模拟退火”(Simulated Annealing)技术，模拟退火在每一步都以一定概率接受比当前解更差的结果，从而有助于“跳出”局部极小。在每步迭代过程中，接受“次优解”的概率会随着时间的推移而逐步降低，从而保证算法的稳定。</li>
<li>使用随机梯度下降，它在计算梯度的时候加入了随机因素，所以即使陷入了局部极小值，它计算出来的梯度仍然可能不为0，这样就有机会跳出局部极小继续搜索。</li>
</ol>
<blockquote>
<p>转载 <a href="https://juejin.im/post/5a37b4cf6fb9a045023bbe25" target="_blank" rel="external">https://juejin.im/post/5a37b4cf6fb9a045023bbe25</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]]}
});
&lt;/script&gt;

&lt;script type=&quot;te
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/machine/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java|自己撸一个SpringMVC框架</title>
    <link href="http://yoursite.com/2018/02/25/Java-%E5%BE%92%E6%89%8B%E6%92%B8%E6%A1%86%E6%9E%B6-%E5%AE%9E%E7%8E%B0SpringMVC%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/02/25/Java-徒手撸框架-实现SpringMVC框架/</id>
    <published>2018-02-24T18:37:19.000Z</published>
    <updated>2018-02-24T14:53:24.619Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架对于Java后端程序员来说再熟悉不过了，以前只知道它用的反射实现的，但了解之后才知道有很多巧妙的设计在里面。如果不看Spring的源码，你将会失去一次和大师学习的机会：它的代码规范，设计思想很值得学习。我们程序员大部分人都是野路子，不懂什么叫代码规范。写了一个月的代码，最后还得其他老司机花3天时间重构，相信大部分老司机都很头疼看新手的代码。</p>
<p>废话不多说，我们进入今天的正题，在Web应用程序设计中，MVC模式已经被广泛使用。SpringMVC以DispatcherServlet为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。想要实现自己的SpringMVC框架，需要从以下几点入手：</p>
<ul>
<li>了解SpringMVC运行流程及九大组件</li>
<li>自己实现SpringMVC的功能分析</li>
<li>手写SpringMVC框架</li>
</ul>
<h3 id="了解SpringMVC运行流程及九大组件"><a href="#了解SpringMVC运行流程及九大组件" class="headerlink" title="了解SpringMVC运行流程及九大组件"></a>了解SpringMVC运行流程及九大组件</h3><h4 id="SpringMVC的运行流程"><a href="#SpringMVC的运行流程" class="headerlink" title="SpringMVC的运行流程"></a>SpringMVC的运行流程</h4><p><img src="/images/springMVC-01.jpg" alt="springMVC" title="springMVC-01"></p>
<ul>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>
<li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器<br>执行处理器(Controller，也叫后端控制器)。</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体View</li>
<li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ul>
<p>从上面可以看出，DispatcherServlet有接受请求，响应结果，转发等作用。有了DispatcherServlet之后，可以减少组件之间的耦合度。</p>
<h4 id="SpringMVC的九大组件"><a href="#SpringMVC的九大组件" class="headerlink" title="SpringMVC的九大组件"></a>SpringMVC的九大组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">protected void initStrategies(ApplicationContext context) &#123;</div><div class="line">	//用于处理上传请求。处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File.</div><div class="line">	initMultipartResolver(context);</div><div class="line">	//SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。</div><div class="line">	initLocaleResolver(context); </div><div class="line">	//用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、</div><div class="line">	//如图片、css样式等。SpringMVC的主题也支持国际化， </div><div class="line">	initThemeResolver(context);</div><div class="line">	//用来查找Handler的。</div><div class="line">	initHandlerMappings(context);</div><div class="line">	//从名字上看，它就是一个适配器。Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。</div><div class="line">	//如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情</div><div class="line">	initHandlerAdapters(context);</div><div class="line">	//其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？</div><div class="line">	//这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。</div><div class="line">	initHandlerExceptionResolvers(context);</div><div class="line">	//有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，</div><div class="line">	//如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。</div><div class="line">	initRequestToViewNameTranslator(context);</div><div class="line">	//ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。</div><div class="line">	//View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。</div><div class="line">	initViewResolvers(context);</div><div class="line">	//用来管理FlashMap的，FlashMap主要用在redirect重定向中传递参数。</div><div class="line">	initFlashMapManager(context); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自己实现SpringMVC功能分析"><a href="#自己实现SpringMVC功能分析" class="headerlink" title="自己实现SpringMVC功能分析"></a>自己实现SpringMVC功能分析</h3><p>本片文章只实现SpringMVC的配置加载、实例化扫描的包、HandlerMapping的url映射到对应的Controller的method上、异常的拦截和动态调用后返回结果输出给浏览器的功能。其余SpringMVC功能读者可以尝试自己实现。</p>
<h4 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h4><p><img src="/images/springMVC-02.png" alt="springMVC" title="springMVC-02"></p>
<p> 从图中可以看出，SpringMVC本质上是一个Servlet,这个 Servlet 继承自 HttpServlet。FrameworkServlet负责初始化SpringMVC的容器，并将Spring容器设置为父容器。因为本文只是实现SpringMVC，对于Spring容器不做过多讲解。</p>
<p> 为了读取web.xml中的配置，我们用到ServletConfig这个类，它代表当前Servlet在web.xml中的配置信息。通过web.xml中加载我们自己写的MyDispatcherServlet和读取配置文件。</p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>在上文中，我们知道了DispatcherServlet的initStrategies方法会初始化9大组件，但是本文将实现一些SpringMVC的最基本的组件而不是全部，按顺序包括：</p>
<ul>
<li>加载配置文件</li>
<li>初始化所有相关联的类，扫描用户设定的包下面所有的类</li>
<li>拿到扫描到的类，通过反射机制，实例化。并且放到ioc容器中(Map的键值对  beanName-bean) beanName默认是首字母小写</li>
<li>初始化HandlerMapping，其实就是将一个Map的键值对 key是url，value是所调用的方法put进去(将url和method对应上)</li>
</ul>
<h4 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h4><p>每一次请求将会调用doGet或doPost方法，所以统一运行阶段都放在doDispatch方法里处理，它会根据url请求去HandlerMapping中匹配到对应的Method，然后利用反射机制调用Controller中的方法，并得到结果返回。按顺序包括以下功能：</p>
<ul>
<li>异常的拦截</li>
<li>获取请求传入的参数并处理参数</li>
<li>通过初始化好的handlerMapping的Map容器中拿出url对应的方法名，反射调用</li>
</ul>
<h3 id="手写SpringMVC框架"><a href="#手写SpringMVC框架" class="headerlink" title="手写SpringMVC框架"></a>手写SpringMVC框架</h3><p> 工程文件及目录：</p>
<p> <img src="/images/springMVC-03.png" alt="springMVC" title="springMVC-03"></p>
<p>首先，新建一个maven项目，在pom.xml中导入以下依赖。为了方便，博主直接导入了Springboot的web包，里面有我们需要的所有web开发的东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line">  &lt;groupId&gt;com.liugh&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;liughMVC&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</div><div class="line">  </div><div class="line"> &lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;1.4.3.RELEASE&lt;/version&gt;</div><div class="line">				&lt;type&gt;pom&lt;/type&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</div><div class="line">		&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</div><div class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line">	</div><div class="line">	&lt;dependencies&gt;</div><div class="line">  		&lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">    &lt;/dependencies&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure></p>
<p>接着，我们在WEB-INF下创建一个web.xml，如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</div><div class="line">	version=&quot;3.0&quot;&gt;</div><div class="line">	&lt;servlet&gt;</div><div class="line">		&lt;servlet-name&gt;MySpringMVC&lt;/servlet-name&gt;</div><div class="line">		&lt;servlet-class&gt;com.liugh.servlet.MyDispatcherServlet&lt;/servlet-class&gt;</div><div class="line">		&lt;init-param&gt;</div><div class="line">			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">			&lt;param-value&gt;application.properties&lt;/param-value&gt;</div><div class="line">		&lt;/init-param&gt;</div><div class="line">		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">	&lt;/servlet&gt;</div><div class="line">	&lt;servlet-mapping&gt;</div><div class="line">		&lt;servlet-name&gt;MySpringMVC&lt;/servlet-name&gt;</div><div class="line">		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">	&lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>application.properties文件中只是配置要扫描的包到SpringMVC容器中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scanPackage=com.liugh.core</div></pre></td></tr></table></figure></p>
<p>创建自己的Controller注解，它只能标注在类上面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.liugh.annotation;</div><div class="line"></div><div class="line">import java.lang.annotation.Documented;</div><div class="line">import java.lang.annotation.ElementType;</div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.RetentionPolicy;</div><div class="line">import java.lang.annotation.Target;</div><div class="line"></div><div class="line">@Target(ElementType.TYPE)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface MyController &#123;</div><div class="line">	/**</div><div class="line">     * 表示给controller注册别名</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    String value() default &quot;&quot;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RequestMapping注解，可以在类和方法上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.liugh.annotation;</div><div class="line"></div><div class="line">import java.lang.annotation.Documented;</div><div class="line">import java.lang.annotation.ElementType;</div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.RetentionPolicy;</div><div class="line">import java.lang.annotation.Target;</div><div class="line"></div><div class="line">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface MyRequestMapping &#123;</div><div class="line">	/**</div><div class="line">     * 表示访问该方法的url</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    String value() default &quot;&quot;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RequestParam注解,只能注解在参数上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.liugh.annotation;</div><div class="line"></div><div class="line">import java.lang.annotation.Documented;</div><div class="line">import java.lang.annotation.ElementType;</div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.RetentionPolicy;</div><div class="line">import java.lang.annotation.Target;</div><div class="line"></div><div class="line">@Target(ElementType.PARAMETER)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface MyRequestParam &#123;</div><div class="line">	/**</div><div class="line">     * 表示参数的别名，必填</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    String value();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后创建MyDispatcherServlet这个类，去继承HttpServlet，重写init方法、doGet、doPost方法，以及加上我们第二步分析时要实现的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div></pre></td><td class="code"><pre><div class="line">package com.liugh.servlet;</div><div class="line"></div><div class="line">import java.io.File;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.lang.reflect.Method;</div><div class="line">import java.net.URL;</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.List;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.Map.Entry;</div><div class="line">import java.util.Properties;</div><div class="line"></div><div class="line">import javax.servlet.ServletConfig;</div><div class="line">import javax.servlet.ServletException;</div><div class="line">import javax.servlet.http.HttpServlet;</div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import com.liugh.annotation.MyController;</div><div class="line">import com.liugh.annotation.MyRequestMapping;</div><div class="line"></div><div class="line">public class MyDispatcherServlet extends HttpServlet&#123;</div><div class="line">	</div><div class="line">	private Properties properties = new Properties();</div><div class="line">	</div><div class="line">	private List&lt;String&gt; classNames = new ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	private Map&lt;String, Object&gt; ioc = new HashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	private Map&lt;String, Method&gt; handlerMapping = new  HashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	private Map&lt;String, Object&gt; controllerMap  =new HashMap&lt;&gt;();</div><div class="line">	</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void init(ServletConfig config) throws ServletException &#123;</div><div class="line">		</div><div class="line">		//1.加载配置文件</div><div class="line">		doLoadConfig(config.getInitParameter(&quot;contextConfigLocation&quot;));</div><div class="line">		</div><div class="line">		//2.初始化所有相关联的类,扫描用户设定的包下面所有的类</div><div class="line">		doScanner(properties.getProperty(&quot;scanPackage&quot;));</div><div class="line">		</div><div class="line">		//3.拿到扫描到的类,通过反射机制,实例化,并且放到ioc容器中(k-v  beanName-bean) beanName默认是首字母小写</div><div class="line">		doInstance();</div><div class="line">		</div><div class="line">		//4.初始化HandlerMapping(将url和method对应上)</div><div class="line">		initHandlerMapping();</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</div><div class="line">		this.doPost(req,resp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</div><div class="line">		try &#123;</div><div class="line">			//处理请求</div><div class="line">			doDispatch(req,resp);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			resp.getWriter().write(&quot;500!! Server Exception&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	private void doDispatch(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;</div><div class="line">		if(handlerMapping.isEmpty())&#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		String url =req.getRequestURI();</div><div class="line">		String contextPath = req.getContextPath();</div><div class="line">		</div><div class="line">		url=url.replace(contextPath, &quot;&quot;).replaceAll(&quot;/+&quot;, &quot;/&quot;);</div><div class="line">		</div><div class="line">		if(!this.handlerMapping.containsKey(url))&#123;</div><div class="line">			resp.getWriter().write(&quot;404 NOT FOUND!&quot;);</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Method method =this.handlerMapping.get(url);</div><div class="line">		</div><div class="line">		//获取方法的参数列表</div><div class="line">		Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">	</div><div class="line">		//获取请求的参数</div><div class="line">		Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();</div><div class="line">		</div><div class="line">		//保存参数值</div><div class="line">		Object [] paramValues= new Object[parameterTypes.length];</div><div class="line">		</div><div class="line">		//方法的参数列表</div><div class="line">        for (int i = 0; i&lt;parameterTypes.length; i++)&#123;  </div><div class="line">            //根据参数名称，做某些处理  </div><div class="line">            String requestParam = parameterTypes[i].getSimpleName();  </div><div class="line">            </div><div class="line">            </div><div class="line">            if (requestParam.equals(&quot;HttpServletRequest&quot;))&#123;  </div><div class="line">                //参数类型已明确，这边强转类型  </div><div class="line">            	paramValues[i]=req;</div><div class="line">                continue;  </div><div class="line">            &#125;  </div><div class="line">            if (requestParam.equals(&quot;HttpServletResponse&quot;))&#123;  </div><div class="line">            	paramValues[i]=resp;</div><div class="line">                continue;  </div><div class="line">            &#125;</div><div class="line">            if(requestParam.equals(&quot;String&quot;))&#123;</div><div class="line">            	for (Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123;</div><div class="line">         			String value =Arrays.toString(param.getValue()).replaceAll(&quot;\\[|\\]&quot;, &quot;&quot;).replaceAll(&quot;,\\s&quot;, &quot;,&quot;);</div><div class="line">         			paramValues[i]=value;</div><div class="line">         		&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;  </div><div class="line">		//利用反射机制来调用</div><div class="line">		try &#123;</div><div class="line">			method.invoke(this.controllerMap.get(url), paramValues);//obj是method所对应的实例 在ioc容器中</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	private void  doLoadConfig(String location)&#123;</div><div class="line">		//把web.xml中的contextConfigLocation对应value值的文件加载到留里面</div><div class="line">		InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(location);</div><div class="line">		try &#123;</div><div class="line">			//用Properties文件加载文件里的内容</div><div class="line">			properties.load(resourceAsStream);</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;finally &#123;</div><div class="line">			//关流</div><div class="line">			if(null!=resourceAsStream)&#123;</div><div class="line">				try &#123;</div><div class="line">					resourceAsStream.close();</div><div class="line">				&#125; catch (IOException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private void doScanner(String packageName) &#123;</div><div class="line">		//把所有的.替换成/</div><div class="line">		URL url  =this.getClass().getClassLoader().getResource(&quot;/&quot;+packageName.replaceAll(&quot;\\.&quot;, &quot;/&quot;));</div><div class="line">		File dir = new File(url.getFile());</div><div class="line">		for (File file : dir.listFiles()) &#123;</div><div class="line">			if(file.isDirectory())&#123;</div><div class="line">				//递归读取包</div><div class="line">				doScanner(packageName+&quot;.&quot;+file.getName());</div><div class="line">			&#125;else&#123;</div><div class="line">				String className =packageName +&quot;.&quot; +file.getName().replace(&quot;.class&quot;, &quot;&quot;);</div><div class="line">				classNames.add(className);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">	private void doInstance() &#123;</div><div class="line">		if (classNames.isEmpty()) &#123;</div><div class="line">			return;</div><div class="line">		&#125;	</div><div class="line">		for (String className : classNames) &#123;</div><div class="line">			try &#123;</div><div class="line">				//把类搞出来,反射来实例化(只有加@MyController需要实例化)</div><div class="line">				Class&lt;?&gt; clazz =Class.forName(className);</div><div class="line">			   if(clazz.isAnnotationPresent(MyController.class))&#123;</div><div class="line">					ioc.put(toLowerFirstWord(clazz.getSimpleName()),clazz.newInstance());</div><div class="line">				&#125;else&#123;</div><div class="line">					continue;</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">				continue;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	private void initHandlerMapping()&#123;</div><div class="line">		if(ioc.isEmpty())&#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		try &#123;</div><div class="line">			for (Entry&lt;String, Object&gt; entry: ioc.entrySet()) &#123;</div><div class="line">				Class&lt;? extends Object&gt; clazz = entry.getValue().getClass();</div><div class="line">				if(!clazz.isAnnotationPresent(MyController.class))&#123;</div><div class="line">					continue;</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				//拼url时,是controller头的url拼上方法上的url</div><div class="line">				String baseUrl =&quot;&quot;;</div><div class="line">				if(clazz.isAnnotationPresent(MyRequestMapping.class))&#123;</div><div class="line">					MyRequestMapping annotation = clazz.getAnnotation(MyRequestMapping.class);</div><div class="line">					baseUrl=annotation.value();</div><div class="line">				&#125;</div><div class="line">				Method[] methods = clazz.getMethods();</div><div class="line">				for (Method method : methods) &#123;</div><div class="line">					if(!method.isAnnotationPresent(MyRequestMapping.class))&#123;</div><div class="line">						continue;</div><div class="line">					&#125;</div><div class="line">					MyRequestMapping annotation = method.getAnnotation(MyRequestMapping.class);</div><div class="line">					String url = annotation.value();</div><div class="line">					</div><div class="line">					url =(baseUrl+&quot;/&quot;+url).replaceAll(&quot;/+&quot;, &quot;/&quot;);</div><div class="line">					handlerMapping.put(url,method);</div><div class="line">					controllerMap.put(url,clazz.newInstance());</div><div class="line">					System.out.println(url+&quot;,&quot;+method);</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 把字符串的首字母小写</div><div class="line">	 * @param name</div><div class="line">	 * @return</div><div class="line">	 */</div><div class="line">	private String toLowerFirstWord(String name)&#123;</div><div class="line">		char[] charArray = name.toCharArray();</div><div class="line">		charArray[0] += 32;</div><div class="line">		return String.valueOf(charArray);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">		</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们就开发完了自己的SpringMVC，现在我们测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package com.liugh.core.controller;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import com.liugh.annotation.MyController;</div><div class="line">import com.liugh.annotation.MyRequestMapping;</div><div class="line">import com.liugh.annotation.MyRequestParam;</div><div class="line"></div><div class="line">@MyController</div><div class="line">@MyRequestMapping(&quot;/test&quot;)</div><div class="line">public class TestController &#123;</div><div class="line">	</div><div class="line"></div><div class="line">	</div><div class="line">	 @MyRequestMapping(&quot;/doTest&quot;)</div><div class="line">    public void test1(HttpServletRequest request, HttpServletResponse response,</div><div class="line">    		@MyRequestParam(&quot;param&quot;) String param)&#123;</div><div class="line"> 		System.out.println(param);</div><div class="line">	    try &#123;</div><div class="line">            response.getWriter().write( &quot;doTest method success! param:&quot;+param);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	 </div><div class="line">	 </div><div class="line">	 @MyRequestMapping(&quot;/doTest2&quot;)</div><div class="line">    public void test2(HttpServletRequest request, HttpServletResponse response)&#123;</div><div class="line">        try &#123;</div><div class="line">            response.getWriter().println(&quot;doTest2 method success!&quot;);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:8080/liughMVC/test/doTest?param=liugh如下：" target="_blank" rel="external">http://localhost:8080/liughMVC/test/doTest?param=liugh如下：</a></p>
<p><img src="/images/springMVC-04.jpg" alt="test" title="springMVC-04"></p>
<p>访问一个不存在的试试：<br><img src="/images/springMVC-05.jpg" alt="test" title="springMVC-05"></p>
<p>到这里我们就大功告成了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring框架对于Java后端程序员来说再熟悉不过了，以前只知道它用的反射实现的，但了解之后才知道有很多巧妙的设计在里面。如果不看Spring的源码，你将会失去一次和大师学习的机会：它的代码规范，设计思想很值得学习。我们程序员大部分人都是野路子，不懂什么叫代码规范。写了一
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福机器学习课程|第一周(1)认识机器学习</title>
    <link href="http://yoursite.com/2018/02/22/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%B8%80%E5%91%A8-1-%E8%AE%A4%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/02/22/斯坦福机器学习课程-第一周-1-认识机器学习/</id>
    <published>2018-02-22T11:08:52.000Z</published>
    <updated>2018-02-22T03:47:46.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生活中机器学习的影子"><a href="#生活中机器学习的影子" class="headerlink" title="生活中机器学习的影子"></a>生活中机器学习的影子</h3><p>在生活中，每天你都可能在不知不觉中使用了各种各样的机器学习算法。比如，当你每一次使用像诸如谷歌 (Google)或必应 (Bing) 的搜索引擎时，它们运作得如此之好的原因之一便是，由Google或微软实现的一种学习算法可以“学会”如何对网页进行排名；每当你使用脸书 (Facebook)或苹果 (Apple) 的照片处理应用时，它们都能自动识别出你朋友的照片，这也是机器学习的一种；每当你阅读电子邮件时，你的垃圾邮件过滤器帮你免受大量垃圾邮件的困扰，这也是通过一种学习算法实现的。还有一个让我兴奋的理由，是一个关于人工智能的梦想：有朝一日，我们能创造出像你我一样聪明的机器，尽管我们离这个目标仍有很长的距离，但许多的人工智能专家相信，实现这一目标最好的途径是通过学习算法，来模拟人类大脑的学习方式。</p>
<p>话说，为什么机器学习在当今如此流行呢？ 机器学习发源于人工智能领域 我们希望能够创造出具有智慧的机器。我们通过编程来让机器完成一些基础的工作，比如如何找到从A到B的最短路径，但在大多数情况下，我们并不知道如何显式地编写人工智能程序，来做一些更有趣的任务。比如网页搜索，标记照片和拦截垃圾邮件等。人们意识到唯一能够达成这些目标的方法，就是让机器自己学会如何去做。因而，机器学习已经发展成为计算机的一项新能力，并且与工业界和基础科学界有着紧密的联系。</p>
<p>身处机器学习领域。我常常会在短短一周中与形形色色的人打交道 如直升机飞行员、生物学家、还有许多计算机系统专家。比如我在斯坦福的同事们，同时平均每周我还会数次收到来自硅谷的业界人士的email，咨询我是否有兴趣将机器学习算法应用到他们所遇到的实际问题中，以上的例子都彰显了机器学习所能处理的问题范围之广。在硅谷，机器学习引导着大量的课题。如自主机器人、计算生物学等。机器学习的实例还有很多，比如数据库挖掘。机器学习变得如此流行的原因之一，便是网络和自动化算法的爆炸性增长，这意味着我们掌握了比以往多得多的数据集。举例来说，当今有数不胜数的硅谷企业，在收集有关网络点击的数据 (Clickstream Data) 并试图在这些数据上运用机器学习的算法来更好的理解和服务用户，这在硅谷已经成为了一项巨大的产业。随着电子自动化的发展，我们现在拥有了电子医疗记录，如果我们能够将这些记录转变为医学知识，那我们就能对各种疾病了解的更深入，同时，计算生物学也在电子自动化的辅助下快速发展。生物学家收集了大量有关基因序列以及DNA序列的数据，通过对其应用机器学习的算法来帮助我们跟深入地理解人类基因组，及其对我们人类的意义，几乎工程界的所有领域，都在使用机器学习算法来分析日益增长的海量数据集。有些机器应用我们并不能够通过手工编程来实现，比如说，我个人对自动直升机有着许多年的研究，想要写出一个能让直升机自主飞行的程序几乎是不可能的任务。唯一可行的解决方案就是让一台计算机能够自主地学会如何让直升机飞行。再比如手写识别，如今将大量的邮件，按地址分类寄送到全美甚至全球的代价大大降低，其中重要的理由之一便是每当你写下这样一封信时 一个机器学习的算法已经学会如何读懂你的笔迹并自动地将你的信件发往它的目的地.所以邮寄跨越上万里的信件的费用也很低。你也许曾经接触过自然语言处理和计算机视觉，事实上，这些领域都是试图通过人工智能来理解人类的语言和图像，如今大多数的自然语言处理和计算机视觉都是对机器学习的一种应用。</p>
<p><strong>机器学习算法也在用户自定制化程序(self-customizing program)中有着广泛的应用</strong>，每当你使用亚马逊、Netflix或iTunes Genius的服务时，都会收到它们为你量身推荐的电影或产品。这就是通过学习算法来实现的。可以相信，这些应用都有着上千万的用户，而针对这些海量的用户编写千万个不同的程序显然是不可能的。唯一有效的解决方案就是开发出能够自我学习，定制出符合你喜好的并据此进行推荐的软件，最后，机器学习算法已经被应用于探究人类的学习方式，并试图理解人类的大脑。我们也将会了解到研究者是如何运用机器学习的工具，来一步步实现人工智能的梦想。</p>
<h3 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h3><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p>来个例子：</p>
<p>假设你想预测房价（无比需要啊！)，之前，某学生已经从某地收集了数据集（不是中国的，囧） 其中一个数据集是这样的。</p>
<p><img src="/images/机器学习-监督学习-01.png" alt="机器学习-监督学习-01" title="机器学习-监督学习-01"></p>
<p>这是横坐标，即不同房子的面积，单位平方脚（^-^） 纵轴上是房价，单位 千美元。 根据给定数据，假设你朋友有栋房子，750平尺（70平米） 想知道这房子能卖多少，好卖掉。 那么，学习算法怎么帮你呢？学习算法可以： 绘出一条直线，让直线尽可能匹配到所有数据。</p>
<p><img src="/images/机器学习-监督学习-02.png" alt="机器学习-监督学习-02" title="机器学习-监督学习-02"></p>
<p>于此，看上去，那个房子应该、可能、也许、大概 卖到15万美元（一平米两千刀！）。但这不是唯一的学习算法。可能还有更好的。比如不用直线了，可能平方函数会更好，即二次多项式更符合数据集。如果你这样做，预测结果就应该是20万刀（一平三千刀，涨价好快）。</p>
<p><img src="/images/机器学习-监督学习-03.png" alt="机器学习-监督学习-03" title="机器学习-监督学习-03"></p>
<p>对于应该选择直线还是曲线，不是我们现在关心的问题。我们需要知道的是这是一个监督学习得例子。术语监督学习，意指给出一个算法，需要部分数据集已经有正确答案。比如给定房价数据集， 对于里面每个数据，算法都知道对应的正确房价，即这房子实际卖出的价格。算法的结果就是算出更多的正确价格，比如那个新房子，你朋友想卖的那个。</p>
<p>用更术语的方式来定义，监督学习又叫回归问题，（应该是回归属于监督中的一种）意指要预测一个连续值的输出，比如房价。虽然从技术上，一般把房价记到美分单位。所以实际还是个离散值，但通常把它看作实际数字，是一个标量值，一个连续值的数，而术语回归，意味着要预测这类连续值属性的种类。</p>
<h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><p>在监督学习中，我们用到的例子中的数据集，每个样本，都已经被标明为正样本或者负样本，即良性或恶性肿瘤。</p>
<p>因此，对于监督学习中的每一个样本，我们已经被清楚地告知了什么是所谓的正确答案，即它们是良性还是恶性。在无监督学习中，我们用的数据会和监督学习里的看起来有些不一样。在无监督学习中，没有属性或标签这一概念，也就是说所有的数据都是一样的，没有区别。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;生活中机器学习的影子&quot;&gt;&lt;a href=&quot;#生活中机器学习的影子&quot; class=&quot;headerlink&quot; title=&quot;生活中机器学习的影子&quot;&gt;&lt;/a&gt;生活中机器学习的影子&lt;/h3&gt;&lt;p&gt;在生活中，每天你都可能在不知不觉中使用了各种各样的机器学习算法。比如，当你每
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/machine/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>运维|安装Octave</title>
    <link href="http://yoursite.com/2018/02/22/%E8%BF%90%E7%BB%B4-%E5%AE%89%E8%A3%85Octave/"/>
    <id>http://yoursite.com/2018/02/22/运维-安装Octave/</id>
    <published>2018-02-22T10:42:45.000Z</published>
    <updated>2018-02-22T03:47:05.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What-is-Octave"><a href="#What-is-Octave" class="headerlink" title="What is Octave"></a>What is Octave</h3><p>Octave是一个旨在提供与Matlab语法兼容的开放源代码科学计算及数值分析的工具。Octave是在GNU协议下被开放的，这意味着它一直是可以免费下载的。</p>
<h3 id="在Windows下安装Octave"><a href="#在Windows下安装Octave" class="headerlink" title="在Windows下安装Octave"></a>在Windows下安装Octave</h3><p>使用这个链接来在Windows安装Octave:</p>
<blockquote>
<p><a href="http://wiki.octave.org/Octave_for_Microsoft_Windows" target="_blank" rel="external">http://wiki.octave.org/Octave_for_Microsoft_Windows</a></p>
</blockquote>
<h3 id="在GNU-Linux上安装Octave"><a href="#在GNU-Linux上安装Octave" class="headerlink" title="在GNU/Linux上安装Octave"></a>在GNU/Linux上安装Octave</h3><ul>
<li>在Ubuntu上，你可以使用：<ul>
<li>sudo apt-get update &amp;&amp; sudo apt-get install octave</li>
</ul>
</li>
<li>在Fedora上，你可以使用：<ul>
<li>sudo yum install octave-forge</li>
</ul>
</li>
<li>在Red Hat Enterprise/CentOS上，你可以使用：<ul>
<li>Method One:<ul>
<li><blockquote>
<p>yum install epel-release<br>  yum install octave</p>
</blockquote>
</li>
</ul>
</li>
<li>Method Two:<ul>
<li><blockquote>
<p>wget <a href="http://url/to/latest/epel-release-6-7.noarch.rpm" target="_blank" rel="external">http://url/to/latest/epel-release-6-7.noarch.rpm</a><br> yum localinstall epel-release-6-7.noarch.rpm </p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在CentOS上，可以到 <a href="https://fedoraproject.org/wiki/EPEL" target="_blank" rel="external">https://fedoraproject.org/wiki/EPEL</a> 中选择自己需要的Octave版本。</p>
<p>Octave is available for Red Hat Enterprise Linux distributions through the <a href="https://fedoraproject.org/wiki/EPEL" target="_blank" rel="external">EPEL</a> repository. This section applies to CentOS, Scientific Linux, and other Red Hat Enterprise rebuild distributions as well.</p>
<blockquote>
<p>参考 <a href="http://wiki.octave.org/Octave_for_GNU/Linux" target="_blank" rel="external">http://wiki.octave.org/Octave_for_GNU/Linux</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What-is-Octave&quot;&gt;&lt;a href=&quot;#What-is-Octave&quot; class=&quot;headerlink&quot; title=&quot;What is Octave&quot;&gt;&lt;/a&gt;What is Octave&lt;/h3&gt;&lt;p&gt;Octave是一个旨在提供与Matlab语法
    
    </summary>
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Octave" scheme="http://yoursite.com/tags/Octave/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP安全性开发</title>
    <link href="http://yoursite.com/2018/02/21/PHP-PHP%E5%AE%89%E5%85%A8%E6%80%A7%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/02/21/PHP-PHP安全性开发/</id>
    <published>2018-02-21T11:28:02.000Z</published>
    <updated>2018-02-24T11:05:07.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>“php给了开发者极大的灵活性，但是这也为安全问题带来了潜在的隐患，近期需要总结一下以往的问题，在这里借翻译一篇文章同时加上自己开发的一些感触总结一下。”</p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>当开发一个互联网服务的时候，必须时刻牢记==安全观念==，并在开发的代码中体现。PHP脚本语言对安全问题并不关心，特别是对大多数没有经验的开发者来说。每当你讲任何涉及到钱财事务等交易问题时，需要特别注意安全问题的考虑，例如开发一个论坛或者是一个购物车等。</p>
<h3 id="安全保护一般性要点"><a href="#安全保护一般性要点" class="headerlink" title="安全保护一般性要点"></a>安全保护一般性要点</h3><h4 id="不相信表单"><a href="#不相信表单" class="headerlink" title="不相信表单"></a>不相信表单</h4><p>对于一般的Javascript前台验证，由于无法得知用户的行为，例如关闭了浏览器的javascript引擎，这样通过POST恶意数据到服务器。需要在服务器端进行验证，对每个php脚本验证传递到的数据，防止XSS攻击和SQL注入</p>
<h4 id="不相信用户"><a href="#不相信用户" class="headerlink" title="不相信用户"></a>不相信用户</h4><p>要假设你的网站接收的每一条数据都是存在恶意代码的，存在隐藏的威胁，要对每一条数据都进行清理</p>
<h4 id="服务器方面"><a href="#服务器方面" class="headerlink" title="服务器方面"></a>服务器方面</h4><h5 id="打开php的安全模式"><a href="#打开php的安全模式" class="headerlink" title="打开php的安全模式"></a>打开php的安全模式</h5><p>php的安全模式是个非常重要的内嵌的安全机制，能够控制一些php中的函数，比如system()，同时把很多文件操作函数进行了权限控制，也不允许对某些关键文件的文件，比如/etc/passwd，但是默认的php.ini是没有打开安全模式的，我们把它打开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode = on</div></pre></td></tr></table></figure></p>
<h5 id="用户组安全"><a href="#用户组安全" class="headerlink" title="用户组安全"></a>用户组安全</h5><p>当safe_mode打开时，safe_mode_gid被关闭，那么php脚本能够对文件进行访问，而且相同组的用户也能够对文件进行访问。</p>
<p>建议设置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode_gid = off</div></pre></td></tr></table></figure></p>
<p>如果不进行设置，可能我们无法对我们服务器网站目录下的文件进行操作了，比如我们需要对文件进行操作的时候。</p>
<p>安全模式下执行程序主目录如果安全模式打开了，但是却是要执行某些程序的时候，可以指定要执行程序的主目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode_exec_dir = D:/usr/bin</div></pre></td></tr></table></figure></p>
<p>一般情况下是不需要执行什么程序的，所以推荐不要执行系统程序目录，可以指向一个目录，然后把需要执行的程序拷贝过去，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode_exec_dir = D:/tmp/cmd</div></pre></td></tr></table></figure></p>
<p>但是，我更推荐不要执行任何程序，那么就可以指向我们网页目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode_exec_dir = D:/usr/www</div></pre></td></tr></table></figure></p>
<p>安全模式下包含文件如果要在安全模式下包含某些公共文件，那么就修改一下选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode_include_dir = D:/usr/www/include/</div></pre></td></tr></table></figure></p>
<p>其实一般php脚本中包含文件都是在程序自己已经写好了，这个可以根据具体需要设置。</p>
<h5 id="控制php脚本能访问的目录"><a href="#控制php脚本能访问的目录" class="headerlink" title="控制php脚本能访问的目录"></a>控制php脚本能访问的目录</h5><p>使用open_basedir选项能够控制PHP脚本只能访问指定的目录，这样能够避免PHP脚本访问不应该访问的文件，一定程度上限制了phpshell的危害，我们一般可以设置为只能访问网站目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open_basedir = D:/usr/www</div></pre></td></tr></table></figure></p>
<h5 id="关闭危险函数"><a href="#关闭危险函数" class="headerlink" title="关闭危险函数"></a>关闭危险函数</h5><p>如果打开了安全模式，那么函数禁止是可以不需要的，但是我们为了安全还是考虑进去。比如，<br>我们觉得不希望执行包括system()等在那的能够执行命令的php函数，或者能够查看php信息的<br>phpinfo()等函数，那么我们就可以禁止它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disable_functions = system,passthru,exec,shell_exec,popen,phpinfo</div></pre></td></tr></table></figure></p>
<p>如果你要禁止任何文件和目录的操作，那么可以关闭很多文件操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disable_functions = chdir,chroot,dir,getcwd,opendir,readdir,scandir,fopen,unlink,delete,copy,mkdir, rmdir,rename,file,file_get_contents,fputs,fwrite,chgrp,chmod,chown</div></pre></td></tr></table></figure></p>
<p>以上只是列了部分不叫常用的文件处理函数，你也可以把上面执行命令函数和这个函数结合，就能够抵制大部分的phpshell了。</p>
<h5 id="关闭PHP版本信息"><a href="#关闭PHP版本信息" class="headerlink" title="关闭PHP版本信息"></a>关闭PHP版本信息</h5><p>关闭PHP版本信息在http头中的泄漏我们为了防止黑客获取服务器中php版本的信息，可以关闭该信息斜路在http头中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expose_php = Off</div></pre></td></tr></table></figure></p>
<p>比如黑客在 telnet www.12345.com 80 的时候，那么将无法看到PHP的信息。</p>
<h5 id="关闭注册全局变量"><a href="#关闭注册全局变量" class="headerlink" title="关闭注册全局变量"></a>关闭注册全局变量</h5><p>在PHP中提交的变量，包括使用POST或者GET提交的变量，都将自动注册为全局变量，能够直接访问，这是对服务器非常不安全的，所以我们不能让它注册为全局变量，就把注册全局变量选项关闭：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">register_globals = Off</div></pre></td></tr></table></figure></p>
<p>当然，如果这样设置了，那么获取对应变量的时候就要采用合理方式，比如获取GET提交的变量var，那么就要用$_GET[‘var’]来进行获取，这个php程序员要注意。</p>
<h5 id="打开magic-quotes-gpc来防止SQL注入"><a href="#打开magic-quotes-gpc来防止SQL注入" class="headerlink" title="打开magic_quotes_gpc来防止SQL注入"></a>打开magic_quotes_gpc来防止SQL注入</h5><p>SQL注入是非常危险的问题，小则网站后台被入侵，重则整个服务器沦陷，所以一定要小心。php.ini中有一个设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">magic_quotes_gpc = Off</div></pre></td></tr></table></figure></p>
<p>这个默认是关闭的，如果它打开后将自动把用户提交对sql的查询进行转换，比如把 ‘ 转为 &#39;等，这对防止sql注射有重大作用。所以我们推荐设置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">magic_quotes_gpc = On</div></pre></td></tr></table></figure></p>
<h5 id="错误信息控制"><a href="#错误信息控制" class="headerlink" title="错误信息控制"></a>错误信息控制</h5><p>一般php在没有连接到数据库或者其他情况下会有提示错误，一般错误信息中会包含php脚本当前的路径信息或者查询的SQL语句等信息，这类信息提供给黑客后，是不安全的，所以一般服务器建议禁止错误提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display_errors = Off</div></pre></td></tr></table></figure></p>
<p>如果你却是是要显示错误信息，一定要设置显示错误的级别，比如只显示警告以上的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error_reporting = E_WARNING &amp; E_ERROR</div></pre></td></tr></table></figure></p>
<p>当然，我还是建议关闭错误提示。</p>
<p><strong>同时，错误日志建议在关闭display_errors后能够把错误信息记录下来，便于查找服务器运行的原因</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log_errors = On</div></pre></td></tr></table></figure></p>
<p>同时也要设置错误日志存放的目录，建议根apache的日志存在一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error_log = D:/usr/local/apache2/logs/php_error.log</div></pre></td></tr></table></figure></p>
<p>注意：日志文件必须允许apache用户的和组具有写的权限。</p>
<h4 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h4><p>对于操作数据库的SQL语句，需要特别注意安全性，因为用户可能输入特定语句使得原有的SQL语句改变了功能。类似下面的例子：</p>
<blockquote>
<p>$sql = “select * from pinfo where product = ‘$product’”;</p>
</blockquote>
<p>此时如果用户输入的$product参数为：</p>
<blockquote>
<p>39’; DROP pinfo; SELECT ‘FOO</p>
</blockquote>
<p>那么最终SQL语句就变成了如下的样子：</p>
<blockquote>
<p>select product from pinfo where product = ‘39’; DROP pinfo; SELECT ‘FOO’</p>
</blockquote>
<p>这样就会变成三条SQL语句，会造成pinfo表被删除，这样会造成严重的后果。</p>
<p>这个问题可以简单的使用PHP的内置函数解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$sql = &apos;Select * from pinfo where product = &apos;&quot;&apos;</div><div class="line">mysql_real_escape_string($product) . &apos;&quot;&apos;;</div></pre></td></tr></table></figure></p>
<h5 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h5><h6 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h6><p>主要就是一些数据没有经过严格的验证，然后直接拼接 SQL 去查询。导致漏洞产生，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$id  = $_GET[&apos;id&apos;];</div><div class="line">$sql = &quot;SELECT name FROM users WHERE id = $id&quot;;</div></pre></td></tr></table></figure></p>
<p>因为没有对 $_GET[‘id’] 做数据类型验证，注入者可提交任何类型的数据，比如 “ and 1= 1 or “ 等不安全的数据。如果按照下面方式写，就安全一些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$id  = intval($_GET[&apos;id&apos;]);</div><div class="line">$sql = &quot;SELECT name FROM users WHERE id = $id&quot;;</div></pre></td></tr></table></figure></p>
<p>把 id 转换成 int 类型，就可以去掉不安全的东西。</p>
<h6 id="验证数据"><a href="#验证数据" class="headerlink" title="验证数据"></a>验证数据</h6><p>防止注入的第一步就是验证数据，可以根据相应类型进行严格的验证。比如 int 类型直接同过 intval 进行转换就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$id =intval( $_GET[&apos;id&apos;]);</div></pre></td></tr></table></figure></p>
<p>字符处理起来比较复杂些，首先通过 sprintf 函数格式话输出，确保它是一个字符串。然后通过一些安全函数去掉一些不合法的字符，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str = addslashes(sprintf(&quot;%s&quot;,$str));</div></pre></td></tr></table></figure></p>
<p>也可以用 mysqli_real_escape_string　函数替代addslashes这样处理以后会比较安全。当然还可以进一步去判断字符串长度，去防止「缓冲区溢出攻击」比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$str = addslashes(sprintf(&quot;%s&quot;,$str));　</div><div class="line">$str = substr($str,0,40); //最大长度为40</div></pre></td></tr></table></figure></p>
<h6 id="参数化绑定"><a href="#参数化绑定" class="headerlink" title="参数化绑定"></a>参数化绑定</h6><p>参数化绑定，防止 SQL 注入的又一道屏障。php MySQLi 和 PDO 均提供这样的功能。比如 MySQLi 可以这样去查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$mysqli = new mysqli(&apos;localhost&apos;, &apos;my_user&apos;, &apos;my_password&apos;, &apos;world&apos;);</div><div class="line">$stmt = $mysqli-&gt;prepare(&quot;INSERT INTO my_table VALUES (?, ?, ?, ?)&quot;);</div><div class="line">$code = &apos;DEU&apos;;</div><div class="line">$language = &apos;Bavarian&apos;;</div><div class="line">$official = &quot;F&quot;;</div><div class="line">$percent = 11.2;</div><div class="line">$stmt-&gt;bind_param(&apos;sssd&apos;, $code, $language, $official, $percent);</div></pre></td></tr></table></figure>
<p>PDO 的更是方便，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Execute a prepared statement by passing an array of values */</div><div class="line">$sql = &apos;SELECT name, colour, calories  </div><div class="line">FROM fruit</div><div class="line">WHERE calories &lt; :calories AND colour = :colour&apos;; $sth = $dbh-&gt;prepare($sql, array(PDO::ATTR_CURSOR =&gt; PDO::CURSOR_FWDONLY));</div><div class="line">$sth-&gt;execute(array(&apos;:calories&apos; =&gt; 150, &apos;:colour&apos; =&gt; &apos;red&apos;));</div><div class="line">$red = $sth-&gt;fetchAll();</div><div class="line">$sth-&gt;execute(array(&apos;:calories&apos; =&gt; 175, &apos;:colour&apos; =&gt; &apos;yellow&apos;));</div><div class="line">$yellow = $sth-&gt;fetchAll();</div></pre></td></tr></table></figure></p>
<p>我们多数使用 php 的框架进行编程，所以最好不要自己拼写 SQL，按照框架给定参数绑定进行查询。遇到较为复杂的 SQL 语句，一定要自己拼写的时候，一定要注意严格的判断。没有用 PDO 或者 MySQLi 也可以自己写个 prepared，比如 wordprss db 查询语句，可以看出也是经过严格的类型验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function prepare( $query, $args ) &#123;</div><div class="line">    if ( is_null( $query ) )</div><div class="line">         return;</div><div class="line">    // This is not meant to be foolproof -- </div><div class="line">           but it will catch obviously incorrect usage.</div><div class="line">    if ( strpos( $query, &apos;%&apos; ) === false ) &#123;</div><div class="line">         _doing_it_wrong( &apos;wpdb::prepare&apos; , </div><div class="line">         sprintf ( __( &apos;The query argument of %s</div><div class="line">                 must have a placeholder.&apos; ), &apos;wpdb::prepare()&apos; ), &apos;3.9&apos; );</div><div class="line">   &#125;</div><div class="line">    $args = func_get_args();</div><div class="line">    array_shift( $args );</div><div class="line">    // If args were passed as an array (as in vsprintf), move them up</div><div class="line">    if ( isset( $args[ 0] ) &amp;&amp; is_array( $args[0]) )</div><div class="line">         $args = $args [0];</div><div class="line">    $query = str_replace( &quot;&apos;%s&apos;&quot;, &apos;%s&apos; , $query ); </div><div class="line">        // in case someone mistakenly already singlequoted it</div><div class="line">    $query = str_replace( &apos;&quot;%s&quot;&apos;, &apos;%s&apos; , $query ); </div><div class="line">        // doublequote unquoting</div><div class="line">    $query = preg_replace( &apos;|(?&lt;!%)%f|&apos; , &apos;%F&apos; , $query ); </div><div class="line">        // Force floats to be locale unaware</div><div class="line">    $query = preg_replace( &apos;|(?&lt;!%)%s|&apos;, &quot;&apos;%s&apos;&quot; , $query ); </div><div class="line">        // quote the strings, avoiding escaped strings like %%s</div><div class="line">    array_walk( $args, array( $this, &apos;escape_by_ref&apos; ) );</div><div class="line">    return @ vsprintf( $query, $args );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="防止基本的XSS攻击"><a href="#防止基本的XSS攻击" class="headerlink" title="防止基本的XSS攻击"></a>防止基本的XSS攻击</h4><p>XSS攻击不像其他攻击，这种攻击在客户端进行，最基本的XSS工具就是<strong>防止一段javascript脚本在用户待提交的表单页面，将用户提交的数据和cookie偷取过来</strong>。</p>
<p>XSS工具比SQL注入更加难以防护，各大公司网站都被XSS攻击过，虽然这种攻击与php语言无关，但可以使用php来筛选用户数据达到保护用户数据的目的，这里主要使用的是对用户的数据进行过滤，一般过滤掉HTML标签，特别是a标签。下面是一个普通的过滤方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function transform_HTML($string, $length = null) &#123;</div><div class="line">    // Helps prevent XSS attacks</div><div class="line">    // Remove dead space.</div><div class="line">    $string = trim($string);</div><div class="line">    // Prevent potential Unicode codec problems.</div><div class="line">    $string = utf8_decode($string);</div><div class="line">    // HTMLize HTML-specific characters.</div><div class="line">    $string = htmlentities($string, ENT_NOQUOTES);</div><div class="line">    $string = str_replace(&quot;#&quot;, &quot;#&quot;, $string);</div><div class="line">    $string = str_replace(&quot;%&quot;, &quot;%&quot;, $string);</div><div class="line">    $length = intval($length);</div><div class="line">    if ($length &gt; 0) &#123;</div><div class="line">        $string = substr($string, 0, $length);</div><div class="line">    &#125;</div><div class="line">    return $string;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数将HTML的特殊字符转换为了HTML实体，浏览器在渲染这段文本的时候以纯文本形式显示。如bold会被显示为：</p>
<strong>BoldText</strong>

<p>上述函数的核心就是==htmlentities函数==，这个函数将html特殊标签转换为html实体字符，这样可以过滤大部分的XSS攻击。</p>
<p>但是对于有经验的XSS攻击者，有更加巧妙的办法进行攻击：将他们的恶意代码使用十六进制或者utf-8编码，而不是普通的ASCII文本，例如可以使用下面的方式进行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;http://host/a.php?variable=%22%3e %3c%53%43%52%49%50%54%3e%44%6f%73%6f%6d%65%74%68%69%6e%67%6d%61%6c%69%63%69%6f%75%73%3c%2f%53%43%52%49%50%54%3e&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>这样浏览器渲染的结果其实是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;http://host/a.php?variable=&quot;&gt;                   &lt;SCRIPT&gt;Dosomethingmalicious&lt;/SCRIPT&gt;</div><div class="line">&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>这样就达到了攻击的目的。为了防止这种情况，需要在transform_HTML函数的基础上再将#和%转换为他们对应的实体符号，同时加上了$length参数来限制提交的数据的最大长度。</p>
<h4 id="使用SafeHTML防止XSS攻击"><a href="#使用SafeHTML防止XSS攻击" class="headerlink" title="使用SafeHTML防止XSS攻击"></a>使用SafeHTML防止XSS攻击</h4><p>上述关于XSS攻击的防护非常简单，但是不包含用户的所有标记，同时有上百种绕过过滤函数提交javascript代码的方法，也没有办法能完全阻止这个情况。</p>
<p>目前，没有一个单一的脚本能保证不被攻击突破，但是总有相对来说防护程度更好的。一共有两个安全防护的方式：白名单和黑名单。其中白名单更加简单和有效。</p>
<p>一种白名单解决方案就是SafeHTML，它足够智能能够识别有效的HTML，然后就可以去除任何危险的标签。这个需要基于HTMLSax包来进行解析。</p>
<blockquote>
<p>安装使用SafeHTML的方法：<br>1、前往<a href="http://pixel-apes.com/safehtml/?page=safehtml" target="_blank" rel="external">http://pixel-apes.com/safehtml/?page=safehtml</a> 下载最新的SafeHTML<br>2、将文件放入服务器的classes 目录，这个目录包含所有的SafeHTML和HTMLSax库<br>3、在自己的脚本中包含SafeHTML类文件<br>4、建立一个SafeHTML对象<br>5、使用parse方法进行过滤</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    /* If you&apos;re storing the HTMLSax3.php in the /classes directory, along</div><div class="line">    with the safehtml.php script, define XML_HTMLSAX3 as a null string. */</div><div class="line">    define(XML_HTMLSAX3, &apos;&apos;);</div><div class="line">    // Include the class file.</div><div class="line">    require_once(&apos;classes/safehtml.php&apos;);</div><div class="line">    // Define some sample bad code.</div><div class="line">    $data = &quot;This data would raise an alert &lt;script&gt;alert(&apos;XSS Attack&apos;)&lt;/script&gt;&quot;;</div><div class="line">    // Create a safehtml object.</div><div class="line">    $safehtml = new safehtml();</div><div class="line">    // Parse and sanitize the data.</div><div class="line">    $safe_data = $safehtml-&gt;parse($data);</div><div class="line">    // Display result.</div><div class="line">    echo &apos;The sanitized data is &lt;br /&gt;&apos; . $safe_data;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>SafeHTML并不能完全防止XSS攻击，只是一个相对复杂的脚本来检验的方式。</p>
<p>使用单向HASH加密方式来保护数据</p>
<p>单向hash加密保证对每个用户的密码都是唯一的，而且不能被破译的，只有最终用户知道密码，系统也是不知道原始密码的。这样的一个好处是在系统被攻击后攻击者也无法知道原始密码数据。</p>
<p>加密和Hash是不同的两个过程。与加密不同，Hash是无法被解密的，是单向的；同时两个不同的字符串可能会得到同一个hash值，并不能保证hash值的唯一性。</p>
<p>MD5函数处理过的hash值基本不能被破解，但是总是有可能性的，而且网上也有MD5的hash字典。</p>
<h4 id="使用mcrypt加密数据"><a href="#使用mcrypt加密数据" class="headerlink" title="使用mcrypt加密数据"></a>使用mcrypt加密数据</h4><p>MD5 hash函数可以在可读的表单中显示数据，但是对于存储用户的信用卡信息的时候，需要进行加密处理后存储，并且需要之后进行解密。</p>
<p>最好的方法是使用mcrypt模块，这个模块包含了超过30中加密方式来保证只有加密者才能解密数据。</p>
<blockquote>
<p>mcrypt函数需要以下信息：<br>1、待加密数据<br>2、用来加密和解密数据的key<br>3、用户选择的加密数据的特定算法（cipher：如 MCRYPT_TWOFISH192,MCRYPT_SERPENT_256， MCRYPT_RC2, MCRYPT_DES, and MCRYPT_LOKI97）<br>4、用来加密的模式<br>5、加密的种子，用来起始加密过程的数据，是一个额外的二进制数据用来初始化加密算法<br>6、加密key和种子的长度，使用mcrypt_get_key_size函数和mcrypt_get_block_size函数可以获取</p>
</blockquote>
<p>如果数据和key都被盗取，那么攻击者可以遍历ciphers寻找开行的方式即可，因此我们需要将加密的key进行MD5一次后保证安全性。同时由于mcrypt函数返回的加密数据是一个二进制数据，这样保存到数据库字段中会引起其他错误，使用了base64encode将这些数据转换为了十六进制数方便保存。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>安全性很重要，也可以看出一个人基本功，项目漏洞百出，扩展性和可维护性再好也没有用。平时多留意，树立安全意识，养成一种习惯，一些基本的安全当然也不会占用用 coding 的时间。养成这个习惯，即便在项目急，时间短的情况一下，依然可以做的质量很高。不要等到自己以后负责的东西，数据库都被拿走了，造成损失才重视。共勉！</p>
<p>虽然国内很多PHP程序员仍在依靠addslashes防止SQL注入，还是建议大家加强中文防止SQL注入的检查。addslashes的问题在于黑客可以用0xbf27来代替单引号，而addslashes只是将0xbf27修改为0xbf5c27，成为一个有效的多字节字符，其中的0xbf5c仍会被看作是单引号，所以addslashes无法成功拦截。</p>
<p>当然addslashes也不是毫无用处，它是用于单字节字符串的处理，多字节字符还是用mysql_real_escape_string吧。</p>
<blockquote>
<p>引用 <a href="https://www.daijiale.cn/back-end-dev/【php】php安全性开发.html" target="_blank" rel="external">https://www.daijiale.cn/back-end-dev/【php】php安全性开发.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;“php给了开发者极大的灵活性，但是这也为安全问题带来了潜在的隐患，近期需要总结一下以往的问题，在这里借翻译一篇文
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
</feed>
