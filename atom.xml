<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-10T16:11:48.932Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>My-Plan</title>
    <link href="http://yoursite.com/2017/09/11/My-Plan/"/>
    <id>http://yoursite.com/2017/09/11/My-Plan/</id>
    <published>2017-09-10T23:26:42.000Z</published>
    <updated>2017-09-10T16:11:48.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在大一的这个小学期，课不是很多，技术这一块也遇到了一些瓶颈，感觉自己都懂又感觉自己都不懂，看网上的教程，觉得自己掌握了，但要实际运用起来却又不是很遂心应手，自己也不知道自己现在是个什么情况。这跟自己当初学吉他有点相识之处啊，网上能看到的吉他教材啊、视频呀，自己看也能明白，但只要自己拿起吉他，就不知道要弹什么了，就是一种眼高手低的状态吧，跟现在学习的状态是一样一样的。</p>
<p>自己这几天也不做什么事，没课就跟老乡骑小黄车四处逛，长沙的公园都快被我们逛完了。自己也利用这几天也想了许多，总觉得自己走进了死胡同—-一直在学习，但从未使用学的东西。在高中学吉他那会，自己自以为是的觉得只要学会了所有的技巧，就能弹奏所有的曲子了，但事实证明这是错的，自己虽然懂得了所有的技巧，但并不懂得怎么在正确的时间使用，这也无济于事，就相当于没学过一样。所以，自己不能在犯同样的错误了，学了，还有使用，懂得去运用自己所学的东西也是学习的一部分…</p>
<p>So，这学期也不要学太多新的东西啦，重点要放在怎么使用自己学过的东西，在使用的过程中学习。</p>
<h3 id="My-Plan"><a href="#My-Plan" class="headerlink" title="My Plan"></a>My Plan</h3><ul>
<li>自己完成一些Java、JavaWeb项目 （参照亮剑Java（JavaWeb） 项目开发案例导航）</li>
<li>学习Linux，对服务器进行管理</li>
<li>学习数据结构，对算法的积累</li>
<li>…</li>
</ul>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p>大一整整一年，自己几乎把所有的时间都放在了技术的学习上，天真的以为只要技术牛逼就万事大吉了。经过这一年的摸索，发现自己真的很傻，事情并非如此。自己虽然是计算机专业，但并不是说自己的生活里就只能是代码，也不能就只把自己定义为码农、程序员，这不是自己的唯一的道路。坦白点，学程序无非就是为了赚钱。赚钱不只有写程序这一个办法，还有很多办法呢，自己的眼界要开阔，比如说可以炒炒股呀、卖点东西呀…</p>
<p>此外，程序不能是自己生活的全部，自己不能把自己的爱好丢了，虽然不能天天玩吉他了，但这并不代表每天都不玩了；虽然不能天天去打球、运动了，但并不代表每天都不去了…</p>
<p>以后要想有更多的机会，并不是会写程序就可以的，还要有其他的一些辅助技能，比如说语言啦、沟通能力啦、管理能力啦…这些都是很重要的东西，也是自己要提高的东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在大一的这个小学期，课不是很多，技术这一块也遇到了一些瓶颈，感觉自己都懂又感觉自己都不懂，看网上的教程，觉得自己掌握了，但要实际运用起来却又
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划从新手到专家</title>
    <link href="http://yoursite.com/2017/09/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E4%B8%93%E5%AE%B6/"/>
    <id>http://yoursite.com/2017/09/09/动态规划从新手到专家/</id>
    <published>2017-09-08T16:00:34.000Z</published>
    <updated>2017-09-10T16:18:53.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们遇到的问题中，有很大一部分可以用动态规划(简称DP)来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解题。 这篇文章是基于实例展开来讲的，因为干巴巴的理论实在不好理解。</p>
<p>注意：如果你对于其中某一节已经了解并且不想阅读它，没关系，直接跳过它即可。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>简介(入门)</p>
<p>什么是动态规划，我们要如何描述它?</p>
<p>动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。</p>
<p>现在让我们通过一个例子来了解一下DP的基本原理。</p>
<p>首先，我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。</p>
<p>“状态”代表什么及如何找到它?</p>
<p>“状态”用来描述该问题的子问题的解。</p>
<p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)</p>
<p>首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11) ？为什么要这么问呢? 两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。</p>
<p>好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。</p>
<p>OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。</p>
<p>上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”， 这个状态是怎么找出来的呢？我在另一篇文章 动态规划之背包问题(一)中写过： 根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p>
<p>d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值;</p>
<p>有了状态和状态转移方程，这个问题基本上也就解决了。当然了，Talk is cheap,show me the code!</p>
<p>  从上图可以得出，要凑够11元至少需要3枚硬币。</p>
<p>此外，通过追踪我们是如何从前一个状态值得到当前状态值的， 可以找到每一次我们用的是什么面值的硬币。比如，从上面的图我们可以看出， 最终结果d(11)=d(10)+1(面值为1)，而d(10)=d(5)+1(面值为5)，最后d(5)=d(0)+1 (面值为5)。所以我们凑够11元最少需要的3枚硬币是：1元、5元、5元。</p>
<h3 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h3><p>上面讨论了一个非常简单的例子。现在让我们来看看对于更复杂的问题， 如何找到状态之间的转移方式(即找到状态转移方程)。 为此我们要引入一个新词叫递推关系来将状态联系起来(说的还是状态转移方程)</p>
<p>OK，上例子，看看它是如何工作的。</p>
<p>一个序列有N个数：A<a href="./images/sum.png" title="sum">1</a>,A[2],…,A[N]，求出最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)</p>
<p>正如上面我们讲的，面对这样一个问题，我们首先要定义一个“状态”来代表它的子问题， 并且找到它的解。注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。</p>
<p>让我们沿用“入门”一节里那道简单题的思路来一步步找到“状态”和“状态转移方程”。 假如我们考虑求A<a href="./images/sum.png" title="sum">1</a>,A[2],…,A[i]的最长非降子序列的长度，其中i&lt;N， 那么上面的问题变成了原问题的一个子问题(问题规模变小了，你可以让i=1,2,3等来分析) 然后我们定义d(i)，表示前i个数中以A[i]结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p>
<p>为了方便理解我们是如何找到状态转移方程的，我先把下面的例子提到前面来讲。 如果我们要求的这N个数的序列是：</p>
<p>5，3，4，8，6，7<br>根据上面找到的状态，我们可以得到：（下文的最长非降子序列都用LIS表示）</p>
<p>前1个数的LIS长度d(1)=1(序列：5)<br>前2个数的LIS长度d(2)=1(序列：3；3前面没有比3小的)<br>前3个数的LIS长度d(3)=2(序列：3，4；4前面有个比它小的3，所以d(3)=d(2)+1)<br>前4个数的LIS长度d(4)=3(序列：3，4，8；8前面比它小的有3个数，所以 d(4)=max{d(1),d(2),d(3)}+1=3)<br>OK，分析到这，我觉得状态转移方程已经很明显了，如果我们已经求出了d(1)到d(i-1)， 那么d(i)可以用下面的状态转移方程得到：</p>
<p>d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;=A[i]<br>用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。</p>
<p>Talk is cheap, show me the code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int lis(int A[], int n)&#123;</div><div class="line">    int *d = new int[n];</div><div class="line">    int len = 1;</div><div class="line">    for(int i=0; i&lt;n; ++i)&#123;</div><div class="line">        d[i] = 1;</div><div class="line">        for(int j=0; j&lt;i; ++j)</div><div class="line">            if(A[j]&lt;=A[i] &amp;&amp; d[j]+1&gt;d[i])</div><div class="line">                d[i] = d[j] + 1;</div><div class="line">        if(d[i]&gt;len) len = d[i];</div><div class="line">    &#125;</div><div class="line">    delete[] d;</div><div class="line">    return len;</div><div class="line">&#125;</div><div class="line">int main()&#123;</div><div class="line">    int A[] = &#123;</div><div class="line">        5, 3, 4, 8, 6, 7</div><div class="line">    &#125;;</div><div class="line">    cout&lt;&lt;lis(A, 6)&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该算法的时间复杂度是O(n^2 )，并不是最优的解法。 还有一种很巧妙的算法可以将时间复杂度降到O(nlogn)，网上已经有各种文章介绍它， 这里就不再赘述。传送门： LIS的O(nlogn)解法。 此题还可以用“排序+LCS”来解，感兴趣的话可自行Google。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我们遇到的问题中，有很大一部分可以用动态规划(简称DP)来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划之背包问题</title>
    <link href="http://yoursite.com/2017/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/09/06/动态规划之背包问题/</id>
    <published>2017-09-06T15:44:51.000Z</published>
    <updated>2017-09-06T07:55:15.399Z</updated>
    
    <content type="html"><![CDATA[<p>一切都要从一则故事说起。</p>
<p>话说有一哥们去森林里玩发现了一堆宝石，他数了数，一共有n个。 但他身上能装宝石的就只有一个背包，背包的容量为C。这哥们把n个宝石排成一排并编上号： 0,1,2,…,n-1。第i个宝石对应的体积和价值分别为V[i]和W[i] 。排好后这哥们开始思考： 背包总共也就只能装下体积为C的东西，那我要装下哪些宝石才能让我获得最大的利益呢？</p>
<p>OK，如果是你，你会怎么做？你斩钉截铁的说：动态规划啊！恭喜你，答对了。 那么让我们来看看，动态规划中最最最重要的两个概念： 状态和状态转移方程在这个问题中分别是什么。</p>
<p>我们要怎样去定义状态呢？这个状态总不能是凭空想象或是从天上掉下来的吧。 为了方便说明，让我们先实例化上面的问题。一般遇到n，你就果断地给n赋予一个很小的数， 比如n=3。然后设背包容量C=10，三个宝石的体积为5，4，3，对应的价值为20，10，12。 对于这个例子，我想智商大于0的人都知道正解应该是把体积为5和3的宝石装到背包里， 此时对应的价值是20+12=32。接下来，我们把第三个宝石拿走， 同时背包容量减去第三个宝石的体积（因为它是装入背包的宝石之一）， 于是问题的各参数变为：n=2，C=7，体积｛5，4｝，价值｛20，10｝。好了， 现在这个问题的解是什么？我想智商等于0的也解得出了：把体积为5的宝石放入背包 （然后剩下体积2，装不下第二个宝石，只能眼睁睁看着它溜走），此时价值为20。 这样一来，我们发现，n=3时，放入背包的是0号和2号宝石；当n=2时， 我们放入的是0号宝石。这并不是一个偶然，没错， 这就是传说中的“全局最优解包含局部最优解”（n=2是n=3情况的一个局部子问题）。 绕了那么大的圈子，你可能要问，这都哪跟哪啊？说好的状态呢？说好的状态转移方程呢？ 别急，它们已经呼之欲出了。</p>
<p>我们再把上面的例子理一下。当n=2时，我们要求的是前2个宝石， 装到体积为7的背包里能达到的最大价值；当n=3时，我们要求的是前3个宝石， 装到体积为10的背包里能达到的最大价值。有没有发现它们其实是一个句式！OK， 让我们形式化地表示一下它们， 定义d(i,j)为前i个宝石装到剩余体积为j的背包里能达到的最大价值。 那么上面两句话即为：d(2, 7)和d(3, 10)。这样看着真是爽多了， 而这两个看着很爽的符号就是我们要找的状态了。 即状态d(i,j)表示前i个宝石装到剩余体积为j的背包里能达到的最大价值。 上面那么多的文字，用一句话概括就是：根据子问题定义状态！你找到子问题， 状态也就浮出水面了。而我们最终要求解的最大价值即为d(n, C)：前n个宝石 （0,1,2…,n-1）装入剩余容量为C的背包中的最大价值。状态好不容易找到了， 状态转移方程呢？顾名思义，状态转移方程就是描述状态是怎么转移的方程（好废话！）。 那么回到例子，d(2, 7)和d(3, 10)是怎么转移的？来，我们来说说2号宝石 （记住宝石编号是从0开始的）。从d(2, 7)到d(3, 10)就隔了这个2号宝石。 它有两种情况，装或者不装入背包。如果装入，在面对前2个宝石时， 背包就只剩下体积7来装它们，而相应的要加上2号宝石的价值12， d(3, 10)=d(2, 10-3)+12=d(2, 7)+12；如果不装入，体积仍为10，价值自然不变了， d(3, 10)=d(2, 10)。记住，d(3, 10)表示的是前3个宝石装入到剩余体积为10 的背包里能达到的最大价值，既然是最大价值，就有d(3, 10)=max{ d(2, 10), d(2, 7)+12 }。好了，这条方程描述了状态d(i, j)的一些关系， 没错，它就是状态转移方程了。把它形式化一下：d(i, j)=max{ d(i-1, j), d(i-1,j-V[i-1]) + W[i-1] }。注意讨论前i个宝石装入背包的时候， 其实是在考查第i-1个宝石装不装入背包（因为宝石是从0开始编号的）。至此， 状态和状态转移方程都已经有了。接下来，直接上代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">    for(int j=0; j&lt;=C; ++j)&#123;</div><div class="line">        d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">        if(i&gt;0 &amp;&amp; j&gt;=V[i-1])  d[i][j] &gt;?= d[i-1][j-V[i-1]]+W[i-1];</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> i=0时，d(i, j)为什么为0呢？因为前0个宝石装入背包就是没东西装入，所以最大价值为0。 if语句里，j&gt;=V[i-1]说明只有当背包剩余体积j大于等于i-1号宝石的体积时， 我才考虑把它装进来的情况，不然d[i][j]就直接等于d[i-1][j]。i&gt;0不用说了吧， 前0个宝石装入背包的情况是边界，直接等于0，只有i&gt;0才有必要讨论， 我是装呢还是不装呢。简单吧，核心算法就这么一丁点，接下来上完整代码knapsack.cpp。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> /**0-1 knapsack d(i, j)表示前i个物品装到剩余容量为j的背包中的最大重量**/</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">#define MAXN 1000</div><div class="line">#define MAXC 100000</div><div class="line"></div><div class="line">int V[MAXN], W[MAXN];</div><div class="line">int d[MAXN][MAXC];</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);//重定向输入流</div><div class="line">	freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);//重定向输出流</div><div class="line">	int n, C;</div><div class="line">	while(scanf(&quot;%d %d&quot;, &amp;n, &amp;C) != EOF)&#123;</div><div class="line">		for(int i=0; i&lt;n; ++i)	scanf(&quot;%d %d&quot;, &amp;V[i], &amp;W[i]);</div><div class="line">		</div><div class="line">		for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">			for(int j=0; j&lt;=C; ++j)&#123;</div><div class="line">				d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">				if(i&gt;0 &amp;&amp; j&gt;=V[i-1])	d[i][j] &gt;?= d[i-1][j-V[i-1]]+W[i-1];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, d[n][C]);//最终求解的最大价值</div><div class="line">	&#125;</div><div class="line">	fclose(stdin);</div><div class="line">	fclose(stdout);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中freopen函数将标准输入流重定向到文件data.in， 这比运行程序时一点点手输要方便许多，将标准输出流重定向到data.out。 data.in中每组输入的第一行为宝石数量n及背包体积C，接下来会有n行的数据， 每行两个数对应的是宝石的体积及价值。本测试用例data.in如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">5 10</div><div class="line">4 9</div><div class="line">3 6</div><div class="line">5 1</div><div class="line">2 4</div><div class="line">5 1</div><div class="line">4 9</div><div class="line">4 20</div><div class="line">3 6</div><div class="line">4 20</div><div class="line">2 4</div><div class="line">5 10</div><div class="line">2 6</div><div class="line">2 3</div><div class="line">6 5</div><div class="line">5 4</div><div class="line">4 6</div></pre></td></tr></table></figure></p>
<p>data.out为算法输出结果，对应该测试用例，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">19</div><div class="line">40</div><div class="line">15</div></pre></td></tr></table></figure></p>
<p>好，至此我们解决了背包问题中最基本的0/1背包问题。等等，这时你可能要问， 我现在只知道背包能装入宝石的最大价值，但我还不知道要往背包里装入哪些宝石啊。嗯， 好问题！让我们先定义一个数组x，对于其中的元素为1时表示对应编号的宝石放入背包， 为0则不放入。让我们回到上面的例子，对于体积为5，4，3，价值为20，10，12的3个宝石 ，如何求得其对应的数组x呢？（明显我们目测一下就知道x={1 0 1}， 但程序可目测不出来）OK，让我们还是从状态说起。如果我们把2号宝石放入了背包， 那么是不是也就意味着，前3个宝石放入背包的最大价值要比前2个宝石放入背包的价值大， 即：d(3, 10)&gt;d(2, 10)。再用字母代替具体的数字 （不知不觉中我们就用了不完全归纳法哈），当d(i, j)&gt;d(i-1, j)时，x(i-1)=1;OK， 上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//输出打印方案</div><div class="line">int j = C;</div><div class="line">for(int i=n; i&gt;0; --i)&#123;</div><div class="line">    if(d[i][j] &gt; d[i-1][j])&#123;</div><div class="line">        x[i-1] = 1;</div><div class="line">        j = j - V[i-1];//装入第i-1个宝石后背包能装入的体积就只剩下j - V[i-1]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">for(int i=0; i&lt;n; ++i)  printf(&quot;%d &quot;, x[i]);</div></pre></td></tr></table></figure></p>
<p>好了，加入这部分内容，knapsack.cpp变为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**0-1 knapsack d(i, j)表示前i个物品装到剩余容量为j的背包中的最大重量**/</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">#define MAXN 1000</div><div class="line">#define MAXC 100000</div><div class="line"></div><div class="line">int V[MAXN], W[MAXN], x[MAXN];</div><div class="line">int d[MAXN][MAXC];</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);</div><div class="line">	freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);</div><div class="line">	int n, C;</div><div class="line">	while(scanf(&quot;%d %d&quot;, &amp;n, &amp;C) != EOF)&#123;</div><div class="line">		for(int i=0; i&lt;n; ++i)	scanf(&quot;%d %d&quot;, &amp;V[i], &amp;W[i]);</div><div class="line">		for(int i=0; i&lt;n; ++i)	x[i] = 0; //初始化打印方案</div><div class="line">		</div><div class="line">		for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">			for(int j=0; j&lt;=C; ++j)&#123;</div><div class="line">				d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">				if(i&gt;0 &amp;&amp; j&gt;=V[i-1])	d[i][j] &gt;?= d[i-1][j-V[i-1]]+W[i-1];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, d[n][C]);</div><div class="line">		</div><div class="line">		//输出打印方案</div><div class="line">		int j = C;</div><div class="line">		for(int i=n; i&gt;0; --i)&#123;</div><div class="line">			if(d[i][j] &gt; d[i-1][j])&#123;</div><div class="line">				x[i-1] = 1;</div><div class="line">				j = j - V[i-1];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		for(int i=0; i&lt;n; ++i)	printf(&quot;%d &quot;, x[i]);</div><div class="line">		printf(&quot;\n&quot;);</div><div class="line">	&#125;</div><div class="line">	fclose(stdin);</div><div class="line">	fclose(stdout);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>data.out输出结果变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">19</div><div class="line">1 1 0 1 0</div><div class="line">40</div><div class="line">1 0 1 0</div><div class="line">15</div><div class="line">1 1 0 0 1</div></pre></td></tr></table></figure></p>
<p>至此，好像该解决的问题都解决了。当一个问题找到一个放心可靠的解决方案后， 我们往往就要考虑一下是不是有优化方案了。为了保持代码的简洁， 我们暂且把宝石装包方案的求解去掉。该算法的时间复杂度是O(nC)， 即时间都花在两个for循环里了，这个应该是没办法再优化了。再看看空间复杂度， 数组d用来保存每个状态的值，空间复杂度为O(nC)； 数组V和W用来保存每个宝石的体积和价值，空间复杂度为O(n)。程序总的空间复杂度为 O(nC)，这个是可以进一步优化的。首先，我们先把数组V和W去掉， 因为它们没有保存的必要，改为一边读入一边计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int V = 0, W = 0;</div><div class="line">for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">    if(i&gt;0) scanf(&quot;%d %d&quot;, &amp;V,&amp;W);</div><div class="line">    for(int j=0; j&lt;=C;++j)&#123;</div><div class="line">        d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">        if(j&gt;=V &amp;&amp; i&gt;0) d[i][j] &gt;?= d[i-1][j-V]+W;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，接下来让我们继续压榨空间复杂度。保存状态值我们开了一个二维数组d， 在看过把一维数组V和W变为一个变量后，我们是不是要思考一下， 有没有办法将这个二维数组也压榨一下呢？换言之， 这个二维数组中的每个状态值我们真的有必要都保存么？ 让我们先来看一下以下的一张示意图（参照《算法竞赛入门经典》P169的图画的）<br><img src="./images/pic.png" alt="enter description here" title="pic"></p>
<p>由上面那一小段优化过后的代码可知，状态转移方程为：d(i, j)=max{ d(i-1, j), d(i-1, j-V)+W }，也就是在计算d(i, j)时我们用到了d(i-1,j)和d(i-1, j-V)的值。 如果我们只用一个一维数组d(0)～d(C)来保存状态值可以么？将i方向的维数去掉， 我们可以将原来二维数组表示为一维数据：d(i-1, j-V)变为d(j-V)， d(i-1, j)变为d(j)。当我们要计算d(i, j)时，只需要比较d(j)和d(j-V)+W的大小， 用较大的数更新d(j)即可。等等，如果我要计算d(i, j+1)，而它恰好要用到d(i-1, j)的值， 那么问题就出来了，因为你刚刚才把它更新为d(i, j)了。那么，怎么办呢？ 按照j递减的顺序即可避免这种问题。比如，你计算完d(i, j)， 接下来要计算的是d(i,j-1)，而它的状态转移方程为d(i, j-1)=max{ d(i-1, j-1), d(i-1, j-1-V)+W }，它不会再用到d(i-1,j)的值！所以， 即使该位置的值被更新了也无所谓。好，上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">memset(d, 0, sizeof(d));</div><div class="line">for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">    if(i&gt;0) scanf(&quot;%d %d&quot;, &amp;V,&amp;W);</div><div class="line">    for(int j=C;j&gt;=0; --j)&#123;</div><div class="line">        if(j&gt;=V &amp;&amp; i&gt;0) d[j] &gt;?= d[j-V]+W;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优化后的完整代码如下，此时空间复杂度仅为O(C)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**0-1 knapsack d(i, j)表示前i个物品装到剩余容量为j的背包中的最大重量**/</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cstdlib&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);</div><div class="line">	freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);</div><div class="line">	int n, C, V = 0, W = 0;</div><div class="line">	while(scanf(&quot;%d %d&quot;, &amp;n, &amp;C) != EOF)&#123;</div><div class="line">		int* d = (int*)malloc((C+1)*sizeof(int));</div><div class="line">		memset(d, 0, (C+1)*sizeof(int));</div><div class="line">		</div><div class="line">		for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">			if(i&gt;0)	scanf(&quot;%d %d&quot;, &amp;V, &amp;W);</div><div class="line">			for(int j=C; j&gt;=0; --j)&#123;</div><div class="line">				if(j&gt;=V &amp;&amp; i&gt;0)	d[j] &gt;?= d[j-V]+W;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, d[C]);</div><div class="line">		free(d);</div><div class="line">	&#125;</div><div class="line">	fclose(stdin);</div><div class="line">	fclose(stdout);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，背包问题暂时先讲这么多，以后接着讲。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一切都要从一则故事说起。&lt;/p&gt;
&lt;p&gt;话说有一哥们去森林里玩发现了一堆宝石，他数了数，一共有n个。 但他身上能装宝石的就只有一个背包，背包的容量为C。这哥们把n个宝石排成一排并编上号： 0,1,2,…,n-1。第i个宝石对应的体积和价值分别为V[i]和W[i] 。排好后这
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大二的一些改变</title>
    <link href="http://yoursite.com/2017/09/02/%E5%A4%A7%E4%BA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B9%E5%8F%98/"/>
    <id>http://yoursite.com/2017/09/02/大二的一些改变/</id>
    <published>2017-09-02T00:01:09.000Z</published>
    <updated>2017-09-01T16:29:33.774Z</updated>
    
    <content type="html"><![CDATA[<p>###<br>时间飞逝，转眼间，转眼间就大二了，看到大一新生报道的场景，仿佛看到了当初的自己—-那个带着无限的憧憬的少年。</p>
<p>是的，自己带着音乐的梦想、广交好友、说一口流利的英语等无限的纯真的想法来到这里，但不知为何一直都没有付诸行动，自己安慰自己说要忙专业的事情，觉得学好专业才是正确的事情，但也只有自己知道这是让自己内心好受一点的借口。</p>
<p>那么问题来了，什么才是正确的事情呢？在不知道答案的情况下，我要怎么选择呢？</p>
<p>在这个暑假，跟丰哥、日哥聚了一下，上一次见面好像是在高考后，算起来有一年不见了。丰哥买车了，日哥又重新开了一家琴行，大家都更上一层楼了，但在看看自己，在这一年里，自己在学校勉强不挂科，自己摸索着学习了一点网站的开发，就没什么其他能说的事情了，可悲。</p>
<p>这一年里，自己放下了吉他，也不再关心英语，能说话的朋友没几个，自己深知这样的大学生活不是自己想要的，但一直不知道要如何改变。不过，在这个暑假跟丰哥聊过之后，觉得计算机与音乐其实是可以结合在一起的，也谷歌到了一个新名词—-Computer  Music（王戈）。是的，计算机与音乐是可以联合起来的。我们深知计算机只是一个工具，一个帮助人们解决问题的工具，就像吉他是一个表现音乐的工具一样。我们要学的是怎么使用工具去解决实际的问题，而不是掌握工具。</p>
<p>丰哥还说了勤工俭学的事情，自己仔细算了算，大学这一年 确实是花了好多钱，学费高就不说了，自己还报名参加了外面的培训班，虽然自己知道这是正确的投资，但这一切都是建立在父母亲的辛苦之上的，不妥不妥。自己学吉他这么久了，没有用吉他来赚过一分钱，只有付出，没有任何回报….学了没有有，就等于没学，也是时候重新拿起吉他，以一个初学者的心态重新回忆，相信会有不同的收获。</p>
<p>一个人不能在同一个地方跌倒两次，所以自己摸索着学习的网站的开发的技能需要发挥出来，要能帮助自己，说白了，就是要得到回报。</p>
<p>还有就是朋友。自己参加了两个社团，吉他协会和排球协会，自己本来是有机会深入到核心团队的，但因为自己不是很把这些东西当回事，不是很上心，与协会里面的人只能说是认识，还不能是朋友的关系。在这一点上，自己需要改正，需要上心，只有我们把别人当成朋友，别人才能把自己当成朋友。</p>
<p>小智，就让你在大二遇见更好的你自己吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###&lt;br&gt;时间飞逝，转眼间，转眼间就大二了，看到大一新生报道的场景，仿佛看到了当初的自己—-那个带着无限的憧憬的少年。&lt;/p&gt;
&lt;p&gt;是的，自己带着音乐的梦想、广交好友、说一口流利的英语等无限的纯真的想法来到这里，但不知为何一直都没有付诸行动，自己安慰自己说要忙专业的事
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hibernate基础</title>
    <link href="http://yoursite.com/2017/08/12/Hibernate/"/>
    <id>http://yoursite.com/2017/08/12/Hibernate/</id>
    <published>2017-08-12T11:11:43.000Z</published>
    <updated>2017-09-01T16:39:51.022Z</updated>
    
    <content type="html"><![CDATA[<p>1.下载hibernate</p>
<pre><code>需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
</code></pre><p>2.解压hibernate</p>
<pre><code>下载后解压缩，得到一个hibernate-release-4.3.11.Final文件夹（我下载的hibernate版本是4.3.11），在hibernate-release-4.3.11.Final文件夹里有一个lib文件夹，里面放着hibernate的jar包。

例子中使用了lib下的required文件夹中的所有jar包。如图：



这些包的作用如下（待验证）：
</code></pre><p>包名<br>说明<br>antlr-2.7.7<br>可以接收词文法语言描述，并能产生识别这些语言的语句的程序，hibernate利用它实现hql到sql的转换。<br>dom4j-1.6.1<br>xml解析器，用来读写xml文件的。<br>hibernate-commons-annotations-4.0.5.Final<br>hibernate中支持注解开发的程序。<br>hibernate-core-4.3.11.Final<br>hibernate的核心程序。<br>hibernate-jpa-2.1-api-1.0.0.Final    hibernate对jap(java persistence API)规范的支持，可以理解为JAP是标准接口，hibernate是实现。<br>jandex-1.1.0.Final    用来检索注解(annotation)索引的程序，识别该对象是注解对象(待验证)？<br>javassist-3.18.1-GA    用来操作字节码的程序，可直接编辑和生成java字节码，以达到对.class文件的动态修改。<br>jboss-logging-3.1.3.GA    提供hibernate日志功能的程序(待验证)?<br>jboss-logging-annotations-1.2.0.Beta1    解析logging的注解模式程序(待验证)?<br>jboss-transaction-api_1.2_spec-1.0.0.Final    事务控制程序(待验证)?<br>3.导入hibernate的jar包</p>
<pre><code>创建一个JavaProject，引用上面图片中的jar包，这里需要另外一个jar包，由于我连接的是mysql数据库，所以需要在导入一个mysql-connector-java-5.1.7-bin.jar
</code></pre><p>4.新建一个测试用的java对象</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>public class User {</p>
<pre><code>public User() {
}

public User(String name, Date birthday) {
    this.name = name;
    this.birthday = birthday;
}

@Override
public String toString() {
    return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, birthday=&quot; + birthday
            + &quot;]&quot;;
}

public int getId() {
    return id;
}

public void setId(int id) {
    this.id = id;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public Date getBirthday() {
    return birthday;
}

public void setBirthday(Date birthday) {
    this.birthday = birthday;
}

private int id;
private String name;
private Date birthday;
</code></pre><p>}<br>    编写的java对象需要满足如下要素：</p>
<p>需要有一个无参的构造函数，因为在session.get时需要用到反射创建java对象；</p>
<p>需要提供一个id属性，对应数据库的主键；</p>
<p>需要为对象的其他属性提供get/set方法；</p>
<p>需要定义成非final的类，以便在hibernate进行延迟加载时为类创建代理；</p>
<p>如有必要保存到集合中，需要重equals方法和hashcode方法；</p>
<p>5.设置java对象与数据库的映射关系</p>
<pre><code>需要创建一个User.hbm.xml文件，编辑java对象与数据库的映射关系，格式如下：
</code></pre><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE hibernate-mapping PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN”<br>“<a href="http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-mapping><br>    <class name="cn.net.bysoft.lesson1.User" table="S_USER"><br>        <id name="id" type="integer" column="ID"><br>            <!-- 指定主键的生成方式，native是使用数据库本地的方式 --><br>            <generator class="native"></generator><br>        </id><br>        <property name="name" type="string" column="NAME"></property><br>        <property name="birthday" type="timestamp" column="BIRTHDAY"></property><br>    </class><br></hibernate-mapping><br>    该文件是用来配置java对象与数据表之间的映射关系的，其中需要留意的是id这个属性，generator来指定主键的生成方式，而native则代表是调用数据库本地的方式来生成主键，我使用的mysql数据库就会自动将id列设置成自增。</p>
<pre><code>主键具体有哪些生成方式，待接下来详细研究。
</code></pre><p>6.配置hibernate的配置信息</p>
<p>在src下创建一个hibernate.cfg.xml文件，格式如下：</p>
<p>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>    “-//Hibernate/Hibernate Configuration DTD 3.0//EN”<br>    “<a href="http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-configuration><br>    <session-factory><br>        <!-- 连接数据库的基本信息 --><br>        <property name="hibernate.connection.username">root</property><br>        <property name="hibernate.connection.password">root</property><br>        <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property><br>        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate4</property></session-factory></hibernate-configuration></p>
<pre><code>    &lt;!-- hibernate使用的数据库方言
         如果不知道可以去/hibernate-release-4.3.11.Final/project/etc/hibernate.properties
         中查找 --&gt;
    &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;
    &lt;!-- 是否在控制台显示sql语句 --&gt;
    &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否格式化显示的sql语句 --&gt;
    &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否自动生成数据表的策略,create代表每次启动程序都重新创建数据表 --&gt;
    &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;

    &lt;!-- 需要使用到的*.hbm.xml文件 --&gt;
    &lt;mapping resource=&quot;cn/net/bysoft/lesson1/User.hbm.xml&quot;/&gt;
&lt;/session-factory&gt;
</code></pre><p><br>    该文件需要注意的有两个地方，第一个是mapping属性，第二个是hibernate.hbm2ddl.auto这个属性。</p>
<pre><code>mapping属性用来配置*.hbm.xml的资源文件地址，这里需要注意的是没有用cn.net.bysoft.lession的形式，而是使用的&apos;/&apos;来描述目录位置。

接下来是自动执行ddl语句的设置(也就是hibernate.hbm2ddl.auto)参数有4个，分别是：
</code></pre><p>create</p>
<p>create为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来drop掉数据表，drop后重新create数据表；</p>
<p>create-drop</p>
<p>create-drop为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来create数据表。而每当sessionfactory被close时，会drop掉开始时create的数据表；</p>
<p>update</p>
<p>update为每次创建sessionfactory时，如果数据库中没有对应的表，则新建。</p>
<p>若已经新建过，则会判断*.hbm.xml文件的配置与建立好的数据表的结构是否相同。</p>
<p>如果相同则不去进行ddl的操作。</p>
<p>如果不同，则会根据*.hbm.xml文件中有变化的配置项去更新数据表，但不会删除数据表中已创建过的任何信息。</p>
<p>validate</p>
<p>validate为每次创建sessionfactory时，将用*.hbm.xml文件中的配置信息与现有的对应的数据表结构进行比较，若发现不同则抛出异常。</p>
<p>7.编写代码测试</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.hibernate.Transaction;<br>import org.hibernate.boot.registry.StandardServiceRegistry;<br>import org.hibernate.boot.registry.StandardServiceRegistryBuilder;<br>import org.hibernate.cfg.Configuration;<br>import org.junit.Test;</p>
<p>public class UserTest {</p>
<pre><code>@Test
public void test() {
    // 0.创建configuration对象，该对象保存着hibernate的配置信息和对象关系映射的信息。
    Configuration cfg = new Configuration().configure();
    // 1.创建sessionfactory对象
    StandardServiceRegistryBuilder builder = new StandardServiceRegistryBuilder().applySettings(cfg.getProperties());
    StandardServiceRegistry registry =  builder.build();
    SessionFactory sessionFactory = cfg.buildSessionFactory(registry); 
    // 2.创建session对象
    Session session = sessionFactory.openSession();
    // 3.开始事务
    Transaction transaction = session.beginTransaction();
    // 4.保存
    User user = new User(&quot;Jack&quot;, new Date());
    session.save(user);
    // 5.提交事务
    transaction.commit();
    // 6.关闭session对象
    session.close();
    // 7.关闭sessionfactory对象
    sessionFactory.close();
}
</code></pre><p>}<br>    上面这段代码中configuration对象用来保存则hibernate的配置信息，如hibernate.cfg.xml中的配置信息，和*.hbm.xml的映射信息。</p>
<pre><code>sessionfactory为创建session的工厂，它是线程安全的。一般建议一个项目中只有一个sessionfactory，因为创建sessionfactory非常费资源。

接下来是session对象，该对象是hibernate的核心，是一个单线程的对象，内部有session缓存。

对需要持久化的java对象的所有操作都用到了session。

常用的方法有get、load、save、update、saveorupdate、delete、begintransaction、isopen、flush、clear、evicto、close等等方法，接下来将会一个一个研究这些方法的使用。

这是执行这段代码后，控制台输出的内容：



创建了一张名为S_USER的数据表，并insert了一条数据。



到此位置，一个简单的hibernate环境就搭建好了。工程的目录结构如下：
</code></pre><p>1.下载hibernate</p>
<pre><code>需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
</code></pre><p>2.解压hibernate</p>
<pre><code>下载后解压缩，得到一个hibernate-release-4.3.11.Final文件夹（我下载的hibernate版本是4.3.11），在hibernate-release-4.3.11.Final文件夹里有一个lib文件夹，里面放着hibernate的jar包。

例子中使用了lib下的required文件夹中的所有jar包。如图：



这些包的作用如下（待验证）：
</code></pre><p>包名<br>说明<br>antlr-2.7.7<br>可以接收词文法语言描述，并能产生识别这些语言的语句的程序，hibernate利用它实现hql到sql的转换。<br>dom4j-1.6.1<br>xml解析器，用来读写xml文件的。<br>hibernate-commons-annotations-4.0.5.Final<br>hibernate中支持注解开发的程序。<br>hibernate-core-4.3.11.Final<br>hibernate的核心程序。<br>hibernate-jpa-2.1-api-1.0.0.Final    hibernate对jap(java persistence API)规范的支持，可以理解为JAP是标准接口，hibernate是实现。<br>jandex-1.1.0.Final    用来检索注解(annotation)索引的程序，识别该对象是注解对象(待验证)？<br>javassist-3.18.1-GA    用来操作字节码的程序，可直接编辑和生成java字节码，以达到对.class文件的动态修改。<br>jboss-logging-3.1.3.GA    提供hibernate日志功能的程序(待验证)?<br>jboss-logging-annotations-1.2.0.Beta1    解析logging的注解模式程序(待验证)?<br>jboss-transaction-api_1.2_spec-1.0.0.Final    事务控制程序(待验证)?<br>3.导入hibernate的jar包</p>
<pre><code>创建一个JavaProject，引用上面图片中的jar包，这里需要另外一个jar包，由于我连接的是mysql数据库，所以需要在导入一个mysql-connector-java-5.1.7-bin.jar
</code></pre><p>4.新建一个测试用的java对象</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>public class User {</p>
<pre><code>public User() {
}

public User(String name, Date birthday) {
    this.name = name;
    this.birthday = birthday;
}

@Override
public String toString() {
    return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, birthday=&quot; + birthday
            + &quot;]&quot;;
}

public int getId() {
    return id;
}

public void setId(int id) {
    this.id = id;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public Date getBirthday() {
    return birthday;
}

public void setBirthday(Date birthday) {
    this.birthday = birthday;
}

private int id;
private String name;
private Date birthday;
</code></pre><p>}<br>    编写的java对象需要满足如下要素：</p>
<p>需要有一个无参的构造函数，因为在session.get时需要用到反射创建java对象；</p>
<p>需要提供一个id属性，对应数据库的主键；</p>
<p>需要为对象的其他属性提供get/set方法；</p>
<p>需要定义成非final的类，以便在hibernate进行延迟加载时为类创建代理；</p>
<p>如有必要保存到集合中，需要重equals方法和hashcode方法；</p>
<p>5.设置java对象与数据库的映射关系</p>
<pre><code>需要创建一个User.hbm.xml文件，编辑java对象与数据库的映射关系，格式如下：
</code></pre><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE hibernate-mapping PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN”<br>“<a href="http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-mapping><br>    <class name="cn.net.bysoft.lesson1.User" table="S_USER"><br>        <id name="id" type="integer" column="ID"><br>            <!-- 指定主键的生成方式，native是使用数据库本地的方式 --><br>            <generator class="native"></generator><br>        </id><br>        <property name="name" type="string" column="NAME"></property><br>        <property name="birthday" type="timestamp" column="BIRTHDAY"></property><br>    </class><br></hibernate-mapping><br>    该文件是用来配置java对象与数据表之间的映射关系的，其中需要留意的是id这个属性，generator来指定主键的生成方式，而native则代表是调用数据库本地的方式来生成主键，我使用的mysql数据库就会自动将id列设置成自增。</p>
<pre><code>主键具体有哪些生成方式，待接下来详细研究。
</code></pre><p>6.配置hibernate的配置信息</p>
<p>在src下创建一个hibernate.cfg.xml文件，格式如下：</p>
<p>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>    “-//Hibernate/Hibernate Configuration DTD 3.0//EN”<br>    “<a href="http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-configuration><br>    <session-factory><br>        <!-- 连接数据库的基本信息 --><br>        <property name="hibernate.connection.username">root</property><br>        <property name="hibernate.connection.password">root</property><br>        <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property><br>        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate4</property></session-factory></hibernate-configuration></p>
<pre><code>    &lt;!-- hibernate使用的数据库方言
         如果不知道可以去/hibernate-release-4.3.11.Final/project/etc/hibernate.properties
         中查找 --&gt;
    &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;
    &lt;!-- 是否在控制台显示sql语句 --&gt;
    &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否格式化显示的sql语句 --&gt;
    &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否自动生成数据表的策略,create代表每次启动程序都重新创建数据表 --&gt;
    &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;

    &lt;!-- 需要使用到的*.hbm.xml文件 --&gt;
    &lt;mapping resource=&quot;cn/net/bysoft/lesson1/User.hbm.xml&quot;/&gt;
&lt;/session-factory&gt;
</code></pre><p><br>    该文件需要注意的有两个地方，第一个是mapping属性，第二个是hibernate.hbm2ddl.auto这个属性。</p>
<pre><code>mapping属性用来配置*.hbm.xml的资源文件地址，这里需要注意的是没有用cn.net.bysoft.lession的形式，而是使用的&apos;/&apos;来描述目录位置。

接下来是自动执行ddl语句的设置(也就是hibernate.hbm2ddl.auto)参数有4个，分别是：
</code></pre><p>create</p>
<p>create为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来drop掉数据表，drop后重新create数据表；</p>
<p>create-drop</p>
<p>create-drop为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来create数据表。而每当sessionfactory被close时，会drop掉开始时create的数据表；</p>
<p>update</p>
<p>update为每次创建sessionfactory时，如果数据库中没有对应的表，则新建。</p>
<p>若已经新建过，则会判断*.hbm.xml文件的配置与建立好的数据表的结构是否相同。</p>
<p>如果相同则不去进行ddl的操作。</p>
<p>如果不同，则会根据*.hbm.xml文件中有变化的配置项去更新数据表，但不会删除数据表中已创建过的任何信息。</p>
<p>validate</p>
<p>validate为每次创建sessionfactory时，将用*.hbm.xml文件中的配置信息与现有的对应的数据表结构进行比较，若发现不同则抛出异常。</p>
<p>7.编写代码测试</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.hibernate.Transaction;<br>import org.hibernate.boot.registry.StandardServiceRegistry;<br>import org.hibernate.boot.registry.StandardServiceRegistryBuilder;<br>import org.hibernate.cfg.Configuration;<br>import org.junit.Test;</p>
<p>public class UserTest {</p>
<pre><code>@Test
public void test() {
    // 0.创建configuration对象，该对象保存着hibernate的配置信息和对象关系映射的信息。
    Configuration cfg = new Configuration().configure();
    // 1.创建sessionfactory对象
    StandardServiceRegistryBuilder builder = new StandardServiceRegistryBuilder().applySettings(cfg.getProperties());
    StandardServiceRegistry registry =  builder.build();
    SessionFactory sessionFactory = cfg.buildSessionFactory(registry); 
    // 2.创建session对象
    Session session = sessionFactory.openSession();
    // 3.开始事务
    Transaction transaction = session.beginTransaction();
    // 4.保存
    User user = new User(&quot;Jack&quot;, new Date());
    session.save(user);
    // 5.提交事务
    transaction.commit();
    // 6.关闭session对象
    session.close();
    // 7.关闭sessionfactory对象
    sessionFactory.close();
}
</code></pre><p>}<br>    上面这段代码中configuration对象用来保存则hibernate的配置信息，如hibernate.cfg.xml中的配置信息，和*.hbm.xml的映射信息。</p>
<pre><code>sessionfactory为创建session的工厂，它是线程安全的。一般建议一个项目中只有一个sessionfactory，因为创建sessionfactory非常费资源。

接下来是session对象，该对象是hibernate的核心，是一个单线程的对象，内部有session缓存。

对需要持久化的java对象的所有操作都用到了session。

常用的方法有get、load、save、update、saveorupdate、delete、begintransaction、isopen、flush、clear、evicto、close等等方法，接下来将会一个一个研究这些方法的使用。

这是执行这段代码后，控制台输出的内容：



创建了一张名为S_USER的数据表，并insert了一条数据。



到此位置，一个简单的hibernate环境就搭建好了。工程的目录结构如下：
</code></pre><p>配置对象<br>配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。</p>
<p>数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。<br>类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。<br>SessionFactory 对象<br>配置对象被用于创造一个 SessionFactory 对象，使用提供的配置文件为应用程序依次配置 Hibernate，并允许实例化一个会话对象。SessionFactory 是一个线程安全对象并由应用程序所有的线程所使用。</p>
<p>SessionFactory 是一个重量级对象所以通常它都是在应用程序启动时创造然后留存为以后使用。每个数据库需要一个 SessionFactory 对象使用一个单独的配置文件。所以如果你使用多种数据库那么你要创造多种 SessionFactory 对象。</p>
<p>Session 对象<br>一个会话被用于与数据库的物理连接。Session 对象是轻量级的，并被设计为每次实例化都需要与数据库的交互。持久对象通过 Session 对象保存和检索。</p>
<p>Session 对象不应该长时间保持开启状态因为它们通常情况下并非线程安全，并且它们应该按照所需创造和销毁。</p>
<p>Transaction 对象<br>一个事务代表了与数据库工作的一个单元并且大部分 RDBMS 支持事务功能。在 Hibernate 中事务由底层事务管理器和事务（来自 JDBC 或者 JTA）处理。</p>
<p>这是一个选择性对象，Hibernate 应用程序可能不选择使用这个接口，而是在自己应用程序代码中管理事务。</p>
<p>Query 对象<br>Query 对象使用 SQL 或者 Hibernate 查询语言（HQL）字符串在数据库中来检索数据并创造对象。一个查询的实例被用于连结查询参数，限制由查询返回的结果数量，并最终执行查询。</p>
<p>Criteria 对象<br>Criteria 对象被用于创造和执行面向规则查询的对象来检索对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.下载hibernate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.解压hibernate&lt;/p&gt;
&lt;pre&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate基础</title>
    <link href="http://yoursite.com/2017/08/11/Hibernate%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/08/11/Hibernate基础/</id>
    <published>2017-08-11T11:11:43.000Z</published>
    <updated>2017-08-12T01:49:34.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>众所周知，Java是面向对象的世界，但数据库不是，现在的主流数据库大多都是关系型数据库。Java的对象想要进入数据库，就必须遵守数据库的“关系”规范，变成一条条的“记录”，数据库中的记录要变成Java中的对象，也同样需要有一个变身的过程—-繁琐的过程。通过SQL这个关系世界的魔法，我们建立起了“面向世界的世界”和“面向关系的世界”的桥梁。</p>
<p>那么问题来了，SQL是面向关系的语言， 它的脑袋里只有数据库中死板的记录，和眼中 “万事万物皆对象” 的Java在一起，显得格格不入。所以，“用面向对象的方法处理数据库操作”的 Hibernate 出世了。可以这么说，Hibernate 为 “面向对象” 和 “面向关系” 这两个截然不同的世界搭起了桥梁，所以它被称为ORM（Object–Relation Maping）—-对象映射框架。</p>
<h3 id="Hibernate基本工作原理"><a href="#Hibernate基本工作原理" class="headerlink" title="Hibernate基本工作原理"></a>Hibernate基本工作原理</h3><p>配置对象<br>配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。</p>
<p>数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。<br>类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。<br>SessionFactory 对象<br>配置对象被用于创造一个 SessionFactory 对象，使用提供的配置文件为应用程序依次配置 Hibernate，并允许实例化一个会话对象。SessionFactory 是一个线程安全对象并由应用程序所有的线程所使用。</p>
<p>SessionFactory 是一个重量级对象所以通常它都是在应用程序启动时创造然后留存为以后使用。每个数据库需要一个 SessionFactory 对象使用一个单独的配置文件。所以如果你使用多种数据库那么你要创造多种 SessionFactory 对象。</p>
<p>Session 对象<br>一个会话被用于与数据库的物理连接。Session 对象是轻量级的，并被设计为每次实例化都需要与数据库的交互。持久对象通过 Session 对象保存和检索。</p>
<p>Session 对象不应该长时间保持开启状态因为它们通常情况下并非线程安全，并且它们应该按照所需创造和销毁。</p>
<p>Transaction 对象<br>一个事务代表了与数据库工作的一个单元并且大部分 RDBMS 支持事务功能。在 Hibernate 中事务由底层事务管理器和事务（来自 JDBC 或者 JTA）处理。</p>
<p>这是一个选择性对象，Hibernate 应用程序可能不选择使用这个接口，而是在自己应用程序代码中管理事务。</p>
<p>Query 对象<br>Query 对象使用 SQL 或者 Hibernate 查询语言（HQL）字符串在数据库中来检索数据并创造对象。一个查询的实例被用于连结查询参数，限制由查询返回的结果数量，并最终执行查询。</p>
<p>Criteria 对象<br>Criteria 对象被用于创造和执行面向规则查询的对象来检索对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;Why&lt;/h3&gt;&lt;p&gt;众所周知，Java是面向对象的世界，但数据库不是，现在的主流数据库大多都是关系型数据库。Java的对象想要进入数据库，就必须遵守数据
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java动态网页</title>
    <link href="http://yoursite.com/2017/08/09/Java%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/"/>
    <id>http://yoursite.com/2017/08/09/Java动态网页/</id>
    <published>2017-08-09T12:56:59.000Z</published>
    <updated>2017-08-09T14:28:53.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何为动态网页"><a href="#何为动态网页" class="headerlink" title="何为动态网页"></a>何为动态网页</h3><p>所谓动态，是指浏览器所接受到的HTML页面是由服务器端的程序动态生成的，而不是事先制作好的。</p>
<h4 id="Java动态网页"><a href="#Java动态网页" class="headerlink" title="Java动态网页"></a>Java动态网页</h4><p>Java的动态Web编程技术是从Servlet（Servlet是服务器端小程序的意思）开始的。它在服务器端运行，动态地向客户端输出HTML页面。</p>
<h4 id="从HTML到JSP"><a href="#从HTML到JSP" class="headerlink" title="从HTML到JSP"></a>从HTML到JSP</h4><p>JSP是Servlet技术的扩展—-JSP(Java Server Pages) 。JSP实际上是Servlet的 一种变体，二者在本质上是一致的。为什么这样说呢？首先，Servlet和JSP是不能直接运行的，它们必须部署到一种特殊的应用程序—-Web服务器中。Web服务器会将JSP编译为Servlet，最后用于响应客户端浏览器的请求。虽然JSP和Servlet在本质上没有不同。只是Servlet在Java中插入HTML代码，而JSP是在HTML中插入Java代码而已。但这种形式上的转变简化了页面的编写工作：在JSP中书写静态HTML代码更加方便，不必在用print输出每一行。网页设计师和JSP程序员也可以很好地配合，前者只需要制作好HTML静态页面，将需要生成的地方预留空白，再交给后者加入动态内容、制作成JSP页面就可以了。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;何为动态网页&quot;&gt;&lt;a href=&quot;#何为动态网页&quot; class=&quot;headerlink&quot; title=&quot;何为动态网页&quot;&gt;&lt;/a&gt;何为动态网页&lt;/h3&gt;&lt;p&gt;所谓动态，是指浏览器所接受到的HTML页面是由服务器端的程序动态生成的，而不是事先制作好的。&lt;/p&gt;
&lt;h4
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDBC简单用</title>
    <link href="http://yoursite.com/2017/08/08/JDBC%E7%AE%80%E5%8D%95%E7%94%A8/"/>
    <id>http://yoursite.com/2017/08/08/JDBC简单用/</id>
    <published>2017-08-07T22:15:28.000Z</published>
    <updated>2017-08-07T14:40:31.782Z</updated>
    
    <content type="html"><![CDATA[<h4 id="何为JDBC"><a href="#何为JDBC" class="headerlink" title="何为JDBC"></a>何为JDBC</h4><p>JDBC（Java Data Base Connectivity,Java数据库连接）是由原Sun公司制定的数据库连接技术。SQL是用户操作数据库的语言，JDBC则为用户与数据库之间搭起了<strong>通信</strong>的通道。JDBC的根本目的：<strong>为Java编程人员提供操作各种数据库统一接口</strong></p>
<p>作为程序员，我们不能要求我们的用户只用一种数据库，所以说同一个Java应用能运用在不同的数据库之上是非常重要的，同时，这也是很不容易的。当今的数据库种类繁多，就像不同的国家的人说不同的语言一样，不同的数据库也使用着不同的语言…想要跟不同的数据库“交流”，就要使用他们的语言，那是不是说作为一名Java程序员要懂得所有的数据库语言？</p>
<p>要解决这个问题，我们就需要一个翻译，就像国家领导人经常出访不同的国家，但不需要懂得全世界的语言一样。</p>
<p>原Sun公司制定了JDBC的标准，这个标准规定了JDBC的接口，就如同规定了Java程序员与JDBC使用的语言。不同数据库语言的表达方式被JDBC统一了起来。就拿 “给我一个数据库连接” 这样一个命令来说，不论在各个数据库中是怎么实现的，在JDBC中都是一个命令—-“getConnection” 。</p>
<p>这些功能的实现，主要靠的是“JDBC驱动” 这个东西，它承担了翻译的核心机能。JDBC标准规定后，各个数据库厂商根据这个标准，开发出对应自己数据库产品的JDBC驱动。所以想要操作什么数据库，只要找到相应的驱动就好了。当然，JDBC驱动实际上就是一组class文件，它们被打包为Java专用压缩格式jar。</p>
<p>这样一来，数据库程序的开发就变得简单了。JDBC为Java提供了一个统一接口，程序员在编程时，可以不考虑所要操作的是什么数据库，只需要使用标准的JDBC书写数据库操作代码，再根据目标数据库的不同，加在相应的JDBC驱动就行了。</p>
<p>JDBC的所有接口都在Java基础类库的  java.sql 包以及 javax.sql 包中，但请注意这些都只是接口，所有的实现类就是由各数据库厂商根据这些接口编写的具体类而已。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;何为JDBC&quot;&gt;&lt;a href=&quot;#何为JDBC&quot; class=&quot;headerlink&quot; title=&quot;何为JDBC&quot;&gt;&lt;/a&gt;何为JDBC&lt;/h4&gt;&lt;p&gt;JDBC（Java Data Base Connectivity,Java数据库连接）是由原Sun公司制定的
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库的优势</title>
    <link href="http://yoursite.com/2017/08/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/08/07/数据库相关/</id>
    <published>2017-08-07T15:18:28.000Z</published>
    <updated>2017-08-07T14:11:20.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用数据库的优势"><a href="#使用数据库的优势" class="headerlink" title="使用数据库的优势"></a>使用数据库的优势</h3><h4 id="1、灵活、高效地管理数据"><a href="#1、灵活、高效地管理数据" class="headerlink" title="1、灵活、高效地管理数据"></a>1、灵活、高效地管理数据</h4><p>数据库可不是简单地把存进去的数据堆积起来。它会将数据分门别类存放好，并在此基础上建立起一整套查询、修改、输入与输出的机制，极大地提高工作效率。</p>
<h4 id="2、方便共享数据"><a href="#2、方便共享数据" class="headerlink" title="2、方便共享数据"></a>2、方便共享数据</h4><p>在现实中，不少用户之间都经常存在重复数据的现象。此外，现实中的数据经常要同时提供给许多使用者，如果每个使用者都保存一份相同的数据，一方面会造成巨大的浪费，另一方面也会为保证数据的一致性增加困难。举个简单例子，中国所有的公民的有关数据的量是非常庞大的，而很多地方都需要这些数据，即使真的把这些数据都复制成千上万份发放给各个机关，那么一旦这些数据更改（每一秒都有人出生、死亡），所有的机关必须对自己手中的数据进行准确无误的更改…工作量是很大的。但将公民的数据统一保存在数据库中，以上的问题便能迎刃而解：各个机关通过网络访问数据库，数据库中数据的更改也会及时。统一地反映给各个机构。</p>
<p>将“数据”与“应用”分离。把程序中的数据部分转移到数据库这个安全稳定的盒子中，这些数据就与应用程序之间有了清晰的界限。这样一来，程序的任何改变都不会影响到数据，就算程序废弃了，数据库中的数据仍然能为其他应用程序所用。</p>
<h4 id="3、增强安全性"><a href="#3、增强安全性" class="headerlink" title="3、增强安全性"></a>3、增强安全性</h4><p>任何对数据库内任何数据的访问都必须经过数据库系统的授权，从而更加有力地保障了数据的安全。举个例子吧，说白了，数据库就相当与现实生活中的图书馆，堆积如山的书籍就是数据。乱七八糟的图书进入图书馆后，被一个个贴上标签，分类整理好之后放入指定的位置。之后，读者更方便查找、借阅书籍，一本书也能给更多人阅读—-这些都类似于数据库为数据提供的管理、共享功能。与此同时，读者借阅书籍时必须经过图书管理者的允许，借阅之后限期归还，这就像数据库为数据提供的安全保障。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用数据库的优势&quot;&gt;&lt;a href=&quot;#使用数据库的优势&quot; class=&quot;headerlink&quot; title=&quot;使用数据库的优势&quot;&gt;&lt;/a&gt;使用数据库的优势&lt;/h3&gt;&lt;h4 id=&quot;1、灵活、高效地管理数据&quot;&gt;&lt;a href=&quot;#1、灵活、高效地管理数据&quot; cla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写代码前的准备</title>
    <link href="http://yoursite.com/2017/08/06/%E5%86%99%E4%BB%A3%E7%A0%81%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2017/08/06/写代码前的准备/</id>
    <published>2017-08-05T23:16:38.000Z</published>
    <updated>2017-08-05T16:07:37.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写代码前的准备"><a href="#写代码前的准备" class="headerlink" title="写代码前的准备"></a>写代码前的准备</h3><p>对很多初学者来说，写程序前的第一件事就是打开IDE，然后开始敲代码…</p>
<p>其实，这样是不对的，我们不能着急，程序开发的第一步是分析设计。我们大多数人在初学编程的时候，都喜欢上手就开始写代码，而不习惯先做一些设计思考，更别提将这些设计付诸于笔端了。这有两个方面的原因：一是因为和 “设计” 这样看起来虚无缥缈的东西比起来，代码是实实在在的，运行起来就很有成就感；二是初学编程是写的都是一些小程序，前期设计的作用在这些小规模的程序上体现不出来。但请读者记住，在实际的编程之前做一些前期设计，必要时动笔在纸上写一谢、画一画，是百利无一害的。简单的设计图表能帮助程序员整理思路，回避一些不必要的错误。</p>
<h4 id="什么是设计"><a href="#什么是设计" class="headerlink" title="什么是设计"></a>什么是设计</h4><p>对于面向对象的程序，本质上是对象之间的关系，所以设计的第一步就是找出这个程序里究竟有那些对象。方法说起来也简单：分析现实应用场景，从这些情境中抽出相应的 “角色” ，这些 “角色” 就是程序中的对象。那什么是角色呢？简单来说，就是现实环境中的人与物。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写代码前的准备&quot;&gt;&lt;a href=&quot;#写代码前的准备&quot; class=&quot;headerlink&quot; title=&quot;写代码前的准备&quot;&gt;&lt;/a&gt;写代码前的准备&lt;/h3&gt;&lt;p&gt;对很多初学者来说，写程序前的第一件事就是打开IDE，然后开始敲代码…&lt;/p&gt;
&lt;p&gt;其实，这样是不对
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>代码之髓读书笔记</title>
    <link href="http://yoursite.com/2017/08/01/%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%AB%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/01/代码之髓读书笔记/</id>
    <published>2017-07-31T21:26:19.000Z</published>
    <updated>2017-08-01T04:14:28.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>“内容能够理解，但总觉得不够彻底。”<br>我们在学习编程的过程中总是有这样的感觉。当新学的知识与之身经验以及原来掌握的知识尚未很好的结合的时候，往往会出现这种似懂非懂的状态。<br>“要学的东西太多了，先学什么好呢？”<br>大家曾经为这种问题苦恼过吗？<br>我们都要集中精力学习一些知识要点，但是怎样才能做到呢？</p>
<h4 id="在比较中学习"><a href="#在比较中学习" class="headerlink" title="在比较中学习"></a>在比较中学习</h4><p>我们学习语言也不仅仅是学习语言，而是从学习这门语言中学到一些在其他语言中也能用的一些知识。多种语言共同的知识才是要点。掌握了这些要点，学习其他语言时才会更加轻松。</p>
<ul>
<li><p>语言不同，规则不同</p>
<ul>
<li>在比较中学习多种语言，一些知识我们就能理解的更深刻，因为我们学的是不同语言之间的共性，最基本也是最重要的东西。某种具体的编程语言教程中会罗列出各种各样的规则。其实这些规则并不具有普遍意义，只是因为 “在当前的特定情况下，作此规定能更方便”。也就是说，某种语言的教材里出现的某某规则不过是该语言里的规则，仅此而已。就像在C语言中，0代表假；在Ruby中代表的是真；但在Java中，不能用来当作布尔变量。</li>
</ul>
</li>
</ul>
<h4 id="在历史中学习"><a href="#在历史中学习" class="headerlink" title="在历史中学习"></a>在历史中学习</h4><ul>
<li><p>理解语言设计者的意图</p>
<ul>
<li>在学某种编程语言的某个功能时，如果我们觉得掌握的并不够彻底，无法深入学习时，我么应该站在设计者的角度想一想。为什么设计者要设计这个功能？设计者是为了解决什么问题而设计了这种功能？</li>
</ul>
</li>
<li><p>应该学那种语言，我们无从所知</p>
<ul>
<li>了解了语言的历史，我们对其的理解会更加深刻。“想学编程，但该学那种语言呢？”这个问题是很多初学者要问的，但这个问题有意义吗？没有。因为未来的事谁也说不准。</li>
</ul>
</li>
<li><p>学习适用于各种语言的知识</p>
<ul>
<li>现在还有很多被不同人以不同理由推荐学习的编程语言。然而，在5年后、十年后，单个语言的知识是否依然有用？没人能说的清楚。通过比较不同的语言、了解语言的发展历史及其变化原因，培养对不同语言都试用的理解能力，是非常重要的。</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>“在比较中学习”不是学习某种特定语言的编程，而指的是同时比较几种语言，从而掌握那些知识是因语言的不同而不同的，那些知识是几种语言共享的。</li>
<li>“在历史中学习”指的是探寻语言是如何变化的，以及在发生变化前存在那些问题，从而理解语言为何开发出各种功能。</li>
</ul>
<h3 id="程序语言诞生史"><a href="#程序语言诞生史" class="headerlink" title="程序语言诞生史"></a>程序语言诞生史</h3><p>程序设计语言是如何诞生的？<br>前人是基于什么目的发明了程序设计语言？</p>
<h4 id="连接电缆"><a href="#连接电缆" class="headerlink" title="连接电缆"></a>连接电缆</h4><p>1946年，世界上第一台电子计算机—-ENIAC问世。它可以改变计算方式，即可以更改程序。用现在的话来讲，它是一台可编程计算机。但其编程方法和如今大家熟知的程序设计有很大的不同。它的程序设计就是指把这台计算机不同的端口通过电缆连接起来。每次更改程序是都要重新调整电缆连接方式，是在费劲。<br> 有没有方便一点的方式呢？</p>
<h4 id="程序内置"><a href="#程序内置" class="headerlink" title="程序内置"></a>程序内置</h4><p> 1949年，EDSAC问世。这是一种通过纸带打点的方式来记录和读取数据的计算机。程序作为数据通过纸带输入。不需要重新连接电缆，只需要让计算机不断读取纸带上的数据就可以更改程序了。这比重新连接电缆进步一点了，但还是有缺点了，如果想改程序的话，就很麻烦，代价也很大，虽然我们只想改一个标点符号还是全部，都要从头再来。</p>
<h4 id="FORTRAN语言问世"><a href="#FORTRAN语言问世" class="headerlink" title="FORTRAN语言问世"></a>FORTRAN语言问世</h4><p> 直到1954年，与大家现在使用的语言类似的程序设计语言才被发明出来。这就是FORYRAN（Formula Translating System  公式翻译系统）。现在，我们常用 “X*Y+Z”来表达“X乘 以Y在加Z“ 。最早实现这一点的就是是FORYRAN。将公式转化为机器是是FORYRAN的特点之一。 </p>
<h4 id="程序设计语言产生的原因"><a href="#程序设计语言产生的原因" class="headerlink" title="程序设计语言产生的原因"></a>程序设计语言产生的原因</h4><p> 我们为了获得更轻松辩解的体验而编写程序。但轻松便捷不等于偷工减料。偷工减料在前，痛苦在后，这不是真正的便捷。</p>
<ul>
<li>懒惰：程序员的三大美德之一<ul>
<li>优秀的程序员具有三大美德：懒惰、急躁和傲慢。</li>
<li>懒惰是一项为了减少总量支出，而不留余力地努力的素质。为了节省功夫，设计的程序逐渐被更多的人使用。单独回答每个使用者疑问费时费力，所以出现了注释。所以说，懒惰是程序员最宝贵的素质。</li>
</ul>
</li>
</ul>
<h4 id="语言们各有各的便捷"><a href="#语言们各有各的便捷" class="headerlink" title="语言们各有各的便捷"></a>语言们各有各的便捷</h4><ul>
<li><p>何为便捷</p>
<ul>
<li>语言是为了使什么变得便捷呢？是高速的代码执行？还是简单易于掌握的语言规范呢？抑或是轻松地理解他人编写的代码？比如，C++具有很高的执行力，但其的语言规范变得很复杂；Scheme重视语言规范，追求语言规范简洁；python是一种侧重于把代码阅读变得容易的语言。</li>
</ul>
<ul>
<li>各有各的便捷<ul>
<li>语言的便捷之处各不相同。比如,PHP语言编写Web服务很轻松，但它不擅长文字处理。相反，Haskll和OCaml这样的ML系列语言，编写处理文字的应用很便捷，但编写Web服务是就没有PHP那么便捷了。总的来说，程序设计语言的选用因使用者目的不同而不同。</li>
</ul>
</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>语言只是工具。某种语言是否适合自己，要看使用这种语言能否给我们当前的工作发挥作用或者说能发挥多大的作用，而不是看这种语言是否流行。我们要根据自己的情况选择合适的工具。</li>
</ul>
</li>
</ul>
<h3 id="专栏"><a href="#专栏" class="headerlink" title="专栏"></a>专栏</h3><h4 id="要确认理解是否正确，首先得表达出来"><a href="#要确认理解是否正确，首先得表达出来" class="headerlink" title="要确认理解是否正确，首先得表达出来"></a>要确认理解是否正确，首先得表达出来</h4><ul>
<li>假设我们正在学习一些知识，并自我感觉已经理解了。那么，我们到底是真正理解了呢，还是感觉自己已经理解了呢？仅凭自己苦思冥想是不行的。为了验证理解正确与否，需要表达出来。只能基于自己的理解说出自己的观点，然后让第三方来判断和检验。比如学习英语，就要在别人面前使用自己学到的英语，同时观察别人的反应。不这样做的话，就无法知道自己是否真正掌握了英语。</li>
<li>程序员一直收益于这一点。写文章，写出来的东西即使有错误也可能没人指点出来，或者根本没有人看你的东西。但写程序不一样，语言处理器会事无巨细地做错误检查并指出。这和人打交道不同，只要你方便，它总是有足够的时间和耐心陪你一起。</li>
</ul>
<h4 id="当你不知道学习什么时"><a href="#当你不知道学习什么时" class="headerlink" title="当你不知道学习什么时"></a>当你不知道学习什么时</h4><ul>
<li>应该学习什么？我们经常听到这样的问题。在回答之前，笔者想先问这样一个问题：你学习的目的是什么？我们生活在一个信息爆炸的时代。不管三七二十一统统都学，这样的学习策略已经不在适用。必然要有所学，有所不学。这时，我们就要事先明确自己到底想做什么，然后再去学习能够达到这一目标的知识。</li>
<li>不知道自己要做什么？或许你从一开始就在思考，想做一件完美的事情。一件从没有人想到过的，能获得别人赞誉的事情。如果最初的设想太过宏大导致无从下手，那么这一设想就永远不可能实现。还不如从小事做起，从简单的事情做起。这个过程中，你可以逐渐明白自己那些已经能做、那些还不能做，如果要做还要学习那些知识。长此以往，就能培养出完成更复杂任务的能力。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h3&gt;&lt;p&gt;“内容能够理解，但总觉得不够彻底。”&lt;br&gt;我们在学习编程的过程中总是有这样的感觉。当新学的知识与之身经验以及原来掌握的知识尚未很好
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>玩转cmd</title>
    <link href="http://yoursite.com/2017/07/31/%E7%8E%A9%E8%BD%ACcmd/"/>
    <id>http://yoursite.com/2017/07/31/玩转cmd/</id>
    <published>2017-07-31T00:22:04.000Z</published>
    <updated>2017-07-30T16:50:36.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cmd应用基础"><a href="#cmd应用基础" class="headerlink" title="cmd应用基础"></a>cmd应用基础</h3><p>Posted on 2012-12-15</p>
<h4 id="cmd是什么？"><a href="#cmd是什么？" class="headerlink" title="cmd是什么？"></a>cmd是什么？</h4><p>对于程序员而言，cmd命令提示符是windows操作系统下一个比较重要的工具。对于程序员而言，为了追求更高的效率而抛弃花俏的界面已然是意见很常见的行为，截止到目前的，全世界仍有大量的服务器还使用着单一的命令行界面。</p>
<p>使用命令行界面的一个重要因素就是，在远程管理的过程中，命令行操作紧需要传递少量的数据就可以对机器进行操作，如果是图形界面，由于需要传输大量的图形数据，很可能出现延迟、链接不稳定等情况，亦或者在同样情况下效率没有使用命令行界面操作来得高。所以，至今人们依旧离不开命令行操作。</p>
<p>而cmd则是windows系列操作系统下的命令行操作程序 <strong>(不论是命令行或者是桌面这样的图形界面本质上都是程序)</strong></p>
<p>命令行界面程序cmd.exe所在的目录是C:\Windows\System32</p>
<p>顺带一提我们的桌面（图形操作界面）则是位于C:\Windows下的explorer.exe</p>
<h4 id="如何打开cmd"><a href="#如何打开cmd" class="headerlink" title="如何打开cmd"></a>如何打开cmd</h4><p><strong>方法有很多，以下列举几种</strong></p>
<ol>
<li>打开C:\WindowsSystem32目录，找到cmd.exe双击运行。当然，通常人们都不会这么做。</li>
<li>打开开始菜单-&gt;运行-&gt;输入cmd-&gt;回车</li>
<li>通过快捷键：win（windows商标键） + r 调出运行框，然后输入cmd回车</li>
<li>win7打开开始菜单之后可以直接输入cmd回车</li>
</ol>
<p><strong>关于当前目录</strong></p>
<p>对于新手而言，这是一个必须要搞清楚的问题。首先我们来学习几个命令：</p>
<h5 id="cd-C-cd是change-directory的简写，意思是改变目录，上面这条命令的意思就是切换到C-目录下。"><a href="#cd-C-cd是change-directory的简写，意思是改变目录，上面这条命令的意思就是切换到C-目录下。" class="headerlink" title="cd C:\  cd是change directory的简写，意思是改变目录，上面这条命令的意思就是切换到C:\目录下。"></a>cd C:\  cd是change directory的简写，意思是改变目录，上面这条命令的意思就是切换到C:\目录下。</h5><p>可以观察到，cmd界面上的目录变成了C:\</p>
<p><img src="/images/cmd.jpg" alt=""></p>
<p>我们可以从图中看到，cmd中的文字有变化，而有变化的地方就是我们要注意的地方。</p>
<p>在每一行的最前面就是当前目录的地址，例如最开始的</p>
<p>C:\Users\Lellansin&gt;cd C:\  这当中”C:\Users\Lellansin” 你的账户名称是Admin的话就是C:\Users\Admin,注意是win7的默认目录)就是我的当前目录而执行了cd C:\命令之后当前目录就变成了 C:\</p>
<p>当前目录是一个相对重要的概念，因为很多操作只能对当前目录里面的文件进行。就好比，通常情况下，你要操作E盘某个目录下的某个文件，你首先要双击“我的电脑”打开E盘相应的文件夹，找到那个目录才能操作那个目录下的文件一样。对于cmd而言，要操作相应目录下的文件需要切换到相应的目录。</p>
<h5 id="输入dir回车，系统会返回当前目录下的文件列表"><a href="#输入dir回车，系统会返回当前目录下的文件列表" class="headerlink" title="输入dir回车，系统会返回当前目录下的文件列表"></a>输入dir回车，系统会返回当前目录下的文件列表</h5><ol>
<li><p>如何执行或打开文件</p>
<ul>
<li><p>C:>1.txt</p>
<ul>
<li><p>如果我在C盘根目录下有一个1.txt的文本文件，那么就可以直接输入1.txt回车，即可打开该文件。（这个在linux下也是同样的情况，博主当年也搞不清楚怎么运行程序来着）</p>
</li>
<li><p>同样的，如果存在hello.exe，那么直接输入hello.exe即可运行该程序。当然需要注意的是，某些系统默认的应用程序格式（如.exe文件）在cmd中调用的时候是可以省略后缀的。也就是可以直接输入hello，然后回车也同样可以运行hello.exe。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>环境变量</p>
<ul>
<li><p>环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等。</p>
</li>
<li><p>常见的环境变量：</p>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>变量名</th>
<th style="text-align:right">变量值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Path</td>
<td style="text-align:right">…太多省略…</td>
</tr>
<tr>
<td>OS</td>
<td style="text-align:right">Windows_NT</td>
</tr>
<tr>
<td>windir</td>
<td style="text-align:right">%SystemRoot%</td>
</tr>
<tr>
<td>TMP</td>
<td style="text-align:right">%SystemRoot%TEMP</td>
</tr>
<tr>
<td>ComSpec</td>
<td style="text-align:right">%SystemRoot%system32cmd.exe</td>
</tr>
</tbody>
</table>
<p>至于%SystemRoot%的值是什么，大家只要把它复制到文件浏览上面的地址栏里面然后回车就知道了。</p>
<ol>
<li><p>环境变量的作用</p>
<ul>
<li>为系统或者用户程序设置一些默认参数。比如windir这个环境变量，就可能有程序通过读取这个环境变量的值来查看系统的版本。</li>
</ul>
</li>
<li><p>环境变量的设置方法</p>
<p> -【我的电脑】-&gt;右键【属性】-&gt;【高级】-&gt;【环境变量】-&gt;选中你要修改的环境变量点击【编辑】即可</p>
<ul>
<li>通过cmd设置（不推荐）</li>
</ul>
</li>
<li><p>path的作用</p>
<ul>
<li><p>path是一个很常见得环境变量。主要用来配置系统的默认路径。也就是当你在某个目录下执行某个程序，但是本身目录下却没有这个程序的时候，系统会自动到默认路径下面也去找一找，有没有你要执行的程序。</p>
</li>
<li><p>比如你写了一个hello.exe（编译运行后，能在在程序的相应的debug目录下能找到）。然后把这个hello.exe移动到E:\test目录下，接着</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 切换到E盘</div><div class="line">cd E:\</div><div class="line"># 切换到E盘下的test文件中</div><div class="line">cd test</div><div class="line">#执行hello.exe</div><div class="line">hello.exe</div><div class="line"># 假设程序输出hello world</div><div class="line"># 这个时候再切换到E盘根目录下(cd .. 是切换到上级目录)</div><div class="line">cd ..</div><div class="line"># 再执行hello.exe</div><div class="line">hello.exe</div><div class="line"># 这个时候系统会提醒你找不到这个命令</div><div class="line"># 但是如果你将 E:\test 这个目录加入到 path中，</div><div class="line"># 就可以在任意地方运行hello.exe</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="cmd的常见作用"><a href="#cmd的常见作用" class="headerlink" title="cmd的常见作用"></a>cmd的常见作用</h4><p>1.自动关机<br>2.常看本地ip<br>3.使用ping<br>4.快速查询本地服务、端口使用情况<br>5.快速调用一些常用工具<br>6.原始编程方式，用cmd调用编译<br>7.学汇编都应该知道cmd下的debug<br>8.批处理</p>
<h4 id="自动关机"><a href="#自动关机" class="headerlink" title="自动关机"></a>自动关机</h4><p>先说自动关机,貌似很多人都被开过自动关机的玩笑,我们通过cmd就可以实现自动关机命令</p>
<h6 id="输入shutdown回车"><a href="#输入shutdown回车" class="headerlink" title="输入shutdown回车"></a>输入shutdown回车</h6><p>shutdown并不是一个cmd命令而是一个windows系统自带的程序shutdown.exe，位于C:\WINDOWS\system32目录下，之所以能够直接执行，是因为C:\WINDOWS\system32目录，是系统默认配置在环境变量path中的。其他还有很多的自带程序都在这个目录，以下其他程序不做过多说明。（PS：这里仅仅只讲一些cmd的常见应用，至于cmd的语法之类的，讲了也有些鸡肋，如果想学习批处理再研究也不迟）<br>废话不多说，我们可以从上面的图片看到，直接输入程序自动给出了一些提示，这些参数告诉了我们这个shutdown.exe要怎么使用</p>
<h4 id="shutdown-s"><a href="#shutdown-s" class="headerlink" title="shutdown -s"></a>shutdown -s</h4><p>按照他提示的参数输入这个命令，会弹出提示：</p>
<p>博主是在xp下测试，当然如果是在win7等系统下的话效果会不一样。如果你在实验这个命令，不要慌张马上按照提示执行下面的命令：</p>
<h4 id="取消关机"><a href="#取消关机" class="headerlink" title="取消关机"></a>取消关机</h4><p>shutdown -a<br>接下来我们来看一下这个程序最常用的方式：</p>
<h4 id="1小时-3600秒-后关机"><a href="#1小时-3600秒-后关机" class="headerlink" title="1小时(3600秒)后关机"></a>1小时(3600秒)后关机</h4><p>shutdown -s -t 3600<br>博主就经常用到上面这个命令，甚至桌面常备取消关机的批处理（哈哈，当年没少被开过这种玩笑）<br>好吧，少年，你是要问我批处理是什么嘛？<br>请你新建一个文件把“shutdown -s -t 3600”复制进去，然后保存，另存为.bat后缀的文件（如何更改文件后缀，不懂请戳度娘谷歌），接着双击这个bat文件。<br>如果你看到系统提示你一小时后会自动关闭，那么恭喜你，你已经写好了一个自动关机的批处理文件。那么同样的可以想象，取消关机的批处理，就是一个.bat文件，里面写着一行“shutdown -a”，双击一下就可以运行了（批处理的特点之一）。</p>
<p>当然如果，想在C语言中调用这个命令也很简单。<br>先引入stdlib.h库。接着就可以通过system()命令来调用了，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">    system(&quot;shutdown -s -t 3600&quot;);</div><div class="line">    printf(&quot;自动关机已设置！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="常看本地ip"><a href="#常看本地ip" class="headerlink" title="常看本地ip"></a>常看本地ip</h4><p>通过ipconfig.exe就可以查看本地ip</p>
<p>当然也可以通过 /? 参数获取更多的帮助</p>
<p>ipconfig /?</p>
<p>当然ipconfig还有很多其他的用处，比如按照提示上面说的<br>/all Display full configuration information.<br>通过/all参数调用,可以显示出全部的设置信息:</p>
<p>Windows IP Configuration</p>
<pre><code>Host Name . . . . . . . . . . . . : s3049
Primary Dns Suffix  . . . . . . . :
Node Type . . . . . . . . . . . . : Unknown
IP Routing Enabled. . . . . . . . : No
WINS Proxy Enabled. . . . . . . . : No
</code></pre><p>Ethernet adapter 本地连接:</p>
<pre><code>Connection-specific DNS Suffix  . :
Description . . . . . . . . . . . : Realtek PCIe GBE Family Controller
Physical Address. . . . . . . . . : 78-E3-B5-A3-A5-44
Dhcp Enabled. . . . . . . . . . . : No
IP Address. . . . . . . . . . . . : 172.26.22.49
Subnet Mask . . . . . . . . . . . : 255.255.0.0
Default Gateway . . . . . . . . . : 172.26.2.6
DNS Servers . . . . . . . . . . . : 58.22.96.66
</code></pre><p>（直接复制了，发图麻烦）</p>
<p>这里可以查看到一些常见的信息，比如host name是主机名，Physical Address 则是传说中的mac地址，IP Address 就是你的本机地址（注意这个通常是局域网下的）。至于后面的子网掩码还有默认网关什么的，想了解的一可以去搜索一下。<br>还有/flushdns(flush DNS)刷新DNS缓存什么的。相信这些信息，网管专业的同学应该都非常熟悉。（注：不明情况的围观群众不要随意开跳这个坑，了解基本即可。）</p>
<h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>记得原来微博上面有个吐槽，就是说很多人普通人用百度来搜索，而很多程序员则用百度来测试网络是否联通。那么如果使用ping.exe来测试网络是否联通：</p>
<p>ping www.baidu.com</p>
<p>除了这个用处以外还有一个很常见的作用就是测试自己是否能够连接到某个ip，这里有一个路由器，连接了两台电脑，在每台电脑上都可以通过ipconfig查看自己在局域网中的ip地址，假设对方的ip是192.168.1.106。那么便可以使用ping命令测试是否能联通对方的电脑。</p>
<p>ping 192.168.1.106<br>当然，眼尖的同学应该已经发现了ping.exe的另一个作用，那就使用获取某个网站的ip地址：</p>
<p>其他闲话</p>
<p>至于<br>4.快速查询本地服务、端口使用情况<br>5.快速调用一些常用工具<br>6.原始编程方式，用cmd调用编译<br>7.学汇编都应该知道cmd下的debug<br>8.批处理</p>
<p>这些有的内容对于新手而言略坑，这里暂不做介绍。</p>
<p>其中的5.快速调用一些常用工具，就简单说一下博主常用的工具：</p>
<p>notepad 记事本<br>calc 计算器<br>mspaint 画图板</p>
<p>这些实际上通过菜单调出运行（或者win+r）就可以直接输入调出来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;cmd应用基础&quot;&gt;&lt;a href=&quot;#cmd应用基础&quot; class=&quot;headerlink&quot; title=&quot;cmd应用基础&quot;&gt;&lt;/a&gt;cmd应用基础&lt;/h3&gt;&lt;p&gt;Posted on 2012-12-15&lt;/p&gt;
&lt;h4 id=&quot;cmd是什么？&quot;&gt;&lt;a href=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="http://yoursite.com/2017/07/31/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2017/07/31/Java异常处理/</id>
    <published>2017-07-30T19:13:02.000Z</published>
    <updated>2017-08-05T16:13:46.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><h4 id="先说什么是异常"><a href="#先说什么是异常" class="headerlink" title="先说什么是异常"></a>先说什么是异常</h4><p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的错误条件。当条件生成时，错误将引发异常。<strong>异常的正确使用，能帮助程序员迅速找到异常的出现，同时，也不至于让程序崩溃，得已继续执行下去。当然，在出现异常后，还能让程序继续运行去，对程序员的要求是极高的。</strong></p>
<h4 id="Java的异常处理方式"><a href="#Java的异常处理方式" class="headerlink" title="Java的异常处理方式"></a>Java的异常处理方式</h4><ol>
<li><p>throw Exception.当我们写个函数来处理IO流或Socket连接的时候，函数内部可能会发生错误，我们就需要把程序抛出给调用函数的人，让他来处理。</p>
</li>
<li><p>try..catch。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">    可能出现异常的语句</div><div class="line">&#125;eacth(Exception e)&#123;  //捕捉异常</div><div class="line">    处理异常的语句</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方式，也就是说我们知道要发生的具体错误是什么，然后我们自己解决掉错误。</p>
<h4 id="异常的重要性"><a href="#异常的重要性" class="headerlink" title="异常的重要性"></a>异常的重要性</h4><blockquote>
<p>在一个完美的世界中，用户不会输入错误，计算机硬件永远不会出错，相关的数据文件永远不会被丢失…遗憾的是，这个世界并不是如此美好。</p>
</blockquote>
<p>程序运行时可能遇到各种非正常状况—-用户输入的数据非法、电脑硬盘空间不足，程序所需要的文件被删除等等。一个足够健壮的程序，用于处理异常的代码要占到很大部分。正是由于异常处理如此重要，Java设计者将异常处理作为Java语言的一种内置特性。在其他语言中，编写者可以偷懒不写异常处理；而在Java中，如果一个方法声明可能会抛出异常，那么调用方法的人必须对此进行处理；否则不能编译通过。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>不知道我们有没有想过为什么Java需要有两种异常处理方式呢？我们应该知道，我们写的代码、写的类、写的函数，不仅仅只是我们自己用的，同时我们也发现这两种方式对异常的处理也是不同的。throw这种方式，错误是由调用方来解决的；try..catch这种方式呢，是写代码的人来解决的。学技术，不仅仅只是为了知道怎么使用这种技术，还应该清楚技术背后的含义。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java异常处理&quot;&gt;&lt;a href=&quot;#Java异常处理&quot; class=&quot;headerlink&quot; title=&quot;Java异常处理&quot;&gt;&lt;/a&gt;Java异常处理&lt;/h3&gt;&lt;h4 id=&quot;先说什么是异常&quot;&gt;&lt;a href=&quot;#先说什么是异常&quot; class=&quot;header
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>windows 安装Mysql</title>
    <link href="http://yoursite.com/2017/07/31/windows-%E5%AE%89%E8%A3%85Mysql/"/>
    <id>http://yoursite.com/2017/07/31/windows-安装Mysql/</id>
    <published>2017-07-30T19:11:01.000Z</published>
    <updated>2017-07-30T15:59:29.802Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Windows-环境下-MySQL-5-7-安装配置指南"><a href="#Windows-环境下-MySQL-5-7-安装配置指南" class="headerlink" title="Windows 环境下 MySQL 5.7 安装配置指南"></a>Windows 环境下 MySQL 5.7 安装配置指南</h3><h5 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h5><ul>
<li>Windows 版本：Windows 10 专业版 64bit</li>
<li>MySQL 版本：MySQL 5.7.16</li>
</ul>
<h5 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h5><p>在安装 MySQL 前请务必确认自己电脑的 net 指令是正常工作的。有些 Windows 系统会丢失 net 指令<em>(环境变量缺失)</em>，解决方法请自行搜索一下。</p>
<h4 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h4><ol>
<li><p>下载 MySQL Community Server <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">下载链接</a></p>
<ul>
<li>选择合适自己操作系统的版本，通常使用 Windows (x86, 64-bit), ZIP Archive</li>
</ul>
</li>
<li><p>解压并“合理安放” MySQL Server。</p>
<ul>
<li>将下载好的mysql-5.7.16-winx64.zip解压，并将解压好的文件夹妥善放置（比如放置在 Program FIles 文件夹内）。本教程中 MySQL 被放置在了D:\ProgramFiles下，并被重命名为了 MySQL。</li>
</ul>
</li>
<li><p>为 MySQL Server 配置环境变量</p>
<ul>
<li>右击开始菜单按钮，选择“系统”选项。</li>
<li>在“系统”界面左侧，选择“高级系统设置”。</li>
<li><p>在打开的“系统属性”对话框中的“高级”选项卡页面的下方，选择“环境变量”。</p>
<ul>
<li><p>系统属性设置窗口</p>
<p> 在“用户变量”区块中，选择“新建”，在打开的对话框中，变量名写 MySQL，变量值写 MySQL 文件夹的完整路径（本教程为D:\Program Files\MySQL）。</p>
</li>
<li><p>添加环境变量</p>
<p> 同样在用户区块中寻找 PATH 环境变量，如果有，点击“编辑”。在弹出的对<br> 话框中点击“新建”，输入%MySQL%\bin（在老版本 Windows 系统中，变量值末尾用英文分号;分开后再添加%MySQL%\bin）。如果没有，点击“新建”，添加一个变量名为 Path 的环境变量。在这个环境变量的变量值处，添加%MySQL%\bin</p>
</li>
<li><p>修改环境变量<br>  点击确定按钮退出环境变量配置对话框。<br>  点击确定按钮退出系统属性配置对话框。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注册 MySQL 服务</p>
<ul>
<li>右击开始菜单按钮，选择/“命令提示符（管理员）”/选项。</li>
<li>输入盘符 + “:” 指令，进入MySQL文件夹所在的磁盘（本教程是 D 盘）。再使用  cd指令进入MySQL Server所在文件夹的bin文件夹中。<strong>这一步非常重要，如果不在这个目录下，无法正确注册 MySQL 服务。</strong></li>
</ul>
</li>
<li><p>定位到 MySQL 所在路径</p>
<ul>
<li>执行mysqld -install指令，注册 MySQL 服务。</li>
</ul>
</li>
<li><p>注册 MySQL 服务</p>
<ul>
<li>执行完毕后，请不要退出“命令提示符”。</li>
</ul>
</li>
<li><p>配置 MySQL Server</p>
<ul>
<li>进入 MySQL Server 所在的文件夹 （本教程为D:\Program Files\MySQL）</li>
<li><p>编辑my-default.ini</p>
<ul>
<li><p>在该文件中，#是注释标记。<br>去掉 basedir 的注释符号，并在等号后边填写 MySQL Server 文件夹的完整地址。<br>去掉 datadir 的注释符号，并在等号后边填写 MySQL Server 文件夹的完整地址外加\data。<br> <strong>切记不要手动创建 data 文件夹！</strong></p>
</li>
<li><p>port 不需要配置，不配置的状态下默认为 3306。（MySQL Server 默认使用的端口号）</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>最终配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># For advice on how to change settings please see</div><div class="line"># http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</div><div class="line"># *** DO NOT EDIT THIS FILE. It&apos;s a template which will be copied to the</div><div class="line"># *** default location during install, and will be replaced if you</div><div class="line"># *** upgrade to a newer version of MySQL.</div><div class="line"></div><div class="line">[mysqld]</div><div class="line"></div><div class="line"># Remove leading # and set to the amount of RAM for the most important data</div><div class="line"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</div><div class="line"># innodb_buffer_pool_size = 128M</div><div class="line"></div><div class="line"># Remove leading # to turn on a very important data integrity option: logging</div><div class="line"># changes to the binary log between backups.</div><div class="line"># log_bin</div><div class="line"></div><div class="line"># These are commonly set, remove the # and set as required.</div><div class="line">basedir =D:\Program Files\MySQL</div><div class="line">datadir =D:\Program Files\MySQL\date</div><div class="line"># port = .....</div><div class="line"># server_id = .....</div><div class="line"></div><div class="line"></div><div class="line"># Remove leading # to set options mainly useful for reporting servers.</div><div class="line"># The server defaults are faster for transactions and fast SELECTs.</div><div class="line"># Adjust sizes as needed, experiment to find the optimal values.</div><div class="line"># join_buffer_size = 128M</div><div class="line"># sort_buffer_size = 2M</div><div class="line"># read_rnd_buffer_size = 2M </div><div class="line"></div><div class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</div></pre></td></tr></table></figure></p>
<p>保存退出。退出后将my-default.ini重命名为my.ini</p>
<ol>
<li><p>在刚才的“命令提示符”中，执行mysqld –initialize（可能会假死，等一分钟手动关闭就好）。</p>
</li>
<li><p>开启 MySQL Server</p>
<ul>
<li>在“命令提示符”中执行net start mysql，开启 MySQL Server。</li>
</ul>
</li>
<li><p>配置 MySQL root 账户。</p>
<ul>
<li>在“命令提示符”中，执行net stop mysql关闭 MySQL Server。</li>
<li>再执行mysqld –skip-grant-tables开启无密码的 MySQL Server。</li>
</ul>
</li>
<li><p>无密码启动 MySQL Server</p>
<ul>
<li>打开一个新的“命令提示符”，执行mysql -u root登陆 MySQL Server。</li>
<li>执行flush privileges刷新权限。</li>
<li>执行grant all privileges on <em>.</em> to ‘root’@’localhost’ identified by ‘你想设置的密码’ with grant option;。</li>
<li>执行flush privileges刷新新的 root 用户密码。</li>
<li>执行exit退出 MySQL。</li>
</ul>
</li>
<li><p>结束进程</p>
<ul>
<li>在任务管理器下手动结束mysqld.exe。</li>
</ul>
</li>
<li><p>正常登陆</p>
<ul>
<li>在“命令提示符”下执行net mysql start重新开启MySQL Server，再次使用mysql -u root -p 你设置的密码即可安全登陆 MySQL。</li>
</ul>
</li>
</ol>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p><strong>本教程中所有的“命令提示符”，一定要运行在 管理员模式下，否则会出现“拒绝访问”的问题。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Windows-环境下-MySQL-5-7-安装配置指南&quot;&gt;&lt;a href=&quot;#Windows-环境下-MySQL-5-7-安装配置指南&quot; class=&quot;headerlink&quot; title=&quot;Windows 环境下 MySQL 5.7 安装配置指南&quot;&gt;&lt;/a&gt;Wi
    
    </summary>
    
      <category term="config" scheme="http://yoursite.com/categories/config/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>我的大一</title>
    <link href="http://yoursite.com/2017/07/29/%E6%88%91%E7%9A%84%E5%A4%A7%E4%B8%80/"/>
    <id>http://yoursite.com/2017/07/29/我的大一/</id>
    <published>2017-07-29T00:07:02.000Z</published>
    <updated>2017-08-25T08:12:57.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>一眨眼间，我的大一就结束了，等开学就有人叫我学长了，还真有点不习惯。现在还记得刚来时的陌生、军训时的痛苦，回想起来，感觉还是昨天的事情，但早已过去一年了，自己也从当初的小鲜肉变成老司机了。大一新生的保护伞也没了，遇到问题再也不能说自己是大一新生，以前没学过，不懂了。这一年自己都干嘛了呢？</p>
<h4 id="大一上"><a href="#大一上" class="headerlink" title="大一上"></a>大一上</h4><p>在大一上个学期，一时间还是不能适应大学这种宽松的生活，但还好自己以前也都是住校生，能管理好自己的生活和学习，虽然不是完全适应，但还不会迷失自己，不会一天天无所事事。</p>
<p>后来，在老乡群，有一个学长发了一个招新信息，是学校千年弦歌网络工作室的。恰好自己对网站这一块也比较感兴趣，大一上的课也很少，跟学长了解了一下，就报名了，然后过段时间就面试，自己第一次面试，挺紧张的。但自己也很幸运，当了实习程序员。<br>还记得第一次去开会的时候，学长们说的一些名词，自己之前从来没听过，学长们说的很happy，自己听的很懵逼，但也装作听懂了一样。弦歌实行的是放养政策，就是你不懂，你就自己学去。</p>
<p>之后，自己就踏上了自学的道路，这个过程中自己学到了很多。自己先看了前端的一些知识，就是一些简单的HTML便签很CSS样式表，然后简写一些简单的页面，接着学习了JS,让自己的网页有了一些特效。现在说起来，感觉没什么，但回想其自己当时的学习历程，还是觉得自己很棒。在大学之前，只会装软件，上网聊天的人，要自己学习这些东西，还是有点困难的。那段时间，自己总是往图书馆跑，每次都是借好几本书回来，因为自己不知道那本适合自己，也不知道从哪里开始学起，就把自己觉得还可以的都借回来了，然后慢慢看，找到一本适合自己的。同时呢，因为在网上学习，看一些视频呀，做一些小练习呀。就这样的学习节奏，自己的大一上就结束了。</p>
<h4 id="大一下"><a href="#大一下" class="headerlink" title="大一下"></a>大一下</h4><p>寒假回家过个年回来，就是大一下半年了。没有了当初的那份陌生与羞涩了，一来就进入状态，开始正常的生活了。</p>
<p>这学期，学校的课程也多了起来，有高数、离散、线代，三门数学，没有一本是简单的，所以自己得花一定的时间来学习，应付学校的考试。但是，老师在课上讲的都是很表面的东西，就拿线性代数来说吧：老师讲的都是都是很浅显的矩阵运算、解方程组，但线代的作用仅非于此，更重要的是自己能从中抽象出对空间的理解，知道课本上的名词，对应空间中向量的变换是什么。为此，自己就找其他书籍和上网找资源来充饥。所以说呀，上课讲的有时候并不是我们需要的，我们需要发挥自己的能动性去寻找自己需要的知识。</p>
<p>此外，自己还继续在Web这条路上探索着，开始学习一些后端的数据操作。有一次去开会，有个学长叫我搭个个人博客。自己也在CSDN或者其他平台写过博客，也想过弄个自己的个人网站。</p>
<p>然后就开始网站搭建个人博客风波。谷歌到有Word这一个框架搭建个人博客非常方便，不过需要搭建LAMP（Linux+Apache+MySql+PHP）环境。自己在学的开始学的时候，用的是集成的wamp软件。然后自己就想不如分开装试试，反正也是在学习嘛。</p>
<p>还真别说，要搞定这三者（Apache+Mysql+PHP），不是一件容易的事噢，也明白了为什么当初学长推荐我们使用集成软件来学习了。自己当时摸索了三天才让这三者开始工作，但自己能连接数据库，打印“Hello world”的那一刻，自己很是开心啊，觉得很有成就感。经过这一次经历，自己再也不怕配置软件了，比如一些IDE啊。</p>
<p>环境搭好了，就开始搭建个人软件了，过程中也出现了一些问题，但自己摸索和上网查资料，也都解决了。这是在本地弄得，然后自己又想着是不是可以在服务器上弄弄。</p>
<p>然后又开始搞事情了。最开始是买服务器，是在阿里云买的，不巧，选择的是Linux的操作系统，在操作服务器的时候，还得学习一波Linux的操作，然后上传镜像，配置，跟本地操作差不多，很快搞定了。搞定后，有寻思着，应该有个域名，说干就干，就买域名，建立映射关系，也很快搞定。</p>
<p>虽然这一切自己描述都挺顺利的，但过程中还是遇到了一些难题的，不过，这一路都是自己在摸索，知道了遇到问题怎么去解决，所以，遇到的问题自己都很快解决了，就觉得没什么问题了。</p>
<h4 id="大一下之蓝杰篇"><a href="#大一下之蓝杰篇" class="headerlink" title="大一下之蓝杰篇"></a>大一下之蓝杰篇</h4><p>自己能知道蓝杰这个培训机构的存在，可以说是上天的安排。为什么这么说呢？</p>
<p>记得我在自习室自习，接到一个电话，说自己是蓝杰的，还说认识我，但我问她我的名字，她说的并不是我的名字，后来还说知道我的家乡、专业，但当我问他时，都是错的。但我也不知道为什么，就相信她了，就到了蓝杰上免费的六节课了。第一次到蓝杰，就觉得那边挺好的，虽然学费挺贵的，自己还是咬咬牙牙报名了，还是感谢老爸老妈和我的好兄弟阿伟仔啊。</p>
<p>然后，晚上没课和周末就过去蓝杰上课，其他的空余时间就自己琢磨Web和学习数学啦，所以感觉大一下过的挺充实挺快的。</p>
<p>自己要去蓝杰学习，其实不光是为了学习，最主要的原因是去那里认识更多喜欢计算机的人，大家一起学习、交流，以后工作后，还能互相照应。是的，在蓝杰这边，也认识了挺多和自己谈得来的朋友，也认识了挺牛逼的学长学姐，有保研的、有值博的、有国外留学的…跟这些牛人的交流，自己开阔了眼界，知道了大学四年能有这么多不一样的选择，很受启发。当然，这都是要通过自己的努力，才能达到的高度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h3&gt;&lt;p&gt;一眨眼间，我的大一就结束了，等开学就有人叫我学长了，还真有点不习惯。现在还记得刚来时的陌生、军训时的痛苦，回想起来，感觉还是昨天的事情，但早
    
    </summary>
    
      <category term="colleage" scheme="http://yoursite.com/categories/colleage/"/>
    
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Java浅谈Socket</title>
    <link href="http://yoursite.com/2017/07/29/Java%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/07/29/Java服务器编程/</id>
    <published>2017-07-28T20:30:36.000Z</published>
    <updated>2017-07-28T13:23:20.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>现在是互联网的时代，说到底也就是连接的时代。人与人、人与物、物与物都需要连接，那为什么要连接呢？<br>我的答案是：为了交换信息。人与人的连接，就是我们说的交流，这也是一个互享信息的过程；人与物的连接，也是为了交换信息，举个简单的例子：但我们在自动购物机上购物时，我们通过挑选我们需要的商品告诉购物机我们要的是什么，这是你给购物机的信息，你扫二维码付款，告诉了购物机你的身份，这难道不是一个交换信息的过程吗？物与物的连接，也是这样的，就像智能家居里的家具，是要连接起来，共享信息，才能把我们的家控制在一个适宜的状态。我们写程序也一样，也要连接，也要交流，也要共享信息…</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>客户端套接字（也可以就叫“套接字”），套接字是两台机器之间的通信端点，是源IP地址和目的IP地址以及源端口号和目的端口号的组合，一般用于标识客户端请求的服务器和服务，是支持TCP/IP的网络通信的基本操作单元。</p>
<p>一个Socket由一个IP地址和一个端口号唯一确定。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。具体的介绍参考Oracle的Socket说明文档。</p>
<h5 id="使用Socket的过程有："><a href="#使用Socket的过程有：" class="headerlink" title="使用Socket的过程有："></a>使用Socket的过程有：</h5><ol>
<li><p>创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">指定ip地址和端口号</div><div class="line">Socket client = new Socket(&quot;127.0.0.1.&quot;, 8080);</div><div class="line">打开连接到Socket的输入/输出流</div><div class="line">BufferedReader input=new BufferedReader(new InputStreamReader(client.getInputStream()));</div><div class="line">BufferedReader output=new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));</div></pre></td></tr></table></figure>
</li>
<li><p>进行读/写操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String line = input.readLine();</div><div class="line">output.write(&quot;Success!&quot;);</div><div class="line">output.flush();</div></pre></td></tr></table></figure>
</li>
<li><p>关闭Socket</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input.close();</div><div class="line">output.close();</div><div class="line">client.close();</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>服务器套接字，可以绑定到指定的服务器IP地址和端口，等待请求通过网络传入，基于该请求执行某些操作，然后可能向请求者返回结果。</p>
<h5 id="使用ServerSocket的过程有："><a href="#使用ServerSocket的过程有：" class="headerlink" title="使用ServerSocket的过程有："></a>使用ServerSocket的过程有：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">这里绑定8080端口，默认绑定本地IP地址，侦听并接收HTTP请求。</div><div class="line">ServerSocket server = new ServerSocket(8080);</div><div class="line">accept()方法，侦听并接受到此套接字的连接,程序会在此处堵塞，简单点说，程序会在此处停住，一直等到有客户端连接</div><div class="line">Socket socket = server.accept();</div><div class="line"></div><div class="line">Server接收消息后再对请求做处理，注意服务端input对应客户端的output，服务端的output对应客户端的input。</div></pre></td></tr></table></figure>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">package service.com;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">import org.apache.commons.lang3.time.DateFormatUtils;</div><div class="line"></div><div class="line">public class HttpServer &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 侦听8080端口</div><div class="line">            ServerSocket server = new ServerSocket(8080);</div><div class="line"></div><div class="line">            System.out.println(&quot;Info:Server start,&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));</div><div class="line">            while (1 == 1) &#123;</div><div class="line">                // 接收客户端请求数据   程序堵塞</div><div class="line">                Socket socket = server.accept();</div><div class="line"></div><div class="line">                // 读取</div><div class="line">                BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));</div><div class="line">                // 写入</div><div class="line">                BufferedWriter output = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</div><div class="line"></div><div class="line">                String line = input.readLine();</div><div class="line"></div><div class="line">                while (line != null) &#123;</div><div class="line">                    System.out.println(line);</div><div class="line">                    output.write(&quot;Success!!&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;) + &quot;\r\n&quot;);</div><div class="line">                    output.flush();</div><div class="line">                    line = input.readLine();</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                //必须关闭</div><div class="line">                input.close();</div><div class="line">                output.close();</div><div class="line"></div><div class="line">                socket.close();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">           System.out.println(&quot;Error binding the specified port.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><ol>
<li><p>启动程序后，控制台信息输出：<br>Info:Server start,2016-12-02 15:26:13</p>
</li>
<li><p>使用cmd,输入命令 telnet localhost 8080:<br>输入 hello world</p>
</li>
<li><p>命令行显示:<br>Success!!2016-12-02 15:29:01</p>
</li>
<li><p>控制台输出：<br>hello world</p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过上面的讲述，不难发现，虽然我们说的Socket编程，但这一部分的内容并不多，无非就是建立SocketServer和Socket，两者使用同样的端口，就能相互连接上，<br>最主要的还是怎么处理连接后的的IO流的操作。此外，还需要服务器端的输入输出流和客户端的输入输出流，必要弄混淆了。</p>
<p>我们用的例子是发送字符串，但我们要看到本质性的东西：我们发送的字符串是以字节的形式发送出去的，那是不是说明我们就可以发送图像、视频…了呢？是的，我们能把计算机上的任何东西发送出去，只需要找到我们要发送的文件的URI，就能打开它，保存到字节数组里，然后发送出去。当然，如果文件过大，还要注意内存溢出的问题。</p>
<p>此外，我们常说的Web服务器，其实也就是一个用来接收客户端请求，并处理用户端的请求并返回信息的程序，只不过有一些特别的规定，也就是Http协议。那是不是说，如果我们了解了Http协议的规定，我们也能写一个Http服务器了呢？下一节咱们就来完成一个简单的能处理http请求的服务器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h3&gt;&lt;p&gt;现在是互联网的时代，说到底也就是连接的时代。人与人、人与物、物与物都需要连接，那为什么要连接呢？&lt;br&gt;我的答案是：为了交换信息。人与人的连
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>jxl操作excel</title>
    <link href="http://yoursite.com/2017/07/28/jxl%E6%93%8D%E4%BD%9Cexcel/"/>
    <id>http://yoursite.com/2017/07/28/jxl操作excel/</id>
    <published>2017-07-28T09:53:44.000Z</published>
    <updated>2017-07-28T01:59:07.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java操作Excel（jxl）"><a href="#Java操作Excel（jxl）" class="headerlink" title="Java操作Excel（jxl）"></a>Java操作Excel（jxl）</h3><h5 id="读"><a href="#读" class="headerlink" title="读"></a>读</h5><p>读的时候是这样的一个思路,先用一个输入流(InputStream)得到Excel文件,然后用jxl中的Workbook得到工作薄,用Sheet从工作薄中得到工作表,用Cell得到工作表中得某个单元格.<br>InputStream-&gt;Workbook-&gt;Sheet-&gt;Cell,就得到了excel文件中的单元格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String path = &quot;c:\\excel.xls&quot;; //Excel文件URL</div><div class="line">InputStream is = new FileInputStream(path); //写入到FileInputStream</div><div class="line">jxl.Workbook wb = Workbook.getWorkbook(is); //得到工作薄 </div><div class="line">jxl.Sheet st = wb.getSheet(0); //得到工作薄中的第一个工作表</div><div class="line">Cell cell = st.getCell(0, 0); //得到工作表的第一个单元格,即A1</div><div class="line">String content = cell.getContents(); //getContents()将Cell中的字符转为字符串</div><div class="line">wb.close(); //关闭工作薄</div><div class="line">is.close(); //关闭输入流</div></pre></td></tr></table></figure>
<p>我们可以通过Sheet的getCell(x,y)方法得到任意一个单元格,x,y和excel中的坐标对应.<br>例如A1对应(0,0),A2对应(0,1),D3对应(3,2).Excel中坐标从A,1开始,jxl中全部是从0开始.<br>还可以通过Sheet的getRows(),getColumns()方法得到行数列数,并用于循环控制,输出一个sheet中的所有内容.</p>
<h5 id="写"><a href="#写" class="headerlink" title="写"></a>写</h5><p>往Excel中写入内容主要是用jxl.write包中的类.<br>思路是这样的:<br>OutputStream&lt;-WritableWorkbook&lt;-WritableSheet&lt;-Label<br>这里面Label代表的是写入Sheet的Cell位置及内容.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">OutputStream os = new FileOutputStream(&quot;c:\\test.xls&quot;); </div><div class="line">WritableWorkbook wwb = Workbook.createWorkbook(os); </div><div class="line">WritableSheet ws = wwb.createSheet(&quot;sheet1&quot;, 0);    //创建可写工作表</div><div class="line">Label labelCF = new Label(0, 0, &quot;hello&quot;);    //创建写入位置和内容</div><div class="line">ws.addCell(labelCF);    //将Label写入sheet中</div><div class="line">//Label的构造函数Label(int x, int y,String aString)xy意同读的时候的xy,aString是写入的内容.</div><div class="line">WritableFont wf = new WritableFont(WritableFont.TIMES, 12, WritableFont.BOLD, false);   //设置写入字体</div><div class="line">WritableCellFormat wcfF = new WritableCellFormat(wf);    //设置CellFormat</div><div class="line">Label labelCF = new Label(0, 0, &quot;hello&quot;);   //创建写入位置,内容和格式</div><div class="line">//Label的另一构造函数Label(int c, int r, String cont, CellFormat st)可以对写入内容进行格式化,设置字体及其它的属性.</div><div class="line">    </div><div class="line">wwb.write();</div><div class="line">wwb.close();</div><div class="line">os.close;</div></pre></td></tr></table></figure></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>OK,了解了怎么读与写，我们只要把读和写结合起来,就可以在N个Excel中读取数据写入你希望的Excel新表中,还是比较方便的。举个例子吧:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">sql = &quot;select * from tablename&quot;;</div><div class="line">rs = stmt.executeQuery(sql);</div><div class="line">//新建Excel文件</div><div class="line">String filePath = request.getRealPath(&quot;aaa.xls&quot;);</div><div class="line">File myFilePath = new File(filePath);</div><div class="line">if (!myFilePath.exists()) myFilePath.createNewFile();</div><div class="line">FileWriter resultFile = new FileWriter(myFilePath);</div><div class="line">PrintWriter myFile = new PrintWriter(resultFile);</div><div class="line">resultFile.close();</div><div class="line">//用JXL向新建的文件中添加内容</div><div class="line">OutputStream outf = new FileOutputStream(filePath);</div><div class="line">jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(outf);</div><div class="line">jxl.write.WritableSheet ws = wwb.createSheet(&quot;sheettest&quot;, 0);</div><div class="line">int i = 0;</div><div class="line">int j = 0;</div><div class="line">for (int k = 0; k &lt; rs.getMetaData().getColumnCount(); k++) &#123;</div><div class="line">    ws.addCell(new Label(k, 0, rs.getMetaData().getColumnName(k + 1)));</div><div class="line">&#125;</div><div class="line">while (rs.next()) &#123;</div><div class="line">    out.println(rs.getMetaData().getColumnCount());</div><div class="line">    for (int k = 0; k &lt; rs.getMetaData().getColumnCount(); k++) &#123;</div><div class="line">        ws.addCell(new Label(k, j + i + 1, rs.getString(k + 1)));</div><div class="line">    &#125;</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line">wwb.write();</div><div class="line">wwb.close();</div><div class="line">&#125; catch(Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">    rs.close();</div><div class="line">    conn.close();</div><div class="line">&#125;</div><div class="line">response.sendRedirect(&quot;aaa.xls&quot;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java操作Excel（jxl）&quot;&gt;&lt;a href=&quot;#Java操作Excel（jxl）&quot; class=&quot;headerlink&quot; title=&quot;Java操作Excel（jxl）&quot;&gt;&lt;/a&gt;Java操作Excel（jxl）&lt;/h3&gt;&lt;h5 id=&quot;读&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>a+b=c</title>
    <link href="http://yoursite.com/2017/07/28/a-b-c/"/>
    <id>http://yoursite.com/2017/07/28/a-b-c/</id>
    <published>2017-07-27T16:53:27.000Z</published>
    <updated>2017-07-27T14:39:52.285Z</updated>
    
    <content type="html"><![CDATA[<h3 id="见林见森"><a href="#见林见森" class="headerlink" title="见林见森"></a>见林见森</h3><p>小时候，常听大人们讲”看问题要看本质”，那是还小，不太懂这句话的意思，也没有进行深入的思考。慢慢的长大，经历的许多事情后，再次听到这句话，觉得自己有了一点理解。</p>
<p>就拿我们小时候学的算术来举个例子，我们都知道2+3=5，6+8=10…在小学，我们学了很多这样的例子；等我们到了初中的时候，接触到代数，有了这样的表达式  a+b=c ，人们所说的代数。一个简单的表达式就涵盖了我们小学6年所学的算术，说到底，我们在小学学的无穷的算术，就是为了在初中能更好地理解为什么 a+b=c 是可以成立的。换句话来说a+b=c就是我们在学了无穷的算术后，所真正需要掌握的东西,如果小学毕业后我们不能理解为什么a+b=c ，那就是我们的不对了。a+b=c的背后，是一种思考方法…</p>
<p>我们长大了，需要学习的东西也变多了，也没有多少个六年让我们去掌握一件东西了。所以在学习的时候，我们就需要从表面的东西看到最深层的东西，这不容易，需要平常多思考，多与人交流。</p>
<p>拿自己来说吧，一个以后极其可能走上码农道路上的人来说，有无数中高级语言需要我们去学习，因为我们并不知道客户的需求是什么样的。那是不是说如果客户要求使用的语言我没学过，那这工作我是不是就不能接了呢？如果是这样，那码农这个职业的存在就是不合理的。要解决这种问题，需要我们有学过一本语言，就能知道怎么使用其他语言的能力，那怎么做到呢？是的，这时候我们就需要找到这些编程语言的共性。如果我们有学过一本编程语言，就应该知道用这门语言完成一些操作时的步骤，比如说用来操作文件，一般都是先找到文件、建立通道、操作文件…再比如说数据库操作，一般步骤为怎么连接数据库、怎么发送SQL语句…是的，能够发现这些基本的步骤，才是我们学习一门语言的目的，也只有这样，我们才能更快的学习另一门语言，满足客户的要求。</p>
<p>在唠叨一下，如果我们今天自己完成了一个可以复制、加密文件的小程序，第二天，有一个叫做“学生信息管理系统”的项目需要你来完成，你的反应是什么呢？第一反应极大可能是我不会呀，我只会最基本的文件复制、加密，怎么完成你的这个学生信息管理系统呀。这是正常的，我们接触到新的事物时，正常反应都是这样的。但如果我们仔细想想，管理系统说到底也就是信息处理呀，就是把把填写的学生信息存起来或者能把学生的信息读取出来，跟我们完成的文件复制、加密程序，不是一样的功能吗？还是那句话，见到树，就要想到森林。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;见林见森&quot;&gt;&lt;a href=&quot;#见林见森&quot; class=&quot;headerlink&quot; title=&quot;见林见森&quot;&gt;&lt;/a&gt;见林见森&lt;/h3&gt;&lt;p&gt;小时候，常听大人们讲”看问题要看本质”，那是还小，不太懂这句话的意思，也没有进行深入的思考。慢慢的长大，经历的许多事情后，再
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java加密系统</title>
    <link href="http://yoursite.com/2017/07/27/Java%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/07/27/Java加密系统/</id>
    <published>2017-07-26T20:17:32.000Z</published>
    <updated>2017-07-26T13:02:02.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加密系统"><a href="#加密系统" class="headerlink" title="加密系统"></a>加密系统</h3><p>最近,在学习文件操作这一部分的内容，在了解了一些文件的增、删、改、查后，突发奇想不如来整合一些这些功能，弄个简单的软件。</p>
<h5 id="生成密文"><a href="#生成密文" class="headerlink" title="生成密文"></a>生成密文</h5><p>加密的方法有很多种，有对称、非对称加密算法，具体区别就不再这里细说了。初次尝试，用的是对称的加密算法，就是用来加密和解密的密文都是一样的。对于密文的实现，自己用的是一个很简单的算法，就是随机生成一些随机数，然后写进一个文件里，然后就可以使用其进行加密。</p>
<h5 id="加密-解密"><a href="#加密-解密" class="headerlink" title="加密/解密"></a>加密/解密</h5><p>密文有了，我们就可以加密了，也很简单。我们先把密文的信息取出来，存在一个数组中，然后一个字节一个字节的把需要在加密的信息读出来，先加上数组的值，然后在写到另一个文件，这样就能加密了。是不是很简单呀，知道了加密，那解密也就不是事了，用同样的密文，减去相应的值就好啦。</p>
<h5 id="Finall"><a href="#Finall" class="headerlink" title="Finall"></a>Finall</h5><p>最后，需要指出的是这种加密方法还是挺容易被破解的，只要拿到加密所需要的密文，一切就都可以解决了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;加密系统&quot;&gt;&lt;a href=&quot;#加密系统&quot; class=&quot;headerlink&quot; title=&quot;加密系统&quot;&gt;&lt;/a&gt;加密系统&lt;/h3&gt;&lt;p&gt;最近,在学习文件操作这一部分的内容，在了解了一些文件的增、删、改、查后，突发奇想不如来整合一些这些功能，弄个简单的软件。&lt;/
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java文件处理器</title>
    <link href="http://yoursite.com/2017/07/26/Java%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://yoursite.com/2017/07/26/Java文件处理器/</id>
    <published>2017-07-25T22:46:17.000Z</published>
    <updated>2017-07-26T12:32:02.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谈谈Java文件处理"><a href="#谈谈Java文件处理" class="headerlink" title="谈谈Java文件处理"></a>谈谈Java文件处理</h3><p>今天，一时兴起，用Java跟着教程弄了一个文件管理器，其功能有复制源文件夹内的容到目标文件夹、查看、修改功能。</p>
<p>文件管理器的核心就是文件的操作，Java为我们封装了许多用于文件操作的类，初学的话对这些类不熟悉，常常会觉得文件操作很困难，但其实并不困难，只要我们记住一下的步骤：</p>
<ol>
<li>定位要操作的文件</li>
<li>建立管道</li>
<li>进行操作</li>
</ol>
<p>简单点说，就是我们只需要找到我们想要操作的文件的路径，就能定位到它，就能对其进行一些列的操作，比如查看、复制、删除…这些操作，Java都已经为我们准备好了，需要用的时候查看文档就好了，最主要的是要记住步骤。</p>
<p>另外，需要注意的是，IO流的操作是很占用内存的，举个例子吧：如果我们要把文件A里的内容复制到B中，计算机是这样工作的：计算机要先找到A文件，然后读取内容到JVM的内存中，然后在写进B文件中，但我们的A文件很大时，计算机就需要进行多次这样的循环工作，非常耗时，浪费资源。所以我们可以改进一下，我们可以这样设想，如果我们把从A读取的内容先在JVM中存起来，当达到足够的量时在一次把这些内容写进B中，这样就减少了一些重复性的工作，效率会提高不少。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;谈谈Java文件处理&quot;&gt;&lt;a href=&quot;#谈谈Java文件处理&quot; class=&quot;headerlink&quot; title=&quot;谈谈Java文件处理&quot;&gt;&lt;/a&gt;谈谈Java文件处理&lt;/h3&gt;&lt;p&gt;今天，一时兴起，用Java跟着教程弄了一个文件管理器，其功能有复制源文件夹内
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
