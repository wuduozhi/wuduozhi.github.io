<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-18T09:30:35.303Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构|图</title>
    <link href="http://yoursite.com/2018/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/01/18/数据结构-图/</id>
    <published>2018-01-18T14:43:37.000Z</published>
    <updated>2018-01-18T09:30:35.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图这种数据结构，是对现实中人们常说的地图的一种抽象，在数据结构中，图有点和边构成，每两个点之间如果有关系，就用一条边将这两个点连起来，这样就形成了类似于地图的图。图是个好东西啊，可以用于对现实世界中的很多问题进行抽象建模:</p>
<ul>
<li>为计算机之间的互联与通信网络之间的互联建立模型</li>
<li>把一张地图表示为一组位置点，以及位置点之间的关系，求两个点之间的最短路径（这不就是导航吗）</li>
<li>为交通网络的流量状态建模</li>
<li>为一个复杂的活动找到一个可以接受的各个子任务完成的先后顺序，例如大型建筑工程的建设任务分解</li>
<li>为家族、商业或军事组织和自然科学分类中的各种相互关系建模 </li>
</ul>
<p>其实，讲到底，在多对多的关系中，几乎都能用图来表示其关系，最形象的就是人的关系网。我们前面学的线性表是一对一的关系，树是一对多的关系，现在讲的图是多对多的关系。</p>
<h4 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h4><p>我们先来解决第一个问题，怎么表示在计算机中存储图，也就是要怎么表示图。容易想到的是用二位数组，a[i][j],i与j表示两个点，如果a[i][j]为 1 就表示 i , j 之间有关系，否则就没有关系，书上称之为邻接矩阵表示法。还有一种是邻接表表示法，即数组与链表相结合的存储方法。具体是这样的：</p>
<ul>
<li>图中顶点用一个一维数组存储，另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。</li>
<li>图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图称为顶点vi作为弧尾的出边表。</li>
</ul>
<p><img src="/images/图1.jpg" alt="图的表示" title="图1"></p>
<p><img src="/images/图2.jpg" alt="图的表示" title="图2"></p>
<p>值得一提的是，这两种表示法的各有各的优缺点，一般来说，如果图的边较少的情况下，我们一般选用邻接表，这样开销较小，因为如果用邻接矩阵的话，整个二维数组里就有很多空间没有用到，浪费空间；如果是边较多的时候，也就是我们所说的稠密图，选用邻接矩阵是个好的选择。</p>
<h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><p>确定从一个指定的顶点可以到达其他哪些顶点。这是经常对图执行的操作。我们可能想通过地图了解到从一个城镇到另一个城镇有哪些路，或者从一个机场到其他机场有哪些航班。</p>
<p>图的遍历方法一般有两种：</p>
<ul>
<li>深度遍历</li>
<li>广度遍历</li>
</ul>
<h5 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h5><p>深度优先搜索DFS遍历类似于树的前序遍历。其基本思路是：</p>
<ul>
<li><p>a) 假设初始状态是图中所有顶点都未曾访问过，则可从图G中任意一顶点v为初始出发点，首先访问出发点v，并将其标记为已访问过。</p>
</li>
<li><p>b)然后依次从v出发搜索v的每个邻接点w，若w未曾访问过，则以w作为新的出发点出发，继续进行深度优先遍历，直到图中所有和v有路径相通的顶点都被访问到。</p>
</li>
<li><p>c) 若此时图中仍有顶点未被访问，则另选一个未曾访问的顶点作为起点，重复上述步骤，直到图中所有顶点都被访问到为止。</p>
</li>
</ul>
<p>简单的来说，深度优先搜索包括从一条路径的起始点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。不好听地说，就是先一条路走到黑，只到无路可走，然后退回上一个顶点，在一直走，重复此操作。</p>
<p><img src="/images/图-深度遍历.jpg" alt="图的深度优先遍历" title="图-深度遍历"></p>
<p>注：红色数字代表遍历的先后顺序，所以图(e)无向图的深度优先遍历的顶点访问序列为：V0，V1，V2，V5，V4，V6，V3，V7，V8</p>
<p>深度优先搜索的算法比较简单： 访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在起始点的邻接表中其他没有访问过的顶点。</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>广度优先搜索遍历BFS类似于树的按层次遍历。其基本思路是：</p>
<ul>
<li>a) 首先访问出发点Vi</li>
<li>b) 接着依次访问Vi的所有未被访问过的邻接点Vi1，Vi2，Vi3，…，Vit并均标记为已访问过。</li>
<li>c) 然后再按照Vi1，Vi2，… ，Vit的次序，访问每一个顶点的所有未曾访问过的顶点并均标记为已访问过，依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。</li>
</ul>
<p><img src="/images/图-广度遍历.jpg" alt="图的广度优先遍历" title="图-广度遍历"></p>
<p>因此，图(f)采用广义优先搜索遍历以V0为出发点的顶点序列为：V0，V1，V3，V4，V2，V6，V8，V5，V7</p>
<p>简单的来说，广度优先搜索从一个顶点开始，尝试访问尽可能靠近它的顶点。本质上这种搜索在图上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层。就想警察进山抓贼一样，层层逼近，逐渐缩小包围圈。</p>
<p>要实现广度优先搜索，我们自然会想到用队列来存储我们找到过得顶点，当遍历完一个当前顶点的所关联点后，就从队列中弹出一个新的顶点，访问其还没被访问的关联顶点，直到队列为空。</p>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。<br>该序列必须满足下面两个条件：</p>
<ul>
<li>每个顶点出现且只出现一次</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li>
</ul>
<p><img src="/images/拓扑排序1.png" alt="enter description here" title="拓扑排序1"></p>
<p>它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：</p>
<ul>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li>
</ul>
<p><img src="/images/拓扑排序2.png" alt="拓扑排序" title="拓扑排序2"></p>
<p>于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。</p>
<p>值得一提的是，一个有向无环图是可以有一个或多个拓扑排序序列的。</p>
<h6 id="拓扑排序的应用"><a href="#拓扑排序的应用" class="headerlink" title="拓扑排序的应用"></a>拓扑排序的应用</h6><p>拓扑排序通常用来“排序”具有依赖关系的任务。比如学校对我们的课程安排，一些课程是需要学生先去修特定的课程后才能开课的，所以可以用一个有向图来表示这些课程的关系，然后得到该图的拓扑排序排序，就能得到我们的课程先后关系，进而安排大一修什么课，大二修什么课…还有就是一些生产工艺，有些工序之间也是有关系的，也能用图将其建模，得出它的拓扑排序序列，更好地安排生产顺序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h3&gt;&lt;p&gt;图这种数据结构，是对现实中人们常说的地图的一种抽象，在数据结构中，图有点和边构成，每两个点之间如果有关系，就用一条边将这两个点连起来，这样就形成了类
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构|排序算法浅谈</title>
    <link href="http://yoursite.com/2018/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2018/01/18/数据结构-排序算法浅谈/</id>
    <published>2018-01-17T23:13:38.000Z</published>
    <updated>2018-01-18T06:47:35.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>经过大一到大二的洗礼，自己对自己专业的认识也越来越深，从最开始认为自己是学软件工程的，然后认为自己是学计算机的，再到现在认为自己是搞互联网的，可能还会有更深的认识。学习，不仅是要学习专业知识，更要知道行业的发展趋势和发展方向，两者缺一不可。这个行业说到底还是对信息进行处理，那么排序就是最重要的处理方式之一。</p>
<p>排序算法有很多种，现在我们主要谈谈常见的几种：</p>
<ul>
<li>插入排序</li>
<li>冒泡排序</li>
<li>选择排序</li>
<li>shell排序</li>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序，就是我们打扑克是所用的伎俩，我们抽到一张牌，然后从手里的牌中寻找合适的位置插入，这个寻找的过程就是插入排序。</p>
<p><img src="/images/插入排序.gif" alt="enter description here" title="插入排序"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">	A[]  待排序列</div><div class="line">	n    元素个数</div><div class="line">*/</div><div class="line">void inssort(int A[],int n)&#123;</div><div class="line">	for(int i=1;i&lt;n;i++)&#123;</div><div class="line">		for(int j=i;j&gt;0;j--)&#123;</div><div class="line">			if(A[j]&lt;A[j-1])&#123;</div><div class="line">				int temp = A[j];</div><div class="line">				A[j] = A[j-1];</div><div class="line">				A[j-1] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序也挺好理解，就是没每趟比较相邻的两个数，把小的数往后移，每一趟都把待排序列中最小的数往后移，重复n-1此操作就能让待排序列有序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">	A[]  待排序列</div><div class="line">	n    元素个数</div><div class="line">*/</div><div class="line">void bubSort(int A[],int n)&#123;</div><div class="line">	for(int i=1;i&lt;n;i++)&#123;</div><div class="line">		for(int j=0;j&lt;n-i;j++)&#123;</div><div class="line">			if(A[j]&lt;A[j+1])&#123;</div><div class="line">				int temp = A[j];</div><div class="line">				A[j] = A[j+1];</div><div class="line">				A[j+1] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p><img src="/images/选择排序.gif" alt="enter description here" title="选择排序"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">	A[]  待排序列</div><div class="line">	n    元素个数</div><div class="line">*/</div><div class="line">void choSort(int A[],int n)&#123;</div><div class="line">	for(int i=0;i&lt;n-1;i++)&#123;</div><div class="line">		for(int j=i;j&lt;n;j++)&#123;</div><div class="line">			int index = i;</div><div class="line">			if(A[j]&lt;A[index])&#123;</div><div class="line">				index = j;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		int temp = A[i];</div><div class="line">		A[i] = A[index];</div><div class="line">		A[index] = temp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="一点干货"><a href="#一点干货" class="headerlink" title="一点干货"></a>一点干货</h4><p>上面三种排序方法的时间复杂度都是 n2;通过比较我们可以发现它们都有一个共同的瓶颈：都是只比较相邻的两个数，这是个致命的缺点，只到后来人们找到了分组比较的方法，得以让排序算法的复杂度降低了。接下来，咱们讨论更高级的排序算法。</p>
<h4 id="Shell排序"><a href="#Shell排序" class="headerlink" title="Shell排序"></a>Shell排序</h4><p>Shell排序讲到底还是插入排序，不过它先把待排序列分成了许多组，先分组用插入排序，这样做到目的是先将待排序列变成基本有序，然后在用一次完整的插入排序。我们都知道，如果序列是基本有序的，插入排序的效率还是挺高的。Shell的特点就在于：它的作法不是每次一个元素挨一个元素的比较。而是初期选用大跨步（增量较大）间隔比较，使记录跳跃式接近它的排序位置；然后增量缩小；最后增量为 1 ，这样记录移动次数大大减少，提高了排序效率。</p>
<p>假设有数组 array = [80, 93, 60, 12, 42, 30, 68, 85, 10]，首先取 d1 = 4，将数组分为 4 组，如下图中相同颜色代表一组：<br><img src="/images/shell-sort-step1.1.png" alt="enter description here" title="shell-sort-step1.1"><br>然后分别对 4 个小组进行插入排序，排序后的结果为：<br><img src="/images/shell-sort-step1.2.png" alt="enter description here" title="shell-sort-step1.2"><br>然后，取 d2 = 2，将原数组分为 2 小组，如下图：<br><img src="/images/shell-sort-step2.1.png" alt="enter description here" title="shell-sort-step2.1"><br>然后分别对 2 个小组进行插入排序，排序后的结果为：<br><img src="/images/shell-sort-step2.2.png" alt="enter description here" title="shell-sort-step2.2"><br>最后，取 d3 = 1，进行插入排序后得到最终结果：<br><img src="/images/shell-sort-step3.png" alt="enter description here" title="shell-sort-step3"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void shell_sort(int a[], int n)&#123;</div><div class="line">    int i,j,gap;</div><div class="line">    //gap为步长，每次减为原来的一半</div><div class="line">    for(gap = n/2;gap&gt;0;gap/=2)&#123;</div><div class="line">        // 共gap个组，对每一组都执行直接插入排序</div><div class="line">        for(i = 0;i&lt;gap;i++)&#123;</div><div class="line">            for(j = i+gap;j&lt;n;j+=gap)&#123;</div><div class="line">                // 如果a[j] &lt; a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。</div><div class="line">                if (a[j] &lt; a[j - gap]) </div><div class="line">                &#123;</div><div class="line">                    int tmp = a[j];</div><div class="line">                    int k = j - gap;</div><div class="line">                    while (k &gt;= 0 &amp;&amp; a[k] &gt; tmp)</div><div class="line">                    &#123;</div><div class="line">                        a[k + gap] = a[k];</div><div class="line">                        k -= gap;</div><div class="line">                    &#125;</div><div class="line">                    a[k + gap] = tmp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并操作(Merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。归并排序有多路归并排序、两路归并排序 , 可用于内排序，也可以用于外排序。这里仅对内排序的两路归并方法进行讨论。</p>
<p>算法思路：</p>
<ul>
<li>把 n 个记录看成 n 个长度为 l 的有序子表</li>
<li>进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表</li>
<li>重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。</li>
</ul>
<p>先讲讲归并吧，就是将两个有序个数据合并成一个新的有序数组。看代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 将一个数组中的两个相邻有序区间合并成一个</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     a -- 包含两个有序区间的数组</div><div class="line"> *     start -- 第1个有序区间的起始地址。</div><div class="line"> *     mid   -- 第1个有序区间的结束地址。也是第2个有序区间的起始地址。</div><div class="line"> *     end   -- 第2个有序区间的结束地址。</div><div class="line"> */</div><div class="line">void merge(int* a, int start, int mid, int end)</div><div class="line">&#123;</div><div class="line">    int *tmp = new int[end-start+1];    // tmp是汇总2个有序区的临时区域</div><div class="line">    int i = start;            // 第1个有序区的索引</div><div class="line">    int j = mid + 1;        // 第2个有序区的索引</div><div class="line">    int k = 0;                // 临时区域的索引</div><div class="line"></div><div class="line">    while(i &lt;= mid &amp;&amp; j &lt;= end)</div><div class="line">    &#123;</div><div class="line">        if (a[i] &lt;= a[j])</div><div class="line">            tmp[k++] = a[i++];</div><div class="line">        else</div><div class="line">            tmp[k++] = a[j++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while(i &lt;= mid)</div><div class="line">        tmp[k++] = a[i++];</div><div class="line"></div><div class="line">    while(j &lt;= end)</div><div class="line">        tmp[k++] = a[j++];</div><div class="line"></div><div class="line">    // 将排序后的元素，全部都整合到数组a中。</div><div class="line">    for (i = 0; i &lt; k; i++)</div><div class="line">        a[start + i] = tmp[i];</div><div class="line"></div><div class="line">    delete[] tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就是我们的归并排序算法啦，刚刚讲到是用分而治之的办法，那就是要用到递归了，先看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 归并排序(从上往下)</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     a -- 待排序的数组</div><div class="line"> *     start -- 数组的起始地址</div><div class="line"> *     end -- 数组的结束地址</div><div class="line"> */</div><div class="line"></div><div class="line">void mergeSortUp2Down(int* a, int start, int end)&#123;</div><div class="line">    </div><div class="line">    if(a==NULL || start &gt;= end)</div><div class="line">        return ;</div><div class="line"></div><div class="line">    int mid = (end + start)/2;</div><div class="line">    mergeSortUp2Down(a, start, mid); // 递归排序a[start...mid]</div><div class="line">    mergeSortUp2Down(a, mid+1, end); // 递归排序a[mid+1...end]</div><div class="line"></div><div class="line">    // a[start...mid] 和 a[mid...end]是两个有序空间，</div><div class="line">    // 将它们排序成一个有序空间a[start...end]</div><div class="line">    merge(a, start, mid, end);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/归并排序.gif" alt="归并排序动画演示" title="归并排序"></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序与归并排序的思想是一致的，都是 采用的分而治之的办法，但这个分的方法不一样，归并算法是相邻的两个分，快速排序是选择一个基准，然后通过比较将小于基准的数放在其左边，大于基准的数放在右边，这个操作叫做分区操作，然后对基准左边和右边的数进行同样的操作。</p>
<p>利用分治法可将快速排序的分为三步：</p>
<ul>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ul>
<p><img src="/images/快速排序.gif" alt="快速排序" title="快速排序"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 快速排序</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     a -- 待排序的数组</div><div class="line"> *     l -- 数组的左边界(例如，从起始位置开始排序，则l=0)</div><div class="line"> *     r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)</div><div class="line"> */</div><div class="line"></div><div class="line">void quickSort(int *a ,int l,int r)&#123; </div><div class="line">    if(l&lt;r)&#123;</div><div class="line">        int i,j,x;</div><div class="line">        i=l;</div><div class="line">        j=r;</div><div class="line">        x = a[i];</div><div class="line">        while(i&lt;j)&#123;</div><div class="line">            while(i&lt;j &amp;&amp; a[j]&gt;x)&#123;</div><div class="line">                j--; // 从右向左找第一个小于x的数</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if(i&lt;j)&#123;</div><div class="line">                a[i] = a[j];</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            while(i&lt;j &amp;&amp; a[i]&lt;x)&#123;</div><div class="line">                i++;   // 从左向右找第一个大于x的数</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if(i&lt;j)&#123;</div><div class="line">                a[j] = a[i];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        a[i] = x;</div><div class="line">        quickSort(a,l,i-1);</div><div class="line">        quickSort(a,i+1,r);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h3&gt;&lt;p&gt;经过大一到大二的洗礼，自己对自己专业的认识也越来越深，从最开始认为自己是学软件工程的，然后认为自己是学计算机的，再到现在认为
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>VHDL与数字逻辑的一些坑</title>
    <link href="http://yoursite.com/2018/01/09/VHDL%E4%B8%8E%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2018/01/09/VHDL与数字逻辑的一些坑/</id>
    <published>2018-01-08T23:24:03.000Z</published>
    <updated>2018-01-08T15:45:23.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于VHDL"><a href="#关于VHDL" class="headerlink" title="关于VHDL"></a>关于VHDL</h3><p>来了大二，学习数字逻辑电路后才知道VHDL的，用来写数字逻辑的实验。刚开始接触的时候，也并不知道它是用来干什么的，经过一个学期的琢磨，才搞清楚它是用来干嘛的。简单点说，就是用来描述电路的，就像我们常说的芯片，它都有自己的功能，这些功能的实现都是内部封装好了的，只留下一些外部接口给我们，VHDL这门语言呢，就是用来描述这些芯片的内部功能的。用代码设计电路，想不到吧。更不可思议的是，IDE工具还能根据写的代码，帮我们把电路实现。</p>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>VHDL跟我们所学习的C语言这些差不多，也有if、else这些逻辑语句，但毕竟是描述电路的，还是有一些区别的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于VHDL&quot;&gt;&lt;a href=&quot;#关于VHDL&quot; class=&quot;headerlink&quot; title=&quot;关于VHDL&quot;&gt;&lt;/a&gt;关于VHDL&lt;/h3&gt;&lt;p&gt;来了大二，学习数字逻辑电路后才知道VHDL的，用来写数字逻辑的实验。刚开始接触的时候，也并不知道它是用来干什
    
    </summary>
    
      <category term="VHDL" scheme="http://yoursite.com/categories/VHDL/"/>
    
    
      <category term="VHDL" scheme="http://yoursite.com/tags/VHDL/"/>
    
  </entry>
  
  <entry>
    <title>Java|Hibernate入门</title>
    <link href="http://yoursite.com/2017/12/24/Java-Hibernate%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/12/24/Java-Hibernate入门/</id>
    <published>2017-12-24T09:39:28.000Z</published>
    <updated>2017-12-24T01:54:11.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hibernate简介"><a href="#Hibernate简介" class="headerlink" title="Hibernate简介"></a>Hibernate简介</h3><h4 id="为什么要有Hiernate"><a href="#为什么要有Hiernate" class="headerlink" title="为什么要有Hiernate"></a>为什么要有Hiernate</h4><p>我们都知道，现在主流的编程语言大多是面向对象的，如Java、C++，但是现在的主流数据库产品又是关系型的数据，在面向对象的世界里，对关系型数据库的访问与操作都是相当麻烦的。这时候ORM（Object/Relation Mapping,对象/关系数据库映射)出现了，可以说它是一种规范，完成了面向对象编程语言到关系数据库的映射。</p>
<p><img src="./images/ORM.gif" alt="ORM工具作用示意图" title="ORM"></p>
<p>Hibernate是ORM框架的一种，也是目前最流行的ORM框架。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hibernate简介&quot;&gt;&lt;a href=&quot;#Hibernate简介&quot; class=&quot;headerlink&quot; title=&quot;Hibernate简介&quot;&gt;&lt;/a&gt;Hibernate简介&lt;/h3&gt;&lt;h4 id=&quot;为什么要有Hiernate&quot;&gt;&lt;a href=&quot;#为什么要
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>PHP||文件操作</title>
    <link href="http://yoursite.com/2017/12/16/PHP-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/12/16/PHP-文件操作/</id>
    <published>2017-12-16T08:29:56.000Z</published>
    <updated>2017-12-16T17:18:58.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PHP文件操作"><a href="#PHP文件操作" class="headerlink" title="PHP文件操作"></a>PHP文件操作</h3><p>今天来记录一下PHP的文件操作，由于之前没怎么用过，导致需要用的时候也是需要查看文档，不如就记录下来，不然下次还需要查看文档。</p>
<p>当然，文件的操作，还是一样的步骤：</p>
<ul>
<li>打开文件</li>
<li>获取数据流</li>
<li>进行操作</li>
<li>关闭文件</li>
</ul>
<h4 id="文件创建-打开"><a href="#文件创建-打开" class="headerlink" title="文件创建/打开"></a>文件创建/打开</h4><p>PHP Open File - fopen() </p>
<p>打开文件的更好的方法是通过 fopen() 函数。此函数为您提供比 readfile() 函数更多的选项。open() 的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式。如果 fopen() 函数未能打开指定的文件，下面的例子会生成一段消息：</p>
<p>webdictionary.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AJAX = Asynchronous JavaScript and XML</div><div class="line">CSS = Cascading Style Sheets</div><div class="line">HTML = Hyper Text Markup Language</div><div class="line">PHP = PHP Hypertext Preprocessor</div><div class="line">SQL = Structured Query Language</div><div class="line">SVG = Scalable Vector Graphics</div><div class="line">XML = EXtensible Markup Language</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$myfile = fopen(&quot;webdictionary.txt&quot;, &quot;r&quot;) or die(&quot;Unable to open file!&quot;);</div><div class="line">echo fread($myfile,filesize(&quot;webdictionary.txt&quot;));</div><div class="line">fclose($myfile);</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AJAX = Asynchronous JavaScript and XML CSS = Cascading Style Sheets HTML = Hyper Text Markup Language PHP = PHP Hypertext Preprocessor SQL = Structured Query Language SVG = Scalable Vector Graphics XML = EXtensible Markup Language</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>打开文件为只读。文件指针在文件的开头开始。</td>
<td></td>
</tr>
<tr>
<td>w</td>
<td>打开文件为只写。删除文件的内容或创建一个新的文件，如果它不存在。文件指针在文件的开头开始。</td>
<td></td>
</tr>
<tr>
<td>a</td>
<td>打开文件为只写。文件中的现有数据会被保留。文件指针在文件结尾开始。创建新的文件，如果文件不存在。</td>
<td></td>
</tr>
<tr>
<td>x</td>
<td>创建新文件为只写。返回 FALSE 和错误，如果文件已存在。</td>
<td></td>
</tr>
<tr>
<td>r+</td>
<td>打开文件为读/写、文件指针在文件开头开始。</td>
<td></td>
</tr>
<tr>
<td>w+</td>
<td>打开文件为读/写。删除文件内容或创建新文件，如果它不存在。文件指针在文件开头开始。</td>
<td></td>
</tr>
<tr>
<td>a+</td>
<td>打开文件为读/写。文件中已有的数据会被保留。文件指针在文件结尾开始。创建新文件，如果它不存在。</td>
<td></td>
</tr>
<tr>
<td>x+</td>
<td>创建新文件为读/写。返回 FALSE 和错误，如果文件已存在。</td>
</tr>
</tbody>
</table>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><ul>
<li>fwrite：向文件写入内容，可安全用于二进制文件 。</li>
<li>file_put_contents：向文件写入内容，等同依次调用 fopen，fwrite 以及 fclose 函数。</li>
</ul>
<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><ul>
<li>fread：读取文件，可安全用于二进制文件。</li>
<li>fgets：从文件中读取 一行 数据，并将文件指针指向下一行。</li>
<li>feof:函数是用来检测文件是否结束的。该函数唯一参数就是文件指针（即$fp对应打开的文件）</li>
<li>fgetc：从文件中 逐字 读取文件数据，直到文件结束。</li>
<li>file_get_contents：把 整个文件 读入一个字符串。</li>
<li>file：把 整个文件 读入一个数组中，数组中的每个单元都是文件中相应的一行。</li>
</ul>
<h3 id="检查文件是否存在"><a href="#检查文件是否存在" class="headerlink" title="检查文件是否存在"></a>检查文件是否存在</h3><ul>
<li>file_exists：检查文件或目录是否存在。</li>
</ul>
<h4 id="检查文件是否可读写执行"><a href="#检查文件是否可读写执行" class="headerlink" title="检查文件是否可读写执行"></a>检查文件是否可读写执行</h4><ul>
<li>is_readable：检查文件是否可读。</li>
<li>is_writable：检查文件是否是否可写入。</li>
<li>is_executable：检查文件是否可执行。</li>
</ul>
<h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>copy：拷贝文件。</p>
<h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>unlink：删除文件。</p>
<h3 id="取得文件大小、类型、修改时间信息"><a href="#取得文件大小、类型、修改时间信息" class="headerlink" title="取得文件大小、类型、修改时间信息"></a>取得文件大小、类型、修改时间信息</h3><ul>
<li>filesize：取得文件大小。</li>
<li>filetype：取得文件类型。</li>
<li>filemtime：取得文件修改时间。</li>
</ul>
<h3 id="文件指针函数"><a href="#文件指针函数" class="headerlink" title="文件指针函数"></a>文件指针函数</h3><ul>
<li>fclose：关闭文件指针。</li>
<li>feof：测试文件指针是否到了文件结束的位置。</li>
<li>fseek：在文件指针中定位。</li>
<li>rewind：倒回文件指针的位置。</li>
<li>ftell：返回文件指针读/写的位置</li>
</ul>
<h3 id="测试Demo"><a href="#测试Demo" class="headerlink" title="测试Demo"></a>测试Demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">const FILE_NAME = &quot;file_info.dat&quot;;</div><div class="line"></div><div class="line">class file_info</div><div class="line">&#123;</div><div class="line">    public $file_name;</div><div class="line">    public $self_count;</div><div class="line">    public $total_count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//判断文件是否存在</div><div class="line">if (file_exists(FILE_NAME))</div><div class="line">&#123;</div><div class="line">  echo &quot;file existed.\n&quot;;</div><div class="line">  unlink(FILE_NAME);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$fd = NULL;</div><div class="line"></div><div class="line">$fd = fopen(FILE_NAME, &quot;wb&quot;);</div><div class="line"></div><div class="line">if ($fd == NULL || $fd == false)</div><div class="line">&#123;</div><div class="line">  echo &quot;Failed to open file.\n&quot;; </div><div class="line">  return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$obj = new file_info();</div><div class="line"></div><div class="line">if ($obj == NULL)</div><div class="line">&#123;</div><div class="line">   echo &quot;Failed to create object.\n&quot;;</div><div class="line">   return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for($i=0; $i&lt;3; $i++)</div><div class="line">&#123;</div><div class="line">   $temp_1 = $i * 10;</div><div class="line">   $temp_2 = $i * 100;</div><div class="line">   /*</div><div class="line">   $obj-&gt;file_name = &quot;file_&quot;.$i.&quot;\n&quot;;</div><div class="line">   $obj-&gt;self_count = $temp_1.&quot;\n&quot;;</div><div class="line">   $obj-&gt;total_count = $temp_2.&quot;\n&quot;;</div><div class="line">   */</div><div class="line">   //构造字符串。filename-0-0\n</div><div class="line">   $row = &quot;file_&quot;.$i.&quot;-&quot;.$temp_1.&quot;-&quot;.$temp_2.&quot;\n&quot;;</div><div class="line">   echo &quot;row: &quot;.$row;</div><div class="line">   fwrite($fd, $row);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if ($fd)</div><div class="line">  fclose($fd); </div><div class="line"></div><div class="line">$fd = fopen(FILE_NAME, &quot;rb&quot;);</div><div class="line">if ($fd == false)</div><div class="line">&#123;</div><div class="line">   echo &quot;Failed to open read file.\n&quot;;</div><div class="line">   return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$obj_params =  array();</div><div class="line"></div><div class="line">$i = 0;</div><div class="line"></div><div class="line">while (!feof($fd))</div><div class="line">&#123;</div><div class="line">    $tmp_obj = new file_info();</div><div class="line">    $tmp_row = fgets($fd);</div><div class="line">    if ($tmp_row == NULL)</div><div class="line">    break;</div><div class="line">    $pos_1 = strpos($tmp_row, &apos;-&apos;,0);</div><div class="line">    $pos_2 = strpos($tmp_row,&apos;-&apos;,$pos_1 + 1);</div><div class="line">    $tmp_obj-&gt;file_name = substr($tmp_row, 0, $pos_1);</div><div class="line">    $tmp_obj-&gt;self_count = substr($tmp_row, $pos_1 + 1, $pos_2- $pos_1 - 1);</div><div class="line">    $tmp_obj-&gt;total_count = substr($tmp_row, $pos_2 + 1, strlen($tmp_row) - $pos_2 - 2);</div><div class="line">    $obj_params[$i] = $tmp_obj;</div><div class="line">    $i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for ($k = 0; $k &lt; count($obj_params); $k++)</div><div class="line">&#123;</div><div class="line">   echo $obj_params[$k]-&gt;file_name.&quot;\n&quot;;</div><div class="line">   echo $obj_params[$k]-&gt;self_count.&quot;\n&quot;;</div><div class="line">   echo $obj_params[$k]-&gt;total_count.&quot;\n&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if ($fd)</div><div class="line">   fclose($fd);</div></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>参考<a href="http://www.cnblogs.com/Anker/p/3387180.html" target="_blank" rel="external">http://www.cnblogs.com/Anker/p/3387180.html</a></p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PHP文件操作&quot;&gt;&lt;a href=&quot;#PHP文件操作&quot; class=&quot;headerlink&quot; title=&quot;PHP文件操作&quot;&gt;&lt;/a&gt;PHP文件操作&lt;/h3&gt;&lt;p&gt;今天来记录一下PHP的文件操作，由于之前没怎么用过，导致需要用的时候也是需要查看文档，不如就记录下来
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>游学|一次关于创业的分享</title>
    <link href="http://yoursite.com/2017/12/16/%E6%B8%B8%E5%AD%A6-%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8E%E5%88%9B%E4%B8%9A%E7%9A%84%E5%88%86%E4%BA%AB/"/>
    <id>http://yoursite.com/2017/12/16/游学-一次关于创业的分享/</id>
    <published>2017-12-16T00:20:23.000Z</published>
    <updated>2017-12-15T17:15:40.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>胡哥前几天就说带人去外面的公司参观一波，自己有事去不了，但这次是在周五下午，自己还是有空去的，就报名参加了。之前暑假的时候就说要去微信参观学习了，但由于种种原因还没去，就先看长沙的吧。</p>
<h3 id="参观"><a href="#参观" class="headerlink" title="参观"></a>参观</h3><p>坐大巴车一个小时左右就到了。刚开始是来到百度孵化中心，这里有很多入驻的项目。我们参观了一下，感觉好大啊，接着是一些分享。</p>
<p>首先是一名在百度待过，现在出来创业的—-磊哥（记得是这名字）。磊哥说了自己的经历，首先创业失败了，然后去百度工作，然后出来创业，现在在搞大数据方面的工作，梦想是运用大数据，帮长沙的公司更好的确定目标用户，更精准的推广。真的是这样的，自己都是在象牙塔里面闭门造车，并不知道学的这些技术有什么作用，也不知道现在流行的机器学习、大数据、云计算能运用到什么方面。听了磊哥的分享，有了一点理解了，这些所谓的技术，最重要的还是要用到实处，帮助人们解决一些实际的问题，这样才能发挥价值。</p>
<p>磊哥还跟我们谈到未来的发展趋势，农业啊、文化产业啊、服务业啊，都会是将来可能发展的方向，互联网在这些方面都会有很大的应用。磊哥还提到的就是人生五年计划，每个五年内专心做一件事，做到极致，五年后在选择下一个五年要做什么。五年，我们的一声没多少个五年，黄金年龄段20~40岁之间也就4个五年，在这四个五年里也仅仅能在这四个五年里，我们能通过自己的努力来提升自己的社会阶层，有一定的财富积累。然而发现，自己已经20岁了，已经到了奋斗的年龄了，但还不知道自己今后要干嘛，实在是悲剧。</p>
<p><img src="/images/磊哥.jpg" alt="磊哥" title="磊哥"></p>
<p>接着是也在蓝杰待过的学长，刘楷强，专业三次，失败两次，一次还没失败。学长在大学就开始创业，毕业后也是一直在创业。学长分享了自己失败的经历，说创业的艰辛，但也说创业是一个在折腾自己的过程。创业初期，很多事情需要亲事亲为，要做调研、跑市场、谈客户、做报表….每一个环节都时不容易的，都需要有一定的专业知识的，所以创业就要不断的学习，不断的折腾自己。</p>
<p><img src="/images/刘楷强.jpg" alt="enter description here" title="刘楷强"></p>
<p>再接着也是我们湖大的学长， 刘叶焕 ，在读研究生，研三，但已经是以为公司的创始人了，公司年营业额一千多万，真是人比人气死人啊。学长高中毕业后就开始创业，搞培训公司。大一大二也在折腾，搞网站。大四保研后开始继续折腾，用公众号弄订单系统。自己挺佩服学长的，大学里能边创业，还能搞好学习，还成绩保研了，莫非是在出生那一刻，自己就已经输了。学长现在搞得是公众号，一个有一千万关注的公众号，主要营业靠广告，还有线下的打印店，经营理念就是服务于千万大学生。打印店只是他们公司的一个起步，是为自己赢得信赖的第一步，是让广大学生相信他们是真心实意地为学生服务的一个公司，之后就能有很大的创新了，能搞驾校啊、水果店啊…只要有人相信他了，做什么不行呢？</p>
<p><img src="/images/刘叶焕.jpg" alt="刘叶焕" title="刘叶焕"></p>
<h3 id="留给自己的"><a href="#留给自己的" class="headerlink" title="留给自己的"></a>留给自己的</h3><p>创业，是很多有梦想的人都想去干的事情，但并不是人人都能做成功的事情。自己也想过创业，但并没有付出过行动，除了高二暑假卖石榴、卖报纸那档子事，也并不能体验其中的艰辛，自己这一生还是要经历一次才算完美。在这里，为正在努力奋斗的创业者加油打气啦。</p>
<h3 id="来一次打击"><a href="#来一次打击" class="headerlink" title="来一次打击"></a>来一次打击</h3><p>晚上回来参加了今日头条的宣讲会和笔试。三道题，两道算法题，一个是求最长子数列，另一个是求最大矩形，最后一个是附加题，设计数据结构，解决群聊消息通知的问题。自己是真心不懂，想了半个小时就放弃了，溜了。仔细想想，算法这个东西还真是不能偷懒啊，还是要刷一些题的，只写一些增删改查的代码，不会有多大进步的。</p>
<p>只能下次再战了。</p>
<p><img src="/images/12.15.jpg" alt="enter description here" title="12.15"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;胡哥前几天就说带人去外面的公司参观一波，自己有事去不了，但这次是在周五下午，自己还是有空去的，就报名参加了。之前暑假的时候就
    
    </summary>
    
    
      <category term="游学" scheme="http://yoursite.com/tags/%E6%B8%B8%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>git|踩过的坑</title>
    <link href="http://yoursite.com/2017/12/15/git-%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2017/12/15/git-踩过的坑/</id>
    <published>2017-12-15T00:03:02.000Z</published>
    <updated>2017-12-14T16:41:24.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录这些年踩过的坑"><a href="#记录这些年踩过的坑" class="headerlink" title="记录这些年踩过的坑"></a>记录这些年踩过的坑</h3><p>第一次接触 Git 是在大一，刚进弦歌那会。由于Git是命令行操作的，没接触过命令行，就觉得这东西挺高大尚的，自己还专门也研究了好久呢，书都借了好几本。</p>
<p>刚开始自己也没概念，搞不清楚本地仓库和远程仓库，只有到开发新生宝典时真正使用了才知道是怎么回事，确实啊，这种工具类的东西，是要使用才能真正掌握的，就像后来用的Composer和Maven。</p>
<h3 id="说说Git"><a href="#说说Git" class="headerlink" title="说说Git"></a>说说Git</h3><h4 id="为什么要用Git"><a href="#为什么要用Git" class="headerlink" title="为什么要用Git"></a>为什么要用Git</h4><p>首先，一定要明确Git就是一个工具，一个可以帮助我们管理我们的文件的工具。特点就是，它能够记录我们的修改，我们可以回退到我们修改之前的版本。想象一下，我正在写一篇文章，我想改一些地方，但又不知道改了好不好，我就可能会复制一份来改，那要是我要改很多了？那岂不是要备份很多份？如果有了Git这个工具，我们就不需要备份了，如果改完之后不满意，可以撤回到改之前的版本，并且不局限于上一个版本，还能返回到之前的各个版本。</p>
<p>Git还有一个很重要的功能，那就是能把我们本地的文件推送到云端，也就相当与上传到百度云或各种云。这对于我们这种码农来说，就有利与多人合作开发了。毕竟这个工具的初衷就是方便程序开发的，还有其他很多重要的功能，比如开分支啊等等。</p>
<h4 id="Git是怎么工作的"><a href="#Git是怎么工作的" class="headerlink" title="Git是怎么工作的"></a>Git是怎么工作的</h4><p>俗话说“千行字不如图一张”，来张图说明一切吧：</p>
<p><img src="/images/git.png" alt="enter description here" title="git"></p>
<h3 id="一些干货"><a href="#一些干货" class="headerlink" title="一些干货"></a>一些干货</h3><h4 id="添加-gitignore没起作用"><a href="#添加-gitignore没起作用" class="headerlink" title="添加 .gitignore没起作用"></a>添加 .gitignore没起作用</h4><p>此时需要删除本地库里的东西，重新添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rm -r --cached .</div><div class="line">git add .</div><div class="line">git commit -m &quot;.gitignore is now working&quot;</div></pre></td></tr></table></figure>
<h4 id="提交到远程仓库前"><a href="#提交到远程仓库前" class="headerlink" title="提交到远程仓库前"></a>提交到远程仓库前</h4><ul>
<li>先git pull 拉下来，看有没有冲突</li>
<li>如果有，就解决冲突，然后git add，git commit ，git push</li>
</ul>
<h4 id="fetch和pull的区别"><a href="#fetch和pull的区别" class="headerlink" title="fetch和pull的区别"></a>fetch和pull的区别</h4><p>pull=fetch+merge，pull的话，下拉远程分支并与本地分支合并。fetch只是下拉远程分支，怎么合并，可以自己再做选择。</p>
<h4 id="可以参考的资料"><a href="#可以参考的资料" class="headerlink" title="可以参考的资料"></a>可以参考的资料</h4><blockquote>
<blockquote>
<p><a href="http://huanglei.me/git-theory.html" target="_blank" rel="external">http://huanglei.me/git-theory.html</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;记录这些年踩过的坑&quot;&gt;&lt;a href=&quot;#记录这些年踩过的坑&quot; class=&quot;headerlink&quot; title=&quot;记录这些年踩过的坑&quot;&gt;&lt;/a&gt;记录这些年踩过的坑&lt;/h3&gt;&lt;p&gt;第一次接触 Git 是在大一，刚进弦歌那会。由于Git是命令行操作的，没接触过命令行
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>动态规划——由实践总结经验</title>
    <link href="http://yoursite.com/2017/12/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/"/>
    <id>http://yoursite.com/2017/12/09/动态规划经典例题/</id>
    <published>2017-12-09T00:10:32.000Z</published>
    <updated>2017-12-08T16:56:52.877Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划——由实践总结经验</p>
<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul>
<li>基础题目<ul>
<li>矩阵取数问题</li>
<li>最大子段和</li>
<li>最长公共子序列问题</li>
<li>编辑距离问题</li>
<li>最长单增子序列</li>
<li>0-1背包问题</li>
<li>正整数分组</li>
</ul>
</li>
<li>进阶题目<br>  -最大子矩阵和<ul>
<li>循环数组最大字段和</li>
<li>多重背包问题</li>
</ul>
</li>
</ul>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学校出门一台政策，要求计算机专业的学生必须参加CCF的考试，且必须通过考核后，才能毕业.无奈之下，需要认真钻研动态规划算法，应付考试。在经过两周多的训练和查阅资料，对其有了一点理解理解。</p>
<p>在我看来，动态规划的核心在于将待求解问题分解为子问题，子问题的规模小于原问题，并且求解方法一致，但原问题的求解依赖于子问题，子问题之间往往不相互独立。典型特征就是，动态规划中所使用的递推公式。与之相比，分治法的核心在于将原问题规模缩小，分解为多个子问题，且各个子问题之间相互独立。</p>
<p>核心思想：</p>
<ul>
<li>全局最优解包含局部最优解。</li>
<li>状态转移方程</li>
</ul>
<h3 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h3><h4 id="矩阵取数问题"><a href="#矩阵取数问题" class="headerlink" title="矩阵取数问题"></a>矩阵取数问题</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>一个NN矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。</p>
<p>例如：3 3的方格。<br>1 3 3<br>2 1 3<br>2 2 1<br>能够获得的最大价值为：11。</p>
<p>输入<br>第1行：N，N为矩阵的大小。(2 &lt;= N &lt;= 500)<br>第2 - N + 1行：每行N个数，中间用空格隔开，对应格子中奖励的价值。（1 &lt;= N[i] &lt;= 10000)<br>输出<br>输出能够获得的最大价值。<br>输入示例<br>3<br>1 3 3<br>2 1 3<br>2 2 1<br>输出示例<br>11</p>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; nums(n);</div><div class="line">    vector&lt;vector&lt;long long&gt; &gt; dp(n + 1);</div><div class="line">    for(int i = 0; i &lt; n;i++)&#123;</div><div class="line">        vector&lt;int&gt; row(n);</div><div class="line">        vector&lt;long long&gt; maxRow(n + 1,0);</div><div class="line">        for(int j = 0;j &lt; n;j++)&#123;</div><div class="line">            cin &gt;&gt; row[j];</div><div class="line">        &#125;</div><div class="line">        nums[i] = row;</div><div class="line">        dp[i] = maxRow;</div><div class="line">    &#125;</div><div class="line">    vector&lt;long long&gt; maxRow(n + 1,0);</div><div class="line">    dp[n] = maxRow;</div><div class="line"></div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        for(int j = 1; j &lt;= n; j++)&#123;</div><div class="line">            dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]) + nums[i - 1][j - 1];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt; dp[n][n]&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在本例中，我们用dp[i][j]来表示从点（0，0）走到点（i,j）时，所能得到的最大值，也就是说，dp[][]数组中存储的是从原点到点（i,j）的所有有局部最优解，这就体现了我们重要思想中的 <strong>全局最优解包含局部最优解*</strong>。简单点说，最后的解就是通过前面的局部的最优解通过状态转移方程一步步的得到的。</p>
<h4 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。当所给的整数均为负数时和为0。<br>例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。</p>
<p>输入<br>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：N个整数（-10^9 &lt;= A[i] &lt;= 10^9）<br>输出<br>输出最大子段和。<br>输入示例<br>6<br>-2<br>11<br>-4<br>13<br>-5<br>-2<br>输出示例<br>20</p>
<h6 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">/*动态规划算法:</div><div class="line">b[j]=max&#123;a[i]++a[j]&#125;,1&lt;=i&lt;=j,且1&lt;=j&lt;=n,则所求的最大子段和为max b[j]，1&lt;=j&lt;=n。</div><div class="line"></div><div class="line">由b[j]的定义可易知，当b[j-1]&gt;0时b[j]=b[j-1]+a[j]，否则b[j]=a[j]。故b[j]</div><div class="line">的动态规划递归式为:</div><div class="line"></div><div class="line">b[j]=max(b[j-1]+a[j],a[j])，1&lt;=j&lt;=n。</div><div class="line">代码中，pre就相当与b[j]；result保存b[j]中的最大值</div><div class="line">T(n)=O(n)</div><div class="line">*/</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    int cur;</div><div class="line">    cin &gt;&gt; cur;</div><div class="line">    long long result = cur;</div><div class="line">    long long pre = cur;</div><div class="line">    for(int i = 1; i &lt; n;i++)&#123;</div><div class="line">       cin &gt;&gt; cur;</div><div class="line">       if(pre &gt; 0)&#123;</div><div class="line">           pre = pre + cur;</div><div class="line">       &#125;</div><div class="line">       else&#123;</div><div class="line">           pre = cur;</div><div class="line">       &#125;</div><div class="line">       if(pre &gt; result)&#123;</div><div class="line">           result = pre;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; result&lt;&lt;endl;</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">/*</div><div class="line">动态规划:数组为in[]，设dp[i] 是以in[i]结尾的子数组的最大和.</div><div class="line">对于元素in[i+1],它有两种选择：a、vec[i+1]接着前面的子数组构成最大和，b、in[i+1]自己单独构成子数组。</div><div class="line">则dp[i+1] = max&#123;dp[i]+in[i+1],  in[i+1]&#125;</div><div class="line">*/</div><div class="line">int main()&#123;</div><div class="line">    int n;cin&gt;&gt;n;</div><div class="line">    int in[n];</div><div class="line">    int dp[n];</div><div class="line">    for(int i=0;i&lt;n;i++)&#123;</div><div class="line">        cin&gt;&gt;in[i];</div><div class="line">        dp[i]=in[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(int i=1;i&lt;n;i++)&#123;</div><div class="line">        dp[i] = max(dp[i-1]+in[i],  in[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(int i=0;i&lt;n;i++)&#123;</div><div class="line">        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>对于此题呢，这里给出了两种写法，但两者思想都是一样的，都是用了动态规划的思想。在第一中写法中，我们用变量pre代表序列中以 i 结尾的连续数列的最大值，这就是当前i的最优节，一个局部最优解，通过状态转移方程不断得到全部的最优解。第二种写法是比较容易接受的，dp[i] 代表的是序列中以 i 结尾的连续数列的最大值,那么dp[i+1]=max(dp[i]+a[i+1],a[i+1])。</p>
<h4 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>最长公共子序列的问题常用于解决字符串的相似度，是一个非常实用的算法，作为码农，此算法是我们的必备基本功。</p>
<p>给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。<br>比如两个串为：<br>abcicba<br>abdkscab<br>ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。</p>
<p>输入<br>第1行：字符串A<br>第2行：字符串B<br>(A,B的长度 &lt;= 1000)<br>输出<br>输出最长的子序列，如果有多个，随意输出1个。</p>
<p>输入示例<br>abcicba<br>abdkscab<br>输出示例<br>abca</p>
<h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line">using namespace std;</div><div class="line">typedef struct &#123;</div><div class="line">    int x;</div><div class="line">    int y;</div><div class="line">    char node = &apos;\0&apos;;</div><div class="line">    int maxLength = 0;</div><div class="line">&#125; DpNode;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    string a;</div><div class="line">    string b;</div><div class="line">    std:cin &gt;&gt; a &gt;&gt;b;</div><div class="line">    vector&lt;vector&lt;DpNode&gt; &gt; dp(a.size() + 1);</div><div class="line">    for (int i = 0; i &lt;= a.size(); i++) &#123;</div><div class="line">        vector&lt;DpNode&gt; dpRow(b.size() + 1);</div><div class="line">        dp[i] = dpRow;</div><div class="line">    &#125;</div><div class="line">    for (int i = 1; i &lt;= a.size(); i++) &#123;</div><div class="line">        for (int j = 1; j &lt;= b.size(); j++) &#123;</div><div class="line">            if (a[i - 1] == b[j - 1]) &#123;</div><div class="line">                dp[i][j].maxLength = dp[i - 1][j - 1].maxLength + 1;</div><div class="line">                dp[i][j].x = i - 1;</div><div class="line">                dp[i][j].y = j - 1;</div><div class="line">                dp[i][j].node = a[i - 1];</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                if (dp[i - 1][j].maxLength &gt; dp[i][j - 1].maxLength) &#123;</div><div class="line">                    dp[i][j].maxLength = dp[i - 1][j].maxLength;</div><div class="line">                    dp[i][j].x = i - 1;</div><div class="line">                    dp[i][j].y = j;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    dp[i][j].maxLength = dp[i][j - 1].maxLength;</div><div class="line">                    dp[i][j].x = i;</div><div class="line">                    dp[i][j].y = j - 1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int x = a.size();</div><div class="line">    int y = b.size();</div><div class="line">    char c;</div><div class="line">    list&lt;char&gt; result;</div><div class="line">    int xTemp;</div><div class="line">    while (x != 0 &amp;&amp; y != 0) &#123;</div><div class="line">        c = dp[x][y].node;</div><div class="line">        if (c != &apos;\0&apos;) &#123;</div><div class="line">            result.push_front(c);</div><div class="line">        &#125;</div><div class="line">        xTemp = x;</div><div class="line">        x = dp[xTemp][y].x;</div><div class="line">        y = dp[xTemp][y].y;</div><div class="line">    &#125;</div><div class="line">    for (list&lt;char&gt;::iterator it = result.begin(); it != result.end(); it++) &#123;</div><div class="line">        cout &lt;&lt; *it;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。<br>例如将kitten一字转成sitting：<br>sitten （k-&gt;s）<br>sittin （e-&gt;i）<br>sitting （-&gt;g）<br>所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。<br>给出两个字符串a,b，求a和b的编辑距离。<br>输入<br>第1行：字符串a(a的长度 &lt;= 1000)。<br>第2行：字符串b(b的长度 &lt;= 1000)。<br>输出<br>输出a和b的编辑距离。</p>
<p>输入示例<br>kitten<br>sitting<br>输出示例<br>3</p>
<h5 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    string a;</div><div class="line">    string b;</div><div class="line">    cin &gt;&gt; a &gt;&gt; b;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; dp(a.size() + 1);</div><div class="line">    vector&lt;int&gt; dpRow(b.size() + 1);</div><div class="line">    dp[0] = dpRow;</div><div class="line">    for(int i = 0; i &lt;= b.size();i++ )&#123;</div><div class="line">        dp[0][i] = i;</div><div class="line">    &#125;</div><div class="line">    for(int i = 1; i &lt;= a.size();i++)&#123;</div><div class="line">        vector&lt;int&gt; dpRow(b.size() + 1);</div><div class="line">        dp[i] = dpRow;</div><div class="line">        dp[i][0] = i;</div><div class="line">    &#125;</div><div class="line">    int minTemp;</div><div class="line">    for(int i = 0; i &lt; a.size();i++)&#123;</div><div class="line">        for(int j = 0; j &lt; b.size();j++)&#123;</div><div class="line">            if(a[i] == b[j])&#123;</div><div class="line">                dp[i + 1][j + 1] = dp[i][j];</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                minTemp = min(dp[i][j] + 1,dp[i][j + 1] + 1);</div><div class="line">                dp[i + 1][j + 1] = min(minTemp,dp[i + 1][j] + 1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt;dp[a.size()][b.size()]&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最长单增子序列"><a href="#最长单增子序列" class="headerlink" title="最长单增子序列"></a>最长单增子序列</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的）<br>例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。<br>输入<br>第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9)<br>输出<br>输出最长递增子序列的长度。<br>输入示例<br>8<br>5<br>1<br>6<br>8<br>2<br>4<br>5<br>10<br>输出示例<br>5</p>
<h5 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;climits&gt;</div><div class="line">using namespace std;</div><div class="line">/**</div><div class="line"> * maxs[x] 中记录了目前单调子序列中长度为x的所有子序列中，最后一个元素的最小值。</div><div class="line"> * 比如当然有两个单调子序列长度为2: 1 3; 1 4。maxs[2] = 3</div><div class="line"> * 代表了最优情况，因为元素越小继续延伸的潜力越大</div><div class="line"> */</div><div class="line">void updateMaxArray(vector&lt;int&gt; &amp;maxs, int newNum)</div><div class="line">&#123;</div><div class="line">    int temp = 0;</div><div class="line">    for (int left = 0, right = maxs.size() - 1, mid = left + (right - left) / 2; left &lt;= right;) &#123;</div><div class="line">        if (maxs[mid] &lt; newNum) &#123;</div><div class="line">            temp = mid;</div><div class="line">            left = mid + 1;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            right = mid - 1;</div><div class="line">        &#125;</div><div class="line">        mid = left + (right - left) / 2;</div><div class="line">    &#125;</div><div class="line">    if (temp != maxs.size() - 1) &#123;</div><div class="line">        maxs[temp + 1] = newNum;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        maxs.insert(maxs.begin() + temp + 1, newNum);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    int cur;</div><div class="line">    vector&lt;int&gt; maxs(1, INT_MIN);</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        cin &gt;&gt; cur;</div><div class="line">        updateMaxArray(maxs, cur);</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; (maxs.size() - 1) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。<br>输入<br>第1行，2个整数，N和W中间用空格隔开。N为物品的数量，W为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= W &lt;= 10000)<br>第2 - N + 1行，每行2个整数，Wi和Pi，分别是物品的体积和物品的价值。(1 &lt;= Wi, Pi &lt;= 10000)<br>输出<br>输出可以容纳的最大价值。<br>输入示例<br>3 6<br>2 5<br>3 8<br>4 9<br>输出示例<br>14<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int dp[101][10001];</div><div class="line">/**</div><div class="line"> * dp[i][j] -&gt; 在前个物品中任意选取，容量不超过j的物品最大价值</div><div class="line"> * dp[i][j] = dp[i-1][j] 第i个物品的重量大于j</div><div class="line"> * dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]] + p[i]) 否则</div><div class="line"> */</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n,m;</div><div class="line">    cin &gt;&gt; n &gt;&gt; m;</div><div class="line">    vector&lt;int&gt; w(n + 1);</div><div class="line">    vector&lt;int&gt; p(n + 1);</div><div class="line">    for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">        cin &gt;&gt; w[i] &gt;&gt; p[i];</div><div class="line">    &#125;</div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        for(int j = 1;j &lt;= m;j++)&#123;</div><div class="line">            if(w[i] &lt;= j)&#123;</div><div class="line">                dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - w[i]] + p[i]);</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                dp[i][j] = dp[i - 1][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="正整数分组"><a href="#正整数分组" class="headerlink" title="正整数分组"></a>正整数分组</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>将一堆正整数分为2组，要求2组的和相差最小。<br>例如：1 2 3 4 5，将1 2 4分为1组，3 5分为1组，两组和相差1，是所有方案中相差最少的。<br>输入<br>第1行：一个数N，N为正整数的数量。<br>第2 - N+1行，N个正整数。<br>(N &lt;= 100, 所有正整数的和 &lt;= 10000)<br>输出<br>输出这个最小差<br>输入示例<br>5<br>1<br>2<br>3<br>4<br>5<br>输出示例<br>1<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">/**</div><div class="line"> * f[i][j] -&gt; 在前i个数中选取一些数，总和不超过j的最大值</div><div class="line"> * f[i][j] = f[i-1][j]  第i个数大于j</div><div class="line"> * f[i][j] = max(f[i - 1][j],f[i - 1][j - nums[i - 1]] + nums[i - 1]) 否则</div><div class="line"> */</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    vector&lt;int&gt; nums(n);</div><div class="line">    int total = 0;</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        cin &gt;&gt; nums[i];</div><div class="line">        total = total+ nums[i];</div><div class="line">    &#125;</div><div class="line">    int half = total / 2;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; f(n + 1);</div><div class="line">    for (int i = 0; i &lt;= n; i++) &#123;</div><div class="line">        vector&lt;int&gt; temp(half + 1);</div><div class="line">        f[i] = temp;</div><div class="line">    &#125;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt;::iterator fIter = f.begin();</div><div class="line">    fill((*fIter).begin(),(*fIter).end(),0);</div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        for(int j = 1; j &lt;= half;j++)&#123;</div><div class="line">            if(nums[i - 1] &gt; j)&#123;</div><div class="line">                f[i][j] = f[i - 1][j];</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                f[i][j] = max(f[i - 1][j],f[i - 1][j - nums[i - 1]] + nums[i - 1]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; (total - 2*f[n][half])  &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="进阶题目"><a href="#进阶题目" class="headerlink" title="进阶题目"></a>进阶题目</h3><h4 id="最大子矩阵和"><a href="#最大子矩阵和" class="headerlink" title="最大子矩阵和"></a>最大子矩阵和</h4><p>问题描述<br>一个MN的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的值。<br>例如：33的矩阵：<br>-1 3 -1<br>2 -1 3<br>-3 1 2<br>和最大的子矩阵是：<br>3 -1<br>-1 3<br>1 2<br>输入<br>第1行：M和N，中间用空格隔开（2 &lt;= M,N &lt;= 500)。<br>第2 - N + 1行：矩阵中的元素，每行M个数，中间用空格隔开。(-10^9 &lt;= M[i] &lt;= 10^9)<br>输出<br>输出和的最大值。如果所有数都是负数，就输出0。<br>输入示例<br>3 3<br>-1 3 -1<br>2 -1 3<br>-3 1 2<br>输出示例<br>7<br>代码说明<br>这道题目与基础题目中的最大子段和有些像，但本题是二维空间。但可以通过一些手段将其转化为一维空间。<br>设想，整个矩阵有3行，最大子矩阵可能的行数1/2/3; 矩阵数组为a[i][j]:<br>矩阵行数为1：分别求第一行、第二行、第三行的最大子段和max1,max2,max3,那么max(max1,max2,max3)即为最大子矩阵和<br>矩阵行数为2：最大子矩阵出现在第1-2行或第2-3行，只有这两种情况。如果有一个一维数组total:<br>total[k] = a[0][k] + a[1][k] total最大字段和max1<br>total[k] = a[1][k] + a[2][k] total最大字段和max2<br>那么max = max(max1,max2)即为最大子矩阵和<br>矩阵行数为3：最大子矩阵出现在第1-3行，只有一种情况。如果有一个一维数组total:<br>total[k] = a[0][k] + a[1][k] + a[2][k] total最大字段和max<br>那么max即为最大子矩阵和<br>通过这个例子是不是可以感受到一些启发？将 第i行到第j行压缩为一行(求和),即可以转化为求解最大子段和,此时可获得行数为(j-i+1)时的最大子矩阵和<br>假设n*m的矩阵的最大子矩阵的行数为i(1&lt;=i&lt;=n) 如果有一个一维数组total:<br>total[k] = a[0][k] + … +a[i-1][k] total最大字段和max1<br>…<br>total[k] = a[n-i][k] + … + a[n - 1][k] total最大字段和max..<br>那么max = max(max1,…)即为最大子矩阵和<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;climits&gt;</div><div class="line">using namespace std;</div><div class="line">/**</div><div class="line">* 求最大字段和</div><div class="line">*/</div><div class="line">int maxSubSequence(vector&lt;int&gt;&amp; arr) &#123;</div><div class="line">    if (arr.size() &gt; 0) &#123;</div><div class="line">        int maxSub = arr[0];</div><div class="line">        int temp = arr[0];</div><div class="line">        for (int i = 1; i &lt; arr.size(); i++) &#123;</div><div class="line">            if (temp &gt; 0) &#123;</div><div class="line">                temp = temp + arr[i];</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                temp = arr[i];</div><div class="line">            &#125;</div><div class="line">            maxSub = max(maxSub, temp);</div><div class="line">        &#125;</div><div class="line">        return maxSub;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int m, n;</div><div class="line">    cin &gt;&gt; m &gt;&gt; n;</div><div class="line">    //初始化</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; nums(n);</div><div class="line">    // total[i][k] = nums[0][k] + ... + nums[i][k];</div><div class="line">    // 所以nums[i..j][k] = total[j][k]-total[i - 1][k]</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; total(n);</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        vector&lt;int&gt; row(m);</div><div class="line">        vector&lt;int&gt; totalRow(m);</div><div class="line">        if (i == 0) &#123;</div><div class="line">            for (int j = 0; j &lt; m; j++) &#123;</div><div class="line">                cin &gt;&gt; row[j];</div><div class="line">                totalRow[j] = row[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            for (int j = 0; j &lt; m; j++) &#123;</div><div class="line">                cin &gt;&gt; row[j];</div><div class="line">                totalRow[j] = total[i - 1][j] + row[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nums[i] = row;</div><div class="line">        total[i] = totalRow;</div><div class="line">    &#125;</div><div class="line">    int maxSub = INT_MIN;</div><div class="line">    // 最大子矩阵行数为 i</div><div class="line">    vector&lt;int&gt; result(m);</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        for (int j = i; j &lt; n; j++) &#123;</div><div class="line">            for (int k = 0; k &lt; m; k++) &#123;</div><div class="line">                if (i == 0) &#123;</div><div class="line">                    result[k] = total[j][k];</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    result[k] = total[j][k] - total[i - 1][k];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            int maxTemp = maxSubSequence(result);</div><div class="line">            if (maxTemp &gt; maxSub) &#123;</div><div class="line">                maxSub = maxTemp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; maxSub &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考<a href="http://blog.csdn.net/beiyeqingteng/article/details/7056687" target="_blank" rel="external">http://blog.csdn.net/beiyeqingteng/article/details/7056687</a></p>
</blockquote>
<h4 id="循环数组最大字段和"><a href="#循环数组最大字段和" class="headerlink" title="循环数组最大字段和"></a>循环数组最大字段和</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>N个整数组成的循环序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续的子段和的最大值（循环序列是指n个数围成一个圈，因此需要考虑a[n-1],a[n],a[1],a[2]这样的序列）。当所给的整数均为负数时和为0。<br>例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。<br>输入<br>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)<br>第2 - N+1行：N个整数 (-10^9 &lt;= S[i] &lt;= 10^9)<br>输出<br>输出循环数组的最大子段和。<br>输入示例<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>6<br>-2<br>11<br>-4<br>13<br>-5<br>-2<br>输出示例<br>1<br>20<br>代码说明<br>如果最大字段和不是跨越数组头尾的情况，即为普通的最大字段和求解问题。<br>如果最大子段和跨越数组头尾，即 arr[j…n-1] + arr[0…i];易得子段arr[i+1…j-1] 为最小子段和，这种情况也就可以转化为 total[0…n-1] - minSubSequence<br>二者取max即为循环数组最大字段和<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;climits&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt;n;</div><div class="line">    ll cur,preMax,preMin;</div><div class="line">    cin &gt;&gt; preMax;</div><div class="line">    ll total = preMax;</div><div class="line">    ll maxSub = preMax;</div><div class="line">    ll minSub = preMax;</div><div class="line">    preMin = preMax;</div><div class="line">    for(int i = 1;i &lt; n;i++)&#123;</div><div class="line">        cin &gt;&gt; cur;</div><div class="line">        total = total + cur;</div><div class="line">        if(preMax &gt; 0)&#123;</div><div class="line">            preMax = preMax + cur;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            preMax = cur;</div><div class="line">        &#125;</div><div class="line">        if(preMin &lt; 0)&#123;</div><div class="line">            preMin = preMin + cur;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            preMin = cur;</div><div class="line">        &#125;</div><div class="line">        maxSub = max(maxSub,preMax);</div><div class="line">        minSub = min(minSub,preMin);</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; max(maxSub,total - minSub) &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>有N种物品，每种物品的数量为C1，C2……Cn。从中任选若干件放在容量为W的背包里，每种物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。<br>输入<br>第1行，2个整数，N和W中间用空格隔开。N为物品的种类，W为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= W &lt;= 50000)<br>第2 - N + 1行，每行3个整数，Wi，Pi和Ci分别是物品体积、价值和数量。(1 &lt;= Wi, Pi &lt;= 10000， 1 &lt;= Ci &lt;= 200)<br>输出<br>输出可以容纳的最大价值。<br>输入示例<br>3 6<br>2 2 5<br>3 3 8<br>1 4 1<br>输出示例<br>9</p>
<h5 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h5><p>将多重背包分解为0-1背包<br>利用二进制的思想，任何一个数都可以由2的幂次表示：N = 1 + 2 + 4 + … + 2^i + (left);<br>即每个物品都可以被分解。假设物品的数量为14,则从14个物品中任取N个物品都可以转化为由以下物品组合(以下物品在每次组合中只能取一次)<br>1^0 重量是Wi，体积是Vi<br>2^2 重量是2 Wi , 体积是2 Vi<br>2^3 重量是4 Wi , 体积是4 Vi<br>14 - (1+2+4) 重量是7 Wi , 体积是7 Vi<br>分解完成后，再利用0-1背包思路求解</p>
<h5 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">typedef struct &#123;</div><div class="line">    int w;</div><div class="line">    int p;</div><div class="line">&#125; Thing;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n,w;</div><div class="line">    cin &gt;&gt; n &gt;&gt; w;</div><div class="line">    </div><div class="line">    //分解</div><div class="line">    vector&lt;Thing&gt; things;</div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        Thing thing;</div><div class="line">        cin &gt;&gt; thing.w &gt;&gt; thing.p;</div><div class="line">        int num;</div><div class="line">        cin &gt;&gt; num;</div><div class="line">        for(int k = 1; k &lt;= num;k &lt;&lt;= 1)&#123;</div><div class="line">            Thing temp;</div><div class="line">            temp.w = k * thing.w;</div><div class="line">            temp.p = k * thing.p;</div><div class="line">            num -= k;</div><div class="line">            things.push_back(temp);</div><div class="line">        &#125;</div><div class="line">        if(num &gt; 0)&#123;</div><div class="line">            thing.w = num * thing.w;</div><div class="line">            thing.p = num * thing.p;</div><div class="line">            things.push_back(thing);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //0-1背包</div><div class="line">    vector&lt;vector&lt;long long&gt; &gt; dp(things.size() + 1, vector&lt;long long&gt;(w + 1,0));</div><div class="line">    for(int i = 0; i &lt; things.size();i++)&#123;</div><div class="line">        for(int j = 0; j &lt;= w;j++)&#123;</div><div class="line">            if(j &lt; things[i].w)&#123;</div><div class="line">                dp[i + 1][j] = dp[i][j];</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                dp[i + 1][j] = max(dp[i][j],dp[i][j - things[i].w] + things[i].p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; dp[things.size()][w]&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划——由实践总结经验&lt;/p&gt;
&lt;h3 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基础题目&lt;ul&gt;
&lt;li&gt;矩阵取数问题&lt;/li&gt;
&lt;li&gt;最大子段和&lt;
    
    </summary>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>大学|记一次比赛</title>
    <link href="http://yoursite.com/2017/12/09/%E5%A4%A7%E5%AD%A6-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%AF%94%E8%B5%9B/"/>
    <id>http://yoursite.com/2017/12/09/大学-记一次比赛/</id>
    <published>2017-12-09T00:10:32.000Z</published>
    <updated>2017-12-08T16:47:59.404Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我的第一次比赛"><a href="#我的第一次比赛" class="headerlink" title="我的第一次比赛"></a>我的第一次比赛</h3><p>说起这次比赛，也挺好玩，自己先前根本不知道是怎么回事，江哥先找到我说想一起组队参加比赛，我也答应了。这是自己在大学第一个参加的比赛，是学校联想俱乐部举办的，比赛内容就是参赛队员想一个产品，有创意的产品。</p>
<p>然后,我们就开始讨论要搞什么，最初是说搞教育那一块的，但觉得太low了，就换成了旅游出行的个性化推荐，创新点主要是能实时通过天气、景点人流、交通情况等因素，实时为旅客修改旅游计划，为用户提供最佳的旅游路线。</p>
<p>最开始是初赛，需要做ppt和上台答辩，说白了，这个比赛就是看谁弄得ppt好看和谁的忽悠能力强就能得奖。ppt是黄智威弄的，还需要一个产品的原型，然后自己是弄原型，其实也就是弄个首页，都不是事。还是黄智威拼，弄ppt到半夜。答辩时黄智威和黄卫江上去讲的，毫无悬念，我们进入了决赛。</p>
<p>初赛后不久是决赛，ppt是用的初赛的，但是原型就不能用初赛的了，需要搞完善一点的，不过这次不是我搞的了，是黄卫江搞的，自己有点惭愧啊，就是个打酱油的。决赛是黄智威自己上去答辩，黄卫江上课去了，我坐在台下给黄智威录像。很幸运，决赛我们的了二等奖。其中，还有一个有趣的环节呢，那就是刷票啊，不知道黄智威怎么搞的，花钱加别人刷票，这小子可以的。</p>
<p>本以为我们能够进决赛的，我们还为此决定搞个半产品出来呢。我们三个专门去蓝杰向胡哥请教了一番，还想好了下一步的分工了。不曾想，回宿舍后，通知说没有进省赛。</p>
<p>这就是自己第一次的比赛经历啦，虽然不精彩，但是自己也认识到一个团队需要不同的人才能做成一件事。就像黄智威，能说，会忽悠；黄卫江，能为了完成任务，熬上几夜；我自己呢，可能在技术这一块擅长一点，所以前期也没做什么工作，是要在做产品的时候出力的。</p>
<p><img src="/images/mmexport1512485485927.jpg" alt="enter description here" title="mmexport1512485485927"></p>
<p><img src="/images/mmexport1512658490870.jpg" alt="enter description here" title="mmexport1512658490870"></p>
<p><img src="/images/mmexport1512658490870.jpg" alt="enter description here" title="mmexport1512658490870"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;我的第一次比赛&quot;&gt;&lt;a href=&quot;#我的第一次比赛&quot; class=&quot;headerlink&quot; title=&quot;我的第一次比赛&quot;&gt;&lt;/a&gt;我的第一次比赛&lt;/h3&gt;&lt;p&gt;说起这次比赛，也挺好玩，自己先前根本不知道是怎么回事，江哥先找到我说想一起组队参加比赛，我也答应了。
    
    </summary>
    
    
      <category term="大学" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>PHP|文件上传</title>
    <link href="http://yoursite.com/2017/12/03/PHP-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2017/12/03/PHP-文件上传/</id>
    <published>2017-12-02T23:30:13.000Z</published>
    <updated>2017-12-02T16:28:11.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这几天，在忙弦歌知湖改版的事情，虽然不是很难，但是bug还是层出不穷，有很多细节的东西没有考虑到，最坑的是投稿的功能了，需要上传文件，同时，自己也是第一次处理文件上传，以前都是弄一些表单数据，没什么细节需要处理，但文件就不同了，要考虑大小、类型、存的位置…</p>
<h3 id="一些干货"><a href="#一些干货" class="headerlink" title="一些干货"></a>一些干货</h3><h4 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h4><p>来一个前端测试的表单：upload.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;form action=&quot;upload.php&quot; method=&quot;post&quot; multipart=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt;</div><div class="line">        &lt;input type=&quot;file&quot; name=&quot;img&quot; multiple&gt;</div><div class="line">        &lt;input type=&quot;submit&quot;&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>再来一个处理文件的php文件，upload.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$img = $_FILES[&apos;img&apos;];</div><div class="line">var_dump($img);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>先看看我们得到的是一个什么东西吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">array (size=5)</div><div class="line">  &apos;name&apos; =&gt; string &apos;父亲1.png&apos; (length=11)</div><div class="line">  &apos;type&apos; =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">  &apos;tmp_name&apos; =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php444D.tmp&apos; (length=39)</div><div class="line">  &apos;error&apos; =&gt; int 0</div><div class="line">  &apos;size&apos; =&gt; int 186938</div></pre></td></tr></table></figure></p>
<p>  我们得到了一个数组，包含了许多信息，比如文件名、文件类型、文件大小，同时还有临时存储的位置、是否有错误，如果 ‘error’ 不等于0，就说明发生错误了，我们就不能接收了。那我们如何将这个文件保存到我们想要保存的地方呢？那就用 ove_uploaded_file() 函数吧。</p>
<p>接收的PHP代码是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$img = $_FILES[&apos;img&apos;];</div><div class="line">var_dump($img);</div><div class="line"></div><div class="line">$path = &apos;upload&apos;;  </div><div class="line">$realName = time().&apos;jpg&apos;;</div><div class="line">$realPath = $path.&apos;/&apos;.$relaName;</div><div class="line">if(move_uploaded_file($img[&apos;temp_name&apos;]) ,$realPath )&#123;</div><div class="line">	echo &apos;上传成功&apos;;</div><div class="line">&#125;else&#123;</div><div class="line">	echo &apos;上传失败&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们的当前文件夹内有一个 upload的文件夹，这样写是没问题的，但是如果没有upload的文件夹呢？如果有个人删了这个文件夹呢？那岂不是完蛋了，所以我们首先要判断文件夹是否存在，如果不存在要先建立文件夹。还有一个问题，如果文件夹内已经有了相同文件名的文件呢？尽管我们用了time（）函数来为文件取名字，但是谁还没有背的时候呢？所以还是要判断一下文件是否存在，在执行 move_uploaded_file() 函数。</p>
<p>先说说创建文件夹吧，mkdir（）这个函数似乎只能建立一级文件夹，所以我们要建立多级文件夹的时候，就需要递归运行了，看看下面的递归建立文件夹的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//创建多级文件夹 $dirname = &apos;upload/image/exter&apos;;</div><div class="line">function mkdir_r($dirName, $rights=0777)&#123;</div><div class="line"></div><div class="line">    $dirs = explode(&apos;/&apos;, $dirName);</div><div class="line"></div><div class="line">    $dir=&apos;&apos;;</div><div class="line"></div><div class="line">    foreach ($dirs as $part) &#123;</div><div class="line"></div><div class="line">        $dir.=$part.&apos;/&apos;;</div><div class="line"></div><div class="line">        if (!is_dir($dir) &amp;&amp; strlen($dir)&gt;0)</div><div class="line"></div><div class="line">            mkdir($dir, $rights);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数的代码还是简单易懂的，就是传文件路径，逐级判断是否有此文件夹，没有就建立文件夹。</p>
<p>然后是判断文件是否存在，用file_exist()函数。</p>
<p>上面是最基本的考虑，如果还需要限制文件大小和文件的类型，可以根据得到的数组，进行判断。</p>
<p>这个是上传单个文件的，如果是多个文件呢？就像这样的表单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;form action=&quot;upload.php&quot; method=&quot;post&quot; multipart=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt;</div><div class="line">        &lt;input type=&quot;file&quot; name=&quot;img[]&quot; multiple&gt;</div><div class="line">        &lt;input type=&quot;submit&quot;&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>相信细心的你已经看出不同来了，现在的name变成img[] 了，也就是说能上传多张照片了。先不急，看看我们得到的是什么吧:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$img = $_FILES[&apos;img&apos;];</div><div class="line">var_dump($img);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>我们得到的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">array (size=5)</div><div class="line">  &apos;name&apos; =&gt; </div><div class="line">    array (size=3)</div><div class="line">      0 =&gt; string &apos;父亲1.png&apos; (length=11)</div><div class="line">      1 =&gt; string &apos;父亲2.png&apos; (length=11)</div><div class="line">      2 =&gt; string &apos;父亲3.png&apos; (length=11)</div><div class="line">  &apos;type&apos; =&gt; </div><div class="line">    array (size=3)</div><div class="line">      0 =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">      1 =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">      2 =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">  &apos;tmp_name&apos; =&gt; </div><div class="line">    array (size=3)</div><div class="line">      0 =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php457E.tmp&apos; (length=39)</div><div class="line">      1 =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php457F.tmp&apos; (length=39)</div><div class="line">      2 =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php4580.tmp&apos; (length=39)</div><div class="line">  &apos;error&apos; =&gt; </div><div class="line">    array (size=3)</div><div class="line">      0 =&gt; int 0</div><div class="line">      1 =&gt; int 0</div><div class="line">      2 =&gt; int 0</div><div class="line">  &apos;size&apos; =&gt; </div><div class="line">    array (size=3)</div><div class="line">      0 =&gt; int 186938</div><div class="line">      1 =&gt; int 208693</div><div class="line">      2 =&gt; int 197557</div></pre></td></tr></table></figure></p>
<p>是这样的一个数组了，不知为何，总觉得这个数组不是我们想要的形式，我们想得到的是这样的一个数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">array (size=3)</div><div class="line">  0 =&gt; </div><div class="line">    array (size=5)</div><div class="line">      &apos;name&apos; =&gt; string &apos;父亲1.png&apos; (length=11)</div><div class="line">      &apos;type&apos; =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">      &apos;tmp_name&apos; =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php1933.tmp&apos; (length=39)</div><div class="line">      &apos;error&apos; =&gt; int 0</div><div class="line">      &apos;size&apos; =&gt; int 186938</div><div class="line">  1 =&gt; </div><div class="line">    array (size=5)</div><div class="line">      &apos;name&apos; =&gt; string &apos;父亲2.png&apos; (length=11)</div><div class="line">      &apos;type&apos; =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">      &apos;tmp_name&apos; =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php1944.tmp&apos; (length=39)</div><div class="line">      &apos;error&apos; =&gt; int 0</div><div class="line">      &apos;size&apos; =&gt; int 208693</div><div class="line">  2 =&gt; </div><div class="line">    array (size=5)</div><div class="line">      &apos;name&apos; =&gt; string &apos;父亲3.png&apos; (length=11)</div><div class="line">      &apos;type&apos; =&gt; string &apos;image/png&apos; (length=9)</div><div class="line">      &apos;tmp_name&apos; =&gt; string &apos;D:\Wampserver3.0.6\wamp\tmp\php1945.tmp&apos; (length=39)</div><div class="line">      &apos;error&apos; =&gt; int 0</div><div class="line">      &apos;size&apos; =&gt; int 197557</div></pre></td></tr></table></figure></p>
<p>如果是这样的形式的数组，那就清晰多了，那我们要怎么把之前形式的数组变成这样的呢？那就需要下面的函数了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/处理多文件上传</div><div class="line">function reArrayFiles($file)</div><div class="line">&#123;</div><div class="line">    $file_ary = array();</div><div class="line">    $file_count = count($file[&apos;name&apos;]);</div><div class="line">    $file_key = array_keys($file);</div><div class="line">    </div><div class="line">    for($i=0;$i&lt;$file_count;$i++)</div><div class="line">    &#123;</div><div class="line">        foreach($file_key as $val)</div><div class="line">        &#123;</div><div class="line">            $file_ary[$i][$val] = $file[$val][$i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return $file_ary;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这个函数的整理，就能得到我们想要的形式的数组了，然后就变成了我们想要形式的数组啦。附上一个完整的upload.php代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;?php</div><div class="line"></div><div class="line">$img = $_FILES[&apos;img&apos;];</div><div class="line"></div><div class="line">if(!empty($img))</div><div class="line">&#123;</div><div class="line">    $img_desc = reArrayFiles($img);</div><div class="line">    </div><div class="line">    foreach($img_desc as $val)</div><div class="line">    &#123;</div><div class="line">        $newname = date(&apos;YmdHis&apos;,time()).mt_rand().&apos;.jpg&apos;;</div><div class="line">		$path = &apos;upload/image/exter&apos;;</div><div class="line">		if(!is_dir($path))&#123;</div><div class="line">			mkdir_r($path);</div><div class="line">		&#125;</div><div class="line">        move_uploaded_file($val[&apos;tmp_name&apos;],$path.&apos;/&apos;.$newname);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//创建多级文件夹 $dirname = &apos;upload/image/exter&apos;;</div><div class="line">function mkdir_r($dirName, $rights=0777)&#123;</div><div class="line"></div><div class="line">    $dirs = explode(&apos;/&apos;, $dirName);</div><div class="line"></div><div class="line">    $dir=&apos;&apos;;</div><div class="line"></div><div class="line">    foreach ($dirs as $part) &#123;</div><div class="line"></div><div class="line">        $dir.=$part.&apos;/&apos;;</div><div class="line"></div><div class="line">        if (!is_dir($dir) &amp;&amp; strlen($dir)&gt;0)</div><div class="line"></div><div class="line">            mkdir($dir, $rights);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//处理多文件上传</div><div class="line">function reArrayFiles($file)</div><div class="line">&#123;</div><div class="line">    $file_ary = array();</div><div class="line">    $file_count = count($file[&apos;name&apos;]);</div><div class="line">    $file_key = array_keys($file);</div><div class="line">    </div><div class="line">    for($i=0;$i&lt;$file_count;$i++)</div><div class="line">    &#123;</div><div class="line">        foreach($file_key as $val)</div><div class="line">        &#123;</div><div class="line">            $file_ary[$i][$val] = $file[$val][$i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return $file_ary;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h3><p>文件上传是很重要的，但需要处理的细节也有很多，所以需要小心处理、慎重处理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这几天，在忙弦歌知湖改版的事情，虽然不是很难，但是bug还是层出不穷，有很多细节的东西没有考虑到，最坑的是投稿的功能了，需要上传文件，同时，
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>数据结构|队列</title>
    <link href="http://yoursite.com/2017/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2017/11/12/数据结构-队列/</id>
    <published>2017-11-11T23:36:59.000Z</published>
    <updated>2017-12-08T16:46:17.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列简介"><a href="#队列简介" class="headerlink" title="队列简介"></a>队列简介</h3><h4 id="队列的特点"><a href="#队列的特点" class="headerlink" title="队列的特点"></a>队列的特点</h4><p>队列 (Queue) 与栈一样，是一种线性存储结构，它具有如下特点： </p>
<ol>
<li>队列中的数据元素遵循 “先进先出”（First In First Out）的原则</li>
<li>在队尾添加元素，在队头删除元素</li>
</ol>
<p>简单点说，队列就像排队打饭一样，先来的先打饭，后来的在队尾后面排队，等前面的人打好，才轮到自己。</p>
<h4 id="队列的相关概念"><a href="#队列的相关概念" class="headerlink" title="队列的相关概念"></a>队列的相关概念</h4><ol>
<li>队头与队尾：允许元素插入的一端称为队尾，允许元素删除的一端称为队头</li>
<li>入队：队列的插入操作</li>
<li>出队：队列的删除操作</li>
</ol>
<p>例如，我们有一个存储整型元素的队列，我们依次入队：{ 1,2,3 }</p>
<p><img src="/images/610439-20160130151830318-592472607.png" alt="enter description here" title="610439-20160130151830318-592472607"></p>
<p>添加元素时，元素只能从队尾一端进入队列，也就是说2只能跟在1后面，3只能跟在2后面。</p>
<p>出队的顺序是这样的：</p>
<p><img src="/images/610439-20160130151820974-712348880.png" alt="enter description here" title="610439-20160130151820974-712348880"></p>
<p>元素只能从队首出队列，出队列的顺序为：1、2、3，与入队列时的顺序是一样的，这就是我们说的 “先进新出” 啦。</p>
<h4 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h4><p>队列通常提供的操作：</p>
<ol>
<li>入队：通常命名为push( );</li>
<li>出队：通常命名为pop( );</li>
<li>求队列中元素的个数</li>
<li>判断队列是否为空</li>
<li>获取队首元素</li>
</ol>
<h4 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h4><p>队列跟栈一样，都是一种特殊的线性结构，因此可以使用数组、链表作为底层的数据结构。</p>
<h3 id="基于数组的循环队列实现"><a href="#基于数组的循环队列实现" class="headerlink" title="基于数组的循环队列实现"></a>基于数组的循环队列实现</h3><p>以数组作为底层数据结构时，一般讲的队列为<strong>循环队列</strong>。这是因为队列在顺序存储上的不足：每次从数组头部删除元素（出队）后，需要将头部以后的所有元素往前移动一个位置，这是一个时间复杂度为O（n）的操作，代价挺大的。</p>
<p><img src="/images/610439-20160130152004193-1945216114.png" alt="enter description here" title="610439-20160130152004193-1945216114"></p>
<p>可能有人说，把队首标志往后移不就不用移动元素了吗？的确，但那样会造成数组空间的 “流失”。我们希望队列的插入与删除操作O(1)的时间复杂度，同时不会造成数组空间的浪费，我们应该使用循环队列。所谓的循环队列，可以把数组看成一个首尾相连的圆环，删除元素是将队首标志往后移动，添加元素是若数组尾部已经没有空间，则考虑数组首部的空间是否空闲，如果是，则在数组头部进行插入。</p>
<p><img src="/images/610439-20160130152048146-364086587.png" alt="enter description here" title="610439-20160130152048146-364086587"></p>
<p>那么问题来啦,我们怎么区别空队列和队列已满这两种状态呢？</p>
<ol>
<li>栈空：队首标志 = 队尾标志是，表示栈空，即红绿两个标志在图中重叠是为栈空。</li>
<li>栈满：队尾+1 = 队首时，表示栈空。图三最下面的队列极为一个满队列。尽管还有一个空位，但我们不存储元素。</li>
</ol>
<h4 id="循环队列的抽象数据类型"><a href="#循环队列的抽象数据类型" class="headerlink" title="循环队列的抽象数据类型"></a>循环队列的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">class LoopQueue</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    LoopQueue(int c = 10);</div><div class="line">    ~LoopQueue();</div><div class="line">public:</div><div class="line">    bool isEmpty();        //队列的判空</div><div class="line">    int size();            //队列的大小</div><div class="line">    bool push(T t);        //入队列</div><div class="line">    bool pop();            //出队列</div><div class="line">    T front();            //队首元素</div><div class="line"> </div><div class="line">private:</div><div class="line">    int capacity;</div><div class="line">    int begin;</div><div class="line">    int end;</div><div class="line">    T*  queue;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>begin：队首标志</li>
<li>end：队尾标志</li>
<li>c\apacity：数组容量</li>
<li>queue：数组</li>
</ol>
<h4 id="队列的具体实现"><a href="#队列的具体实现" class="headerlink" title="队列的具体实现"></a>队列的具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">LoopQueue&lt;T&gt;::LoopQueue(int c = 10)</div><div class="line">: capacity(c), begin(0), end(0), queue(nullptr)</div><div class="line">&#123;</div><div class="line">    queue = new T[capacity];</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template&lt;typename T&gt;</div><div class="line">LoopQueue&lt;T&gt;::~LoopQueue()</div><div class="line">&#123;</div><div class="line">    delete[]queue;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">bool LoopQueue&lt;T&gt;::isEmpty()</div><div class="line">&#123;</div><div class="line">    if (begin == end)</div><div class="line">        return true;</div><div class="line">    return false;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template&lt;typename T&gt;</div><div class="line">int LoopQueue&lt;T&gt;::size()</div><div class="line">&#123;</div><div class="line">    return (end-begin+capacity)%capacity; //计算队列长度</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template&lt;typename T&gt;</div><div class="line">bool LoopQueue&lt;T&gt;::push(T t)</div><div class="line">&#123;</div><div class="line">    if (end + 1 % capacity == begin) //判断队列是否已满</div><div class="line">    &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    queue[end] = t;</div><div class="line">    end = (end + 1) % capacity;</div><div class="line">    return true;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">bool LoopQueue&lt;T&gt;::pop()</div><div class="line">&#123;</div><div class="line">    if (end == begin) //判断队列是否为空</div><div class="line">    &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    begin = (begin + 1) % capacity;</div><div class="line">    return true;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">T LoopQueue&lt;T&gt;::front()</div><div class="line">&#123;</div><div class="line">    if (end == begin)</div><div class="line">    &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return queue[begin];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="基于链表的队列实现"><a href="#基于链表的队列实现" class="headerlink" title="基于链表的队列实现"></a>基于链表的队列实现</h3><p>链队列是基于链表实现的队列，它不存在数组 O(n) 的元素移动问题或空间浪费问题。我们所要确定的就是链表那头做队首，那头做队尾。考虑到链表的特点，以链表头部作为队首，尾部作为队尾是最适合的。由于插入是在尾部，所以存储一个指向队尾的指针，可以节省遍历找队尾的时间，方便从链表尾部插入数据；使用带头节点的链表，方便从链表头删除元素。</p>
<p><img src="/images/610439-20160130152133068-1288144578.png" alt="enter description here" title="610439-20160130152133068-1288144578"></p>
<h4 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">struct Node</div><div class="line">&#123;</div><div class="line">    Node(T t) :value(t), next(nullptr)&#123;&#125;</div><div class="line">    Node() = default;</div><div class="line"> </div><div class="line">    T value;</div><div class="line">    Node&lt;T&gt; * next;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>vaule : 链表节点的值</li>
<li>next : 指针，指向下一个节点</li>
</ol>
<h4 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">class LinkQueue</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    LinkQueue();</div><div class="line">    ~LinkQueue();</div><div class="line"> </div><div class="line">    bool isEmpty();</div><div class="line">    int size();</div><div class="line">    bool pop();</div><div class="line">    void push(T t);</div><div class="line">    T front();</div><div class="line"> </div><div class="line">private:</div><div class="line">    Node&lt;T&gt;* phead;</div><div class="line">    Node&lt;T&gt;* pend;</div><div class="line">    int count;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="队列的具体实现-1"><a href="#队列的具体实现-1" class="headerlink" title="队列的具体实现"></a>队列的具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">LinkQueue&lt;T&gt;::LinkQueue()</div><div class="line">    :phead(nullptr),pend(nullptr),count(0)</div><div class="line">&#123;</div><div class="line">    phead = new Node&lt;T&gt;();</div><div class="line">    pend = phead;</div><div class="line">    count = 0;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">LinkQueue&lt;T&gt;::~LinkQueue()</div><div class="line">&#123;</div><div class="line">    while (phead-&gt;next != nullptr)</div><div class="line">    &#123;</div><div class="line">        Node&lt;T&gt; * pnode = phead;</div><div class="line">        phead = phead-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">bool LinkQueue&lt;T&gt;:: isEmpty()</div><div class="line">&#123;</div><div class="line">    return count==0;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">int LinkQueue&lt;T&gt;::size()</div><div class="line">&#123;</div><div class="line">    return count;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">//在队尾插入</div><div class="line">template &lt;typename T&gt;</div><div class="line">void LinkQueue&lt;T&gt;::push(T t)</div><div class="line">&#123;</div><div class="line">    Node&lt;T&gt;* pnode = new Node&lt;T&gt;(t);</div><div class="line">    pend-&gt;next = pnode;</div><div class="line">    pend = pnode;</div><div class="line">    count++;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">//在队首弹出</div><div class="line">template &lt;typename T&gt;</div><div class="line">bool LinkQueue&lt;T&gt;::pop()</div><div class="line">&#123;</div><div class="line">    if (count == 0)</div><div class="line">        return false;</div><div class="line">    Node&lt;T&gt;* pnode = phead-&gt;next;</div><div class="line">    phead-&gt;next = phead-&gt;next-&gt;next;</div><div class="line">    delete pnode;</div><div class="line">    count--;</div><div class="line">    return true;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">//获取队首元素</div><div class="line">template&lt;typename T&gt;</div><div class="line">T LinkQueue&lt;T&gt;::front()</div><div class="line">&#123;</div><div class="line">    return phead-&gt;next-&gt;value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;队列简介&quot;&gt;&lt;a href=&quot;#队列简介&quot; class=&quot;headerlink&quot; title=&quot;队列简介&quot;&gt;&lt;/a&gt;队列简介&lt;/h3&gt;&lt;h4 id=&quot;队列的特点&quot;&gt;&lt;a href=&quot;#队列的特点&quot; class=&quot;headerlink&quot; title=&quot;队列的特点&quot;&gt;
    
    </summary>
    
      <category term="DataStruct" scheme="http://yoursite.com/categories/DataStruct/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构|栈</title>
    <link href="http://yoursite.com/2017/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>http://yoursite.com/2017/11/11/数据结构-栈/</id>
    <published>2017-11-11T00:30:21.000Z</published>
    <updated>2017-12-08T16:45:54.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈的简介"><a href="#栈的简介" class="headerlink" title="栈的简介"></a>栈的简介</h3><h4 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h4><p>栈（Stack）是一种特殊的线性存储结构，它具有一下特点：</p>
<ol>
<li>栈中的数据元素遵守 “先进后出(First In Last Out)”的yuanze</li>
<li>限定只能在栈顶进行插入和删除操作</li>
</ol>
<h4 id="栈的相关概念"><a href="#栈的相关概念" class="headerlink" title="栈的相关概念"></a>栈的相关概念</h4><ol>
<li>栈顶与栈底：允许元素插入与删除的一端称为栈顶，另一端称为栈底。</li>
<li>压栈：栈的插入操作，叫做进栈，也称压栈、入栈</li>
<li>弹栈：栈的删除操作，也叫做出栈</li>
</ol>
<p>例如我们有一个存储整型元素的栈，我们依次压出：｛1，2，3｝</p>
<p><img src="/images/610439-20160130013806989-121668995.png" alt="enter description here" title="610439-20160130013806989-121668995"></p>
<p>在压栈的过程中，栈顶的位置一直 “向上 ” 移动，而栈底是固定不变的，也就是说我们只在线性表的一端执行操作。</p>
<p>如果我们要把栈中的元素弹出来：</p>
<p><img src="/images/610439-20160130013814661-295746330.png" alt="enter description here" title="610439-20160130013814661-295746330"></p>
<p>出栈的顺序为 3、2、1 ，顺序与入栈时相反，这也就是栈的特点之一：先入后出。弹栈过程中，栈顶的位置一直在“向下移动”，而栈底一直保持不变。</p>
<p>如果你玩过一种称为汉诺塔的益智玩具，你就会知道游戏中小圆盘的存取就是一种先进后出的顺序，一个圆柱就是一个栈：</p>
<p><img src="/images/610439-20160130013821489-1542512229.png" alt="enter description here" title="610439-20160130013821489-1542512229"></p>
<h4 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h4><p>栈的常用操作为：</p>
<ol>
<li>弹栈，通常命名为 pop()</li>
<li>压栈，通常命名为push()</li>
<li>求栈的大小</li>
<li>判断栈是否为空</li>
<li>获取栈顶的元素</li>
</ol>
<h4 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h4><p>前面有说过，栈是一种特殊的线性表，那栈的存储结构就跟线性表是一样的，可以用数组或链表作为底层实现了。</p>
<p>本文我们以数组和单链表作为底层数据结构实现栈。</p>
<h3 id="基于数组的栈实现"><a href="#基于数组的栈实现" class="headerlink" title="基于数组的栈实现"></a>基于数组的栈实现</h3><p>当一数组为底层结构时，通常一数组头作为栈底，数组头数组尾为栈顶的方向：</p>
<p><img src="/images/610439-20160130013928458-208656397.png" alt="enter description here" title="610439-20160130013928458-208656397"></p>
<h4 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">class ArrayStack</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    ArrayStack(int s = 10);    //默认的栈容量为10</div><div class="line">    ~ArrayStack();</div><div class="line"> </div><div class="line">public:</div><div class="line">    T top();            //获取栈顶元素</div><div class="line">    void push(T t);        //压栈操作</div><div class="line">    T pop();            //弹栈操作</div><div class="line">    bool isEmpty();        //判空操作</div><div class="line">    int size();            //求栈的大小</div><div class="line"> </div><div class="line">private:</div><div class="line">    int count;            //栈的元素数量</div><div class="line">    int capacity;        //栈的容量</div><div class="line">    T * array;            //底层为数组</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>count 为栈的元素数量，capacity为栈的容量，count&lt;=capacity，当栈满的时候，count = capacity。</li>
<li>本实现中不支持栈的动态扩容，栈满的时候无法再插入元素。栈的容量在定义栈的时候就需要指定，默认的栈容量为10。</li>
</ol>
<h4 id="栈的具体实现"><a href="#栈的具体实现" class="headerlink" title="栈的具体实现"></a>栈的具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"> /*栈的判空操作*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">bool ArrayStack&lt;T&gt;::isEmpty()</div><div class="line">&#123;</div><div class="line">     return count == 0; //栈元素为0时为栈空</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">/*返回栈的大小*/</div><div class="line"> template &lt;typename  T&gt;</div><div class="line">int ArrayStack&lt;T&gt;::size()</div><div class="line">&#123;</div><div class="line">     return count;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">/*插入元素*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">void ArrayStack&lt;T&gt;::push(T t)</div><div class="line">&#123;</div><div class="line">     if (count != capacity)    //先判断是否栈满</div><div class="line">     &#123;</div><div class="line">         array[count++] = t;   </div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">/*弹栈*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">T ArrayStack&lt;T&gt;::pop()</div><div class="line">&#123;</div><div class="line">     if (count != 0)    //先判断是否是空栈</div><div class="line">     &#123;</div><div class="line">         return array[--count];</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">/*获取栈顶元素*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">T ArrayStack&lt;T&gt;::top()</div><div class="line">&#123;</div><div class="line">     if (count != 0)</div><div class="line">     &#123;</div><div class="line">         return array[count - 1];</div><div class="line">     &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="基于单链表的栈"><a href="#基于单链表的栈" class="headerlink" title="基于单链表的栈"></a>基于单链表的栈</h3><p>以链表为底层的数据结构时，以链表头为作为栈顶较为合适，这样方便节点的插入与删除。压栈产生的新节点将一直出现在链表的头部</p>
<p><img src="/images/610439-20160130013944943-399164407.png" alt="enter description here" title="610439-20160130013944943-399164407"></p>
<h4 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*链表节点结构*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">struct Node</div><div class="line">&#123;</div><div class="line">    Node(T t) :value(t), next(nullptr)&#123;&#125;;</div><div class="line">    Node() :next(nullptr)&#123;&#125;;</div><div class="line"> </div><div class="line">public:</div><div class="line">    T value;</div><div class="line">    Node&lt;T&gt;* next;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>value:栈中元素的值</li>
<li>next:链表节点指针，指向直接后继</li>
</ol>
<h4 id="栈的抽象数据类型-1"><a href="#栈的抽象数据类型-1" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">*栈的抽象数据结构*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">class LinkStack</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     LinkStack();</div><div class="line">     ~LinkStack();</div><div class="line">public:</div><div class="line"> </div><div class="line">     bool isEmpty();</div><div class="line">     int size();</div><div class="line">     void push(T t);</div><div class="line">     T pop();</div><div class="line">     T top();</div><div class="line"> </div><div class="line">private:</div><div class="line"> </div><div class="line">     Node&lt;T&gt;* phead;</div><div class="line">     int count;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="栈的具体实现-1"><a href="#栈的具体实现-1" class="headerlink" title="栈的具体实现"></a>栈的具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/*返回栈的大小*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">int LinkStack&lt;T&gt;::size()</div><div class="line">&#123;</div><div class="line">     return count;</div><div class="line">&#125;;</div><div class="line">/*栈的判空操作*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">bool LinkStack&lt;T&gt;::isEmpty()</div><div class="line">&#123;</div><div class="line">     return count == 0;</div><div class="line">&#125;;</div><div class="line">/*插入元素*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">void LinkStack&lt;T&gt;::push(T t)</div><div class="line">&#123;</div><div class="line">     Node &lt;T&gt; *pnode = new  Node&lt;T&gt;(t);</div><div class="line">     pnode-&gt;next = phead-&gt;next;</div><div class="line">     phead-&gt;next = pnode;</div><div class="line">     count++;</div><div class="line">&#125;;</div><div class="line">/*弹栈*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">T LinkStack&lt;T&gt;::pop()</div><div class="line">&#123;</div><div class="line">     if (phead-&gt;next != nullptr) //栈空判断</div><div class="line">     &#123;</div><div class="line">         Node&lt;T&gt;* pdel = phead-&gt;next;</div><div class="line">         phead-&gt;next = phead-&gt;next-&gt;next;</div><div class="line">         T value = pdel-&gt;value;</div><div class="line">         delete pdel;</div><div class="line">         count--;</div><div class="line">         return value;</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">/*获取栈顶元素*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">T LinkStack&lt;T&gt;::top()</div><div class="line">&#123;</div><div class="line">    if (phead-&gt;next!=nullptr)</div><div class="line">        return phead-&gt;next-&gt;value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>参考 <a href="http://www.cnblogs.com/QG-whz/p/5170418.html" target="_blank" rel="external">http://www.cnblogs.com/QG-whz/p/5170418.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;栈的简介&quot;&gt;&lt;a href=&quot;#栈的简介&quot; class=&quot;headerlink&quot; title=&quot;栈的简介&quot;&gt;&lt;/a&gt;栈的简介&lt;/h3&gt;&lt;h4 id=&quot;栈的特点&quot;&gt;&lt;a href=&quot;#栈的特点&quot; class=&quot;headerlink&quot; title=&quot;栈的特点&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="DataStruct" scheme="http://yoursite.com/categories/DataStruct/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构|线性表</title>
    <link href="http://yoursite.com/2017/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/10/26/数据结构-线性表/</id>
    <published>2017-10-25T22:34:11.000Z</published>
    <updated>2017-12-08T16:44:56.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表"></a>什么是线性表</h3><p>线性表是一种线性结构，它是由零个和多个数据元素元素构成的有序序列。线性表的特征是在一个序列中，除了头尾元素，每个元素都有且只有一个直接前驱，有且只有一个直接后继，而序列头元素没有直接前驱，序列尾元素没有直接后继。<br>数据结构中常见的线性结构有数组、单链表、双链表、循环链表等。线性表中的元素为某种相同的抽象数据类型。可以是C语言的内置类型或结构体，也可以是C++自定义类型。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组在实际的物理内存上也是连续存储的。如果我们用C语言声明一个数组，如：int  array[7]  = {1,2,3,4,5,6,7} ;则他们在在内存中就类似下图：</p>
<p><img src="/images/610439-20160129211728583-2081927870.png" alt="enter description here" title="610439-20160129211728583-2081927870">  </p>
<p>通过上图我们也能得知：当我们声明一个数组时，也就相当于在内存中开辟了一段连续的内存地址。这是数组最重要的性质，有了这个性质，我们就能通过下标很快的访问到数组中的元素，访问速度快的数组的很大的优点。同时，数组分为固定数组与动态数组。其中固定数组的大小必须在编译时就能够确认，动态数组允许在运行时申请数组内存。复杂点的数组是多维数组，多维数组实际上也是通过一维数组来实现的。在C语言中，可以通过malloc来分配动态数组，C+ +使用new。另外，C++的标准模板库提供了动态数组类型vector以及内置有固定数组类型array。 </p>
<p> 用数组实现线性表，会有很快的访问速度，但我们要插入呢？岂不是要把插入位置之后的数据都往后移动一位呢？再说删除，岂不是也要把删除之后的元素前移一位呢？这就很麻烦。还有一个一个问题是：如果我们不知道我们有多少元素时，我们要事先声明多大的数组呢？多了，会浪费空间，少了，就需要扩容，扩容就需要重新声明一个数组，再把数据复制到新的数组中，这也是一个耗时的操作噢。</p>
<p> 总之， 用数组实现线性表有利有弊， 需要根据实际问题来确定是否使用。 </p>
<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>前面提到了数组插入和删除麻烦和需要提前确定大小这些不足，那么有没有其他好的替代品呢？ 有的，那就是用链表来实现的线性表。单向链表是链表的一种。链表由节点所构成，节点内含一个指向下一个节点的指针，节点依次链接成为链表。因此，链表这种数据结构通常在物理内存上是不连续的。链表的通常含有一个头节点，头节点不存放实际的值，它含有一个指针，指向存放元素的第一个节点。那也就是说，在内存允许的情况下，我们需要添加节点的时候，就只需要把链表最后的节点的指针指向新的节点。简单点说，我们可以不用事先确定线性表的大小了，可以按需分配了，可喜可贺啊。</p>
<p><img src="/images/610439-20160129211741349-1771220512.png" alt="enter description here" title="610439-20160129211741349-177122051"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//节点结构</div><div class="line">template &lt;typename T&gt;</div><div class="line">class Node</div><div class="line">&#123;</div><div class="line">public :</div><div class="line">    T _value;</div><div class="line">    Node* _next;</div><div class="line">public:</div><div class="line">    Node() = default;</div><div class="line">    Node(T value, Node * next)</div><div class="line">        : _value(value), _next(next)&#123;&#125;</div><div class="line">&#125;;</div><div class="line">_value: 节点的值</div><div class="line">_next： 指针，指向下一个节点</div></pre></td></tr></table></figure>
<h4 id="单链表ADT"><a href="#单链表ADT" class="headerlink" title="单链表ADT"></a>单链表ADT</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">class SingleLink</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    typedef Node&lt;T&gt;*  pointer;</div><div class="line">    SingleLink();</div><div class="line">    ~SingleLink();</div><div class="line"> </div><div class="line">    int size();                         //获取长度</div><div class="line">    bool isEmpty();                     //判空</div><div class="line"> </div><div class="line">    Node&lt;T&gt;* insert(int index, T t); //在指定位置进行插入</div><div class="line">    Node&lt;T&gt;* insert_head(T t);         //在链表头进行插入</div><div class="line">    Node&lt;T&gt;* insert_last(T t);         //在链表尾进行插入</div><div class="line"> </div><div class="line">    Node&lt;T&gt;*  del(int index);         //在指定位置进行删除</div><div class="line">    Node&lt;T&gt;*  delete_head();         //删除链表头</div><div class="line">    Node&lt;T&gt;*  delete_last();         //删除链表尾</div><div class="line"> </div><div class="line">    T get(int index);                 //获取指定位置的元素</div><div class="line">    T get_head();                     //获取链表头元素</div><div class="line">    T get_last();                     //获取链表尾元素</div><div class="line"> </div><div class="line">    Node&lt;T&gt;* getHead();                 //获取链表头节点</div><div class="line"> </div><div class="line">private :</div><div class="line">    int count;</div><div class="line">    Node&lt;T&gt; * phead;                </div><div class="line"> </div><div class="line">private :</div><div class="line">    Node&lt;T&gt; * getNode(int index);      //获取指定位置的节点</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="单链表添加"><a href="#单链表添加" class="headerlink" title="单链表添加"></a>单链表添加</h4><p>链表的插入元素操作时间复杂度O（1），只需要进行指针的指向修改操作。</p>
<p><img src="/images/610439-20160129211802552-1568099093.png" alt="enter description here" title="610439-20160129211802552-1568099093"></p>
<p>在2之后添加7：</p>
<ul>
<li>为元素7构建节点 。</li>
<li>将节点2 的next指针指向节点7。</li>
<li>将节点7的next指向节点3。（节点3 的位置要先保留起来）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">在指定位置插入新节点</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* SingleLink&lt;T&gt;::insert(int index, T t)</div><div class="line">&#123;</div><div class="line">    Node&lt;T&gt; * preNode = getNode(index);</div><div class="line">    if (preNode)</div><div class="line">    &#123;</div><div class="line">        Node&lt;T&gt; *newNode = new Node&lt;T&gt;(t,preNode-&gt;_next);</div><div class="line">        preNode-&gt;_next = newNode;</div><div class="line">        count++;</div><div class="line">        return newNode;</div><div class="line">    &#125;</div><div class="line">    return nullptr;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">从头部插入</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* SingleLink&lt;T&gt;::insert_head(T t)</div><div class="line">&#123;</div><div class="line">    return insert(0, t);</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">从尾部进行插入</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* SingleLink&lt;T&gt;::insert_last(T t)</div><div class="line">&#123;</div><div class="line">    return insert(count, t);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="单链表删除节点"><a href="#单链表删除节点" class="headerlink" title="单链表删除节点"></a>单链表删除节点</h4><p>单链表的删除操作同样是一个时间复杂度O（1）的操作，它也只需要修改节点的指针指针后即可销毁被删除节点。<br>例如我们删除链表元素7：</p>
<p><img src="/images/610439-20160129211816786-1957915729.png" alt="enter description here" title="610439-20160129211816786-1957915729"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">删除链表指定位置元素</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* SingleLink&lt;T&gt;::del(int index)</div><div class="line">&#123;</div><div class="line">    if (isEmpty())</div><div class="line">        return nullptr;</div><div class="line">    Node&lt;T&gt;* ptrNode = getNode(index);</div><div class="line">    Node&lt;T&gt;* delNode = ptrNode-&gt;_next;</div><div class="line">    ptrNode-&gt;_next = delNode-&gt;_next;</div><div class="line">    count--;</div><div class="line">    delete delNode;</div><div class="line">    return ptrNode-&gt;_next;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">删除头节点</div><div class="line">*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* SingleLink&lt;T&gt;::delete_head()</div><div class="line">&#123;</div><div class="line">    return del(0);</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">删除尾节点</div><div class="line">*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">Node&lt;T&gt;*SingleLink&lt;T&gt;::delete_last()</div><div class="line">&#123;</div><div class="line">    return del(count);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单链表的节点链接是单方向的，要得到指定节点的前一个节点，必须从头遍历链表。<br>双向链表是链表的一种。与单链表一样，双向节点由节点链接而成，每个节点含有两个指针，分别指向直接前驱与直接后继。从双向链表的任何一个节点开始都能够遍历整个链表。<br>我们将双向链表实现为双向循环链表，也即是最后一个元素的后继将指向头节点，整个链表形成一个循环<br>例如，我们为元素1，2，3，4，5 构建一个双向循环链表。</p>
<p><img src="/images/610439-20160129211829474-2026702975.png" alt="enter description here" title="610439-20160129211829474-2026702975"></p>
<h4 id="双向链表节点结构"><a href="#双向链表节点结构" class="headerlink" title="双向链表节点结构"></a>双向链表节点结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">双向链表的节点结构</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">struct Node</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Node()= default;</div><div class="line">    Node(T value, Node&lt;T&gt;* preptr, Node&lt;T&gt;* nextptr)</div><div class="line">        :_value(value), pre_ptr(preptr), next_ptr(nextptr)&#123;&#125;</div><div class="line"> </div><div class="line">public:</div><div class="line">    T _value;</div><div class="line">    Node&lt;T&gt;* pre_ptr;</div><div class="line">    Node&lt;T&gt;* next_ptr;</div><div class="line">&#125;;</div><div class="line">_value: 节点元素的值</div><div class="line">pre_ptr:指向直接前驱的指针</div><div class="line">next_ptr:指向直接后继的指针</div></pre></td></tr></table></figure>
<h4 id="双向链表的抽象数据结构"><a href="#双向链表的抽象数据结构" class="headerlink" title="双向链表的抽象数据结构"></a>双向链表的抽象数据结构</h4><p>双向链表类的定义与单链表相似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 双向链表类</div><div class="line">*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">class DoubleLink</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    typedef Node&lt;T&gt;* pointer;</div><div class="line">public:</div><div class="line">    DoubleLink();</div><div class="line">    ~DoubleLink()&#123;&#125;;</div><div class="line">public:</div><div class="line">    Node&lt;T&gt;* insert(int index, T value);</div><div class="line">    Node&lt;T&gt;* insert_front(T value);</div><div class="line">    Node&lt;T&gt;* insert_last(T value);</div><div class="line"> </div><div class="line">    Node&lt;T&gt;* del(int index);</div><div class="line">    Node&lt;T&gt;* delete_front();</div><div class="line">    Node&lt;T&gt;* delete_last();</div><div class="line"> </div><div class="line">    bool isEmpty();</div><div class="line">    int size();</div><div class="line"> </div><div class="line">    T get(int index);</div><div class="line">    T get_front();</div><div class="line">    T get_last();</div><div class="line">    Node&lt;T&gt;* getHead();</div><div class="line"> </div><div class="line">private:</div><div class="line">    Node&lt;T&gt;* phead;</div><div class="line">    int count;</div><div class="line">private :</div><div class="line">    Node&lt;T&gt;* getNode(int index);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="双向链表添加节点"><a href="#双向链表添加节点" class="headerlink" title="双向链表添加节点"></a>双向链表添加节点</h4><p>与单链表一样，双向链表添加节点的时间复杂度为O（1），它也只需要修改相关指针的指向。</p>
<p><img src="/images/610439-20160129211844927-167005435.png" alt="enter description here" title="610439-20160129211844927-167005435"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*将新节点插到第一个位置</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::insert_front(T value)</div><div class="line">&#123;</div><div class="line">    Node&lt;T&gt;* newNode = new Node&lt;int&gt;(value, phead, phead-&gt;next_ptr);</div><div class="line">    phead-&gt;next_ptr -&gt;pre_ptr= newNode;</div><div class="line">    phead-&gt;next_ptr = newNode;</div><div class="line">    count++;</div><div class="line">    return newNode;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">*将新节点插到链表尾部</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::insert_last(T value)</div><div class="line">&#123;</div><div class="line">    Node&lt;T&gt; * newNode = new Node&lt;int&gt;(value, phead-&gt;pre_ptr, phead);</div><div class="line">    phead-&gt;pre_ptr-&gt;next_ptr = newNode;</div><div class="line">    phead-&gt;pre_ptr = newNode;</div><div class="line">    count++;</div><div class="line">    return newNode;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">*将节点位置插到index位置之前</div><div class="line">*/</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::insert(int index, T value)</div><div class="line">&#123;</div><div class="line">    if (index == 0)</div><div class="line">        return insert_front(value);</div><div class="line"> </div><div class="line">    Node&lt;T&gt;* pNode = getNode(index);</div><div class="line">    if (pNode == nullptr)</div><div class="line">        return nullptr;</div><div class="line">    Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value, pNode-&gt;pre_ptr, pNode);</div><div class="line">    pNode-&gt;pre_ptr-&gt;next_ptr = newNode;</div><div class="line">    pNode-&gt;pre_ptr = newNode;</div><div class="line">    count++;</div><div class="line"> </div><div class="line">    return newNode;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="双向链表删除节点"><a href="#双向链表删除节点" class="headerlink" title="双向链表删除节点"></a>双向链表删除节点</h4><p>双向链表的删除操作时间复杂度为O（1）.我们删除节点7：</p>
<p><img src="/images/610439-20160129211855802-449700803.png" alt="enter description here" title="610439-20160129211855802-449700803"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*删除链表第一个节点</div><div class="line">*返回删除后链表第一个节点</div><div class="line">*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::delete_front()</div><div class="line">&#123;</div><div class="line">    if (count == 0)</div><div class="line">    &#123;</div><div class="line">        return nullptr;</div><div class="line">    &#125;</div><div class="line">    Node&lt;T&gt;* pnode = phead-&gt;next_ptr;</div><div class="line">    phead-&gt;next_ptr = pnode-&gt;next_ptr;</div><div class="line">    pnode-&gt;next_ptr-&gt;pre_ptr = phead;</div><div class="line">    delete pnode;</div><div class="line">    count--;</div><div class="line">    return phead-&gt;next_ptr;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line">*删除链表的末尾节点</div><div class="line">*返回删除后链表尾部元素</div><div class="line">*/</div><div class="line">template&lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::delete_last()</div><div class="line">&#123;</div><div class="line">    if (count == 0)</div><div class="line">    &#123;</div><div class="line">        return nullptr;</div><div class="line">    &#125;</div><div class="line">    Node&lt;T&gt;*pnode = phead-&gt;pre_ptr;</div><div class="line">    pnode-&gt;pre_ptr-&gt;next_ptr = phead;</div><div class="line">    phead-&gt;pre_ptr = pnode-&gt;pre_ptr;</div><div class="line">    delete pnode;</div><div class="line">    count--;</div><div class="line">    return phead-&gt;pre_ptr;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">*删除指定位置的元素</div><div class="line">*</div><div class="line">*/</div><div class="line">template &lt;typename T&gt;</div><div class="line">Node&lt;T&gt;* DoubleLink&lt;T&gt;::del(int index)</div><div class="line">&#123;</div><div class="line">    if (index == 0)</div><div class="line">        return delete_front();</div><div class="line">    if (index == count - 1)</div><div class="line">        return delete_last();</div><div class="line">    if (index &gt;= count)</div><div class="line">        return nullptr;</div><div class="line">    Node&lt;T&gt;* pnode = getNode(index);</div><div class="line">    pnode-&gt;pre_ptr-&gt;next_ptr = pnode-&gt;next_ptr;</div><div class="line">    pnode-&gt;next_ptr-&gt;pre_ptr = pnode-&gt;pre_ptr;</div><div class="line"> </div><div class="line">    Node&lt;T&gt;* ptemp = pnode-&gt;pre_ptr;</div><div class="line">    delete pnode;</div><div class="line">    count--;</div><div class="line">    return ptemp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是线性表&quot;&gt;&lt;a href=&quot;#什么是线性表&quot; class=&quot;headerlink&quot; title=&quot;什么是线性表&quot;&gt;&lt;/a&gt;什么是线性表&lt;/h3&gt;&lt;p&gt;线性表是一种线性结构，它是由零个和多个数据元素元素构成的有序序列。线性表的特征是在一个序列中，除了头尾元素，
    
    </summary>
    
      <category term="DataStruct" scheme="http://yoursite.com/categories/DataStruct/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>生活|58到家面试</title>
    <link href="http://yoursite.com/2017/10/24/%E7%94%9F%E6%B4%BB-58%E5%88%B0%E5%AE%B6%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2017/10/24/生活-58到家面试/</id>
    <published>2017-10-24T00:14:57.000Z</published>
    <updated>2017-10-26T14:24:23.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 在上周，学长（王自琰）回校宣讲，我就自告奋勇把简历给他了，说实话，效率挺高啊，第二天就叫去面试了。说是周五，但自己有课，就跟Hr说换时间，就订在周一了。</p>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p> 58到家在一个软件园里，门卫叔叔说里面有二十栋楼，每一栋都是一个公司基本。这是自己到这种地方，有点小激动啊。然后摸索着找到了17栋，58所在地。然后填表，开始面试。</p>
<p> 来的可能是一个Leader。然后我们两个就坐在等待区，开始 “交谈” 。面试官看起来挺好的，看了一下我的简历，然后看我做过的项目，看到一个专业名词就问一下。比如说看到 Ajax ,就会问你 Ajax 的实现原理，还叫我画了数据交互的过程；看到 MVC 就叫你说一下对 MVC 的理解；看到数据库，就会问你数据库的操作，原理…；还有就是如果看到比较难的功能点，也会停下来问你这个功能点是如何实现的。<strong>总的说，你写的简历，就是你自己给自己挖的坑。</strong></p>
<p>在这次简历中，自己就给自己挖了一个大坑：写了一个照书上一步步来完成的成绩管理系统。然后还说自己学到了如何分析系统功能、怎么设计系统架构及数据库，这个坑足够大啊。面试官就在这里开始发问了，然后才发现自己并不是真正的懂，答非所问了，哎，自己挖的坑还是要自己跳啊。好不容易混过系统这一关了，接着是数据库，先叫你画 ER 图，然后简单描述下各表关系，再接着就是一些数据库的操作，什么排序啊、多表连接啊… 由于多表连接这个自己不是经常用，也栽了。最后，由于这个项目是用Java弄的，面试官又开始问你一些 Java 的东西了，然后问int，double…的范围，说真心话，自己对这些基础的东西真的不是很不不上心，又栽了。</p>
<p>最后是JavaWeb方面的东西，看到了 JSP和Servlet，然后问你这两者的关系、Servlet有那些方法，怪自己没学透啦，再一次栽了。然后，我们说了一些框架的学习方面的东西，这时候是一起交流的阶段，就像是老师和学生那样，在学习的过程中遇到的问题，可以问面试官，大家一起交流，感觉挺好。</p>
<p>然后，面试就结束了，估计这一次是没希望啦，但自己要的就是面试的这一个过程，加油。遗憾的是，最后没有问面试官觉得自己怎么样。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这可以说是自己真正意义上的技术面试，加油，小智。<br><img src="/images/IMG_20171023_154930.jpg" alt="在软件园" title="IMG_20171023_154930"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt; 在上周，学长（王自琰）回校宣讲，我就自告奋勇把简历给他了，说实话，效率挺高啊，第二天就叫去面试了。说是周五，但自己有课，就跟Hr说换时间，
    
    </summary>
    
      <category term="college" scheme="http://yoursite.com/categories/college/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>PHP|Slim入门demo</title>
    <link href="http://yoursite.com/2017/10/12/PHP-Slim%E5%85%A5%E9%97%A8demo/"/>
    <id>http://yoursite.com/2017/10/12/PHP-Slim入门demo/</id>
    <published>2017-10-12T08:44:11.000Z</published>
    <updated>2017-10-12T01:43:52.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>暑假在弦歌开发新生宝典的时候，就接触到Slim这个框架，但当时自己并没有深入了解，因为环境这些都是学长们搭的，我自己只需要写好自己的业务逻辑部分就好了，所以不深入理解也不影响工作。新学期开始，学长要求继续晚上新生宝典，也就是说重构，既然这样，那就需要深入了解Slim了。在一次读源码，感觉还是有很多问题需要解决,比如说：Slim是怎么实现路由转发的？Slim是怎么实现数据库连接的？Slim的作用是什么？给我们带来了什么样的方便之处？</p>
<h3 id="什么是Slim"><a href="#什么是Slim" class="headerlink" title="什么是Slim"></a>什么是Slim</h3><p>官方解释：Slim是一款 PHP 微框架，可以帮助你快速编写简单但功能强大的 web 应用和 API 。在它的核心，Slim 是一个调度程序，它接收一个 HTTP 请求，调用一个适当的回调例程，然后返回一个 HTTP 响应。我个人的理解是这样的：Slim帮我们把客户端的请求与响应封装起来，让我们不用去关心请求与响应，只需要关心业务逻辑部分，简单点说，就只需要处理好数据的响应。一个 Slim 应用包含多个响应特定 HTTP 请求的路由。每个路由调用一个回调并返回一个 HTTP 响应。</p>
<h3 id="怎么安装Slim"><a href="#怎么安装Slim" class="headerlink" title="怎么安装Slim"></a>怎么安装Slim</h3><p>官方推荐使用composer安装，自己也是因此而接触到composer，不用不知道，觉得这个工具挺好的，值得推荐。Slim的安装非常简单，只需要在我们的项目根目录中，运行以下 bash 命令，就可以将最新的稳定版安装到项目的 vendor/ 目录中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer require slim/slim &quot;^3.0&quot;</div></pre></td></tr></table></figure>
<p>举个例子，比如说我们的项目是SlimDemo，我们就只需要在SlimDemo的目录下运行上述命令，就能下载安装Slim了，同时你会发现SlimDemo目录下会出现vendor文件夹、composer.json文件和composer.lock文件。此时，恭喜你安装成功了。</p>
<h3 id="运行Slim"><a href="#运行Slim" class="headerlink" title="运行Slim"></a>运行Slim</h3><p>就用我自己的例子给大家讲解一下吧：</p>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p>项目的文件目录推荐如下：#表示一级目录，##表示二级目录</p>
<p>#app    —-项目主要目录</p>
<p>##routes.php    —-定义路由</p>
<p>##function.php  —-功能函数</p>
<p>#public    —-用户可以访问的目录</p>
<p>##index.php    —-index页面</p>
<p>#vendor    —-使用composer自动生成的目录</p>
<p>##composer.json    —-composer配置文件</p>
<p>##composer.lock    —-composer文件不需要管</p>
<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>按照上面的目录结构创建文件的目录app和public，vendor目录使用composer命令自动生成，所以不需要我们创建。</p>
<h5 id="编辑index-php文件"><a href="#编辑index-php文件" class="headerlink" title="编辑index.php文件"></a>编辑index.php文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">use \Psr\Http\Message\ServerRequestInterface as Request;</div><div class="line">use \Psr\Http\Message\ResponseInterface as Response;</div><div class="line"></div><div class="line">require &apos;../vendor/autoload.php&apos;;   //添加Slim</div><div class="line">require &apos;../app/function.php&apos; ;        //添加功能函数</div><div class="line"></div><div class="line">$app = new \Slim\App;</div><div class="line"></div><div class="line">require &apos;../app/routes.php&apos;;            //添加路由管理</div><div class="line"></div><div class="line">$app-&gt;run();                            //执行</div></pre></td></tr></table></figure>
<h5 id="添加路由管理文件"><a href="#添加路由管理文件" class="headerlink" title="添加路由管理文件"></a>添加路由管理文件</h5><p>在app文件夹里面创建routes.php文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$app-&gt;get(&apos;/hello&apos;,&apos;sayHello&apos;);//get方法路由，并回调sayHello方法</div></pre></td></tr></table></figure>
<h5 id="添加function-php"><a href="#添加function-php" class="headerlink" title="添加function.php"></a>添加function.php</h5><p>我们设置了路由调用 sayHello 函数，所以我们现在在function.php 文件中添加 sayHello函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function syaHello($request, $response, $args)&#123;</div><div class="line">   echo &quot;Hello World&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，我们的小demo就好啦，打开服务器，在浏览器中输入： <a href="http://127.0.0.1/SlimDemo/public/index.php/hello" target="_blank" rel="external">http://127.0.0.1/SlimDemo/public/index.php/hello</a> ;就能输出 Hello World啦。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h3 id="安装Composer"><a href="#安装Composer" class="headerlink" title="安装Composer"></a>安装Composer</h3><ul>
<li><p>下载<br>在终端执行curl -sS <a href="https://getcomposer.org/installer" target="_blank" rel="external">https://getcomposer.org/installer</a> | php下载composer</p>
</li>
<li><p>设置</p>
</li>
</ul>
<p>将Composer设置为全局运行程序方便使用,执行mv composer.phar /usr/local/bin/composer</p>
<ul>
<li>测试</li>
</ul>
<p>执行composer -v,如果能查看到版本信息，则说明安装成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;暑假在弦歌开发新生宝典的时候，就接触到Slim这个框架，但当时自己并没有深入了解，因为环境这些都是学长们搭的，我自己只需要写好自己的业务逻辑
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="Slim" scheme="http://yoursite.com/tags/Slim/"/>
    
  </entry>
  
  <entry>
    <title>游玩|2017国庆</title>
    <link href="http://yoursite.com/2017/10/10/%E6%B8%B8%E7%8E%A9-2017%E5%9B%BD%E5%BA%86/"/>
    <id>http://yoursite.com/2017/10/10/游玩-2017国庆/</id>
    <published>2017-10-09T23:06:50.000Z</published>
    <updated>2017-12-08T16:45:20.477Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h3><p>高中那会，就想着在大学的时候，要多走走，了解外面的世界是怎么样的…</p>
<h3 id="八班国庆小分队"><a href="#八班国庆小分队" class="headerlink" title="八班国庆小分队"></a>八班国庆小分队</h3><p>不知为何，很多人都想来长沙玩，说实话，确实不知道长沙有什么好玩的，这是个无解的问题。就连我远在大连和吉林的同学都过来了，坐30个小时的绿皮车过来确实不容易啊。人家大老远过来，怎么着也不能让人家留有遗憾，所以就带这几个哥们去凤凰古城玩一波啦，去之前听人家说那边挺美的，去之后，应该也算挺美的吧。先来几张图吧：<br><img src="/images/1507427701193.jpeg" alt="enter description here" title="1507427701193"><br><img src="/images/IMG_20171003_223043.jpg" alt="enter description here" title="IMG_20171003_223043"><br><img src="/images/IMG_20171003_211350.jpg" alt="enter description here" title="IMG_20171003_211350"></p>
<p>哈哈，不骗你吧，在城市久了，到了这古镇，还是会有另一番韵味的。</p>
<h3 id="坐车恐惧症"><a href="#坐车恐惧症" class="headerlink" title="坐车恐惧症"></a>坐车恐惧症</h3><p>不骗你，去一趟凤凰回来，我对大巴车有了一种恐惧感。为什么呢？就是坐车多了，怕了呗。我的天，从长沙到凤凰，需要做6个小时的大巴车，要注意的是六个小时是开的比较快的情况下，如果司机技术不是很好，那就好坐七八个小时了。长这么大，这是坐车最久的一次了。我们早上七点出发，到下午3点才到，途中还只能吃方便面充饥，那个酸楚不是能想象的到的。坐车的时候，真后悔出来玩啊，在宿舍带着多好，何必来受这份罪呢？还好景色不让我失望，不然这会是一个悲惨的国庆。</p>
<h3 id="在凤凰"><a href="#在凤凰" class="headerlink" title="在凤凰"></a>在凤凰</h3><p>两天时间，在车上就度过了一天，留给我们的就只有一天的时间了。到了之后，就找酒店放行李，然后大吃一餐，那叫一个爽啊。接着，我们就去看篝火晚会，去之前，意为会想电视上那样一群人围着火坐一圈，然后大碗喝酒大口吃肉呢。现实是这样的，大家确实是围着火坐一圈，但酒和肉就没有了，想哭。在晚会中，也了解到苗族的一些风俗，不虚此行吧。</p>
<h3 id="长沙会师"><a href="#长沙会师" class="headerlink" title="长沙会师"></a>长沙会师</h3><p>在五号这一天，想着东北老同学晚上也要走了，长沙的就都来聚聚，一起吃个饭吧。然后，能过来的就都过来了。然后，在五一地铁站口会师了，接着就到五一消遣。说实话，人多确实难办事啊，一条街走了两个小时，从街头走到街尾，就到了吃饭的时间了。在茶颜悦色这破店就停了差不多一个小时了，等好久才买到的茶，还是带头发的，可以说是买一送一啦，然后就去找店员干一波…<br><img src="/images/-f4fce435b08868e.jpg" alt="enter description here" title="-f4fce435b08868e"><br><img src="/images/135d0a2aa2cfb394.jpg" alt="enter description here" title="135d0a2aa2cfb394"><br><img src="/images/173694c9a419c1e0.jpg" alt="enter description here" title="173694c9a419c1e0"></p>
<h3 id="大聚餐"><a href="#大聚餐" class="headerlink" title="大聚餐"></a>大聚餐</h3><p>逛累玩累，就找地吃饭了。大家找了一个湘菜馆，坐一起吃饭。在他乡一起吃饭和在海南一起吃饭的感觉就是不一样，这种感觉难以用言语表达，就像一家人一样。</p>
<h3 id="散伙"><a href="#散伙" class="headerlink" title="散伙"></a>散伙</h3><p>天下没有不散的聚会。吃饱喝足的时刻，也是分离的时刻了。到车站后，时间还早，就到麦当劳里坐，聊聊家常啊。随着年龄的增长，现在聊天的话题都是跟工作相关的了，有要考研的，要工作的….</p>
<p>愿我们都能变成自己想成为的那个人，世界在变，我们感情不变。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h3&gt;&lt;p&gt;高中那会，就想着在大学的时候，要多走走，了解外面的世界是怎么样的…&lt;/p&gt;
&lt;h3 id=&quot;八班国庆小分队&quot;
    
    </summary>
    
      <category term="colleage" scheme="http://yoursite.com/categories/colleage/"/>
    
    
  </entry>
  
  <entry>
    <title>求职|第一次电话面试</title>
    <link href="http://yoursite.com/2017/09/30/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2017/09/30/第一次电话面试/</id>
    <published>2017-09-30T00:08:21.000Z</published>
    <updated>2017-09-29T16:43:12.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>经过开学第一个星期的疯狂投简历、笔试风波后，自己本以为求职风波就可以暂停一波了，但是就在前几天，蓝杰的学长发了一则深信服的招聘信息，自己看了一下觉得自己挺符合的，并且简历也都写好了，就给学长发过去了，反正不管结果如何，自己也没损失嘛…</p>
<h3 id="电话面试"><a href="#电话面试" class="headerlink" title="电话面试"></a>电话面试</h3><p>投了简历之后，学长跟我说这两天就会有电话面试，让我保持手机畅通。说实话，这两天我手机的电池还真没有少过50%，毕竟第一次电话面试，万一没电了就尴尬了。同时，自己还对笔试时发现的不足进行了一次恶补，就是一些Mysql的知识和PHP面向对象的一些细节啦。然后，自己还上网找了一些PHP的面试题看了一下，不看不知道啊，一看收获还挺大的，还真的有一些知识是自己不知道的，并且平时也不会注意的细节。偷偷告诉你，面试的时候还真的问了一些题，好开心。</p>
<p>一共打了20分钟的电话。面试官问的话就10多分钟吧，并且问的问题都是一些不能在基础的问题了，比如说get和post的区别啊，主键和索引的区别啊，php中echo、print，print_r的区别啊,mvc思想啊，一些比较难的问题，比如说计算机网络啊、Linux啊，都没有问道。在面试官问到数据库这一部分的时候，自己很担心问道Mysql的优化方面的东西，毕竟自己在这一块真的可以说是空白。自己也知道他肯定会问的，所以就提前坦白了说自己在这一块没什么了解，然后面试官就只问了一些简单的问题，就问其他的问题了。是啊，不懂就是不懂，面试官提前并不知道你不懂，出于对你的考虑，肯定会问你一下，如果你坦白了，就不会问了，并且这样也不会让面试变的尴尬。</p>
<p>各个领域都问了一些简单的问题后，面试官就说觉得我还可以，问我什么时候可以来面试。我说寒假或者暑假，然后他就叫我有时间就联系他，他好让Hr联系我。接着，我就问了一些实习方面的问题，面试就结束了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>哈哈，没想到自己第一次电话面试就通过了，有一点有意外。虽然说，难度算不上是一些正规的面试，但是对自己也是一种锻炼。</p>
<p>不得不说，有人内推，就是不一样，起码笔试就省了，直接进入面试环节。说实话，笔试也是不容易的，运气不好，碰到自己不擅长的领域就什么都没了。还有就是，要提前准备好简历，机会一来，就果断把简历发出去。</p>
<p>我在努力，我在成长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h3&gt;&lt;p&gt;经过开学第一个星期的疯狂投简历、笔试风波后，自己本以为求职风波就可以暂停一波了，但是就在前几天，蓝杰的学长发了一则深信服的招聘信息，自己看了
    
    </summary>
    
      <category term="colleage" scheme="http://yoursite.com/categories/colleage/"/>
    
    
      <category term="求职" scheme="http://yoursite.com/tags/%E6%B1%82%E8%81%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构|什么是数据结构</title>
    <link href="http://yoursite.com/2017/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2017/09/28/数据结构-什么是数据结构/</id>
    <published>2017-09-27T20:29:18.000Z</published>
    <updated>2017-09-27T13:32:58.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h3><p>自己在大一时，就从学长口中得知数据结构的重要性，自己也买书琢磨了一波，但对此的理解也仅限与表面，没有了解到其的奥秘。不过，随着一年多的编程，自己逐渐了解数据结构的重要性，也逐渐揭开他的面纱…</p>
<p>作为 一名计算机专业的学生，写的代码不能仅限于实现功能，我们应该有更高的追求，比如说尽量使用较少的空间啊、让程序能运行的更快啊…这些都是我们需要注意的。数据结构作为计算机专业的基本课程，个人觉得就是教我们怎么更合理地使用内存及硬盘，简单间就是怎么最大化利用我们的存储空间；还有就是怎么来存放我们的数据，以便我们能更好更快的操作数据，比如说查找、删除、添加…</p>
<h3 id="什么数据结构"><a href="#什么数据结构" class="headerlink" title="什么数据结构"></a>什么数据结构</h3><p>对于数据结构的定义，我们应该分开来看：一个是数据，另一个数结构。首先，我们先说说什么是数据：</p>
<h4 id="什么是数据"><a href="#什么是数据" class="headerlink" title="什么是数据"></a>什么是数据</h4><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。这个官方定义不是很容易理解，用我们自己的话说，数据就是计算机能处理的东西，比如说整型、实数型，当然，还包括字符、声音、图像…比如说我们常用的搜索引擎，一般会有网页、MP3、图片、视频等分类。其中，MP3是声音数据，图片是图像数据。说白了，我们所说的数据就是符号，但其必须具有两个属性：</p>
<ul>
<li>可以输入到计算机中</li>
<li>能被计算机处理</li>
</ul>
<p>对于整型、实数型等数值数据，计算机可以进行数值计算；对于字符数据类型，需要进行非数值处理。而声音、图像、视频等其实可以通过编码的手段编程字符数据来处理。</p>
<h4 id="什么是结构"><a href="#什么是结构" class="headerlink" title="什么是结构"></a>什么是结构</h4><p>结构，简单来说就是数据之间的关系。我们都知道，在现实中，不同数据之间不是独立的，而是存在某种特定的关系，我们称这些关系为结构。那么在计算机中也是如此，计算机中的数据并不是孤立的、杂乱无章的，而是具有内在联系的数据集合。我们要写一个好的程序，就要分析处理对象的特性及各处理对象之间存在的关系。我们知道了结构就是关系，那么都有那些具体的关系呢？</p>
<p>按照视点的不同，我们把数据结构分为逻辑结构和物理结构。</p>
<h5 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><p>逻辑结构：是指数据对象中数据元素之间的相互关系。</p>
<p>集合关系：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。就是类似与我们数学中所说的集合，各元素之间没有关系，彼此平等。</p>
<p>线性结构：线性结构中的数据元素之间是一对一的关系。就像排队一样，我们只和我们前面的人有关系，和其他人没有关系。</p>
<p>树形结构：树形结构中的元素之间存在一种一对多的层次关系。就像我们所见的数一样，从下往上，枝叶逐渐增多，但下一层只和上一层有关系。</p>
<p>图形结构：图形结构的数据元素是多对多的关系，就像地图一样，不同的节点之间都会有关系。</p>
<p>逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据之间的逻辑关系，我们要懂得根据实际的问题来选择合适的结构来组织我们的数据。</p>
<h5 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h5><p>物理结构：是指数据的逻辑结构在计算机中的存储形式。说白了，选定了具体的逻辑结构后，我们要怎么样把数据存在计算机中。数据的物理结构应该正确反映数据元素之间的逻辑关系。如何在计算机中存储元素之间的逻辑关系，是实现物理结构的重点和难点。</p>
<p>顺序存储结构：把数据元素存放在地址连续的存储单元中。这种存储结构很简单，就类似与我们开的数组，大家按顺序排好队，每个人占一端空间，大家都不插队。这种方式存储数据，最大的好处是易于遍历，大家都在一起，当然容易遍历啦，但是删除操作就很麻烦，需要把要删除的数字后面的数都往上移位。</p>
<p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元不一定是要连续的。哪要怎么从找到下一个位置呢？这时候就需要指针上场了。这种存储方式比较灵活，数据存放在那不重要，只要一个指针存放了相应的地址就能找到。但查找就很困难了，因为每一次查找都必须从头开始查找。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开场白&quot;&gt;&lt;a href=&quot;#开场白&quot; class=&quot;headerlink&quot; title=&quot;开场白&quot;&gt;&lt;/a&gt;开场白&lt;/h3&gt;&lt;p&gt;自己在大一时，就从学长口中得知数据结构的重要性，自己也买书琢磨了一波，但对此的理解也仅限与表面，没有了解到其的奥秘。不过，随着一年多
    
    </summary>
    
      <category term="DataStruct" scheme="http://yoursite.com/categories/DataStruct/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>生活|记一周的求职经历</title>
    <link href="http://yoursite.com/2017/09/25/%E7%94%9F%E6%B4%BB-%E8%AE%B0%E4%B8%80%E5%91%A8%E7%9A%84%E6%B1%82%E8%81%8C%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2017/09/25/生活-记一周的求职经历/</id>
    <published>2017-09-25T00:03:54.000Z</published>
    <updated>2017-09-24T16:49:29.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h3><p>大二开学第一周，自己就尝试着扮演大三或者大四的角色，加入到找实习找工作的行列中，体验生活。在这一周的折腾中，自己也有所感悟。</p>
<h3 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h3><h4 id="猎豹移动"><a href="#猎豹移动" class="headerlink" title="猎豹移动"></a>猎豹移动</h4><p>自己在宣讲会的前一天就在蓝杰见到 Hr 小姐姐了，听小姐姐讲了猎豹移动的一些信息，比如员工宿舍啊、食堂啊、培养计划啊…说实话，自己当时是很被吸引的，也很希望自己能有机会到这样的公司里学习。第二天晚上（周一），自己约上几个学长，就一起听了宣讲会，然后参加笔试。当然，笔试的结果是惨败（在前前一篇文章就讲过了），这里就不细讲了。</p>
<h4 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h4><p>深信服的笔试是在网上弄的。自己也不知到怎么滴就投了PHP岗位的，虽然也学过并用PHP开发了新生宝典，但熟练程度还不至于背出来一些常见函数啊，基本上都是现用现查的，所以结果可想而知。除了PHP，笔试还设计了服务器、linux、数据库方面的知识，也就是关于网站的方方面面都有了，并且都是一些很深入的问题，比如说怎么Apache和Nginx的差别啊，Nginx还有什么其他的作用啊；怎么优化Mysql数据库啊；怎么防止sql注入攻击啊；各种数据库引擎的不同啊…哇，我天，我只能说自己要走的路还很长呢…</p>
<h4 id="恒生"><a href="#恒生" class="headerlink" title="恒生"></a>恒生</h4><p>恒生的笔试是在今天（周六）进行的。自己本来不想去的，但仔细想想反正周六也没什么事，就去玩玩嘛，就在学校。笔试的题目感觉还可以，不算难，就是一些基础的东西，但自己还是不是很懂，可能好久没有看了吧，记忆有点模糊了。笔试中考了一些简单的数据库操作，就是给你一些表，让你写SQL语句找出需要的数据，说实话，这是很容易的，但自己基本都是用客户端操作数据库的，并且用到的都是一些简单的增删改查，总之，就是自己不懂做。</p>
<h4 id="博登信息"><a href="#博登信息" class="headerlink" title="博登信息"></a>博登信息</h4><p>这是唯一一家不需要笔试的，投简历就直接通知面试了。周五下午去面试，更可恶的是并不是一个懂技术的人来面试而是Hr小姐姐来跟我聊，聊的就是自己的一些情况：在学校学了什么 核心课，自己有学了什么，做过什么，并没有问用到什么技术。好吧，我也无话可说啊。虽然不是技术面试，但也算是面试，自己感觉自己表现还是可以的，不是很紧张，也表达出来了自己想要表达的东西。如果放在中学，自己肯定会吞吞吐吐的，不懂怎么组织语言，讲话没主次.。 </p>
<h3 id="自己的一些感悟"><a href="#自己的一些感悟" class="headerlink" title="自己的一些感悟"></a>自己的一些感悟</h3><p>经过这一周的折腾，自己还是有点收获的，也明确了自己今后的学习重点，折腾是值得的。同时，也意识到笔试是个很重要的东西，笔试也确实能看出一个人的水平。同时，笔试考的知识，也同样是面试的时候，面试官要问你的问题，比如说上面提到的Mysql数据库的优化啊、怎么防止SQL注入攻击啊…如果你用笔都不能写下你想要表达的东西，你怎么能用言语讲述出来呢？此外，如果你真的有水平，笔试也是你展示自己的一个很好的机会。如果你的答案与别人与众不同且正确，那么肯定会得到面试官的青睐。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>小伙子，还是要一步一个脚印踏踏实实来，打好基础，并多思考技术背后的原理…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;小记&quot;&gt;&lt;a href=&quot;#小记&quot; class=&quot;headerlink&quot; title=&quot;小记&quot;&gt;&lt;/a&gt;小记&lt;/h3&gt;&lt;p&gt;大二开学第一周，自己就尝试着扮演大三或者大四的角色，加入到找实习找工作的行列中，体验生活。在这一周的折腾中，自己也有所感悟。&lt;/p&gt;
&lt;h3
    
    </summary>
    
      <category term="life" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次深信服网上笔试</title>
    <link href="http://yoursite.com/2017/09/22/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%BD%91%E4%B8%8A%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2017/09/22/记一次深信服网上笔试/</id>
    <published>2017-09-21T23:28:19.000Z</published>
    <updated>2017-09-21T15:48:37.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大一暑假，在蓝杰学习，看到很多学长到外面实习，自己也对外面的时间充满着期待，也想去外面闯荡一番…新学期开始，很多企业来学校校招，自己虽然大二，但也鼓足勇气投了简历，一股劲地向前冲。</p>
<h3 id="笔试经历"><a href="#笔试经历" class="headerlink" title="笔试经历"></a>笔试经历</h3><p>现在想想，自己应该有投了七八个简历了，但只参见了猎豹和深信服的笔试，走得最远的也仅限于笔试了。猎豹的笔试是考的C++和一些算法，自己是惨败啊。今晚呢，再次抱着找虐的心态参加了深信服的网上笔试。自己投的是PHP的开发岗，但考的不仅仅是PHP的知识，还有一些数据结构和算法的知识，可见数据结构和算法对于程序员来说是多么重要的东西。</p>
<p>既然投的是PHP嘛，当然还是有PHP方面的东西的啦。笔试中还设计了PHP对字符串对数组的操作，还有 一些面向对象的知识，比如说叫你写出五个魔方函数啊…这些都是一些最基本的东西，但说实话，自己在写代码的时候，真的还没关注过这些，都是在要用的时候在查的，所以结果就是自己的惨败啦。</p>
<p>最令我想不到的是，笔试中还有一些网络安全、服务器和数据库方面的知识。比如说简单叙述下GET和POST的区别，这个自己虽然有看过，但要细讲还是有难度的。自己还碰到了很多答不上来的题，比如说简单叙述Nginx和Apache的区别，怎么防止SQL注入攻击，怎么提高Mysql的性能…我的天，这可让我如何是好。反正就是一句话，自己需要学习和钻研的东西还有很多…</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过这几次的折腾，自己知道基础的重要性，并且对知识的掌握不能只停留在表面，还应该深入地研究，做到见树见林。<strong>革命尚未成功，同志仍需努力</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;大一暑假，在蓝杰学习，看到很多学长到外面实习，自己也对外面的时间充满着期待，也想去外面闯荡一番…新学期开始，很多企业来学校校招，自己虽然大二
    
    </summary>
    
    
  </entry>
  
</feed>
