<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-27T13:32:58.379Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构|什么是数据结构</title>
    <link href="http://yoursite.com/2017/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2017/09/28/数据结构-什么是数据结构/</id>
    <published>2017-09-27T20:29:18.000Z</published>
    <updated>2017-09-27T13:32:58.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h3><p>自己在大一时，就从学长口中得知数据结构的重要性，自己也买书琢磨了一波，但对此的理解也仅限与表面，没有了解到其的奥秘。不过，随着一年多的编程，自己逐渐了解数据结构的重要性，也逐渐揭开他的面纱…</p>
<p>作为 一名计算机专业的学生，写的代码不能仅限于实现功能，我们应该有更高的追求，比如说尽量使用较少的空间啊、让程序能运行的更快啊…这些都是我们需要注意的。数据结构作为计算机专业的基本课程，个人觉得就是教我们怎么更合理地使用内存及硬盘，简单间就是怎么最大化利用我们的存储空间；还有就是怎么来存放我们的数据，以便我们能更好更快的操作数据，比如说查找、删除、添加…</p>
<h3 id="什么数据结构"><a href="#什么数据结构" class="headerlink" title="什么数据结构"></a>什么数据结构</h3><p>对于数据结构的定义，我们应该分开来看：一个是数据，另一个数结构。首先，我们先说说什么是数据：</p>
<h4 id="什么是数据"><a href="#什么是数据" class="headerlink" title="什么是数据"></a>什么是数据</h4><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。这个官方定义不是很容易理解，用我们自己的话说，数据就是计算机能处理的东西，比如说整型、实数型，当然，还包括字符、声音、图像…比如说我们常用的搜索引擎，一般会有网页、MP3、图片、视频等分类。其中，MP3是声音数据，图片是图像数据。说白了，我们所说的数据就是符号，但其必须具有两个属性：</p>
<ul>
<li>可以输入到计算机中</li>
<li>能被计算机处理</li>
</ul>
<p>对于整型、实数型等数值数据，计算机可以进行数值计算；对于字符数据类型，需要进行非数值处理。而声音、图像、视频等其实可以通过编码的手段编程字符数据来处理。</p>
<h4 id="什么是结构"><a href="#什么是结构" class="headerlink" title="什么是结构"></a>什么是结构</h4><p>结构，简单来说就是数据之间的关系。我们都知道，在现实中，不同数据之间不是独立的，而是存在某种特定的关系，我们称这些关系为结构。那么在计算机中也是如此，计算机中的数据并不是孤立的、杂乱无章的，而是具有内在联系的数据集合。我们要写一个好的程序，就要分析处理对象的特性及各处理对象之间存在的关系。我们知道了结构就是关系，那么都有那些具体的关系呢？</p>
<p>按照视点的不同，我们把数据结构分为逻辑结构和物理结构。</p>
<h5 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><p>逻辑结构：是指数据对象中数据元素之间的相互关系。</p>
<p>集合关系：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。就是类似与我们数学中所说的集合，各元素之间没有关系，彼此平等。</p>
<p>线性结构：线性结构中的数据元素之间是一对一的关系。就像排队一样，我们只和我们前面的人有关系，和其他人没有关系。</p>
<p>树形结构：树形结构中的元素之间存在一种一对多的层次关系。就像我们所见的数一样，从下往上，枝叶逐渐增多，但下一层只和上一层有关系。</p>
<p>图形结构：图形结构的数据元素是多对多的关系，就像地图一样，不同的节点之间都会有关系。</p>
<p>逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据之间的逻辑关系，我们要懂得根据实际的问题来选择合适的结构来组织我们的数据。</p>
<h5 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h5><p>物理结构：是指数据的逻辑结构在计算机中的存储形式。说白了，选定了具体的逻辑结构后，我们要怎么样把数据存在计算机中。数据的物理结构应该正确反映数据元素之间的逻辑关系。如何在计算机中存储元素之间的逻辑关系，是实现物理结构的重点和难点。</p>
<p>顺序存储结构：把数据元素存放在地址连续的存储单元中。这种存储结构很简单，就类似与我们开的数组，大家按顺序排好队，每个人占一端空间，大家都不插队。这种方式存储数据，最大的好处是易于遍历，大家都在一起，当然容易遍历啦，但是删除操作就很麻烦，需要把要删除的数字后面的数都往上移位。</p>
<p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元不一定是要连续的。哪要怎么从找到下一个位置呢？这时候就需要指针上场了。这种存储方式比较灵活，数据存放在那不重要，只要一个指针存放了相应的地址就能找到。但查找就很困难了，因为每一次查找都必须从头开始查找。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开场白&quot;&gt;&lt;a href=&quot;#开场白&quot; class=&quot;headerlink&quot; title=&quot;开场白&quot;&gt;&lt;/a&gt;开场白&lt;/h3&gt;&lt;p&gt;自己在大一时，就从学长口中得知数据结构的重要性，自己也买书琢磨了一波，但对此的理解也仅限与表面，没有了解到其的奥秘。不过，随着一年多
    
    </summary>
    
      <category term="DataStruct" scheme="http://yoursite.com/categories/DataStruct/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>生活|记一周的求职经历</title>
    <link href="http://yoursite.com/2017/09/25/%E7%94%9F%E6%B4%BB-%E8%AE%B0%E4%B8%80%E5%91%A8%E7%9A%84%E6%B1%82%E8%81%8C%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2017/09/25/生活-记一周的求职经历/</id>
    <published>2017-09-25T00:03:54.000Z</published>
    <updated>2017-09-24T16:49:29.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h3><p>大二开学第一周，自己就尝试着扮演大三或者大四的角色，加入到找实习找工作的行列中，体验生活。在这一周的折腾中，自己也有所感悟。</p>
<h3 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h3><h4 id="猎豹移动"><a href="#猎豹移动" class="headerlink" title="猎豹移动"></a>猎豹移动</h4><p>自己在宣讲会的前一天就在蓝杰见到 Hr 小姐姐了，听小姐姐讲了猎豹移动的一些信息，比如员工宿舍啊、食堂啊、培养计划啊…说实话，自己当时是很被吸引的，也很希望自己能有机会到这样的公司里学习。第二天晚上（周一），自己约上几个学长，就一起听了宣讲会，然后参加笔试。当然，笔试的结果是惨败（在前前一篇文章就讲过了），这里就不细讲了。</p>
<h4 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h4><p>深信服的笔试是在网上弄的。自己也不知到怎么滴就投了PHP岗位的，虽然也学过并用PHP开发了新生宝典，但熟练程度还不至于背出来一些常见函数啊，基本上都是现用现查的，所以结果可想而知。除了PHP，笔试还设计了服务器、linux、数据库方面的知识，也就是关于网站的方方面面都有了，并且都是一些很深入的问题，比如说怎么Apache和Nginx的差别啊，Nginx还有什么其他的作用啊；怎么优化Mysql数据库啊；怎么防止sql注入攻击啊；各种数据库引擎的不同啊…哇，我天，我只能说自己要走的路还很长呢…</p>
<h4 id="恒生"><a href="#恒生" class="headerlink" title="恒生"></a>恒生</h4><p>恒生的笔试是在今天（周六）进行的。自己本来不想去的，但仔细想想反正周六也没什么事，就去玩玩嘛，就在学校。笔试的题目感觉还可以，不算难，就是一些基础的东西，但自己还是不是很懂，可能好久没有看了吧，记忆有点模糊了。笔试中考了一些简单的数据库操作，就是给你一些表，让你写SQL语句找出需要的数据，说实话，这是很容易的，但自己基本都是用客户端操作数据库的，并且用到的都是一些简单的增删改查，总之，就是自己不懂做。</p>
<h4 id="博登信息"><a href="#博登信息" class="headerlink" title="博登信息"></a>博登信息</h4><p>这是唯一一家不需要笔试的，投简历就直接通知面试了。周五下午去面试，更可恶的是并不是一个懂技术的人来面试而是Hr小姐姐来跟我聊，聊的就是自己的一些情况：在学校学了什么 核心课，自己有学了什么，做过什么，并没有问用到什么技术。好吧，我也无话可说啊。虽然不是技术面试，但也算是面试，自己感觉自己表现还是可以的，不是很紧张，也表达出来了自己想要表达的东西。如果放在中学，自己肯定会吞吞吐吐的，不懂怎么组织语言，讲话没主次.。 </p>
<h3 id="自己的一些感悟"><a href="#自己的一些感悟" class="headerlink" title="自己的一些感悟"></a>自己的一些感悟</h3><p>经过这一周的折腾，自己还是有点收获的，也明确了自己今后的学习重点，折腾是值得的。同时，也意识到笔试是个很重要的东西，笔试也确实能看出一个人的水平。同时，笔试考的知识，也同样是面试的时候，面试官要问你的问题，比如说上面提到的Mysql数据库的优化啊、怎么防止SQL注入攻击啊…如果你用笔都不能写下你想要表达的东西，你怎么能用言语讲述出来呢？此外，如果你真的有水平，笔试也是你展示自己的一个很好的机会。如果你的答案与别人与众不同且正确，那么肯定会得到面试官的青睐。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>小伙子，还是要一步一个脚印踏踏实实来，打好基础，并多思考技术背后的原理…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;小记&quot;&gt;&lt;a href=&quot;#小记&quot; class=&quot;headerlink&quot; title=&quot;小记&quot;&gt;&lt;/a&gt;小记&lt;/h3&gt;&lt;p&gt;大二开学第一周，自己就尝试着扮演大三或者大四的角色，加入到找实习找工作的行列中，体验生活。在这一周的折腾中，自己也有所感悟。&lt;/p&gt;
&lt;h3
    
    </summary>
    
      <category term="life" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次深信服网上笔试</title>
    <link href="http://yoursite.com/2017/09/22/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%BD%91%E4%B8%8A%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2017/09/22/记一次深信服网上笔试/</id>
    <published>2017-09-21T23:28:19.000Z</published>
    <updated>2017-09-21T15:48:37.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大一暑假，在蓝杰学习，看到很多学长到外面实习，自己也对外面的时间充满着期待，也想去外面闯荡一番…新学期开始，很多企业来学校校招，自己虽然大二，但也鼓足勇气投了简历，一股劲地向前冲。</p>
<h3 id="笔试经历"><a href="#笔试经历" class="headerlink" title="笔试经历"></a>笔试经历</h3><p>现在想想，自己应该有投了七八个简历了，但只参见了猎豹和深信服的笔试，走得最远的也仅限于笔试了。猎豹的笔试是考的C++和一些算法，自己是惨败啊。今晚呢，再次抱着找虐的心态参加了深信服的网上笔试。自己投的是PHP的开发岗，但考的不仅仅是PHP的知识，还有一些数据结构和算法的知识，可见数据结构和算法对于程序员来说是多么重要的东西。</p>
<p>既然投的是PHP嘛，当然还是有PHP方面的东西的啦。笔试中还设计了PHP对字符串对数组的操作，还有 一些面向对象的知识，比如说叫你写出五个魔方函数啊…这些都是一些最基本的东西，但说实话，自己在写代码的时候，真的还没关注过这些，都是在要用的时候在查的，所以结果就是自己的惨败啦。</p>
<p>最令我想不到的是，笔试中还有一些网络安全、服务器和数据库方面的知识。比如说简单叙述下GET和POST的区别，这个自己虽然有看过，但要细讲还是有难度的。自己还碰到了很多答不上来的题，比如说简单叙述Nginx和Apache的区别，怎么防止SQL注入攻击，怎么提高Mysql的性能…我的天，这可让我如何是好。反正就是一句话，自己需要学习和钻研的东西还有很多…</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过这几次的折腾，自己知道基础的重要性，并且对知识的掌握不能只停留在表面，还应该深入地研究，做到见树见林。<strong>革命尚未成功，同志仍需努力</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;大一暑假，在蓝杰学习，看到很多学长到外面实习，自己也对外面的时间充满着期待，也想去外面闯荡一番…新学期开始，很多企业来学校校招，自己虽然大二
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的第一次笔试</title>
    <link href="http://yoursite.com/2017/09/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2017/09/20/我的第一次笔试/</id>
    <published>2017-09-20T00:19:01.000Z</published>
    <updated>2017-09-19T16:39:49.694Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h3><p>现在是北京时间 2017年9月20号凌晨零点20分，距我人生第一次笔试已经过去了一天了。我是在18号进行笔试的，Hr 说笔试后第二天会发面试通知，所以整晚我都在满怀期待地等待着，直到过了12点，最后的希望都烟消云散了…</p>
<h3 id="笔试ing"><a href="#笔试ing" class="headerlink" title="笔试ing"></a>笔试ing</h3><p>总的来说，这次笔试是比较简单的，考的都是一些基础题，比如说第一题就考了指针，第二题考了树的遍历方法，第三题考了排序算法…这些东西自己在大一的时候都有接触过，但并没有深入的了解，只是知道这些东西的存在，所以也导致笔试的时候不能百分百确定答案。这些东西虽然基础，但恰恰就是因为基础，我们才需要真真正正地弄懂，并深入的了解他。这也怪自己大一的时候不懂事，觉得这些东西用不上，就没有深入地去了解，导致笔试的惨败。笔试还考了一些算法，对字符串、数组的操作啊。对于算法这一块，自己也是近期才认识到它的重要性，以前觉得它难，但小学期练了一些CCF的题之后，接触到了一些算法，比如动态规划、最短路径啊，虽然一时难以理解，但花点时间慢慢琢磨，还是能弄懂的。算法当然也不是短时间内就能提高的，需要时间来积累，慢慢钻研，当量足够的时候，才能有质的改变。最后一道题是讲述网络的，就是叫你描述一下从输入网址到显示网页，这一过程中发生了什么。本来呢，自己在网络这一块应该是可以的，但是因为好久没看了，只是知道个大概，细节的一些东西都忘了，自己答得也不是很好。网络这东西，也是需要慢慢研究的啊。</p>
<h3 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h3><p>通过这一次惨败，自己懂得了许多。</p>
<ul>
<li>对于基础的学习，不能小视，需重视，吃透它，深入它</li>
<li>对于算法啊、网络啊，这些必须的知识，要经常性地复习，做到能描述的清清楚楚</li>
</ul>
<p>虽败，但不能服输。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简要&quot;&gt;&lt;a href=&quot;#简要&quot; class=&quot;headerlink&quot; title=&quot;简要&quot;&gt;&lt;/a&gt;简要&lt;/h3&gt;&lt;p&gt;现在是北京时间 2017年9月20号凌晨零点20分，距我人生第一次笔试已经过去了一天了。我是在18号进行笔试的，Hr 说笔试后第二天会发面试
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK环境配置</title>
    <link href="http://yoursite.com/2017/09/13/JDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/09/13/JDK环境配置/</id>
    <published>2017-09-13T00:14:54.000Z</published>
    <updated>2017-09-12T16:55:10.061Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这几天在学习Struts框架，要求的jdk版本不能太高，可恨的是，自己正在使用的是1.8的，无奈之下，只能卸载了重新装 1.7 版本的。</p>
<h3 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h3><h4 id="安装JDK开发环境"><a href="#安装JDK开发环境" class="headerlink" title="安装JDK开发环境"></a>安装JDK开发环境</h4><ol>
<li>下载：<a href="http://www.oracle.com/" target="_blank" rel="external">下载网站</a> 下载就跟我们平时下载软件一样，不过要下载符合自己操作系统的镜像。</li>
<li>开始安装  安装过程也跟我们安装软件一样，不过建议最好改一下安装的位置，就别放在C盘啦。</li>
</ol>
<p>注：当提示安装JRE时，可以选择不要安装。但如果要安装，就不能放在刚刚安装 jdk 同一级目录中。比如 jdk安装在  D:\Program Files\Java\ ；jre就不能安装在 D:\Program Files\Java\了，可以这样安装 ：jdk安装在 D:\Program Files\Java\jdk1.7.0_80 ；jre安装在 D:\Program Files\Java\jre7 。原因是安装jre的时候会覆盖掉jdk中的一些 jre 包，导致缺少tools.jar。</p>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>对于Java程序开发而言，主要会使用JDK的两个命令：javac.exe、java.exe。路径：C:\Java\jdk 1.7.0 _09\bin。但是这些命令由于不属于windows自己的命令，所以要想使用，就需要进行路径配置。 </p>
<p>单击“计算机-属性-高级系统设置”，单击“环境变量”。在“系统变量”栏下单击“新建”，创建新的系统环境变量。</p>
<p>需要创建的环境变量有：</p>
<ol>
<li>新建-&gt;变量名”JAVA_HOME”，变量值<strong>“C:\Java\jdk1.8.0_05”（即JDK的安装路径）</strong></li>
<li>编辑-&gt;变量名”Path”，在原变量值的最后面加上<strong>“;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin”</strong></li>
<li>新建-&gt;变量名“CLASSPATH”,变量值<strong>“.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”</strong>不要忘记 .  。</li>
</ol>
<h4 id="确认环境配置是否真确"><a href="#确认环境配置是否真确" class="headerlink" title="确认环境配置是否真确"></a>确认环境配置是否真确</h4><p>在控制台分别输入java，javac，java -version 命令，出现如下所示的JDK的编译器信息，包括修改命令的语法和参数选项等信息。如果都出现了，就说明你成功了。</p>
<h4 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h4><p>写下自己的第一个Java程序 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;    </div><div class="line">    System.out.println(&quot;Hello Java&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保存为hello.java , 然后在文件所在目录下打开命令行窗口，依次输入  javac hello.java ,java hello 命令，就会在命令行打印出 “HelloWorld” 了。</p>
<p>程序解析：</p>
<p>首先编写java源代码程序，扩展名.java；<br>在命令行模式中，输入命令：javac 源文件名.java，对源代码进行编译，生成class字节码文件；<br>编译完成后，如果没有报错信息，输入命令：java HelloWorld，对class字节码文件进行解释运行,执行时不需要添加.class扩展名。</p>
<p>注：若在CMD中输入javac test.java命令后，显示’javac’不是内部或外部命令，原因是因为没有提前安装好JDK开发环境或环境变量配置有误。 </p>
<blockquote>
<p><a href="http://www.cnblogs.com/smyhvae/p/3788534.html" target="_blank" rel="external">参考资料</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这几天在学习Struts框架，要求的jdk版本不能太高，可恨的是，自己正在使用的是1.8的，无奈之下，只能卸载了重新装 1.7 版本的。&lt;/
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/09/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/"/>
    <id>http://yoursite.com/2017/09/11/动态规划经典例题/</id>
    <published>2017-09-11T01:54:48.479Z</published>
    <updated>2017-09-16T16:43:37.079Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划——由实践总结经验</p>
<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul>
<li>基础题目<ul>
<li>矩阵取数问题</li>
<li>最大子段和</li>
<li>最长公共子序列问题</li>
<li>编辑距离问题</li>
<li>最长单增子序列</li>
<li>0-1背包问题</li>
<li>正整数分组</li>
</ul>
</li>
<li>进阶题目<br>  -最大子矩阵和<ul>
<li>循环数组最大字段和</li>
<li>多重背包问题</li>
</ul>
</li>
</ul>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学校出门一台政策，要求计算机专业的学生必须参加CCF的考试，且必须通过考核后，才能毕业.无奈之下，需要认真钻研动态规划算法，应付考试。在经过两周多的训练和查阅资料，对其有了一点理解理解。</p>
<p>在我看来，动态规划的核心在于将待求解问题分解为子问题，子问题的规模小于原问题，并且求解方法一致，但原问题的求解依赖于子问题，子问题之间往往不相互独立。典型特征就是，动态规划中所使用的递推公式。与之相比，分治法的核心在于将原问题规模缩小，分解为多个子问题，且各个子问题之间相互独立。</p>
<p>核心思想：</p>
<ul>
<li>全局最优解包含局部最优解。</li>
<li>状态转移方程</li>
</ul>
<h3 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h3><h4 id="矩阵取数问题"><a href="#矩阵取数问题" class="headerlink" title="矩阵取数问题"></a>矩阵取数问题</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>一个NN矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。</p>
<p>例如：3 3的方格。<br>1 3 3<br>2 1 3<br>2 2 1<br>能够获得的最大价值为：11。</p>
<p>输入<br>第1行：N，N为矩阵的大小。(2 &lt;= N &lt;= 500)<br>第2 - N + 1行：每行N个数，中间用空格隔开，对应格子中奖励的价值。（1 &lt;= N[i] &lt;= 10000)<br>输出<br>输出能够获得的最大价值。<br>输入示例<br>3<br>1 3 3<br>2 1 3<br>2 2 1<br>输出示例<br>11</p>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; nums(n);</div><div class="line">    vector&lt;vector&lt;long long&gt; &gt; dp(n + 1);</div><div class="line">    for(int i = 0; i &lt; n;i++)&#123;</div><div class="line">        vector&lt;int&gt; row(n);</div><div class="line">        vector&lt;long long&gt; maxRow(n + 1,0);</div><div class="line">        for(int j = 0;j &lt; n;j++)&#123;</div><div class="line">            cin &gt;&gt; row[j];</div><div class="line">        &#125;</div><div class="line">        nums[i] = row;</div><div class="line">        dp[i] = maxRow;</div><div class="line">    &#125;</div><div class="line">    vector&lt;long long&gt; maxRow(n + 1,0);</div><div class="line">    dp[n] = maxRow;</div><div class="line"></div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        for(int j = 1; j &lt;= n; j++)&#123;</div><div class="line">            dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]) + nums[i - 1][j - 1];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt; dp[n][n]&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在本例中，我们用dp[i][j]来表示从点（0，0）走到点（i,j）时，所能得到的最大值，也就是说，dp[][]数组中存储的是从原点到点（i,j）的所有有局部最优解，这就体现了我们重要思想中的 <strong>全局最优解包含局部最优解*</strong>。简单点说，最后的解就是通过前面的局部的最优解通过状态转移方程一步步的得到的。</p>
<h4 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。当所给的整数均为负数时和为0。<br>例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。</p>
<p>输入<br>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：N个整数（-10^9 &lt;= A[i] &lt;= 10^9）<br>输出<br>输出最大子段和。<br>输入示例<br>6<br>-2<br>11<br>-4<br>13<br>-5<br>-2<br>输出示例<br>20</p>
<h6 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">/*动态规划算法:</div><div class="line">b[j]=max&#123;a[i]++a[j]&#125;,1&lt;=i&lt;=j,且1&lt;=j&lt;=n,则所求的最大子段和为max b[j]，1&lt;=j&lt;=n。</div><div class="line"></div><div class="line">由b[j]的定义可易知，当b[j-1]&gt;0时b[j]=b[j-1]+a[j]，否则b[j]=a[j]。故b[j]</div><div class="line">的动态规划递归式为:</div><div class="line"></div><div class="line">b[j]=max(b[j-1]+a[j],a[j])，1&lt;=j&lt;=n。</div><div class="line">代码中，pre就相当与b[j]；result保存b[j]中的最大值</div><div class="line">T(n)=O(n)</div><div class="line">*/</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    int cur;</div><div class="line">    cin &gt;&gt; cur;</div><div class="line">    long long result = cur;</div><div class="line">    long long pre = cur;</div><div class="line">    for(int i = 1; i &lt; n;i++)&#123;</div><div class="line">       cin &gt;&gt; cur;</div><div class="line">       if(pre &gt; 0)&#123;</div><div class="line">           pre = pre + cur;</div><div class="line">       &#125;</div><div class="line">       else&#123;</div><div class="line">           pre = cur;</div><div class="line">       &#125;</div><div class="line">       if(pre &gt; result)&#123;</div><div class="line">           result = pre;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; result&lt;&lt;endl;</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">/*</div><div class="line">动态规划:数组为in[]，设dp[i] 是以in[i]结尾的子数组的最大和.</div><div class="line">对于元素in[i+1],它有两种选择：a、vec[i+1]接着前面的子数组构成最大和，b、in[i+1]自己单独构成子数组。</div><div class="line">则dp[i+1] = max&#123;dp[i]+in[i+1],  in[i+1]&#125;</div><div class="line">*/</div><div class="line">int main()&#123;</div><div class="line">    int n;cin&gt;&gt;n;</div><div class="line">    int in[n];</div><div class="line">    int dp[n];</div><div class="line">    for(int i=0;i&lt;n;i++)&#123;</div><div class="line">        cin&gt;&gt;in[i];</div><div class="line">        dp[i]=in[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(int i=1;i&lt;n;i++)&#123;</div><div class="line">        dp[i] = max(dp[i-1]+in[i],  in[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(int i=0;i&lt;n;i++)&#123;</div><div class="line">        cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>对于此题呢，这里给出了两种写法，但两者思想都是一样的，都是用了动态规划的思想。在第一中写法中，我们用变量pre代表序列中以 i 结尾的连续数列的最大值，这就是当前i的最优节，一个局部最优解，通过状态转移方程不断得到全部的最优解。第二种写法是比较容易接受的，dp[i] 代表的是序列中以 i 结尾的连续数列的最大值,那么dp[i+1]=max(dp[i]+a[i+1],a[i+1])。</p>
<h4 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>最长公共子序列的问题常用于解决字符串的相似度，是一个非常实用的算法，作为码农，此算法是我们的必备基本功。</p>
<p>给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。<br>比如两个串为：<br>abcicba<br>abdkscab<br>ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。</p>
<p>输入<br>第1行：字符串A<br>第2行：字符串B<br>(A,B的长度 &lt;= 1000)<br>输出<br>输出最长的子序列，如果有多个，随意输出1个。</p>
<p>输入示例<br>abcicba<br>abdkscab<br>输出示例<br>abca</p>
<h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line">using namespace std;</div><div class="line">typedef struct &#123;</div><div class="line">    int x;</div><div class="line">    int y;</div><div class="line">    char node = &apos;\0&apos;;</div><div class="line">    int maxLength = 0;</div><div class="line">&#125; DpNode;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    string a;</div><div class="line">    string b;</div><div class="line">    std:cin &gt;&gt; a &gt;&gt;b;</div><div class="line">    vector&lt;vector&lt;DpNode&gt; &gt; dp(a.size() + 1);</div><div class="line">    for (int i = 0; i &lt;= a.size(); i++) &#123;</div><div class="line">        vector&lt;DpNode&gt; dpRow(b.size() + 1);</div><div class="line">        dp[i] = dpRow;</div><div class="line">    &#125;</div><div class="line">    for (int i = 1; i &lt;= a.size(); i++) &#123;</div><div class="line">        for (int j = 1; j &lt;= b.size(); j++) &#123;</div><div class="line">            if (a[i - 1] == b[j - 1]) &#123;</div><div class="line">                dp[i][j].maxLength = dp[i - 1][j - 1].maxLength + 1;</div><div class="line">                dp[i][j].x = i - 1;</div><div class="line">                dp[i][j].y = j - 1;</div><div class="line">                dp[i][j].node = a[i - 1];</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                if (dp[i - 1][j].maxLength &gt; dp[i][j - 1].maxLength) &#123;</div><div class="line">                    dp[i][j].maxLength = dp[i - 1][j].maxLength;</div><div class="line">                    dp[i][j].x = i - 1;</div><div class="line">                    dp[i][j].y = j;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    dp[i][j].maxLength = dp[i][j - 1].maxLength;</div><div class="line">                    dp[i][j].x = i;</div><div class="line">                    dp[i][j].y = j - 1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int x = a.size();</div><div class="line">    int y = b.size();</div><div class="line">    char c;</div><div class="line">    list&lt;char&gt; result;</div><div class="line">    int xTemp;</div><div class="line">    while (x != 0 &amp;&amp; y != 0) &#123;</div><div class="line">        c = dp[x][y].node;</div><div class="line">        if (c != &apos;\0&apos;) &#123;</div><div class="line">            result.push_front(c);</div><div class="line">        &#125;</div><div class="line">        xTemp = x;</div><div class="line">        x = dp[xTemp][y].x;</div><div class="line">        y = dp[xTemp][y].y;</div><div class="line">    &#125;</div><div class="line">    for (list&lt;char&gt;::iterator it = result.begin(); it != result.end(); it++) &#123;</div><div class="line">        cout &lt;&lt; *it;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。<br>例如将kitten一字转成sitting：<br>sitten （k-&gt;s）<br>sittin （e-&gt;i）<br>sitting （-&gt;g）<br>所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。<br>给出两个字符串a,b，求a和b的编辑距离。<br>输入<br>第1行：字符串a(a的长度 &lt;= 1000)。<br>第2行：字符串b(b的长度 &lt;= 1000)。<br>输出<br>输出a和b的编辑距离。</p>
<p>输入示例<br>kitten<br>sitting<br>输出示例<br>3</p>
<h5 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    string a;</div><div class="line">    string b;</div><div class="line">    cin &gt;&gt; a &gt;&gt; b;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; dp(a.size() + 1);</div><div class="line">    vector&lt;int&gt; dpRow(b.size() + 1);</div><div class="line">    dp[0] = dpRow;</div><div class="line">    for(int i = 0; i &lt;= b.size();i++ )&#123;</div><div class="line">        dp[0][i] = i;</div><div class="line">    &#125;</div><div class="line">    for(int i = 1; i &lt;= a.size();i++)&#123;</div><div class="line">        vector&lt;int&gt; dpRow(b.size() + 1);</div><div class="line">        dp[i] = dpRow;</div><div class="line">        dp[i][0] = i;</div><div class="line">    &#125;</div><div class="line">    int minTemp;</div><div class="line">    for(int i = 0; i &lt; a.size();i++)&#123;</div><div class="line">        for(int j = 0; j &lt; b.size();j++)&#123;</div><div class="line">            if(a[i] == b[j])&#123;</div><div class="line">                dp[i + 1][j + 1] = dp[i][j];</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                minTemp = min(dp[i][j] + 1,dp[i][j + 1] + 1);</div><div class="line">                dp[i + 1][j + 1] = min(minTemp,dp[i + 1][j] + 1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout&lt;&lt;dp[a.size()][b.size()]&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最长单增子序列"><a href="#最长单增子序列" class="headerlink" title="最长单增子序列"></a>最长单增子序列</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的）<br>例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。<br>输入<br>第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9)<br>输出<br>输出最长递增子序列的长度。<br>输入示例<br>8<br>5<br>1<br>6<br>8<br>2<br>4<br>5<br>10<br>输出示例<br>5</p>
<h5 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;climits&gt;</div><div class="line">using namespace std;</div><div class="line">/**</div><div class="line"> * maxs[x] 中记录了目前单调子序列中长度为x的所有子序列中，最后一个元素的最小值。</div><div class="line"> * 比如当然有两个单调子序列长度为2: 1 3; 1 4。maxs[2] = 3</div><div class="line"> * 代表了最优情况，因为元素越小继续延伸的潜力越大</div><div class="line"> */</div><div class="line">void updateMaxArray(vector&lt;int&gt; &amp;maxs, int newNum)</div><div class="line">&#123;</div><div class="line">    int temp = 0;</div><div class="line">    for (int left = 0, right = maxs.size() - 1, mid = left + (right - left) / 2; left &lt;= right;) &#123;</div><div class="line">        if (maxs[mid] &lt; newNum) &#123;</div><div class="line">            temp = mid;</div><div class="line">            left = mid + 1;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            right = mid - 1;</div><div class="line">        &#125;</div><div class="line">        mid = left + (right - left) / 2;</div><div class="line">    &#125;</div><div class="line">    if (temp != maxs.size() - 1) &#123;</div><div class="line">        maxs[temp + 1] = newNum;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        maxs.insert(maxs.begin() + temp + 1, newNum);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    int cur;</div><div class="line">    vector&lt;int&gt; maxs(1, INT_MIN);</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        cin &gt;&gt; cur;</div><div class="line">        updateMaxArray(maxs, cur);</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; (maxs.size() - 1) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。<br>输入<br>第1行，2个整数，N和W中间用空格隔开。N为物品的数量，W为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= W &lt;= 10000)<br>第2 - N + 1行，每行2个整数，Wi和Pi，分别是物品的体积和物品的价值。(1 &lt;= Wi, Pi &lt;= 10000)<br>输出<br>输出可以容纳的最大价值。<br>输入示例<br>3 6<br>2 5<br>3 8<br>4 9<br>输出示例<br>14<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">int dp[101][10001];</div><div class="line">/**</div><div class="line"> * dp[i][j] -&gt; 在前个物品中任意选取，容量不超过j的物品最大价值</div><div class="line"> * dp[i][j] = dp[i-1][j] 第i个物品的重量大于j</div><div class="line"> * dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]] + p[i]) 否则</div><div class="line"> */</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n,m;</div><div class="line">    cin &gt;&gt; n &gt;&gt; m;</div><div class="line">    vector&lt;int&gt; w(n + 1);</div><div class="line">    vector&lt;int&gt; p(n + 1);</div><div class="line">    for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">        cin &gt;&gt; w[i] &gt;&gt; p[i];</div><div class="line">    &#125;</div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        for(int j = 1;j &lt;= m;j++)&#123;</div><div class="line">            if(w[i] &lt;= j)&#123;</div><div class="line">                dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - w[i]] + p[i]);</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                dp[i][j] = dp[i - 1][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="正整数分组"><a href="#正整数分组" class="headerlink" title="正整数分组"></a>正整数分组</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>将一堆正整数分为2组，要求2组的和相差最小。<br>例如：1 2 3 4 5，将1 2 4分为1组，3 5分为1组，两组和相差1，是所有方案中相差最少的。<br>输入<br>第1行：一个数N，N为正整数的数量。<br>第2 - N+1行，N个正整数。<br>(N &lt;= 100, 所有正整数的和 &lt;= 10000)<br>输出<br>输出这个最小差<br>输入示例<br>5<br>1<br>2<br>3<br>4<br>5<br>输出示例<br>1<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">/**</div><div class="line"> * f[i][j] -&gt; 在前i个数中选取一些数，总和不超过j的最大值</div><div class="line"> * f[i][j] = f[i-1][j]  第i个数大于j</div><div class="line"> * f[i][j] = max(f[i - 1][j],f[i - 1][j - nums[i - 1]] + nums[i - 1]) 否则</div><div class="line"> */</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    vector&lt;int&gt; nums(n);</div><div class="line">    int total = 0;</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        cin &gt;&gt; nums[i];</div><div class="line">        total = total+ nums[i];</div><div class="line">    &#125;</div><div class="line">    int half = total / 2;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; f(n + 1);</div><div class="line">    for (int i = 0; i &lt;= n; i++) &#123;</div><div class="line">        vector&lt;int&gt; temp(half + 1);</div><div class="line">        f[i] = temp;</div><div class="line">    &#125;</div><div class="line">    vector&lt;vector&lt;int&gt; &gt;::iterator fIter = f.begin();</div><div class="line">    fill((*fIter).begin(),(*fIter).end(),0);</div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        for(int j = 1; j &lt;= half;j++)&#123;</div><div class="line">            if(nums[i - 1] &gt; j)&#123;</div><div class="line">                f[i][j] = f[i - 1][j];</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                f[i][j] = max(f[i - 1][j],f[i - 1][j - nums[i - 1]] + nums[i - 1]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; (total - 2*f[n][half])  &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="进阶题目"><a href="#进阶题目" class="headerlink" title="进阶题目"></a>进阶题目</h3><h4 id="最大子矩阵和"><a href="#最大子矩阵和" class="headerlink" title="最大子矩阵和"></a>最大子矩阵和</h4><p>问题描述<br>一个MN的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的值。<br>例如：33的矩阵：<br>-1 3 -1<br>2 -1 3<br>-3 1 2<br>和最大的子矩阵是：<br>3 -1<br>-1 3<br>1 2<br>输入<br>第1行：M和N，中间用空格隔开（2 &lt;= M,N &lt;= 500)。<br>第2 - N + 1行：矩阵中的元素，每行M个数，中间用空格隔开。(-10^9 &lt;= M[i] &lt;= 10^9)<br>输出<br>输出和的最大值。如果所有数都是负数，就输出0。<br>输入示例<br>3 3<br>-1 3 -1<br>2 -1 3<br>-3 1 2<br>输出示例<br>7<br>代码说明<br>这道题目与基础题目中的最大子段和有些像，但本题是二维空间。但可以通过一些手段将其转化为一维空间。<br>设想，整个矩阵有3行，最大子矩阵可能的行数1/2/3; 矩阵数组为a[i][j]:<br>矩阵行数为1：分别求第一行、第二行、第三行的最大子段和max1,max2,max3,那么max(max1,max2,max3)即为最大子矩阵和<br>矩阵行数为2：最大子矩阵出现在第1-2行或第2-3行，只有这两种情况。如果有一个一维数组total:<br>total[k] = a[0][k] + a[1][k] total最大字段和max1<br>total[k] = a[1][k] + a[2][k] total最大字段和max2<br>那么max = max(max1,max2)即为最大子矩阵和<br>矩阵行数为3：最大子矩阵出现在第1-3行，只有一种情况。如果有一个一维数组total:<br>total[k] = a[0][k] + a[1][k] + a[2][k] total最大字段和max<br>那么max即为最大子矩阵和<br>通过这个例子是不是可以感受到一些启发？将 第i行到第j行压缩为一行(求和),即可以转化为求解最大子段和,此时可获得行数为(j-i+1)时的最大子矩阵和<br>假设n*m的矩阵的最大子矩阵的行数为i(1&lt;=i&lt;=n) 如果有一个一维数组total:<br>total[k] = a[0][k] + … +a[i-1][k] total最大字段和max1<br>…<br>total[k] = a[n-i][k] + … + a[n - 1][k] total最大字段和max..<br>那么max = max(max1,…)即为最大子矩阵和<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;climits&gt;</div><div class="line">using namespace std;</div><div class="line">/**</div><div class="line">* 求最大字段和</div><div class="line">*/</div><div class="line">int maxSubSequence(vector&lt;int&gt;&amp; arr) &#123;</div><div class="line">    if (arr.size() &gt; 0) &#123;</div><div class="line">        int maxSub = arr[0];</div><div class="line">        int temp = arr[0];</div><div class="line">        for (int i = 1; i &lt; arr.size(); i++) &#123;</div><div class="line">            if (temp &gt; 0) &#123;</div><div class="line">                temp = temp + arr[i];</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                temp = arr[i];</div><div class="line">            &#125;</div><div class="line">            maxSub = max(maxSub, temp);</div><div class="line">        &#125;</div><div class="line">        return maxSub;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int m, n;</div><div class="line">    cin &gt;&gt; m &gt;&gt; n;</div><div class="line">    //初始化</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; nums(n);</div><div class="line">    // total[i][k] = nums[0][k] + ... + nums[i][k];</div><div class="line">    // 所以nums[i..j][k] = total[j][k]-total[i - 1][k]</div><div class="line">    vector&lt;vector&lt;int&gt; &gt; total(n);</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        vector&lt;int&gt; row(m);</div><div class="line">        vector&lt;int&gt; totalRow(m);</div><div class="line">        if (i == 0) &#123;</div><div class="line">            for (int j = 0; j &lt; m; j++) &#123;</div><div class="line">                cin &gt;&gt; row[j];</div><div class="line">                totalRow[j] = row[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            for (int j = 0; j &lt; m; j++) &#123;</div><div class="line">                cin &gt;&gt; row[j];</div><div class="line">                totalRow[j] = total[i - 1][j] + row[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nums[i] = row;</div><div class="line">        total[i] = totalRow;</div><div class="line">    &#125;</div><div class="line">    int maxSub = INT_MIN;</div><div class="line">    // 最大子矩阵行数为 i</div><div class="line">    vector&lt;int&gt; result(m);</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        for (int j = i; j &lt; n; j++) &#123;</div><div class="line">            for (int k = 0; k &lt; m; k++) &#123;</div><div class="line">                if (i == 0) &#123;</div><div class="line">                    result[k] = total[j][k];</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    result[k] = total[j][k] - total[i - 1][k];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            int maxTemp = maxSubSequence(result);</div><div class="line">            if (maxTemp &gt; maxSub) &#123;</div><div class="line">                maxSub = maxTemp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; maxSub &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考<a href="http://blog.csdn.net/beiyeqingteng/article/details/7056687" target="_blank" rel="external">http://blog.csdn.net/beiyeqingteng/article/details/7056687</a></p>
</blockquote>
<h4 id="循环数组最大字段和"><a href="#循环数组最大字段和" class="headerlink" title="循环数组最大字段和"></a>循环数组最大字段和</h4><h5 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h5><p>N个整数组成的循环序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续的子段和的最大值（循环序列是指n个数围成一个圈，因此需要考虑a[n-1],a[n],a[1],a[2]这样的序列）。当所给的整数均为负数时和为0。<br>例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。<br>输入<br>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)<br>第2 - N+1行：N个整数 (-10^9 &lt;= S[i] &lt;= 10^9)<br>输出<br>输出循环数组的最大子段和。<br>输入示例<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>6<br>-2<br>11<br>-4<br>13<br>-5<br>-2<br>输出示例<br>1<br>20<br>代码说明<br>如果最大字段和不是跨越数组头尾的情况，即为普通的最大字段和求解问题。<br>如果最大子段和跨越数组头尾，即 arr[j…n-1] + arr[0…i];易得子段arr[i+1…j-1] 为最小子段和，这种情况也就可以转化为 total[0…n-1] - minSubSequence<br>二者取max即为循环数组最大字段和<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;climits&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt;n;</div><div class="line">    ll cur,preMax,preMin;</div><div class="line">    cin &gt;&gt; preMax;</div><div class="line">    ll total = preMax;</div><div class="line">    ll maxSub = preMax;</div><div class="line">    ll minSub = preMax;</div><div class="line">    preMin = preMax;</div><div class="line">    for(int i = 1;i &lt; n;i++)&#123;</div><div class="line">        cin &gt;&gt; cur;</div><div class="line">        total = total + cur;</div><div class="line">        if(preMax &gt; 0)&#123;</div><div class="line">            preMax = preMax + cur;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            preMax = cur;</div><div class="line">        &#125;</div><div class="line">        if(preMin &lt; 0)&#123;</div><div class="line">            preMin = preMin + cur;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            preMin = cur;</div><div class="line">        &#125;</div><div class="line">        maxSub = max(maxSub,preMax);</div><div class="line">        minSub = min(minSub,preMin);</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; max(maxSub,total - minSub) &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><h5 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h5><p>有N种物品，每种物品的数量为C1，C2……Cn。从中任选若干件放在容量为W的背包里，每种物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。<br>输入<br>第1行，2个整数，N和W中间用空格隔开。N为物品的种类，W为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= W &lt;= 50000)<br>第2 - N + 1行，每行3个整数，Wi，Pi和Ci分别是物品体积、价值和数量。(1 &lt;= Wi, Pi &lt;= 10000， 1 &lt;= Ci &lt;= 200)<br>输出<br>输出可以容纳的最大价值。<br>输入示例<br>3 6<br>2 2 5<br>3 3 8<br>1 4 1<br>输出示例<br>9</p>
<h5 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h5><p>将多重背包分解为0-1背包<br>利用二进制的思想，任何一个数都可以由2的幂次表示：N = 1 + 2 + 4 + … + 2^i + (left);<br>即每个物品都可以被分解。假设物品的数量为14,则从14个物品中任取N个物品都可以转化为由以下物品组合(以下物品在每次组合中只能取一次)<br>1^0 重量是Wi，体积是Vi<br>2^2 重量是2 Wi , 体积是2 Vi<br>2^3 重量是4 Wi , 体积是4 Vi<br>14 - (1+2+4) 重量是7 Wi , 体积是7 Vi<br>分解完成后，再利用0-1背包思路求解</p>
<h5 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line">typedef struct &#123;</div><div class="line">    int w;</div><div class="line">    int p;</div><div class="line">&#125; Thing;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n,w;</div><div class="line">    cin &gt;&gt; n &gt;&gt; w;</div><div class="line">    </div><div class="line">    //分解</div><div class="line">    vector&lt;Thing&gt; things;</div><div class="line">    for(int i = 1; i &lt;= n;i++)&#123;</div><div class="line">        Thing thing;</div><div class="line">        cin &gt;&gt; thing.w &gt;&gt; thing.p;</div><div class="line">        int num;</div><div class="line">        cin &gt;&gt; num;</div><div class="line">        for(int k = 1; k &lt;= num;k &lt;&lt;= 1)&#123;</div><div class="line">            Thing temp;</div><div class="line">            temp.w = k * thing.w;</div><div class="line">            temp.p = k * thing.p;</div><div class="line">            num -= k;</div><div class="line">            things.push_back(temp);</div><div class="line">        &#125;</div><div class="line">        if(num &gt; 0)&#123;</div><div class="line">            thing.w = num * thing.w;</div><div class="line">            thing.p = num * thing.p;</div><div class="line">            things.push_back(thing);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //0-1背包</div><div class="line">    vector&lt;vector&lt;long long&gt; &gt; dp(things.size() + 1, vector&lt;long long&gt;(w + 1,0));</div><div class="line">    for(int i = 0; i &lt; things.size();i++)&#123;</div><div class="line">        for(int j = 0; j &lt;= w;j++)&#123;</div><div class="line">            if(j &lt; things[i].w)&#123;</div><div class="line">                dp[i + 1][j] = dp[i][j];</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                dp[i + 1][j] = max(dp[i][j],dp[i][j - things[i].w] + things[i].p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; dp[things.size()][w]&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划——由实践总结经验&lt;/p&gt;
&lt;h3 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基础题目&lt;ul&gt;
&lt;li&gt;矩阵取数问题&lt;/li&gt;
&lt;li&gt;最大子段和&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>My-Plan</title>
    <link href="http://yoursite.com/2017/09/11/My-Plan/"/>
    <id>http://yoursite.com/2017/09/11/My-Plan/</id>
    <published>2017-09-10T23:26:42.000Z</published>
    <updated>2017-09-10T16:11:48.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在大一的这个小学期，课不是很多，技术这一块也遇到了一些瓶颈，感觉自己都懂又感觉自己都不懂，看网上的教程，觉得自己掌握了，但要实际运用起来却又不是很遂心应手，自己也不知道自己现在是个什么情况。这跟自己当初学吉他有点相识之处啊，网上能看到的吉他教材啊、视频呀，自己看也能明白，但只要自己拿起吉他，就不知道要弹什么了，就是一种眼高手低的状态吧，跟现在学习的状态是一样一样的。</p>
<p>自己这几天也不做什么事，没课就跟老乡骑小黄车四处逛，长沙的公园都快被我们逛完了。自己也利用这几天也想了许多，总觉得自己走进了死胡同—-一直在学习，但从未使用学的东西。在高中学吉他那会，自己自以为是的觉得只要学会了所有的技巧，就能弹奏所有的曲子了，但事实证明这是错的，自己虽然懂得了所有的技巧，但并不懂得怎么在正确的时间使用，这也无济于事，就相当于没学过一样。所以，自己不能在犯同样的错误了，学了，还有使用，懂得去运用自己所学的东西也是学习的一部分…</p>
<p>So，这学期也不要学太多新的东西啦，重点要放在怎么使用自己学过的东西，在使用的过程中学习。</p>
<h3 id="My-Plan"><a href="#My-Plan" class="headerlink" title="My Plan"></a>My Plan</h3><ul>
<li>自己完成一些Java、JavaWeb项目 （参照亮剑Java（JavaWeb） 项目开发案例导航）</li>
<li>学习Linux，对服务器进行管理</li>
<li>学习数据结构，对算法的积累</li>
<li>…</li>
</ul>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p>大一整整一年，自己几乎把所有的时间都放在了技术的学习上，天真的以为只要技术牛逼就万事大吉了。经过这一年的摸索，发现自己真的很傻，事情并非如此。自己虽然是计算机专业，但并不是说自己的生活里就只能是代码，也不能就只把自己定义为码农、程序员，这不是自己的唯一的道路。坦白点，学程序无非就是为了赚钱。赚钱不只有写程序这一个办法，还有很多办法呢，自己的眼界要开阔，比如说可以炒炒股呀、卖点东西呀…</p>
<p>此外，程序不能是自己生活的全部，自己不能把自己的爱好丢了，虽然不能天天玩吉他了，但这并不代表每天都不玩了；虽然不能天天去打球、运动了，但并不代表每天都不去了…</p>
<p>以后要想有更多的机会，并不是会写程序就可以的，还要有其他的一些辅助技能，比如说语言啦、沟通能力啦、管理能力啦…这些都是很重要的东西，也是自己要提高的东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在大一的这个小学期，课不是很多，技术这一块也遇到了一些瓶颈，感觉自己都懂又感觉自己都不懂，看网上的教程，觉得自己掌握了，但要实际运用起来却又
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划从新手到专家</title>
    <link href="http://yoursite.com/2017/09/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E4%B8%93%E5%AE%B6/"/>
    <id>http://yoursite.com/2017/09/09/动态规划从新手到专家/</id>
    <published>2017-09-08T16:00:34.000Z</published>
    <updated>2017-09-10T16:18:53.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们遇到的问题中，有很大一部分可以用动态规划(简称DP)来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解题。 这篇文章是基于实例展开来讲的，因为干巴巴的理论实在不好理解。</p>
<p>注意：如果你对于其中某一节已经了解并且不想阅读它，没关系，直接跳过它即可。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>简介(入门)</p>
<p>什么是动态规划，我们要如何描述它?</p>
<p>动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。</p>
<p>现在让我们通过一个例子来了解一下DP的基本原理。</p>
<p>首先，我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。</p>
<p>“状态”代表什么及如何找到它?</p>
<p>“状态”用来描述该问题的子问题的解。</p>
<p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)</p>
<p>首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11) ？为什么要这么问呢? 两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。</p>
<p>好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。</p>
<p>OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。</p>
<p>上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”， 这个状态是怎么找出来的呢？我在另一篇文章 动态规划之背包问题(一)中写过： 根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p>
<p>d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值;</p>
<p>有了状态和状态转移方程，这个问题基本上也就解决了。当然了，Talk is cheap,show me the code!</p>
<p>  从上图可以得出，要凑够11元至少需要3枚硬币。</p>
<p>此外，通过追踪我们是如何从前一个状态值得到当前状态值的， 可以找到每一次我们用的是什么面值的硬币。比如，从上面的图我们可以看出， 最终结果d(11)=d(10)+1(面值为1)，而d(10)=d(5)+1(面值为5)，最后d(5)=d(0)+1 (面值为5)。所以我们凑够11元最少需要的3枚硬币是：1元、5元、5元。</p>
<h3 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h3><p>上面讨论了一个非常简单的例子。现在让我们来看看对于更复杂的问题， 如何找到状态之间的转移方式(即找到状态转移方程)。 为此我们要引入一个新词叫递推关系来将状态联系起来(说的还是状态转移方程)</p>
<p>OK，上例子，看看它是如何工作的。</p>
<p>一个序列有N个数：A<a href="./images/sum.png" title="sum">1</a>,A[2],…,A[N]，求出最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)</p>
<p>正如上面我们讲的，面对这样一个问题，我们首先要定义一个“状态”来代表它的子问题， 并且找到它的解。注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。</p>
<p>让我们沿用“入门”一节里那道简单题的思路来一步步找到“状态”和“状态转移方程”。 假如我们考虑求A<a href="./images/sum.png" title="sum">1</a>,A[2],…,A[i]的最长非降子序列的长度，其中i&lt;N， 那么上面的问题变成了原问题的一个子问题(问题规模变小了，你可以让i=1,2,3等来分析) 然后我们定义d(i)，表示前i个数中以A[i]结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p>
<p>为了方便理解我们是如何找到状态转移方程的，我先把下面的例子提到前面来讲。 如果我们要求的这N个数的序列是：</p>
<p>5，3，4，8，6，7<br>根据上面找到的状态，我们可以得到：（下文的最长非降子序列都用LIS表示）</p>
<p>前1个数的LIS长度d(1)=1(序列：5)<br>前2个数的LIS长度d(2)=1(序列：3；3前面没有比3小的)<br>前3个数的LIS长度d(3)=2(序列：3，4；4前面有个比它小的3，所以d(3)=d(2)+1)<br>前4个数的LIS长度d(4)=3(序列：3，4，8；8前面比它小的有3个数，所以 d(4)=max{d(1),d(2),d(3)}+1=3)<br>OK，分析到这，我觉得状态转移方程已经很明显了，如果我们已经求出了d(1)到d(i-1)， 那么d(i)可以用下面的状态转移方程得到：</p>
<p>d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;=A[i]<br>用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。</p>
<p>Talk is cheap, show me the code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int lis(int A[], int n)&#123;</div><div class="line">    int *d = new int[n];</div><div class="line">    int len = 1;</div><div class="line">    for(int i=0; i&lt;n; ++i)&#123;</div><div class="line">        d[i] = 1;</div><div class="line">        for(int j=0; j&lt;i; ++j)</div><div class="line">            if(A[j]&lt;=A[i] &amp;&amp; d[j]+1&gt;d[i])</div><div class="line">                d[i] = d[j] + 1;</div><div class="line">        if(d[i]&gt;len) len = d[i];</div><div class="line">    &#125;</div><div class="line">    delete[] d;</div><div class="line">    return len;</div><div class="line">&#125;</div><div class="line">int main()&#123;</div><div class="line">    int A[] = &#123;</div><div class="line">        5, 3, 4, 8, 6, 7</div><div class="line">    &#125;;</div><div class="line">    cout&lt;&lt;lis(A, 6)&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该算法的时间复杂度是O(n^2 )，并不是最优的解法。 还有一种很巧妙的算法可以将时间复杂度降到O(nlogn)，网上已经有各种文章介绍它， 这里就不再赘述。传送门： LIS的O(nlogn)解法。 此题还可以用“排序+LCS”来解，感兴趣的话可自行Google。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我们遇到的问题中，有很大一部分可以用动态规划(简称DP)来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划之背包问题</title>
    <link href="http://yoursite.com/2017/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/09/06/动态规划之背包问题/</id>
    <published>2017-09-06T15:44:51.000Z</published>
    <updated>2017-09-06T07:55:15.399Z</updated>
    
    <content type="html"><![CDATA[<p>一切都要从一则故事说起。</p>
<p>话说有一哥们去森林里玩发现了一堆宝石，他数了数，一共有n个。 但他身上能装宝石的就只有一个背包，背包的容量为C。这哥们把n个宝石排成一排并编上号： 0,1,2,…,n-1。第i个宝石对应的体积和价值分别为V[i]和W[i] 。排好后这哥们开始思考： 背包总共也就只能装下体积为C的东西，那我要装下哪些宝石才能让我获得最大的利益呢？</p>
<p>OK，如果是你，你会怎么做？你斩钉截铁的说：动态规划啊！恭喜你，答对了。 那么让我们来看看，动态规划中最最最重要的两个概念： 状态和状态转移方程在这个问题中分别是什么。</p>
<p>我们要怎样去定义状态呢？这个状态总不能是凭空想象或是从天上掉下来的吧。 为了方便说明，让我们先实例化上面的问题。一般遇到n，你就果断地给n赋予一个很小的数， 比如n=3。然后设背包容量C=10，三个宝石的体积为5，4，3，对应的价值为20，10，12。 对于这个例子，我想智商大于0的人都知道正解应该是把体积为5和3的宝石装到背包里， 此时对应的价值是20+12=32。接下来，我们把第三个宝石拿走， 同时背包容量减去第三个宝石的体积（因为它是装入背包的宝石之一）， 于是问题的各参数变为：n=2，C=7，体积｛5，4｝，价值｛20，10｝。好了， 现在这个问题的解是什么？我想智商等于0的也解得出了：把体积为5的宝石放入背包 （然后剩下体积2，装不下第二个宝石，只能眼睁睁看着它溜走），此时价值为20。 这样一来，我们发现，n=3时，放入背包的是0号和2号宝石；当n=2时， 我们放入的是0号宝石。这并不是一个偶然，没错， 这就是传说中的“全局最优解包含局部最优解”（n=2是n=3情况的一个局部子问题）。 绕了那么大的圈子，你可能要问，这都哪跟哪啊？说好的状态呢？说好的状态转移方程呢？ 别急，它们已经呼之欲出了。</p>
<p>我们再把上面的例子理一下。当n=2时，我们要求的是前2个宝石， 装到体积为7的背包里能达到的最大价值；当n=3时，我们要求的是前3个宝石， 装到体积为10的背包里能达到的最大价值。有没有发现它们其实是一个句式！OK， 让我们形式化地表示一下它们， 定义d(i,j)为前i个宝石装到剩余体积为j的背包里能达到的最大价值。 那么上面两句话即为：d(2, 7)和d(3, 10)。这样看着真是爽多了， 而这两个看着很爽的符号就是我们要找的状态了。 即状态d(i,j)表示前i个宝石装到剩余体积为j的背包里能达到的最大价值。 上面那么多的文字，用一句话概括就是：根据子问题定义状态！你找到子问题， 状态也就浮出水面了。而我们最终要求解的最大价值即为d(n, C)：前n个宝石 （0,1,2…,n-1）装入剩余容量为C的背包中的最大价值。状态好不容易找到了， 状态转移方程呢？顾名思义，状态转移方程就是描述状态是怎么转移的方程（好废话！）。 那么回到例子，d(2, 7)和d(3, 10)是怎么转移的？来，我们来说说2号宝石 （记住宝石编号是从0开始的）。从d(2, 7)到d(3, 10)就隔了这个2号宝石。 它有两种情况，装或者不装入背包。如果装入，在面对前2个宝石时， 背包就只剩下体积7来装它们，而相应的要加上2号宝石的价值12， d(3, 10)=d(2, 10-3)+12=d(2, 7)+12；如果不装入，体积仍为10，价值自然不变了， d(3, 10)=d(2, 10)。记住，d(3, 10)表示的是前3个宝石装入到剩余体积为10 的背包里能达到的最大价值，既然是最大价值，就有d(3, 10)=max{ d(2, 10), d(2, 7)+12 }。好了，这条方程描述了状态d(i, j)的一些关系， 没错，它就是状态转移方程了。把它形式化一下：d(i, j)=max{ d(i-1, j), d(i-1,j-V[i-1]) + W[i-1] }。注意讨论前i个宝石装入背包的时候， 其实是在考查第i-1个宝石装不装入背包（因为宝石是从0开始编号的）。至此， 状态和状态转移方程都已经有了。接下来，直接上代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">    for(int j=0; j&lt;=C; ++j)&#123;</div><div class="line">        d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">        if(i&gt;0 &amp;&amp; j&gt;=V[i-1])  d[i][j] &gt;?= d[i-1][j-V[i-1]]+W[i-1];</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> i=0时，d(i, j)为什么为0呢？因为前0个宝石装入背包就是没东西装入，所以最大价值为0。 if语句里，j&gt;=V[i-1]说明只有当背包剩余体积j大于等于i-1号宝石的体积时， 我才考虑把它装进来的情况，不然d[i][j]就直接等于d[i-1][j]。i&gt;0不用说了吧， 前0个宝石装入背包的情况是边界，直接等于0，只有i&gt;0才有必要讨论， 我是装呢还是不装呢。简单吧，核心算法就这么一丁点，接下来上完整代码knapsack.cpp。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> /**0-1 knapsack d(i, j)表示前i个物品装到剩余容量为j的背包中的最大重量**/</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">#define MAXN 1000</div><div class="line">#define MAXC 100000</div><div class="line"></div><div class="line">int V[MAXN], W[MAXN];</div><div class="line">int d[MAXN][MAXC];</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);//重定向输入流</div><div class="line">	freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);//重定向输出流</div><div class="line">	int n, C;</div><div class="line">	while(scanf(&quot;%d %d&quot;, &amp;n, &amp;C) != EOF)&#123;</div><div class="line">		for(int i=0; i&lt;n; ++i)	scanf(&quot;%d %d&quot;, &amp;V[i], &amp;W[i]);</div><div class="line">		</div><div class="line">		for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">			for(int j=0; j&lt;=C; ++j)&#123;</div><div class="line">				d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">				if(i&gt;0 &amp;&amp; j&gt;=V[i-1])	d[i][j] &gt;?= d[i-1][j-V[i-1]]+W[i-1];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, d[n][C]);//最终求解的最大价值</div><div class="line">	&#125;</div><div class="line">	fclose(stdin);</div><div class="line">	fclose(stdout);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中freopen函数将标准输入流重定向到文件data.in， 这比运行程序时一点点手输要方便许多，将标准输出流重定向到data.out。 data.in中每组输入的第一行为宝石数量n及背包体积C，接下来会有n行的数据， 每行两个数对应的是宝石的体积及价值。本测试用例data.in如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">5 10</div><div class="line">4 9</div><div class="line">3 6</div><div class="line">5 1</div><div class="line">2 4</div><div class="line">5 1</div><div class="line">4 9</div><div class="line">4 20</div><div class="line">3 6</div><div class="line">4 20</div><div class="line">2 4</div><div class="line">5 10</div><div class="line">2 6</div><div class="line">2 3</div><div class="line">6 5</div><div class="line">5 4</div><div class="line">4 6</div></pre></td></tr></table></figure></p>
<p>data.out为算法输出结果，对应该测试用例，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">19</div><div class="line">40</div><div class="line">15</div></pre></td></tr></table></figure></p>
<p>好，至此我们解决了背包问题中最基本的0/1背包问题。等等，这时你可能要问， 我现在只知道背包能装入宝石的最大价值，但我还不知道要往背包里装入哪些宝石啊。嗯， 好问题！让我们先定义一个数组x，对于其中的元素为1时表示对应编号的宝石放入背包， 为0则不放入。让我们回到上面的例子，对于体积为5，4，3，价值为20，10，12的3个宝石 ，如何求得其对应的数组x呢？（明显我们目测一下就知道x={1 0 1}， 但程序可目测不出来）OK，让我们还是从状态说起。如果我们把2号宝石放入了背包， 那么是不是也就意味着，前3个宝石放入背包的最大价值要比前2个宝石放入背包的价值大， 即：d(3, 10)&gt;d(2, 10)。再用字母代替具体的数字 （不知不觉中我们就用了不完全归纳法哈），当d(i, j)&gt;d(i-1, j)时，x(i-1)=1;OK， 上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//输出打印方案</div><div class="line">int j = C;</div><div class="line">for(int i=n; i&gt;0; --i)&#123;</div><div class="line">    if(d[i][j] &gt; d[i-1][j])&#123;</div><div class="line">        x[i-1] = 1;</div><div class="line">        j = j - V[i-1];//装入第i-1个宝石后背包能装入的体积就只剩下j - V[i-1]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">for(int i=0; i&lt;n; ++i)  printf(&quot;%d &quot;, x[i]);</div></pre></td></tr></table></figure></p>
<p>好了，加入这部分内容，knapsack.cpp变为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**0-1 knapsack d(i, j)表示前i个物品装到剩余容量为j的背包中的最大重量**/</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">using namespace std;</div><div class="line">#define MAXN 1000</div><div class="line">#define MAXC 100000</div><div class="line"></div><div class="line">int V[MAXN], W[MAXN], x[MAXN];</div><div class="line">int d[MAXN][MAXC];</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);</div><div class="line">	freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);</div><div class="line">	int n, C;</div><div class="line">	while(scanf(&quot;%d %d&quot;, &amp;n, &amp;C) != EOF)&#123;</div><div class="line">		for(int i=0; i&lt;n; ++i)	scanf(&quot;%d %d&quot;, &amp;V[i], &amp;W[i]);</div><div class="line">		for(int i=0; i&lt;n; ++i)	x[i] = 0; //初始化打印方案</div><div class="line">		</div><div class="line">		for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">			for(int j=0; j&lt;=C; ++j)&#123;</div><div class="line">				d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">				if(i&gt;0 &amp;&amp; j&gt;=V[i-1])	d[i][j] &gt;?= d[i-1][j-V[i-1]]+W[i-1];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, d[n][C]);</div><div class="line">		</div><div class="line">		//输出打印方案</div><div class="line">		int j = C;</div><div class="line">		for(int i=n; i&gt;0; --i)&#123;</div><div class="line">			if(d[i][j] &gt; d[i-1][j])&#123;</div><div class="line">				x[i-1] = 1;</div><div class="line">				j = j - V[i-1];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		for(int i=0; i&lt;n; ++i)	printf(&quot;%d &quot;, x[i]);</div><div class="line">		printf(&quot;\n&quot;);</div><div class="line">	&#125;</div><div class="line">	fclose(stdin);</div><div class="line">	fclose(stdout);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>data.out输出结果变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">19</div><div class="line">1 1 0 1 0</div><div class="line">40</div><div class="line">1 0 1 0</div><div class="line">15</div><div class="line">1 1 0 0 1</div></pre></td></tr></table></figure></p>
<p>至此，好像该解决的问题都解决了。当一个问题找到一个放心可靠的解决方案后， 我们往往就要考虑一下是不是有优化方案了。为了保持代码的简洁， 我们暂且把宝石装包方案的求解去掉。该算法的时间复杂度是O(nC)， 即时间都花在两个for循环里了，这个应该是没办法再优化了。再看看空间复杂度， 数组d用来保存每个状态的值，空间复杂度为O(nC)； 数组V和W用来保存每个宝石的体积和价值，空间复杂度为O(n)。程序总的空间复杂度为 O(nC)，这个是可以进一步优化的。首先，我们先把数组V和W去掉， 因为它们没有保存的必要，改为一边读入一边计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int V = 0, W = 0;</div><div class="line">for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">    if(i&gt;0) scanf(&quot;%d %d&quot;, &amp;V,&amp;W);</div><div class="line">    for(int j=0; j&lt;=C;++j)&#123;</div><div class="line">        d[i][j] = i==0 ? 0 : d[i-1][j];</div><div class="line">        if(j&gt;=V &amp;&amp; i&gt;0) d[i][j] &gt;?= d[i-1][j-V]+W;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，接下来让我们继续压榨空间复杂度。保存状态值我们开了一个二维数组d， 在看过把一维数组V和W变为一个变量后，我们是不是要思考一下， 有没有办法将这个二维数组也压榨一下呢？换言之， 这个二维数组中的每个状态值我们真的有必要都保存么？ 让我们先来看一下以下的一张示意图（参照《算法竞赛入门经典》P169的图画的）<br><img src="./images/pic.png" alt="enter description here" title="pic"></p>
<p>由上面那一小段优化过后的代码可知，状态转移方程为：d(i, j)=max{ d(i-1, j), d(i-1, j-V)+W }，也就是在计算d(i, j)时我们用到了d(i-1,j)和d(i-1, j-V)的值。 如果我们只用一个一维数组d(0)～d(C)来保存状态值可以么？将i方向的维数去掉， 我们可以将原来二维数组表示为一维数据：d(i-1, j-V)变为d(j-V)， d(i-1, j)变为d(j)。当我们要计算d(i, j)时，只需要比较d(j)和d(j-V)+W的大小， 用较大的数更新d(j)即可。等等，如果我要计算d(i, j+1)，而它恰好要用到d(i-1, j)的值， 那么问题就出来了，因为你刚刚才把它更新为d(i, j)了。那么，怎么办呢？ 按照j递减的顺序即可避免这种问题。比如，你计算完d(i, j)， 接下来要计算的是d(i,j-1)，而它的状态转移方程为d(i, j-1)=max{ d(i-1, j-1), d(i-1, j-1-V)+W }，它不会再用到d(i-1,j)的值！所以， 即使该位置的值被更新了也无所谓。好，上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">memset(d, 0, sizeof(d));</div><div class="line">for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">    if(i&gt;0) scanf(&quot;%d %d&quot;, &amp;V,&amp;W);</div><div class="line">    for(int j=C;j&gt;=0; --j)&#123;</div><div class="line">        if(j&gt;=V &amp;&amp; i&gt;0) d[j] &gt;?= d[j-V]+W;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优化后的完整代码如下，此时空间复杂度仅为O(C)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**0-1 knapsack d(i, j)表示前i个物品装到剩余容量为j的背包中的最大重量**/</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;cstdlib&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);</div><div class="line">	freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);</div><div class="line">	int n, C, V = 0, W = 0;</div><div class="line">	while(scanf(&quot;%d %d&quot;, &amp;n, &amp;C) != EOF)&#123;</div><div class="line">		int* d = (int*)malloc((C+1)*sizeof(int));</div><div class="line">		memset(d, 0, (C+1)*sizeof(int));</div><div class="line">		</div><div class="line">		for(int i=0; i&lt;=n; ++i)&#123;</div><div class="line">			if(i&gt;0)	scanf(&quot;%d %d&quot;, &amp;V, &amp;W);</div><div class="line">			for(int j=C; j&gt;=0; --j)&#123;</div><div class="line">				if(j&gt;=V &amp;&amp; i&gt;0)	d[j] &gt;?= d[j-V]+W;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		printf(&quot;%d\n&quot;, d[C]);</div><div class="line">		free(d);</div><div class="line">	&#125;</div><div class="line">	fclose(stdin);</div><div class="line">	fclose(stdout);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，背包问题暂时先讲这么多，以后接着讲。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一切都要从一则故事说起。&lt;/p&gt;
&lt;p&gt;话说有一哥们去森林里玩发现了一堆宝石，他数了数，一共有n个。 但他身上能装宝石的就只有一个背包，背包的容量为C。这哥们把n个宝石排成一排并编上号： 0,1,2,…,n-1。第i个宝石对应的体积和价值分别为V[i]和W[i] 。排好后这
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大二的一些改变</title>
    <link href="http://yoursite.com/2017/09/02/%E5%A4%A7%E4%BA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B9%E5%8F%98/"/>
    <id>http://yoursite.com/2017/09/02/大二的一些改变/</id>
    <published>2017-09-02T00:01:09.000Z</published>
    <updated>2017-09-01T16:29:33.774Z</updated>
    
    <content type="html"><![CDATA[<p>###<br>时间飞逝，转眼间，转眼间就大二了，看到大一新生报道的场景，仿佛看到了当初的自己—-那个带着无限的憧憬的少年。</p>
<p>是的，自己带着音乐的梦想、广交好友、说一口流利的英语等无限的纯真的想法来到这里，但不知为何一直都没有付诸行动，自己安慰自己说要忙专业的事情，觉得学好专业才是正确的事情，但也只有自己知道这是让自己内心好受一点的借口。</p>
<p>那么问题来了，什么才是正确的事情呢？在不知道答案的情况下，我要怎么选择呢？</p>
<p>在这个暑假，跟丰哥、日哥聚了一下，上一次见面好像是在高考后，算起来有一年不见了。丰哥买车了，日哥又重新开了一家琴行，大家都更上一层楼了，但在看看自己，在这一年里，自己在学校勉强不挂科，自己摸索着学习了一点网站的开发，就没什么其他能说的事情了，可悲。</p>
<p>这一年里，自己放下了吉他，也不再关心英语，能说话的朋友没几个，自己深知这样的大学生活不是自己想要的，但一直不知道要如何改变。不过，在这个暑假跟丰哥聊过之后，觉得计算机与音乐其实是可以结合在一起的，也谷歌到了一个新名词—-Computer  Music（王戈）。是的，计算机与音乐是可以联合起来的。我们深知计算机只是一个工具，一个帮助人们解决问题的工具，就像吉他是一个表现音乐的工具一样。我们要学的是怎么使用工具去解决实际的问题，而不是掌握工具。</p>
<p>丰哥还说了勤工俭学的事情，自己仔细算了算，大学这一年 确实是花了好多钱，学费高就不说了，自己还报名参加了外面的培训班，虽然自己知道这是正确的投资，但这一切都是建立在父母亲的辛苦之上的，不妥不妥。自己学吉他这么久了，没有用吉他来赚过一分钱，只有付出，没有任何回报….学了没有有，就等于没学，也是时候重新拿起吉他，以一个初学者的心态重新回忆，相信会有不同的收获。</p>
<p>一个人不能在同一个地方跌倒两次，所以自己摸索着学习的网站的开发的技能需要发挥出来，要能帮助自己，说白了，就是要得到回报。</p>
<p>还有就是朋友。自己参加了两个社团，吉他协会和排球协会，自己本来是有机会深入到核心团队的，但因为自己不是很把这些东西当回事，不是很上心，与协会里面的人只能说是认识，还不能是朋友的关系。在这一点上，自己需要改正，需要上心，只有我们把别人当成朋友，别人才能把自己当成朋友。</p>
<p>小智，就让你在大二遇见更好的你自己吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###&lt;br&gt;时间飞逝，转眼间，转眼间就大二了，看到大一新生报道的场景，仿佛看到了当初的自己—-那个带着无限的憧憬的少年。&lt;/p&gt;
&lt;p&gt;是的，自己带着音乐的梦想、广交好友、说一口流利的英语等无限的纯真的想法来到这里，但不知为何一直都没有付诸行动，自己安慰自己说要忙专业的事
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hibernate基础</title>
    <link href="http://yoursite.com/2017/08/12/Hibernate/"/>
    <id>http://yoursite.com/2017/08/12/Hibernate/</id>
    <published>2017-08-12T11:11:43.000Z</published>
    <updated>2017-09-01T16:39:51.022Z</updated>
    
    <content type="html"><![CDATA[<p>1.下载hibernate</p>
<pre><code>需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
</code></pre><p>2.解压hibernate</p>
<pre><code>下载后解压缩，得到一个hibernate-release-4.3.11.Final文件夹（我下载的hibernate版本是4.3.11），在hibernate-release-4.3.11.Final文件夹里有一个lib文件夹，里面放着hibernate的jar包。

例子中使用了lib下的required文件夹中的所有jar包。如图：



这些包的作用如下（待验证）：
</code></pre><p>包名<br>说明<br>antlr-2.7.7<br>可以接收词文法语言描述，并能产生识别这些语言的语句的程序，hibernate利用它实现hql到sql的转换。<br>dom4j-1.6.1<br>xml解析器，用来读写xml文件的。<br>hibernate-commons-annotations-4.0.5.Final<br>hibernate中支持注解开发的程序。<br>hibernate-core-4.3.11.Final<br>hibernate的核心程序。<br>hibernate-jpa-2.1-api-1.0.0.Final    hibernate对jap(java persistence API)规范的支持，可以理解为JAP是标准接口，hibernate是实现。<br>jandex-1.1.0.Final    用来检索注解(annotation)索引的程序，识别该对象是注解对象(待验证)？<br>javassist-3.18.1-GA    用来操作字节码的程序，可直接编辑和生成java字节码，以达到对.class文件的动态修改。<br>jboss-logging-3.1.3.GA    提供hibernate日志功能的程序(待验证)?<br>jboss-logging-annotations-1.2.0.Beta1    解析logging的注解模式程序(待验证)?<br>jboss-transaction-api_1.2_spec-1.0.0.Final    事务控制程序(待验证)?<br>3.导入hibernate的jar包</p>
<pre><code>创建一个JavaProject，引用上面图片中的jar包，这里需要另外一个jar包，由于我连接的是mysql数据库，所以需要在导入一个mysql-connector-java-5.1.7-bin.jar
</code></pre><p>4.新建一个测试用的java对象</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>public class User {</p>
<pre><code>public User() {
}

public User(String name, Date birthday) {
    this.name = name;
    this.birthday = birthday;
}

@Override
public String toString() {
    return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, birthday=&quot; + birthday
            + &quot;]&quot;;
}

public int getId() {
    return id;
}

public void setId(int id) {
    this.id = id;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public Date getBirthday() {
    return birthday;
}

public void setBirthday(Date birthday) {
    this.birthday = birthday;
}

private int id;
private String name;
private Date birthday;
</code></pre><p>}<br>    编写的java对象需要满足如下要素：</p>
<p>需要有一个无参的构造函数，因为在session.get时需要用到反射创建java对象；</p>
<p>需要提供一个id属性，对应数据库的主键；</p>
<p>需要为对象的其他属性提供get/set方法；</p>
<p>需要定义成非final的类，以便在hibernate进行延迟加载时为类创建代理；</p>
<p>如有必要保存到集合中，需要重equals方法和hashcode方法；</p>
<p>5.设置java对象与数据库的映射关系</p>
<pre><code>需要创建一个User.hbm.xml文件，编辑java对象与数据库的映射关系，格式如下：
</code></pre><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE hibernate-mapping PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN”<br>“<a href="http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-mapping><br>    <class name="cn.net.bysoft.lesson1.User" table="S_USER"><br>        <id name="id" type="integer" column="ID"><br>            <!-- 指定主键的生成方式，native是使用数据库本地的方式 --><br>            <generator class="native"></generator><br>        </id><br>        <property name="name" type="string" column="NAME"></property><br>        <property name="birthday" type="timestamp" column="BIRTHDAY"></property><br>    </class><br></hibernate-mapping><br>    该文件是用来配置java对象与数据表之间的映射关系的，其中需要留意的是id这个属性，generator来指定主键的生成方式，而native则代表是调用数据库本地的方式来生成主键，我使用的mysql数据库就会自动将id列设置成自增。</p>
<pre><code>主键具体有哪些生成方式，待接下来详细研究。
</code></pre><p>6.配置hibernate的配置信息</p>
<p>在src下创建一个hibernate.cfg.xml文件，格式如下：</p>
<p>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>    “-//Hibernate/Hibernate Configuration DTD 3.0//EN”<br>    “<a href="http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-configuration><br>    <session-factory><br>        <!-- 连接数据库的基本信息 --><br>        <property name="hibernate.connection.username">root</property><br>        <property name="hibernate.connection.password">root</property><br>        <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property><br>        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate4</property></session-factory></hibernate-configuration></p>
<pre><code>    &lt;!-- hibernate使用的数据库方言
         如果不知道可以去/hibernate-release-4.3.11.Final/project/etc/hibernate.properties
         中查找 --&gt;
    &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;
    &lt;!-- 是否在控制台显示sql语句 --&gt;
    &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否格式化显示的sql语句 --&gt;
    &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否自动生成数据表的策略,create代表每次启动程序都重新创建数据表 --&gt;
    &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;

    &lt;!-- 需要使用到的*.hbm.xml文件 --&gt;
    &lt;mapping resource=&quot;cn/net/bysoft/lesson1/User.hbm.xml&quot;/&gt;
&lt;/session-factory&gt;
</code></pre><p><br>    该文件需要注意的有两个地方，第一个是mapping属性，第二个是hibernate.hbm2ddl.auto这个属性。</p>
<pre><code>mapping属性用来配置*.hbm.xml的资源文件地址，这里需要注意的是没有用cn.net.bysoft.lession的形式，而是使用的&apos;/&apos;来描述目录位置。

接下来是自动执行ddl语句的设置(也就是hibernate.hbm2ddl.auto)参数有4个，分别是：
</code></pre><p>create</p>
<p>create为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来drop掉数据表，drop后重新create数据表；</p>
<p>create-drop</p>
<p>create-drop为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来create数据表。而每当sessionfactory被close时，会drop掉开始时create的数据表；</p>
<p>update</p>
<p>update为每次创建sessionfactory时，如果数据库中没有对应的表，则新建。</p>
<p>若已经新建过，则会判断*.hbm.xml文件的配置与建立好的数据表的结构是否相同。</p>
<p>如果相同则不去进行ddl的操作。</p>
<p>如果不同，则会根据*.hbm.xml文件中有变化的配置项去更新数据表，但不会删除数据表中已创建过的任何信息。</p>
<p>validate</p>
<p>validate为每次创建sessionfactory时，将用*.hbm.xml文件中的配置信息与现有的对应的数据表结构进行比较，若发现不同则抛出异常。</p>
<p>7.编写代码测试</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.hibernate.Transaction;<br>import org.hibernate.boot.registry.StandardServiceRegistry;<br>import org.hibernate.boot.registry.StandardServiceRegistryBuilder;<br>import org.hibernate.cfg.Configuration;<br>import org.junit.Test;</p>
<p>public class UserTest {</p>
<pre><code>@Test
public void test() {
    // 0.创建configuration对象，该对象保存着hibernate的配置信息和对象关系映射的信息。
    Configuration cfg = new Configuration().configure();
    // 1.创建sessionfactory对象
    StandardServiceRegistryBuilder builder = new StandardServiceRegistryBuilder().applySettings(cfg.getProperties());
    StandardServiceRegistry registry =  builder.build();
    SessionFactory sessionFactory = cfg.buildSessionFactory(registry); 
    // 2.创建session对象
    Session session = sessionFactory.openSession();
    // 3.开始事务
    Transaction transaction = session.beginTransaction();
    // 4.保存
    User user = new User(&quot;Jack&quot;, new Date());
    session.save(user);
    // 5.提交事务
    transaction.commit();
    // 6.关闭session对象
    session.close();
    // 7.关闭sessionfactory对象
    sessionFactory.close();
}
</code></pre><p>}<br>    上面这段代码中configuration对象用来保存则hibernate的配置信息，如hibernate.cfg.xml中的配置信息，和*.hbm.xml的映射信息。</p>
<pre><code>sessionfactory为创建session的工厂，它是线程安全的。一般建议一个项目中只有一个sessionfactory，因为创建sessionfactory非常费资源。

接下来是session对象，该对象是hibernate的核心，是一个单线程的对象，内部有session缓存。

对需要持久化的java对象的所有操作都用到了session。

常用的方法有get、load、save、update、saveorupdate、delete、begintransaction、isopen、flush、clear、evicto、close等等方法，接下来将会一个一个研究这些方法的使用。

这是执行这段代码后，控制台输出的内容：



创建了一张名为S_USER的数据表，并insert了一条数据。



到此位置，一个简单的hibernate环境就搭建好了。工程的目录结构如下：
</code></pre><p>1.下载hibernate</p>
<pre><code>需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
</code></pre><p>2.解压hibernate</p>
<pre><code>下载后解压缩，得到一个hibernate-release-4.3.11.Final文件夹（我下载的hibernate版本是4.3.11），在hibernate-release-4.3.11.Final文件夹里有一个lib文件夹，里面放着hibernate的jar包。

例子中使用了lib下的required文件夹中的所有jar包。如图：



这些包的作用如下（待验证）：
</code></pre><p>包名<br>说明<br>antlr-2.7.7<br>可以接收词文法语言描述，并能产生识别这些语言的语句的程序，hibernate利用它实现hql到sql的转换。<br>dom4j-1.6.1<br>xml解析器，用来读写xml文件的。<br>hibernate-commons-annotations-4.0.5.Final<br>hibernate中支持注解开发的程序。<br>hibernate-core-4.3.11.Final<br>hibernate的核心程序。<br>hibernate-jpa-2.1-api-1.0.0.Final    hibernate对jap(java persistence API)规范的支持，可以理解为JAP是标准接口，hibernate是实现。<br>jandex-1.1.0.Final    用来检索注解(annotation)索引的程序，识别该对象是注解对象(待验证)？<br>javassist-3.18.1-GA    用来操作字节码的程序，可直接编辑和生成java字节码，以达到对.class文件的动态修改。<br>jboss-logging-3.1.3.GA    提供hibernate日志功能的程序(待验证)?<br>jboss-logging-annotations-1.2.0.Beta1    解析logging的注解模式程序(待验证)?<br>jboss-transaction-api_1.2_spec-1.0.0.Final    事务控制程序(待验证)?<br>3.导入hibernate的jar包</p>
<pre><code>创建一个JavaProject，引用上面图片中的jar包，这里需要另外一个jar包，由于我连接的是mysql数据库，所以需要在导入一个mysql-connector-java-5.1.7-bin.jar
</code></pre><p>4.新建一个测试用的java对象</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>public class User {</p>
<pre><code>public User() {
}

public User(String name, Date birthday) {
    this.name = name;
    this.birthday = birthday;
}

@Override
public String toString() {
    return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, birthday=&quot; + birthday
            + &quot;]&quot;;
}

public int getId() {
    return id;
}

public void setId(int id) {
    this.id = id;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public Date getBirthday() {
    return birthday;
}

public void setBirthday(Date birthday) {
    this.birthday = birthday;
}

private int id;
private String name;
private Date birthday;
</code></pre><p>}<br>    编写的java对象需要满足如下要素：</p>
<p>需要有一个无参的构造函数，因为在session.get时需要用到反射创建java对象；</p>
<p>需要提供一个id属性，对应数据库的主键；</p>
<p>需要为对象的其他属性提供get/set方法；</p>
<p>需要定义成非final的类，以便在hibernate进行延迟加载时为类创建代理；</p>
<p>如有必要保存到集合中，需要重equals方法和hashcode方法；</p>
<p>5.设置java对象与数据库的映射关系</p>
<pre><code>需要创建一个User.hbm.xml文件，编辑java对象与数据库的映射关系，格式如下：
</code></pre><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE hibernate-mapping PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN”<br>“<a href="http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-mapping><br>    <class name="cn.net.bysoft.lesson1.User" table="S_USER"><br>        <id name="id" type="integer" column="ID"><br>            <!-- 指定主键的生成方式，native是使用数据库本地的方式 --><br>            <generator class="native"></generator><br>        </id><br>        <property name="name" type="string" column="NAME"></property><br>        <property name="birthday" type="timestamp" column="BIRTHDAY"></property><br>    </class><br></hibernate-mapping><br>    该文件是用来配置java对象与数据表之间的映射关系的，其中需要留意的是id这个属性，generator来指定主键的生成方式，而native则代表是调用数据库本地的方式来生成主键，我使用的mysql数据库就会自动将id列设置成自增。</p>
<pre><code>主键具体有哪些生成方式，待接下来详细研究。
</code></pre><p>6.配置hibernate的配置信息</p>
<p>在src下创建一个hibernate.cfg.xml文件，格式如下：</p>
<p>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>    “-//Hibernate/Hibernate Configuration DTD 3.0//EN”<br>    “<a href="http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-configuration><br>    <session-factory><br>        <!-- 连接数据库的基本信息 --><br>        <property name="hibernate.connection.username">root</property><br>        <property name="hibernate.connection.password">root</property><br>        <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property><br>        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate4</property></session-factory></hibernate-configuration></p>
<pre><code>    &lt;!-- hibernate使用的数据库方言
         如果不知道可以去/hibernate-release-4.3.11.Final/project/etc/hibernate.properties
         中查找 --&gt;
    &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;
    &lt;!-- 是否在控制台显示sql语句 --&gt;
    &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否格式化显示的sql语句 --&gt;
    &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否自动生成数据表的策略,create代表每次启动程序都重新创建数据表 --&gt;
    &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;

    &lt;!-- 需要使用到的*.hbm.xml文件 --&gt;
    &lt;mapping resource=&quot;cn/net/bysoft/lesson1/User.hbm.xml&quot;/&gt;
&lt;/session-factory&gt;
</code></pre><p><br>    该文件需要注意的有两个地方，第一个是mapping属性，第二个是hibernate.hbm2ddl.auto这个属性。</p>
<pre><code>mapping属性用来配置*.hbm.xml的资源文件地址，这里需要注意的是没有用cn.net.bysoft.lession的形式，而是使用的&apos;/&apos;来描述目录位置。

接下来是自动执行ddl语句的设置(也就是hibernate.hbm2ddl.auto)参数有4个，分别是：
</code></pre><p>create</p>
<p>create为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来drop掉数据表，drop后重新create数据表；</p>
<p>create-drop</p>
<p>create-drop为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来create数据表。而每当sessionfactory被close时，会drop掉开始时create的数据表；</p>
<p>update</p>
<p>update为每次创建sessionfactory时，如果数据库中没有对应的表，则新建。</p>
<p>若已经新建过，则会判断*.hbm.xml文件的配置与建立好的数据表的结构是否相同。</p>
<p>如果相同则不去进行ddl的操作。</p>
<p>如果不同，则会根据*.hbm.xml文件中有变化的配置项去更新数据表，但不会删除数据表中已创建过的任何信息。</p>
<p>validate</p>
<p>validate为每次创建sessionfactory时，将用*.hbm.xml文件中的配置信息与现有的对应的数据表结构进行比较，若发现不同则抛出异常。</p>
<p>7.编写代码测试</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.hibernate.Transaction;<br>import org.hibernate.boot.registry.StandardServiceRegistry;<br>import org.hibernate.boot.registry.StandardServiceRegistryBuilder;<br>import org.hibernate.cfg.Configuration;<br>import org.junit.Test;</p>
<p>public class UserTest {</p>
<pre><code>@Test
public void test() {
    // 0.创建configuration对象，该对象保存着hibernate的配置信息和对象关系映射的信息。
    Configuration cfg = new Configuration().configure();
    // 1.创建sessionfactory对象
    StandardServiceRegistryBuilder builder = new StandardServiceRegistryBuilder().applySettings(cfg.getProperties());
    StandardServiceRegistry registry =  builder.build();
    SessionFactory sessionFactory = cfg.buildSessionFactory(registry); 
    // 2.创建session对象
    Session session = sessionFactory.openSession();
    // 3.开始事务
    Transaction transaction = session.beginTransaction();
    // 4.保存
    User user = new User(&quot;Jack&quot;, new Date());
    session.save(user);
    // 5.提交事务
    transaction.commit();
    // 6.关闭session对象
    session.close();
    // 7.关闭sessionfactory对象
    sessionFactory.close();
}
</code></pre><p>}<br>    上面这段代码中configuration对象用来保存则hibernate的配置信息，如hibernate.cfg.xml中的配置信息，和*.hbm.xml的映射信息。</p>
<pre><code>sessionfactory为创建session的工厂，它是线程安全的。一般建议一个项目中只有一个sessionfactory，因为创建sessionfactory非常费资源。

接下来是session对象，该对象是hibernate的核心，是一个单线程的对象，内部有session缓存。

对需要持久化的java对象的所有操作都用到了session。

常用的方法有get、load、save、update、saveorupdate、delete、begintransaction、isopen、flush、clear、evicto、close等等方法，接下来将会一个一个研究这些方法的使用。

这是执行这段代码后，控制台输出的内容：



创建了一张名为S_USER的数据表，并insert了一条数据。



到此位置，一个简单的hibernate环境就搭建好了。工程的目录结构如下：
</code></pre><p>配置对象<br>配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。</p>
<p>数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。<br>类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。<br>SessionFactory 对象<br>配置对象被用于创造一个 SessionFactory 对象，使用提供的配置文件为应用程序依次配置 Hibernate，并允许实例化一个会话对象。SessionFactory 是一个线程安全对象并由应用程序所有的线程所使用。</p>
<p>SessionFactory 是一个重量级对象所以通常它都是在应用程序启动时创造然后留存为以后使用。每个数据库需要一个 SessionFactory 对象使用一个单独的配置文件。所以如果你使用多种数据库那么你要创造多种 SessionFactory 对象。</p>
<p>Session 对象<br>一个会话被用于与数据库的物理连接。Session 对象是轻量级的，并被设计为每次实例化都需要与数据库的交互。持久对象通过 Session 对象保存和检索。</p>
<p>Session 对象不应该长时间保持开启状态因为它们通常情况下并非线程安全，并且它们应该按照所需创造和销毁。</p>
<p>Transaction 对象<br>一个事务代表了与数据库工作的一个单元并且大部分 RDBMS 支持事务功能。在 Hibernate 中事务由底层事务管理器和事务（来自 JDBC 或者 JTA）处理。</p>
<p>这是一个选择性对象，Hibernate 应用程序可能不选择使用这个接口，而是在自己应用程序代码中管理事务。</p>
<p>Query 对象<br>Query 对象使用 SQL 或者 Hibernate 查询语言（HQL）字符串在数据库中来检索数据并创造对象。一个查询的实例被用于连结查询参数，限制由查询返回的结果数量，并最终执行查询。</p>
<p>Criteria 对象<br>Criteria 对象被用于创造和执行面向规则查询的对象来检索对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.下载hibernate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.解压hibernate&lt;/p&gt;
&lt;pre&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate基础</title>
    <link href="http://yoursite.com/2017/08/11/Hibernate%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/08/11/Hibernate基础/</id>
    <published>2017-08-11T11:11:43.000Z</published>
    <updated>2017-08-12T01:49:34.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>众所周知，Java是面向对象的世界，但数据库不是，现在的主流数据库大多都是关系型数据库。Java的对象想要进入数据库，就必须遵守数据库的“关系”规范，变成一条条的“记录”，数据库中的记录要变成Java中的对象，也同样需要有一个变身的过程—-繁琐的过程。通过SQL这个关系世界的魔法，我们建立起了“面向世界的世界”和“面向关系的世界”的桥梁。</p>
<p>那么问题来了，SQL是面向关系的语言， 它的脑袋里只有数据库中死板的记录，和眼中 “万事万物皆对象” 的Java在一起，显得格格不入。所以，“用面向对象的方法处理数据库操作”的 Hibernate 出世了。可以这么说，Hibernate 为 “面向对象” 和 “面向关系” 这两个截然不同的世界搭起了桥梁，所以它被称为ORM（Object–Relation Maping）—-对象映射框架。</p>
<h3 id="Hibernate基本工作原理"><a href="#Hibernate基本工作原理" class="headerlink" title="Hibernate基本工作原理"></a>Hibernate基本工作原理</h3><p>配置对象<br>配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。</p>
<p>数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。<br>类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。<br>SessionFactory 对象<br>配置对象被用于创造一个 SessionFactory 对象，使用提供的配置文件为应用程序依次配置 Hibernate，并允许实例化一个会话对象。SessionFactory 是一个线程安全对象并由应用程序所有的线程所使用。</p>
<p>SessionFactory 是一个重量级对象所以通常它都是在应用程序启动时创造然后留存为以后使用。每个数据库需要一个 SessionFactory 对象使用一个单独的配置文件。所以如果你使用多种数据库那么你要创造多种 SessionFactory 对象。</p>
<p>Session 对象<br>一个会话被用于与数据库的物理连接。Session 对象是轻量级的，并被设计为每次实例化都需要与数据库的交互。持久对象通过 Session 对象保存和检索。</p>
<p>Session 对象不应该长时间保持开启状态因为它们通常情况下并非线程安全，并且它们应该按照所需创造和销毁。</p>
<p>Transaction 对象<br>一个事务代表了与数据库工作的一个单元并且大部分 RDBMS 支持事务功能。在 Hibernate 中事务由底层事务管理器和事务（来自 JDBC 或者 JTA）处理。</p>
<p>这是一个选择性对象，Hibernate 应用程序可能不选择使用这个接口，而是在自己应用程序代码中管理事务。</p>
<p>Query 对象<br>Query 对象使用 SQL 或者 Hibernate 查询语言（HQL）字符串在数据库中来检索数据并创造对象。一个查询的实例被用于连结查询参数，限制由查询返回的结果数量，并最终执行查询。</p>
<p>Criteria 对象<br>Criteria 对象被用于创造和执行面向规则查询的对象来检索对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;Why&lt;/h3&gt;&lt;p&gt;众所周知，Java是面向对象的世界，但数据库不是，现在的主流数据库大多都是关系型数据库。Java的对象想要进入数据库，就必须遵守数据
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java动态网页</title>
    <link href="http://yoursite.com/2017/08/09/Java%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/"/>
    <id>http://yoursite.com/2017/08/09/Java动态网页/</id>
    <published>2017-08-09T12:56:59.000Z</published>
    <updated>2017-08-09T14:28:53.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何为动态网页"><a href="#何为动态网页" class="headerlink" title="何为动态网页"></a>何为动态网页</h3><p>所谓动态，是指浏览器所接受到的HTML页面是由服务器端的程序动态生成的，而不是事先制作好的。</p>
<h4 id="Java动态网页"><a href="#Java动态网页" class="headerlink" title="Java动态网页"></a>Java动态网页</h4><p>Java的动态Web编程技术是从Servlet（Servlet是服务器端小程序的意思）开始的。它在服务器端运行，动态地向客户端输出HTML页面。</p>
<h4 id="从HTML到JSP"><a href="#从HTML到JSP" class="headerlink" title="从HTML到JSP"></a>从HTML到JSP</h4><p>JSP是Servlet技术的扩展—-JSP(Java Server Pages) 。JSP实际上是Servlet的 一种变体，二者在本质上是一致的。为什么这样说呢？首先，Servlet和JSP是不能直接运行的，它们必须部署到一种特殊的应用程序—-Web服务器中。Web服务器会将JSP编译为Servlet，最后用于响应客户端浏览器的请求。虽然JSP和Servlet在本质上没有不同。只是Servlet在Java中插入HTML代码，而JSP是在HTML中插入Java代码而已。但这种形式上的转变简化了页面的编写工作：在JSP中书写静态HTML代码更加方便，不必在用print输出每一行。网页设计师和JSP程序员也可以很好地配合，前者只需要制作好HTML静态页面，将需要生成的地方预留空白，再交给后者加入动态内容、制作成JSP页面就可以了。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;何为动态网页&quot;&gt;&lt;a href=&quot;#何为动态网页&quot; class=&quot;headerlink&quot; title=&quot;何为动态网页&quot;&gt;&lt;/a&gt;何为动态网页&lt;/h3&gt;&lt;p&gt;所谓动态，是指浏览器所接受到的HTML页面是由服务器端的程序动态生成的，而不是事先制作好的。&lt;/p&gt;
&lt;h4
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDBC简单用</title>
    <link href="http://yoursite.com/2017/08/08/JDBC%E7%AE%80%E5%8D%95%E7%94%A8/"/>
    <id>http://yoursite.com/2017/08/08/JDBC简单用/</id>
    <published>2017-08-07T22:15:28.000Z</published>
    <updated>2017-08-07T14:40:31.782Z</updated>
    
    <content type="html"><![CDATA[<h4 id="何为JDBC"><a href="#何为JDBC" class="headerlink" title="何为JDBC"></a>何为JDBC</h4><p>JDBC（Java Data Base Connectivity,Java数据库连接）是由原Sun公司制定的数据库连接技术。SQL是用户操作数据库的语言，JDBC则为用户与数据库之间搭起了<strong>通信</strong>的通道。JDBC的根本目的：<strong>为Java编程人员提供操作各种数据库统一接口</strong></p>
<p>作为程序员，我们不能要求我们的用户只用一种数据库，所以说同一个Java应用能运用在不同的数据库之上是非常重要的，同时，这也是很不容易的。当今的数据库种类繁多，就像不同的国家的人说不同的语言一样，不同的数据库也使用着不同的语言…想要跟不同的数据库“交流”，就要使用他们的语言，那是不是说作为一名Java程序员要懂得所有的数据库语言？</p>
<p>要解决这个问题，我们就需要一个翻译，就像国家领导人经常出访不同的国家，但不需要懂得全世界的语言一样。</p>
<p>原Sun公司制定了JDBC的标准，这个标准规定了JDBC的接口，就如同规定了Java程序员与JDBC使用的语言。不同数据库语言的表达方式被JDBC统一了起来。就拿 “给我一个数据库连接” 这样一个命令来说，不论在各个数据库中是怎么实现的，在JDBC中都是一个命令—-“getConnection” 。</p>
<p>这些功能的实现，主要靠的是“JDBC驱动” 这个东西，它承担了翻译的核心机能。JDBC标准规定后，各个数据库厂商根据这个标准，开发出对应自己数据库产品的JDBC驱动。所以想要操作什么数据库，只要找到相应的驱动就好了。当然，JDBC驱动实际上就是一组class文件，它们被打包为Java专用压缩格式jar。</p>
<p>这样一来，数据库程序的开发就变得简单了。JDBC为Java提供了一个统一接口，程序员在编程时，可以不考虑所要操作的是什么数据库，只需要使用标准的JDBC书写数据库操作代码，再根据目标数据库的不同，加在相应的JDBC驱动就行了。</p>
<p>JDBC的所有接口都在Java基础类库的  java.sql 包以及 javax.sql 包中，但请注意这些都只是接口，所有的实现类就是由各数据库厂商根据这些接口编写的具体类而已。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;何为JDBC&quot;&gt;&lt;a href=&quot;#何为JDBC&quot; class=&quot;headerlink&quot; title=&quot;何为JDBC&quot;&gt;&lt;/a&gt;何为JDBC&lt;/h4&gt;&lt;p&gt;JDBC（Java Data Base Connectivity,Java数据库连接）是由原Sun公司制定的
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库的优势</title>
    <link href="http://yoursite.com/2017/08/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/08/07/数据库相关/</id>
    <published>2017-08-07T15:18:28.000Z</published>
    <updated>2017-08-07T14:11:20.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用数据库的优势"><a href="#使用数据库的优势" class="headerlink" title="使用数据库的优势"></a>使用数据库的优势</h3><h4 id="1、灵活、高效地管理数据"><a href="#1、灵活、高效地管理数据" class="headerlink" title="1、灵活、高效地管理数据"></a>1、灵活、高效地管理数据</h4><p>数据库可不是简单地把存进去的数据堆积起来。它会将数据分门别类存放好，并在此基础上建立起一整套查询、修改、输入与输出的机制，极大地提高工作效率。</p>
<h4 id="2、方便共享数据"><a href="#2、方便共享数据" class="headerlink" title="2、方便共享数据"></a>2、方便共享数据</h4><p>在现实中，不少用户之间都经常存在重复数据的现象。此外，现实中的数据经常要同时提供给许多使用者，如果每个使用者都保存一份相同的数据，一方面会造成巨大的浪费，另一方面也会为保证数据的一致性增加困难。举个简单例子，中国所有的公民的有关数据的量是非常庞大的，而很多地方都需要这些数据，即使真的把这些数据都复制成千上万份发放给各个机关，那么一旦这些数据更改（每一秒都有人出生、死亡），所有的机关必须对自己手中的数据进行准确无误的更改…工作量是很大的。但将公民的数据统一保存在数据库中，以上的问题便能迎刃而解：各个机关通过网络访问数据库，数据库中数据的更改也会及时。统一地反映给各个机构。</p>
<p>将“数据”与“应用”分离。把程序中的数据部分转移到数据库这个安全稳定的盒子中，这些数据就与应用程序之间有了清晰的界限。这样一来，程序的任何改变都不会影响到数据，就算程序废弃了，数据库中的数据仍然能为其他应用程序所用。</p>
<h4 id="3、增强安全性"><a href="#3、增强安全性" class="headerlink" title="3、增强安全性"></a>3、增强安全性</h4><p>任何对数据库内任何数据的访问都必须经过数据库系统的授权，从而更加有力地保障了数据的安全。举个例子吧，说白了，数据库就相当与现实生活中的图书馆，堆积如山的书籍就是数据。乱七八糟的图书进入图书馆后，被一个个贴上标签，分类整理好之后放入指定的位置。之后，读者更方便查找、借阅书籍，一本书也能给更多人阅读—-这些都类似于数据库为数据提供的管理、共享功能。与此同时，读者借阅书籍时必须经过图书管理者的允许，借阅之后限期归还，这就像数据库为数据提供的安全保障。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用数据库的优势&quot;&gt;&lt;a href=&quot;#使用数据库的优势&quot; class=&quot;headerlink&quot; title=&quot;使用数据库的优势&quot;&gt;&lt;/a&gt;使用数据库的优势&lt;/h3&gt;&lt;h4 id=&quot;1、灵活、高效地管理数据&quot;&gt;&lt;a href=&quot;#1、灵活、高效地管理数据&quot; cla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写代码前的准备</title>
    <link href="http://yoursite.com/2017/08/06/%E5%86%99%E4%BB%A3%E7%A0%81%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2017/08/06/写代码前的准备/</id>
    <published>2017-08-05T23:16:38.000Z</published>
    <updated>2017-08-05T16:07:37.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写代码前的准备"><a href="#写代码前的准备" class="headerlink" title="写代码前的准备"></a>写代码前的准备</h3><p>对很多初学者来说，写程序前的第一件事就是打开IDE，然后开始敲代码…</p>
<p>其实，这样是不对的，我们不能着急，程序开发的第一步是分析设计。我们大多数人在初学编程的时候，都喜欢上手就开始写代码，而不习惯先做一些设计思考，更别提将这些设计付诸于笔端了。这有两个方面的原因：一是因为和 “设计” 这样看起来虚无缥缈的东西比起来，代码是实实在在的，运行起来就很有成就感；二是初学编程是写的都是一些小程序，前期设计的作用在这些小规模的程序上体现不出来。但请读者记住，在实际的编程之前做一些前期设计，必要时动笔在纸上写一谢、画一画，是百利无一害的。简单的设计图表能帮助程序员整理思路，回避一些不必要的错误。</p>
<h4 id="什么是设计"><a href="#什么是设计" class="headerlink" title="什么是设计"></a>什么是设计</h4><p>对于面向对象的程序，本质上是对象之间的关系，所以设计的第一步就是找出这个程序里究竟有那些对象。方法说起来也简单：分析现实应用场景，从这些情境中抽出相应的 “角色” ，这些 “角色” 就是程序中的对象。那什么是角色呢？简单来说，就是现实环境中的人与物。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写代码前的准备&quot;&gt;&lt;a href=&quot;#写代码前的准备&quot; class=&quot;headerlink&quot; title=&quot;写代码前的准备&quot;&gt;&lt;/a&gt;写代码前的准备&lt;/h3&gt;&lt;p&gt;对很多初学者来说，写程序前的第一件事就是打开IDE，然后开始敲代码…&lt;/p&gt;
&lt;p&gt;其实，这样是不对
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>代码之髓读书笔记</title>
    <link href="http://yoursite.com/2017/08/01/%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%AB%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/01/代码之髓读书笔记/</id>
    <published>2017-07-31T21:26:19.000Z</published>
    <updated>2017-08-01T04:14:28.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>“内容能够理解，但总觉得不够彻底。”<br>我们在学习编程的过程中总是有这样的感觉。当新学的知识与之身经验以及原来掌握的知识尚未很好的结合的时候，往往会出现这种似懂非懂的状态。<br>“要学的东西太多了，先学什么好呢？”<br>大家曾经为这种问题苦恼过吗？<br>我们都要集中精力学习一些知识要点，但是怎样才能做到呢？</p>
<h4 id="在比较中学习"><a href="#在比较中学习" class="headerlink" title="在比较中学习"></a>在比较中学习</h4><p>我们学习语言也不仅仅是学习语言，而是从学习这门语言中学到一些在其他语言中也能用的一些知识。多种语言共同的知识才是要点。掌握了这些要点，学习其他语言时才会更加轻松。</p>
<ul>
<li><p>语言不同，规则不同</p>
<ul>
<li>在比较中学习多种语言，一些知识我们就能理解的更深刻，因为我们学的是不同语言之间的共性，最基本也是最重要的东西。某种具体的编程语言教程中会罗列出各种各样的规则。其实这些规则并不具有普遍意义，只是因为 “在当前的特定情况下，作此规定能更方便”。也就是说，某种语言的教材里出现的某某规则不过是该语言里的规则，仅此而已。就像在C语言中，0代表假；在Ruby中代表的是真；但在Java中，不能用来当作布尔变量。</li>
</ul>
</li>
</ul>
<h4 id="在历史中学习"><a href="#在历史中学习" class="headerlink" title="在历史中学习"></a>在历史中学习</h4><ul>
<li><p>理解语言设计者的意图</p>
<ul>
<li>在学某种编程语言的某个功能时，如果我们觉得掌握的并不够彻底，无法深入学习时，我么应该站在设计者的角度想一想。为什么设计者要设计这个功能？设计者是为了解决什么问题而设计了这种功能？</li>
</ul>
</li>
<li><p>应该学那种语言，我们无从所知</p>
<ul>
<li>了解了语言的历史，我们对其的理解会更加深刻。“想学编程，但该学那种语言呢？”这个问题是很多初学者要问的，但这个问题有意义吗？没有。因为未来的事谁也说不准。</li>
</ul>
</li>
<li><p>学习适用于各种语言的知识</p>
<ul>
<li>现在还有很多被不同人以不同理由推荐学习的编程语言。然而，在5年后、十年后，单个语言的知识是否依然有用？没人能说的清楚。通过比较不同的语言、了解语言的发展历史及其变化原因，培养对不同语言都试用的理解能力，是非常重要的。</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>“在比较中学习”不是学习某种特定语言的编程，而指的是同时比较几种语言，从而掌握那些知识是因语言的不同而不同的，那些知识是几种语言共享的。</li>
<li>“在历史中学习”指的是探寻语言是如何变化的，以及在发生变化前存在那些问题，从而理解语言为何开发出各种功能。</li>
</ul>
<h3 id="程序语言诞生史"><a href="#程序语言诞生史" class="headerlink" title="程序语言诞生史"></a>程序语言诞生史</h3><p>程序设计语言是如何诞生的？<br>前人是基于什么目的发明了程序设计语言？</p>
<h4 id="连接电缆"><a href="#连接电缆" class="headerlink" title="连接电缆"></a>连接电缆</h4><p>1946年，世界上第一台电子计算机—-ENIAC问世。它可以改变计算方式，即可以更改程序。用现在的话来讲，它是一台可编程计算机。但其编程方法和如今大家熟知的程序设计有很大的不同。它的程序设计就是指把这台计算机不同的端口通过电缆连接起来。每次更改程序是都要重新调整电缆连接方式，是在费劲。<br> 有没有方便一点的方式呢？</p>
<h4 id="程序内置"><a href="#程序内置" class="headerlink" title="程序内置"></a>程序内置</h4><p> 1949年，EDSAC问世。这是一种通过纸带打点的方式来记录和读取数据的计算机。程序作为数据通过纸带输入。不需要重新连接电缆，只需要让计算机不断读取纸带上的数据就可以更改程序了。这比重新连接电缆进步一点了，但还是有缺点了，如果想改程序的话，就很麻烦，代价也很大，虽然我们只想改一个标点符号还是全部，都要从头再来。</p>
<h4 id="FORTRAN语言问世"><a href="#FORTRAN语言问世" class="headerlink" title="FORTRAN语言问世"></a>FORTRAN语言问世</h4><p> 直到1954年，与大家现在使用的语言类似的程序设计语言才被发明出来。这就是FORYRAN（Formula Translating System  公式翻译系统）。现在，我们常用 “X*Y+Z”来表达“X乘 以Y在加Z“ 。最早实现这一点的就是是FORYRAN。将公式转化为机器是是FORYRAN的特点之一。 </p>
<h4 id="程序设计语言产生的原因"><a href="#程序设计语言产生的原因" class="headerlink" title="程序设计语言产生的原因"></a>程序设计语言产生的原因</h4><p> 我们为了获得更轻松辩解的体验而编写程序。但轻松便捷不等于偷工减料。偷工减料在前，痛苦在后，这不是真正的便捷。</p>
<ul>
<li>懒惰：程序员的三大美德之一<ul>
<li>优秀的程序员具有三大美德：懒惰、急躁和傲慢。</li>
<li>懒惰是一项为了减少总量支出，而不留余力地努力的素质。为了节省功夫，设计的程序逐渐被更多的人使用。单独回答每个使用者疑问费时费力，所以出现了注释。所以说，懒惰是程序员最宝贵的素质。</li>
</ul>
</li>
</ul>
<h4 id="语言们各有各的便捷"><a href="#语言们各有各的便捷" class="headerlink" title="语言们各有各的便捷"></a>语言们各有各的便捷</h4><ul>
<li><p>何为便捷</p>
<ul>
<li>语言是为了使什么变得便捷呢？是高速的代码执行？还是简单易于掌握的语言规范呢？抑或是轻松地理解他人编写的代码？比如，C++具有很高的执行力，但其的语言规范变得很复杂；Scheme重视语言规范，追求语言规范简洁；python是一种侧重于把代码阅读变得容易的语言。</li>
</ul>
<ul>
<li>各有各的便捷<ul>
<li>语言的便捷之处各不相同。比如,PHP语言编写Web服务很轻松，但它不擅长文字处理。相反，Haskll和OCaml这样的ML系列语言，编写处理文字的应用很便捷，但编写Web服务是就没有PHP那么便捷了。总的来说，程序设计语言的选用因使用者目的不同而不同。</li>
</ul>
</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>语言只是工具。某种语言是否适合自己，要看使用这种语言能否给我们当前的工作发挥作用或者说能发挥多大的作用，而不是看这种语言是否流行。我们要根据自己的情况选择合适的工具。</li>
</ul>
</li>
</ul>
<h3 id="专栏"><a href="#专栏" class="headerlink" title="专栏"></a>专栏</h3><h4 id="要确认理解是否正确，首先得表达出来"><a href="#要确认理解是否正确，首先得表达出来" class="headerlink" title="要确认理解是否正确，首先得表达出来"></a>要确认理解是否正确，首先得表达出来</h4><ul>
<li>假设我们正在学习一些知识，并自我感觉已经理解了。那么，我们到底是真正理解了呢，还是感觉自己已经理解了呢？仅凭自己苦思冥想是不行的。为了验证理解正确与否，需要表达出来。只能基于自己的理解说出自己的观点，然后让第三方来判断和检验。比如学习英语，就要在别人面前使用自己学到的英语，同时观察别人的反应。不这样做的话，就无法知道自己是否真正掌握了英语。</li>
<li>程序员一直收益于这一点。写文章，写出来的东西即使有错误也可能没人指点出来，或者根本没有人看你的东西。但写程序不一样，语言处理器会事无巨细地做错误检查并指出。这和人打交道不同，只要你方便，它总是有足够的时间和耐心陪你一起。</li>
</ul>
<h4 id="当你不知道学习什么时"><a href="#当你不知道学习什么时" class="headerlink" title="当你不知道学习什么时"></a>当你不知道学习什么时</h4><ul>
<li>应该学习什么？我们经常听到这样的问题。在回答之前，笔者想先问这样一个问题：你学习的目的是什么？我们生活在一个信息爆炸的时代。不管三七二十一统统都学，这样的学习策略已经不在适用。必然要有所学，有所不学。这时，我们就要事先明确自己到底想做什么，然后再去学习能够达到这一目标的知识。</li>
<li>不知道自己要做什么？或许你从一开始就在思考，想做一件完美的事情。一件从没有人想到过的，能获得别人赞誉的事情。如果最初的设想太过宏大导致无从下手，那么这一设想就永远不可能实现。还不如从小事做起，从简单的事情做起。这个过程中，你可以逐渐明白自己那些已经能做、那些还不能做，如果要做还要学习那些知识。长此以往，就能培养出完成更复杂任务的能力。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h3&gt;&lt;p&gt;“内容能够理解，但总觉得不够彻底。”&lt;br&gt;我们在学习编程的过程中总是有这样的感觉。当新学的知识与之身经验以及原来掌握的知识尚未很好
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>玩转cmd</title>
    <link href="http://yoursite.com/2017/07/31/%E7%8E%A9%E8%BD%ACcmd/"/>
    <id>http://yoursite.com/2017/07/31/玩转cmd/</id>
    <published>2017-07-31T00:22:04.000Z</published>
    <updated>2017-07-30T16:50:36.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cmd应用基础"><a href="#cmd应用基础" class="headerlink" title="cmd应用基础"></a>cmd应用基础</h3><p>Posted on 2012-12-15</p>
<h4 id="cmd是什么？"><a href="#cmd是什么？" class="headerlink" title="cmd是什么？"></a>cmd是什么？</h4><p>对于程序员而言，cmd命令提示符是windows操作系统下一个比较重要的工具。对于程序员而言，为了追求更高的效率而抛弃花俏的界面已然是意见很常见的行为，截止到目前的，全世界仍有大量的服务器还使用着单一的命令行界面。</p>
<p>使用命令行界面的一个重要因素就是，在远程管理的过程中，命令行操作紧需要传递少量的数据就可以对机器进行操作，如果是图形界面，由于需要传输大量的图形数据，很可能出现延迟、链接不稳定等情况，亦或者在同样情况下效率没有使用命令行界面操作来得高。所以，至今人们依旧离不开命令行操作。</p>
<p>而cmd则是windows系列操作系统下的命令行操作程序 <strong>(不论是命令行或者是桌面这样的图形界面本质上都是程序)</strong></p>
<p>命令行界面程序cmd.exe所在的目录是C:\Windows\System32</p>
<p>顺带一提我们的桌面（图形操作界面）则是位于C:\Windows下的explorer.exe</p>
<h4 id="如何打开cmd"><a href="#如何打开cmd" class="headerlink" title="如何打开cmd"></a>如何打开cmd</h4><p><strong>方法有很多，以下列举几种</strong></p>
<ol>
<li>打开C:\WindowsSystem32目录，找到cmd.exe双击运行。当然，通常人们都不会这么做。</li>
<li>打开开始菜单-&gt;运行-&gt;输入cmd-&gt;回车</li>
<li>通过快捷键：win（windows商标键） + r 调出运行框，然后输入cmd回车</li>
<li>win7打开开始菜单之后可以直接输入cmd回车</li>
</ol>
<p><strong>关于当前目录</strong></p>
<p>对于新手而言，这是一个必须要搞清楚的问题。首先我们来学习几个命令：</p>
<h5 id="cd-C-cd是change-directory的简写，意思是改变目录，上面这条命令的意思就是切换到C-目录下。"><a href="#cd-C-cd是change-directory的简写，意思是改变目录，上面这条命令的意思就是切换到C-目录下。" class="headerlink" title="cd C:\  cd是change directory的简写，意思是改变目录，上面这条命令的意思就是切换到C:\目录下。"></a>cd C:\  cd是change directory的简写，意思是改变目录，上面这条命令的意思就是切换到C:\目录下。</h5><p>可以观察到，cmd界面上的目录变成了C:\</p>
<p><img src="/images/cmd.jpg" alt=""></p>
<p>我们可以从图中看到，cmd中的文字有变化，而有变化的地方就是我们要注意的地方。</p>
<p>在每一行的最前面就是当前目录的地址，例如最开始的</p>
<p>C:\Users\Lellansin&gt;cd C:\  这当中”C:\Users\Lellansin” 你的账户名称是Admin的话就是C:\Users\Admin,注意是win7的默认目录)就是我的当前目录而执行了cd C:\命令之后当前目录就变成了 C:\</p>
<p>当前目录是一个相对重要的概念，因为很多操作只能对当前目录里面的文件进行。就好比，通常情况下，你要操作E盘某个目录下的某个文件，你首先要双击“我的电脑”打开E盘相应的文件夹，找到那个目录才能操作那个目录下的文件一样。对于cmd而言，要操作相应目录下的文件需要切换到相应的目录。</p>
<h5 id="输入dir回车，系统会返回当前目录下的文件列表"><a href="#输入dir回车，系统会返回当前目录下的文件列表" class="headerlink" title="输入dir回车，系统会返回当前目录下的文件列表"></a>输入dir回车，系统会返回当前目录下的文件列表</h5><ol>
<li><p>如何执行或打开文件</p>
<ul>
<li><p>C:>1.txt</p>
<ul>
<li><p>如果我在C盘根目录下有一个1.txt的文本文件，那么就可以直接输入1.txt回车，即可打开该文件。（这个在linux下也是同样的情况，博主当年也搞不清楚怎么运行程序来着）</p>
</li>
<li><p>同样的，如果存在hello.exe，那么直接输入hello.exe即可运行该程序。当然需要注意的是，某些系统默认的应用程序格式（如.exe文件）在cmd中调用的时候是可以省略后缀的。也就是可以直接输入hello，然后回车也同样可以运行hello.exe。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>环境变量</p>
<ul>
<li><p>环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等。</p>
</li>
<li><p>常见的环境变量：</p>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>变量名</th>
<th style="text-align:right">变量值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Path</td>
<td style="text-align:right">…太多省略…</td>
</tr>
<tr>
<td>OS</td>
<td style="text-align:right">Windows_NT</td>
</tr>
<tr>
<td>windir</td>
<td style="text-align:right">%SystemRoot%</td>
</tr>
<tr>
<td>TMP</td>
<td style="text-align:right">%SystemRoot%TEMP</td>
</tr>
<tr>
<td>ComSpec</td>
<td style="text-align:right">%SystemRoot%system32cmd.exe</td>
</tr>
</tbody>
</table>
<p>至于%SystemRoot%的值是什么，大家只要把它复制到文件浏览上面的地址栏里面然后回车就知道了。</p>
<ol>
<li><p>环境变量的作用</p>
<ul>
<li>为系统或者用户程序设置一些默认参数。比如windir这个环境变量，就可能有程序通过读取这个环境变量的值来查看系统的版本。</li>
</ul>
</li>
<li><p>环境变量的设置方法</p>
<p> -【我的电脑】-&gt;右键【属性】-&gt;【高级】-&gt;【环境变量】-&gt;选中你要修改的环境变量点击【编辑】即可</p>
<ul>
<li>通过cmd设置（不推荐）</li>
</ul>
</li>
<li><p>path的作用</p>
<ul>
<li><p>path是一个很常见得环境变量。主要用来配置系统的默认路径。也就是当你在某个目录下执行某个程序，但是本身目录下却没有这个程序的时候，系统会自动到默认路径下面也去找一找，有没有你要执行的程序。</p>
</li>
<li><p>比如你写了一个hello.exe（编译运行后，能在在程序的相应的debug目录下能找到）。然后把这个hello.exe移动到E:\test目录下，接着</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 切换到E盘</div><div class="line">cd E:\</div><div class="line"># 切换到E盘下的test文件中</div><div class="line">cd test</div><div class="line">#执行hello.exe</div><div class="line">hello.exe</div><div class="line"># 假设程序输出hello world</div><div class="line"># 这个时候再切换到E盘根目录下(cd .. 是切换到上级目录)</div><div class="line">cd ..</div><div class="line"># 再执行hello.exe</div><div class="line">hello.exe</div><div class="line"># 这个时候系统会提醒你找不到这个命令</div><div class="line"># 但是如果你将 E:\test 这个目录加入到 path中，</div><div class="line"># 就可以在任意地方运行hello.exe</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="cmd的常见作用"><a href="#cmd的常见作用" class="headerlink" title="cmd的常见作用"></a>cmd的常见作用</h4><p>1.自动关机<br>2.常看本地ip<br>3.使用ping<br>4.快速查询本地服务、端口使用情况<br>5.快速调用一些常用工具<br>6.原始编程方式，用cmd调用编译<br>7.学汇编都应该知道cmd下的debug<br>8.批处理</p>
<h4 id="自动关机"><a href="#自动关机" class="headerlink" title="自动关机"></a>自动关机</h4><p>先说自动关机,貌似很多人都被开过自动关机的玩笑,我们通过cmd就可以实现自动关机命令</p>
<h6 id="输入shutdown回车"><a href="#输入shutdown回车" class="headerlink" title="输入shutdown回车"></a>输入shutdown回车</h6><p>shutdown并不是一个cmd命令而是一个windows系统自带的程序shutdown.exe，位于C:\WINDOWS\system32目录下，之所以能够直接执行，是因为C:\WINDOWS\system32目录，是系统默认配置在环境变量path中的。其他还有很多的自带程序都在这个目录，以下其他程序不做过多说明。（PS：这里仅仅只讲一些cmd的常见应用，至于cmd的语法之类的，讲了也有些鸡肋，如果想学习批处理再研究也不迟）<br>废话不多说，我们可以从上面的图片看到，直接输入程序自动给出了一些提示，这些参数告诉了我们这个shutdown.exe要怎么使用</p>
<h4 id="shutdown-s"><a href="#shutdown-s" class="headerlink" title="shutdown -s"></a>shutdown -s</h4><p>按照他提示的参数输入这个命令，会弹出提示：</p>
<p>博主是在xp下测试，当然如果是在win7等系统下的话效果会不一样。如果你在实验这个命令，不要慌张马上按照提示执行下面的命令：</p>
<h4 id="取消关机"><a href="#取消关机" class="headerlink" title="取消关机"></a>取消关机</h4><p>shutdown -a<br>接下来我们来看一下这个程序最常用的方式：</p>
<h4 id="1小时-3600秒-后关机"><a href="#1小时-3600秒-后关机" class="headerlink" title="1小时(3600秒)后关机"></a>1小时(3600秒)后关机</h4><p>shutdown -s -t 3600<br>博主就经常用到上面这个命令，甚至桌面常备取消关机的批处理（哈哈，当年没少被开过这种玩笑）<br>好吧，少年，你是要问我批处理是什么嘛？<br>请你新建一个文件把“shutdown -s -t 3600”复制进去，然后保存，另存为.bat后缀的文件（如何更改文件后缀，不懂请戳度娘谷歌），接着双击这个bat文件。<br>如果你看到系统提示你一小时后会自动关闭，那么恭喜你，你已经写好了一个自动关机的批处理文件。那么同样的可以想象，取消关机的批处理，就是一个.bat文件，里面写着一行“shutdown -a”，双击一下就可以运行了（批处理的特点之一）。</p>
<p>当然如果，想在C语言中调用这个命令也很简单。<br>先引入stdlib.h库。接着就可以通过system()命令来调用了，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">    system(&quot;shutdown -s -t 3600&quot;);</div><div class="line">    printf(&quot;自动关机已设置！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="常看本地ip"><a href="#常看本地ip" class="headerlink" title="常看本地ip"></a>常看本地ip</h4><p>通过ipconfig.exe就可以查看本地ip</p>
<p>当然也可以通过 /? 参数获取更多的帮助</p>
<p>ipconfig /?</p>
<p>当然ipconfig还有很多其他的用处，比如按照提示上面说的<br>/all Display full configuration information.<br>通过/all参数调用,可以显示出全部的设置信息:</p>
<p>Windows IP Configuration</p>
<pre><code>Host Name . . . . . . . . . . . . : s3049
Primary Dns Suffix  . . . . . . . :
Node Type . . . . . . . . . . . . : Unknown
IP Routing Enabled. . . . . . . . : No
WINS Proxy Enabled. . . . . . . . : No
</code></pre><p>Ethernet adapter 本地连接:</p>
<pre><code>Connection-specific DNS Suffix  . :
Description . . . . . . . . . . . : Realtek PCIe GBE Family Controller
Physical Address. . . . . . . . . : 78-E3-B5-A3-A5-44
Dhcp Enabled. . . . . . . . . . . : No
IP Address. . . . . . . . . . . . : 172.26.22.49
Subnet Mask . . . . . . . . . . . : 255.255.0.0
Default Gateway . . . . . . . . . : 172.26.2.6
DNS Servers . . . . . . . . . . . : 58.22.96.66
</code></pre><p>（直接复制了，发图麻烦）</p>
<p>这里可以查看到一些常见的信息，比如host name是主机名，Physical Address 则是传说中的mac地址，IP Address 就是你的本机地址（注意这个通常是局域网下的）。至于后面的子网掩码还有默认网关什么的，想了解的一可以去搜索一下。<br>还有/flushdns(flush DNS)刷新DNS缓存什么的。相信这些信息，网管专业的同学应该都非常熟悉。（注：不明情况的围观群众不要随意开跳这个坑，了解基本即可。）</p>
<h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>记得原来微博上面有个吐槽，就是说很多人普通人用百度来搜索，而很多程序员则用百度来测试网络是否联通。那么如果使用ping.exe来测试网络是否联通：</p>
<p>ping www.baidu.com</p>
<p>除了这个用处以外还有一个很常见的作用就是测试自己是否能够连接到某个ip，这里有一个路由器，连接了两台电脑，在每台电脑上都可以通过ipconfig查看自己在局域网中的ip地址，假设对方的ip是192.168.1.106。那么便可以使用ping命令测试是否能联通对方的电脑。</p>
<p>ping 192.168.1.106<br>当然，眼尖的同学应该已经发现了ping.exe的另一个作用，那就使用获取某个网站的ip地址：</p>
<p>其他闲话</p>
<p>至于<br>4.快速查询本地服务、端口使用情况<br>5.快速调用一些常用工具<br>6.原始编程方式，用cmd调用编译<br>7.学汇编都应该知道cmd下的debug<br>8.批处理</p>
<p>这些有的内容对于新手而言略坑，这里暂不做介绍。</p>
<p>其中的5.快速调用一些常用工具，就简单说一下博主常用的工具：</p>
<p>notepad 记事本<br>calc 计算器<br>mspaint 画图板</p>
<p>这些实际上通过菜单调出运行（或者win+r）就可以直接输入调出来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;cmd应用基础&quot;&gt;&lt;a href=&quot;#cmd应用基础&quot; class=&quot;headerlink&quot; title=&quot;cmd应用基础&quot;&gt;&lt;/a&gt;cmd应用基础&lt;/h3&gt;&lt;p&gt;Posted on 2012-12-15&lt;/p&gt;
&lt;h4 id=&quot;cmd是什么？&quot;&gt;&lt;a href=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="http://yoursite.com/2017/07/31/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2017/07/31/Java异常处理/</id>
    <published>2017-07-30T19:13:02.000Z</published>
    <updated>2017-08-05T16:13:46.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><h4 id="先说什么是异常"><a href="#先说什么是异常" class="headerlink" title="先说什么是异常"></a>先说什么是异常</h4><p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的错误条件。当条件生成时，错误将引发异常。<strong>异常的正确使用，能帮助程序员迅速找到异常的出现，同时，也不至于让程序崩溃，得已继续执行下去。当然，在出现异常后，还能让程序继续运行去，对程序员的要求是极高的。</strong></p>
<h4 id="Java的异常处理方式"><a href="#Java的异常处理方式" class="headerlink" title="Java的异常处理方式"></a>Java的异常处理方式</h4><ol>
<li><p>throw Exception.当我们写个函数来处理IO流或Socket连接的时候，函数内部可能会发生错误，我们就需要把程序抛出给调用函数的人，让他来处理。</p>
</li>
<li><p>try..catch。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">    可能出现异常的语句</div><div class="line">&#125;eacth(Exception e)&#123;  //捕捉异常</div><div class="line">    处理异常的语句</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方式，也就是说我们知道要发生的具体错误是什么，然后我们自己解决掉错误。</p>
<h4 id="异常的重要性"><a href="#异常的重要性" class="headerlink" title="异常的重要性"></a>异常的重要性</h4><blockquote>
<p>在一个完美的世界中，用户不会输入错误，计算机硬件永远不会出错，相关的数据文件永远不会被丢失…遗憾的是，这个世界并不是如此美好。</p>
</blockquote>
<p>程序运行时可能遇到各种非正常状况—-用户输入的数据非法、电脑硬盘空间不足，程序所需要的文件被删除等等。一个足够健壮的程序，用于处理异常的代码要占到很大部分。正是由于异常处理如此重要，Java设计者将异常处理作为Java语言的一种内置特性。在其他语言中，编写者可以偷懒不写异常处理；而在Java中，如果一个方法声明可能会抛出异常，那么调用方法的人必须对此进行处理；否则不能编译通过。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>不知道我们有没有想过为什么Java需要有两种异常处理方式呢？我们应该知道，我们写的代码、写的类、写的函数，不仅仅只是我们自己用的，同时我们也发现这两种方式对异常的处理也是不同的。throw这种方式，错误是由调用方来解决的；try..catch这种方式呢，是写代码的人来解决的。学技术，不仅仅只是为了知道怎么使用这种技术，还应该清楚技术背后的含义。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java异常处理&quot;&gt;&lt;a href=&quot;#Java异常处理&quot; class=&quot;headerlink&quot; title=&quot;Java异常处理&quot;&gt;&lt;/a&gt;Java异常处理&lt;/h3&gt;&lt;h4 id=&quot;先说什么是异常&quot;&gt;&lt;a href=&quot;#先说什么是异常&quot; class=&quot;header
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>windows 安装Mysql</title>
    <link href="http://yoursite.com/2017/07/31/windows-%E5%AE%89%E8%A3%85Mysql/"/>
    <id>http://yoursite.com/2017/07/31/windows-安装Mysql/</id>
    <published>2017-07-30T19:11:01.000Z</published>
    <updated>2017-07-30T15:59:29.802Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Windows-环境下-MySQL-5-7-安装配置指南"><a href="#Windows-环境下-MySQL-5-7-安装配置指南" class="headerlink" title="Windows 环境下 MySQL 5.7 安装配置指南"></a>Windows 环境下 MySQL 5.7 安装配置指南</h3><h5 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h5><ul>
<li>Windows 版本：Windows 10 专业版 64bit</li>
<li>MySQL 版本：MySQL 5.7.16</li>
</ul>
<h5 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h5><p>在安装 MySQL 前请务必确认自己电脑的 net 指令是正常工作的。有些 Windows 系统会丢失 net 指令<em>(环境变量缺失)</em>，解决方法请自行搜索一下。</p>
<h4 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h4><ol>
<li><p>下载 MySQL Community Server <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">下载链接</a></p>
<ul>
<li>选择合适自己操作系统的版本，通常使用 Windows (x86, 64-bit), ZIP Archive</li>
</ul>
</li>
<li><p>解压并“合理安放” MySQL Server。</p>
<ul>
<li>将下载好的mysql-5.7.16-winx64.zip解压，并将解压好的文件夹妥善放置（比如放置在 Program FIles 文件夹内）。本教程中 MySQL 被放置在了D:\ProgramFiles下，并被重命名为了 MySQL。</li>
</ul>
</li>
<li><p>为 MySQL Server 配置环境变量</p>
<ul>
<li>右击开始菜单按钮，选择“系统”选项。</li>
<li>在“系统”界面左侧，选择“高级系统设置”。</li>
<li><p>在打开的“系统属性”对话框中的“高级”选项卡页面的下方，选择“环境变量”。</p>
<ul>
<li><p>系统属性设置窗口</p>
<p> 在“用户变量”区块中，选择“新建”，在打开的对话框中，变量名写 MySQL，变量值写 MySQL 文件夹的完整路径（本教程为D:\Program Files\MySQL）。</p>
</li>
<li><p>添加环境变量</p>
<p> 同样在用户区块中寻找 PATH 环境变量，如果有，点击“编辑”。在弹出的对<br> 话框中点击“新建”，输入%MySQL%\bin（在老版本 Windows 系统中，变量值末尾用英文分号;分开后再添加%MySQL%\bin）。如果没有，点击“新建”，添加一个变量名为 Path 的环境变量。在这个环境变量的变量值处，添加%MySQL%\bin</p>
</li>
<li><p>修改环境变量<br>  点击确定按钮退出环境变量配置对话框。<br>  点击确定按钮退出系统属性配置对话框。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注册 MySQL 服务</p>
<ul>
<li>右击开始菜单按钮，选择/“命令提示符（管理员）”/选项。</li>
<li>输入盘符 + “:” 指令，进入MySQL文件夹所在的磁盘（本教程是 D 盘）。再使用  cd指令进入MySQL Server所在文件夹的bin文件夹中。<strong>这一步非常重要，如果不在这个目录下，无法正确注册 MySQL 服务。</strong></li>
</ul>
</li>
<li><p>定位到 MySQL 所在路径</p>
<ul>
<li>执行mysqld -install指令，注册 MySQL 服务。</li>
</ul>
</li>
<li><p>注册 MySQL 服务</p>
<ul>
<li>执行完毕后，请不要退出“命令提示符”。</li>
</ul>
</li>
<li><p>配置 MySQL Server</p>
<ul>
<li>进入 MySQL Server 所在的文件夹 （本教程为D:\Program Files\MySQL）</li>
<li><p>编辑my-default.ini</p>
<ul>
<li><p>在该文件中，#是注释标记。<br>去掉 basedir 的注释符号，并在等号后边填写 MySQL Server 文件夹的完整地址。<br>去掉 datadir 的注释符号，并在等号后边填写 MySQL Server 文件夹的完整地址外加\data。<br> <strong>切记不要手动创建 data 文件夹！</strong></p>
</li>
<li><p>port 不需要配置，不配置的状态下默认为 3306。（MySQL Server 默认使用的端口号）</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>最终配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># For advice on how to change settings please see</div><div class="line"># http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</div><div class="line"># *** DO NOT EDIT THIS FILE. It&apos;s a template which will be copied to the</div><div class="line"># *** default location during install, and will be replaced if you</div><div class="line"># *** upgrade to a newer version of MySQL.</div><div class="line"></div><div class="line">[mysqld]</div><div class="line"></div><div class="line"># Remove leading # and set to the amount of RAM for the most important data</div><div class="line"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</div><div class="line"># innodb_buffer_pool_size = 128M</div><div class="line"></div><div class="line"># Remove leading # to turn on a very important data integrity option: logging</div><div class="line"># changes to the binary log between backups.</div><div class="line"># log_bin</div><div class="line"></div><div class="line"># These are commonly set, remove the # and set as required.</div><div class="line">basedir =D:\Program Files\MySQL</div><div class="line">datadir =D:\Program Files\MySQL\date</div><div class="line"># port = .....</div><div class="line"># server_id = .....</div><div class="line"></div><div class="line"></div><div class="line"># Remove leading # to set options mainly useful for reporting servers.</div><div class="line"># The server defaults are faster for transactions and fast SELECTs.</div><div class="line"># Adjust sizes as needed, experiment to find the optimal values.</div><div class="line"># join_buffer_size = 128M</div><div class="line"># sort_buffer_size = 2M</div><div class="line"># read_rnd_buffer_size = 2M </div><div class="line"></div><div class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</div></pre></td></tr></table></figure></p>
<p>保存退出。退出后将my-default.ini重命名为my.ini</p>
<ol>
<li><p>在刚才的“命令提示符”中，执行mysqld –initialize（可能会假死，等一分钟手动关闭就好）。</p>
</li>
<li><p>开启 MySQL Server</p>
<ul>
<li>在“命令提示符”中执行net start mysql，开启 MySQL Server。</li>
</ul>
</li>
<li><p>配置 MySQL root 账户。</p>
<ul>
<li>在“命令提示符”中，执行net stop mysql关闭 MySQL Server。</li>
<li>再执行mysqld –skip-grant-tables开启无密码的 MySQL Server。</li>
</ul>
</li>
<li><p>无密码启动 MySQL Server</p>
<ul>
<li>打开一个新的“命令提示符”，执行mysql -u root登陆 MySQL Server。</li>
<li>执行flush privileges刷新权限。</li>
<li>执行grant all privileges on <em>.</em> to ‘root’@’localhost’ identified by ‘你想设置的密码’ with grant option;。</li>
<li>执行flush privileges刷新新的 root 用户密码。</li>
<li>执行exit退出 MySQL。</li>
</ul>
</li>
<li><p>结束进程</p>
<ul>
<li>在任务管理器下手动结束mysqld.exe。</li>
</ul>
</li>
<li><p>正常登陆</p>
<ul>
<li>在“命令提示符”下执行net mysql start重新开启MySQL Server，再次使用mysql -u root -p 你设置的密码即可安全登陆 MySQL。</li>
</ul>
</li>
</ol>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p><strong>本教程中所有的“命令提示符”，一定要运行在 管理员模式下，否则会出现“拒绝访问”的问题。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Windows-环境下-MySQL-5-7-安装配置指南&quot;&gt;&lt;a href=&quot;#Windows-环境下-MySQL-5-7-安装配置指南&quot; class=&quot;headerlink&quot; title=&quot;Windows 环境下 MySQL 5.7 安装配置指南&quot;&gt;&lt;/a&gt;Wi
    
    </summary>
    
      <category term="config" scheme="http://yoursite.com/categories/config/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
</feed>
