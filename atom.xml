<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-15T15:56:45.250Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工具|gcc的一些坑</title>
    <link href="http://yoursite.com/2018/03/16/%E5%B7%A5%E5%85%B7-gcc%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2018/03/16/工具-gcc的一些坑/</id>
    <published>2018-03-15T23:44:27.000Z</published>
    <updated>2018-03-15T15:56:45.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C 语言、Pascal 语言、COBOL语言，以及支持函数式编程和逻辑编程的 Mercury 语言，等等。而 GCC 也不再单只是 GNU C 语言编译器的意思了，而是变成了 GNU Compiler Collection 也即是 GNU 编译器家族的意思了。另一方面，说到 GCC 对于操作系统平台及硬件平台支持，概括起来就是一句话：无所不在</p>
<h3 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use?"></a>How to use?</h3><p>gcc说到底也就是一个工具，知道怎么用才是硬功夫。</p>
<h4 id="简单编译"><a href="#简单编译" class="headerlink" title="简单编译"></a>简单编译</h4><p>示例程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//test.c</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Hello World!\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序，一步到位的编译指令是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.c -o test</div></pre></td></tr></table></figure></p>
<p>实质上，上述编译过程是分为四个阶段进行的，即预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。</p>
<h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -E test.c -o test.i 或 gcc -E test.c</div></pre></td></tr></table></figure>
<p>可以输出test.i文件中存放着test.c经预处理之后的代码。打开test.i文件，看一看，就明白了。后面那条指令，是直接在命令行窗口中输出预处理后的代码.</p>
<p>gcc的-E选项，可以让编译器在预处理后停止，并输出预处理结果。在本例中，预处理结果就是将stdio.h 文件中的内容插入到test.c中了。</p>
<h5 id="编译为汇编代码-Compilation"><a href="#编译为汇编代码-Compilation" class="headerlink" title="编译为汇编代码(Compilation)"></a>编译为汇编代码(Compilation)</h5><p>预处理之后，可直接对生成的test.i文件编译，生成汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -S test.i -o test.s</div></pre></td></tr></table></figure></p>
<p>gcc的-S选项，表示在程序编译期间，在生成汇编代码后，停止，-o输出汇编代码文件。</p>
<h5 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly)"></a>汇编(Assembly)</h5><p>对于上一小节中生成的汇编代码文件test.s，gas汇编器负责将其编译为目标文件，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c test.s -o test.o</div></pre></td></tr></table></figure></p>
<h5 id="连接-Linking"><a href="#连接-Linking" class="headerlink" title="连接(Linking)"></a>连接(Linking)</h5><p>gcc连接器是gas提供的，负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p>
<p>对于上一小节中生成的test.o，将其与Ｃ标准输入输出库进行连接，最终生成程序test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.o -o test</div></pre></td></tr></table></figure></p>
<p>最后，在命令行窗口中，执行./test, 让它说HelloWorld吧！</p>
<h4 id="多个程序文件的编译"><a href="#多个程序文件的编译" class="headerlink" title="多个程序文件的编译"></a>多个程序文件的编译</h4><p>通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC能够很好地管理这些编译单元。假设有一个由test1.c和 test2.c两个源文件组成的程序，为了对它们进行编译，并最终生成可执行程序test，可以使用下面这条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test1.c test2.c -o test</div></pre></td></tr></table></figure></p>
<p>如果同时处理的文件不止一个，GCC仍然会按照预处理、编译和链接的过程依次进行。如果深究起来，上面这条命令大致相当于依次执行如下三条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -c test1.c -o test1.o</div><div class="line">gcc -c test2.c -o test2.o</div><div class="line">gcc test1.o test2.o -o test</div></pre></td></tr></table></figure></p>
<h4 id="检错"><a href="#检错" class="headerlink" title="检错"></a>检错</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -pedantic illcode.c -o illcode</div></pre></td></tr></table></figure>
<p><strong>-pedantic</strong>编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，<strong>-pedantic</strong>选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。</p>
<p>除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多的警告信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Wall illcode.c -o illcode</div></pre></td></tr></table></figure></p>
<p>GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Werror test.c -o test</div></pre></td></tr></table></figure></p>
<h4 id="库文件连接"><a href="#库文件连接" class="headerlink" title="库文件连接"></a>库文件连接</h4><p>开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。。虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。</p>
<p>例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so</p>
<p>其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib</p>
<h5 id="编译成可执行文件"><a href="#编译成可执行文件" class="headerlink" title="编译成可执行文件"></a>编译成可执行文件</h5><p>首先我们要进行编译test.c为目标文件，这个时候需要执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –c –I /usr/dev/mysql/include test.c –o test.o</div></pre></td></tr></table></figure></p>
<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p>最后我们把所有目标文件链接成可执行文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test</div></pre></td></tr></table></figure></p>
<p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。</p>
<h5 id="强制链接时使用静态链接库"><a href="#强制链接时使用静态链接库" class="headerlink" title="强制链接时使用静态链接库"></a>强制链接时使用静态链接库</h5><p>默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p>
<p>在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test</div></pre></td></tr></table></figure></p>
<p>静态库链接时搜索路径顺序：</p>
<ol>
<li>ld会去找GCC命令中的参数-L</li>
<li>再找gcc的环境变量LIBRARY_PATH</li>
<li>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</li>
</ol>
<p>动态链接时、执行时搜索路径顺序:</p>
<ol>
<li>编译目标代码时指定的动态库搜索路径</li>
<li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li>
<li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li>
<li>默认的动态库搜索路径/lib</li>
<li>默认的动态库搜索路径/usr/lib</li>
</ol>
<p>有关环境变量：<br>LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径<br>LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>面试|SpringMVC常见面试题</title>
    <link href="http://yoursite.com/2018/03/15/%E9%9D%A2%E8%AF%95-SpringMVC%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/15/面试-SpringMVC常见面试题/</id>
    <published>2018-03-14T19:15:46.000Z</published>
    <updated>2018-03-15T15:56:49.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="什么是Spring框架？Spring框架有哪些主要模块？"><a href="#什么是Spring框架？Spring框架有哪些主要模块？" class="headerlink" title="什么是Spring框架？Spring框架有哪些主要模块？"></a>什么是Spring框架？Spring框架有哪些主要模块？</h4><p>Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。</p>
<p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p>
<p><img src="/images/面试--Spring-01.png" alt="Spring模块" title="面试--Spring-01"></p>
<h4 id="使用Spring框架能带来哪些好处？"><a href="#使用Spring框架能带来哪些好处？" class="headerlink" title="使用Spring框架能带来哪些好处？"></a>使用Spring框架能带来哪些好处？</h4><p>下面列举了一些使用Spring框架带来的主要好处：</p>
<ul>
<li>Dependency Injection(DI) 方法使得构造器和JavaBean properties文件中的依赖关系一目了然。</li>
<li>与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。</li>
<li>Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。</li>
<li>Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li>要测试一项用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。</li>
<li>Spring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。</li>
<li>Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。</li>
</ul>
<h4 id="什么是控制反转-IOC-？什么是依赖注入？"><a href="#什么是控制反转-IOC-？什么是依赖注入？" class="headerlink" title="什么是控制反转(IOC)？什么是依赖注入？"></a>什么是控制反转(IOC)？什么是依赖注入？</h4><p>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。</p>
<p>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。</p>
<p>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？</p>
<p>在Java中依然注入有以下三种实现方式：</p>
<ol>
<li>构造器注入</li>
<li>Setter方法注入</li>
<li>接口注入</li>
</ol>
<h4 id="请解释下Spring框架中的IoC？"><a href="#请解释下Spring框架中的IoC？" class="headerlink" title="请解释下Spring框架中的IoC？"></a>请解释下Spring框架中的IoC？</h4><p>Spring中的 org.springframework.beans 包和 org.springframework.context包构成了Spring框架IoC容器的基础。</p>
<p>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。</p>
<p>org.springframework.beans.factory.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。</p>
<h4 id="谈谈你对spring-IOC和DI的理解，它们有什么区别？"><a href="#谈谈你对spring-IOC和DI的理解，它们有什么区别？" class="headerlink" title="谈谈你对spring IOC和DI的理解，它们有什么区别？"></a>谈谈你对spring IOC和DI的理解，它们有什么区别？</h4><p>IoC Inverse of Control 反转控制的概念，就是将原本在程序中手动创建UserService对象的控制权，交由Spring框架管理，简单说，就是创建UserService对象控制权被反转到了Spring框架</p>
<p>DI：Dependency Injection 依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件</p>
<p><img src="/images/面试--Spring-03.jpg" alt="Spring-Ioc" title="面试--Spring-03"></p>
<p><strong>[IoC 控制反转，指将对象的创建权，反转到Spring容器 ， DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入]</strong></p>
<h4 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h4><p>BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。</p>
<p>BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。</p>
<p>从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。</p>
<ul>
<li>提供了支持国际化的文本消息</li>
<li>统一的资源文件读取方式</li>
<li>已在监听器中注册的bean的事件</li>
</ul>
<p>以下是三种较常见的 ApplicationContext 实现方式：</p>
<p>1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</p>
<blockquote>
<p>ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p>
</blockquote>
<p>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。</p>
<blockquote>
<p>ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);</p>
</blockquote>
<p>3、XmlWebApplicationContext：由Web应用的XML文件读取上下文。</p>
<p>6、Spring有几种配置方式？<br>将Spring配置到应用开发中有以下三种方式：</p>
<p>基于XML的配置<br>基于注解的配置<br>基于Java的配置</p>
<h4 id="如何用基于XML配置的方式配置Spring？"><a href="#如何用基于XML配置的方式配置Spring？" class="headerlink" title="如何用基于XML配置的方式配置Spring？"></a>如何用基于XML配置的方式配置Spring？</h4><p>在Spring框架中，依赖和服务需要在专门的配置文件来实现，我常用的XML格式的配置文件。这些配置文件的格式通常用<beans>开头，然后一系列的bean定义和专门的应用配置选项组成。</beans></p>
<p>SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式）</p>
<p>Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line"> </div><div class="line">    &lt;!-- JSON Support --&gt;</div><div class="line">    &lt;bean name=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;/&gt;</div><div class="line">    &lt;bean name=&quot;jsonTemplate&quot; class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;/&gt;</div><div class="line"> </div><div class="line">    &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;/&gt;</div><div class="line"> </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>下面这个web.xml仅仅配置了DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;web-app&gt;</div><div class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</div><div class="line"> </div><div class="line">  &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;</div><div class="line">            &lt;servlet-class&gt;</div><div class="line">                org.springframework.web.servlet.DispatcherServlet</div><div class="line">            &lt;/servlet-class&gt;</div><div class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line"> </div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line"> </div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<h4 id="请解释Spring-Bean的生命周期？"><a href="#请解释Spring-Bean的生命周期？" class="headerlink" title="请解释Spring Bean的生命周期？"></a>请解释Spring Bean的生命周期？</h4><p>Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。</p>
<p>Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。</p>
<ol>
<li>初始化之后调用的回调方法。</li>
<li>销毁之前调用的回调方法。</li>
</ol>
<p>Spring框架提供了以下四种方式来管理bean的生命周期事件：</p>
<ul>
<li>InitializingBean和DisposableBean回调接口</li>
<li>针对特殊行为的其他Aware接口</li>
<li>Bean配置文件中的Custom init()方法和destroy()方法</li>
<li>@PostConstruct和@PreDestroy注解方式</li>
</ul>
<p>使用customInit()和 customDestroy()方法管理bean生命周期的代码样例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">    &lt;bean id=&quot;demoBean&quot; class=&quot;com.howtodoinjava.task.DemoBean&quot;</div><div class="line">            init-method=&quot;customInit&quot; destroy-method=&quot;customDestroy&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Bean注入属性有哪几种方式？"><a href="#Bean注入属性有哪几种方式？" class="headerlink" title="Bean注入属性有哪几种方式？"></a>Bean注入属性有哪几种方式？</h4><p><img src="/images/面试--Spring-04.jpg" alt="Bean注入方式" title="面试--Spring-04"></p>
<h4 id="什么是AOP，AOP的作用是什么？"><a href="#什么是AOP，AOP的作用是什么？" class="headerlink" title="什么是AOP，AOP的作用是什么？"></a>什么是AOP，AOP的作用是什么？</h4><p>面向切面编程（AOP）提供另外一种角度来思考程序结构，通过这种方式弥补了面向对象编程（OOP）的不足，除了类（classes）以外，AOP提供了切面。切面对关注点进行模块化，例如横切多个类型和对象的事务管理。</p>
<p>Spring的一个关键的组件就是AOP框架，可以自由选择是否使用AOP 提供声明式企业服务，特别是为了替代EJB声明式服务。最重要的服务是声明性事务管理，这个服务建立在Spring的抽象事物管理之上。允许用户实现自定义切面，用AOP来完善OOP的使用,可以把Spring AOP看作是对Spring的一种增强。</p>
<p><img src="/images/面试--Spring-05.jpg" alt="Spring-AOP" title="面试--Spring-05"></p>
<h4 id="Spring的核心类有哪些，各有什么作用？"><a href="#Spring的核心类有哪些，各有什么作用？" class="headerlink" title="Spring的核心类有哪些，各有什么作用？"></a>Spring的核心类有哪些，各有什么作用？</h4><ul>
<li>BeanFactory：产生一个新的实例，可以实现单例模式</li>
<li>BeanWrapper：提供统一的get及set方法</li>
<li>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="简单的谈一下SpringMVC的工作流程？"><a href="#简单的谈一下SpringMVC的工作流程？" class="headerlink" title="简单的谈一下SpringMVC的工作流程？"></a>简单的谈一下SpringMVC的工作流程？</h4><p><img src="/images/面试--Spring-02.jpg" alt="SpringMVC工作流程" title="面试--Spring-02"></p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet </li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。 </li>
<li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器 </li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li>
<li>Controller执行完成返回ModelAndView </li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet </li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器 </li>
<li>ViewReslover解析后返回具体View </li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li>
<li>DispatcherServlet响应用户</li>
</ol>
<p>总的来说，系统启动的时候根据配置文件创建spring的容器, 首先是发送http请求到核心控制器disPatherServlet，spring容器通过映射器去寻找业务控制器， 使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用ModelAndView进行视图转发，数据放在model中，用map传递数据进行页面显示。</p>
<h4 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h4><ol>
<li>在web.xml中加入：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
<p>以上可以解决post请求乱码问题。对于get请求中文参数出现乱码解决方法有两个：</p>
<ol>
<li><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>另外一种方法对参数进行重新编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>
<h4 id="SpringMVC与Struts2的主要区别？"><a href="#SpringMVC与Struts2的主要区别？" class="headerlink" title="SpringMVC与Struts2的主要区别？"></a>SpringMVC与Struts2的主要区别？</h4><ul>
<li>①springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li>
<li>②springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。 </li>
<li>③Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。 Jsp视图解析器默认使用jstl。</li>
</ul>
<p><a href="http://www.cnblogs.com/wang-meng/p/5701946.html" target="_blank" rel="external">Java面试大全</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h3&gt;&lt;h4 id=&quot;什么是Spring框架？Spring框架有哪些主要模块？&quot;&gt;&lt;a href=&quot;#什么是Spring
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>工具|虚拟机的一些坑</title>
    <link href="http://yoursite.com/2018/03/13/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2018/03/13/工具-虚拟机的一些坑/</id>
    <published>2018-03-13T09:25:11.000Z</published>
    <updated>2018-03-14T11:23:39.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="虚拟机的三种联网方式"><a href="#虚拟机的三种联网方式" class="headerlink" title="虚拟机的三种联网方式"></a>虚拟机的三种联网方式</h3><p>vmware为我们提供了三种网络工作模式，它们分别是：Bridged（桥接模式）、NAT（网络地址转换模式）、Host-Only（仅主机模式）。</p>
<p>打开vmware虚拟机，我们可以在选项栏的“编辑”下的“虚拟网络编辑器”中看到VMnet0（桥接模式）、VMnet1（仅主机模式）、VMnet8（NAT模式），那么这些都是有什么作用呢？其实，我们现在看到的VMnet0表示的是用于桥接模式下的虚拟交换机；VMnet1表示的是用于仅主机模式下的虚拟交换机；VMnet8表示的是用于NAT模式下的虚拟交换机。</p>
<p><img src="/images/工具--虚拟机-三种联网方式-01.png" alt="虚拟机三种联网方式" title="工具--虚拟机-三种联网方式-01"></p>
<p>同时，在主机上对应的有VMware Network Adapter VMnet1和VMware Network Adapter VMnet8两块虚拟网卡，它们分别作用于仅主机模式与NAT模式下。在“网络连接”中我们可以看到这两块虚拟网卡，如果将这两块卸载了，可以在vmware的“编辑”下的“虚拟网络编辑器”中点击“还原默认设置”，可重新将虚拟网卡还原。</p>
<p><img src="/images/工具--虚拟机-三种联网方式-02.png" alt="主机网卡" title="工具--虚拟机-三种联网方式-02"></p>
<p>小伙伴看到这里，肯定有疑问，为什么在真机上没有VMware Network Adapter VMnet0虚拟网卡呢？那么接下来，我们就一起来看一下这是为什么。</p>
<h4 id="Bridged（桥接模式）"><a href="#Bridged（桥接模式）" class="headerlink" title="Bridged（桥接模式）"></a>Bridged（桥接模式）</h4><p>什么是桥接模式？桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。  </p>
<p>在桥接模式下，虚拟机和宿主计算机处于同等地位，虚拟机就像是一台真实主机一样存在于局域网中。因此在桥接模式下，我们就要像对待其他真实计算机一样为其配置IP、网关、子网掩码等等。</p>
<p>其网络结构如下图所示：</p>
<p><img src="/images/工具--虚拟机-三种联网方式-03.png" alt="桥接" title="工具--虚拟机-三种联网方式-03"></p>
<p>接下来，我们就来实际操作，如何设置桥接模式。</p>
<p>首先，安装完系统之后，在开启系统之前，点击“编辑虚拟机设置”来设置网卡模式。</p>
<h5 id="How-to-do"><a href="#How-to-do" class="headerlink" title="How to do"></a>How to do</h5><ol>
<li>首先，安装完系统之后，在开启系统之前，点击“编辑虚拟机设置”来设置网卡模式。</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-04.png" alt="How-one" title="工具--虚拟机-三种联网方式-04"></p>
<ol>
<li>点击“网络适配器”，选择“桥接模式”，然后“确定”</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-05.png" alt="Hoe-two" title="工具--虚拟机-三种联网方式-05"></p>
<ol>
<li>在进入系统之前，我们先确认一下主机的ip地址、网关、DNS等信息。</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-06.png" alt="How-three" title="工具--虚拟机-三种联网方式-06"></p>
<ol>
<li>然后，进入系统编辑网卡配置文件，命令为vi /etc/sysconfig/network-scripts/ifcfg-eth0</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-07.png" alt="How-four" title="工具--虚拟机-三种联网方式-07"></p>
<ol>
<li>添加内容如下：</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-08.png" alt="How-five" title="工具--虚拟机-三种联网方式-08"></p>
<ol>
<li>编辑完成，保存退出，然后重启虚拟机网卡，使用ping命令ping外网ip，测试能否联网。</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-09.png" alt="How-six" title="工具--虚拟机-三种联网方式-09"></p>
<ol>
<li>能ping通外网ip，证明桥接模式设置成功。那主机与虚拟机之间的通信是否正常呢？我们就用远程工具来测试一下。</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-.png" alt="How-seven" title="工具--虚拟机-三种联网方式-"></p>
<p>主机与虚拟机通信正常。</p>
<p>这就是桥接模式的设置步骤，相信大家应该学会了如何去设置桥接模式了。桥接模式配置简单，但如果你的网络环境是ip资源很缺少或对ip管理比较严格的话，那桥接模式就不太适用了。</p>
<h4 id="NAT（地址转换模式）"><a href="#NAT（地址转换模式）" class="headerlink" title="NAT（地址转换模式）"></a>NAT（地址转换模式）</h4><p>刚刚我们说到，如果你的网络ip资源紧缺，但是你又希望你的虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。其网络结构如下图所示：</p>
<p><img src="/images/工具--虚拟机-三种联网方式-11.png" alt="NAT模式" title="工具--虚拟机-三种联网方式-11"></p>
<p>在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。那么我们会觉得很奇怪，为什么需要虚拟网卡VMware Network Adapter VMnet8呢？原来我们的VMware Network Adapter VMnet8虚拟网卡主要是为了实现主机与虚拟机之间的通信。在之后的设置步骤中，我们可以加以验证。</p>
<h4 id="How-to-do-1"><a href="#How-to-do-1" class="headerlink" title="How to do"></a>How to do</h4><ol>
<li><p>首先，设置虚拟机中NAT模式的选项，打开vmware，点击“编辑”下的“虚拟网络编辑器”，设置NAT参数及DHCP参数。<br><img src="/images/工具--虚拟机-三种联网方式-12.png" alt="How-one" title="工具--虚拟机-三种联网方式-12"><br><img src="/images/工具--虚拟机-三种联网方式-13.png" alt="How-two" title="工具--虚拟机-三种联网方式-13"><br><img src="/images/工具--虚拟机-三种联网方式-14.png" alt="How-three" title="工具--虚拟机-三种联网方式-14"></p>
</li>
<li><p>将虚拟机的网络连接模式修改成NAT模式，点击“编辑虚拟机设置”，然后点击“网络适配器”，选择“NAT模式”<br><img src="/images/工具--虚拟机-三种联网方式-15.png" alt="How-four" title="工具--虚拟机-三种联网方式-15"><br><img src="/images/工具--虚拟机-三种联网方式-6.png" alt="How-five" title="工具--虚拟机-三种联网方式-6"></p>
</li>
<li><p>然后开机启动系统，编辑网卡配置文件，命令为vi /etc/sysconfig/network-scripts/ifcfg-eth0<br><img src="/images/工具--虚拟机-三种联网方式-17.png" alt="How-six" title="工具--虚拟机-三种联网方式-17"><br><img src="/images/工具--虚拟机-三种联网方式-18.png" alt="How-seven" title="工具--虚拟机-三种联网方式-18"></p>
</li>
<li><p>编辑完成，保存退出，然后重启虚拟机网卡，动态获取ip地址，使用ping命令ping外网ip，测试能否联网。</p>
</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-19.png" alt="How-eight" title="工具--虚拟机-三种联网方式-19"></p>
<ol>
<li>之前，我们说过VMware Network Adapter VMnet8虚拟网卡的作用，那我们现在就来测试一下。</li>
</ol>
<p><img src="/images/工具--虚拟机-三种联网方式-20.png" alt="How-nine" title="工具--虚拟机-三种联网方式-20"></p>
<p>如此看来，虚拟机能联通外网，确实不是通过VMware Network Adapter VMnet8虚拟网卡，那么为什么要有这块虚拟网卡呢？<br>之前我们就说VMware Network Adapter VMnet8的作用是主机与虚拟机之间的通信，接下来，我们就用远程连接工具来测试一下。</p>
<p><img src="/images/工具--虚拟机-三种联网方式-21.png" alt="How-ten" title="工具--虚拟机-三种联网方式-21"></p>
<p>然后，将VMware Network Adapter VMnet8启用之后，发现远程工具可以连接上虚拟机了。</p>
<p>那么，这就是NAT模式，利用虚拟的NAT设备以及虚拟DHCP服务器来使虚拟机连接外网，而VMware Network Adapter VMnet8虚拟网卡是用来与虚拟机通信的。</p>
<h4 id="Host-Only（仅主机模式）"><a href="#Host-Only（仅主机模式）" class="headerlink" title="Host-Only（仅主机模式）"></a>Host-Only（仅主机模式）</h4><p>ost-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。其网络结构如下图所示：</p>
<p><img src="/images/工具--虚拟机-三种联网方式-22.png" alt="enter description here" title="工具--虚拟机-三种联网方式-22"></p>
<p>通过上图，我们可以发现，如果要使得虚拟机能联网，我们可以将主机网卡共享给VMware Network Adapter VMnet1网卡，从而达到虚拟机联网的目的。</p>
<p><a href="https://www.cnblogs.com/linjiaxin/p/6476480.html" target="_blank" rel="external">虚拟机三种联网方式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;虚拟机的三种联网方式&quot;&gt;&lt;a href=&quot;#虚拟机的三种联网方式&quot; class=&quot;headerlink&quot; title=&quot;虚拟机的三种联网方式&quot;&gt;&lt;/a&gt;虚拟机的三种联网方式&lt;/h3&gt;&lt;p&gt;vmware为我们提供了三种网络工作模式，它们分别是：Bridged（桥接模
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>工具|Vim操作</title>
    <link href="http://yoursite.com/2018/03/12/%E5%B7%A5%E5%85%B7-Vim%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/03/12/工具-Vim操作/</id>
    <published>2018-03-12T14:35:26.000Z</published>
    <updated>2018-03-14T11:23:42.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开始学习以前，我需要给你一些警告：</p>
<ul>
<li>学习vim在开始时是痛苦的。</li>
<li>需要时间</li>
<li>需要不断地练习，就像你学习一个乐器一样。</li>
<li>不要期望你能在3天内把vim练得比别的编辑器更有效率。</li>
<li>事实上，你需要2周时间的苦练，而不是3天。</li>
</ul>
<h3 id="开始攻关"><a href="#开始攻关" class="headerlink" title="开始攻关"></a>开始攻关</h3><h4 id="第一级-–-存活"><a href="#第一级-–-存活" class="headerlink" title="第一级 – 存活"></a>第一级 – 存活</h4><ol>
<li>安装 vim</li>
<li>启动 vim</li>
<li>什么也别干！请先阅读</li>
</ol>
<p>当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：</p>
<ol>
<li>启 动Vim后，vim在 Normal 模式下。</li>
<li>让我们进入 Insert 模式，请按下键 i 。(注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</li>
<li>此时，你可以输入文本了，就像你用“记事本”一样。</li>
<li>如果你想返回 Normal 模式，请按 ESC 键。</li>
</ol>
<p>现在，你知道如何在 Insert 和 Normal 模式下切换了。下面是一些命令，可以让你在 Normal 模式下幸存下来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">i → Insert 模式，按 ESC 回到 Normal 模式.</div><div class="line">x → 删当前光标所在的一个字符。</div><div class="line">:wq → 存盘 + 退出 (:w 存盘, :q 退出)   [注：:w 后可以跟文件名]</div><div class="line">dd → 删除当前行，并把删除的行存到剪贴板里</div><div class="line">p → 粘贴剪贴板</div><div class="line">推荐:</div><div class="line"></div><div class="line">hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。</div><div class="line">:help &lt;command&gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（陈皓注：退出帮助需要输入:q）</div></pre></td></tr></table></figure>
<p>你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p>
<p>当是，在你进入第二级时，需要再说一下 Normal 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 Ctrl 键，比如：Ctrl-C。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，在VIM的Normal模式下，所有的键就是功能键了。这个你需要知道。</p>
<p>标记:</p>
<ul>
<li>下面的文字中，如果是 Ctrl-λ我会写成 <c-λ>.</c-λ></li>
<li>以 : 开始的命令你需要输入 <enter>回车，例如 — 如果我写成 :q 也就是说你要输入 :q<enter>.</enter></enter></li>
</ul>
<h4 id="第二级-–-感觉良好"><a href="#第二级-–-感觉良好" class="headerlink" title="第二级 – 感觉良好"></a>第二级 – 感觉良好</h4><p>上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：[注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键]</p>
<h5 id="各种插入模式"><a href="#各种插入模式" class="headerlink" title="各种插入模式"></a>各种插入模式</h5><ul>
<li>a → 在光标后插入</li>
<li>o → 在当前行后插入一个新行</li>
<li>O → 在当前行前插入一个新行</li>
<li>cw → 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
<h5 id="简单的移动光标"><a href="#简单的移动光标" class="headerlink" title="简单的移动光标"></a>简单的移动光标</h5><ul>
<li>0 → 数字零，到行头</li>
<li>^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</li>
<li>$ → 到本行行尾</li>
<li>g_ → 到本行最后一个不是blank字符的位置。</li>
<li>/pattern → 搜索 pattern 的字符串（注：如果搜索出多个匹配，可按n键到下一个）</li>
</ul>
<h5 id="拷贝-粘贴-（注：p-P都可以，p是表示在当前位置之后，P表示在当前位置之前）"><a href="#拷贝-粘贴-（注：p-P都可以，p是表示在当前位置之后，P表示在当前位置之前）" class="headerlink" title="拷贝/粘贴 （注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）"></a>拷贝/粘贴 （注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）</h5><ul>
<li>P → 粘贴</li>
<li>yy → 拷贝当前行当行于 ddP</li>
</ul>
<h5 id="Undo-Redo"><a href="#Undo-Redo" class="headerlink" title="Undo/Redo"></a>Undo/Redo</h5><p>u → undo</p>
<p><c-r> → redo</c-r></p>
<h5 id="打开-保存-退出-改变文件-Buffer"><a href="#打开-保存-退出-改变文件-Buffer" class="headerlink" title="打开/保存/退出/改变文件(Buffer)"></a>打开/保存/退出/改变文件(Buffer)</h5><ul>
<li>:e <path to="" file=""></path> → 打开一个文件</li>
<li>:w → 存盘</li>
<li>:saveas <path to="" file=""></path> → 另存为 <path to="" file=""></path></li>
<li>:x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车)</li>
<li>:q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。</li>
<li>:bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）</li>
</ul>
<p>花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。</p>
<h4 id="第三级-–-更好，更强，更快"><a href="#第三级-–-更好，更强，更快" class="headerlink" title="第三级 – 更好，更强，更快"></a>第三级 – 更好，更强，更快</h4><p>先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。</p>
<h5 id="更好"><a href="#更好" class="headerlink" title="更好"></a>更好</h5><p>下面，让我们看一下vim是怎么重复自己的：</p>
<ul>
<li>. → (小数点) 可以重复上一次的命令</li>
<li>N<command> → 重复某个命令N次</li>
</ul>
<p>下面是一个示例，找开一个文件你可以试试下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2dd → 删除2行</div><div class="line">3p → 粘贴文本3次</div><div class="line">100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</div><div class="line">. → 重复上一个命令—— 100 “desu “.</div><div class="line">3. → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).</div></pre></td></tr></table></figure></p>
<h5 id="更强"><a href="#更强" class="headerlink" title="更强"></a>更强</h5><p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。</p>
<ul>
<li>NG → 到第 N 行 （注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</li>
<li>gg → 到第一行。（注：相当于1G，或 :1）</li>
<li>G → 到最后一行。</li>
<li>按单词移动：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">w → 到下一个单词的开头。</div><div class="line">e → 到下一个单词的结尾。</div><div class="line"></div><div class="line">如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个</div><div class="line">单词由字母，数字和下划线组成（陈皓注：程序变量）</div></pre></td></tr></table></figure>
</li>
</ul>
<p>下面，让我来说说最强的光标移动：</p>
<ul>
<li>% : 匹配括号移动，包括 (, {, [. （注：你需要把光标先移到括号上）</li>
<li><em>和#:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（</em>是下一个，#是上一个）</li>
</ul>
<p>相信我，上面这三个命令对程序员来说是相当强大的。</p>
<h5 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h5><p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：</p>
<p><start position=""><command><end position=""></end></start></p>
<p>例如 0y$ 命令意味着：</p>
<ul>
<li>0 → 先到行头</li>
<li>y → 从这里开始拷贝</li>
<li>$ → 拷贝到本行最后一个字符</li>
</ul>
<p>你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。</p>
<p>你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。</p>
<p>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p>
<ul>
<li>d (删除 )</li>
<li>v (可视化的选择)</li>
<li>gU (变大写)</li>
<li>gu (变小写)</li>
<li>等等</li>
</ul>
<p>[注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等]</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在开始学习以前，我需要给你一些警告：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习vim在开始时是痛苦的。&lt;/li&gt;
&lt;li&gt;需要时间&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Vim" scheme="http://yoursite.com/categories/Vim/"/>
    
    
  </entry>
  
  <entry>
    <title>Java|Tomcat基础知识</title>
    <link href="http://yoursite.com/2018/03/01/Java-Tomcat%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/03/01/Java-Tomcat基础知识/</id>
    <published>2018-03-01T10:54:42.000Z</published>
    <updated>2018-03-01T03:31:58.668Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>Tomcat简单的说就是一个运行JAVA的网络服务器，底层是Socket的一个程序，它也是JSP和Serlvet的一个容器。</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>如果你学过html，css，你会知道你写的页面只能自己访问，别人不能远程访问你写的页面，Tomcat就是提供能够让别人访问自己写的页面的一个程序。</p>
<p><img src="/images/Java-Tomcat-01.png" alt="Tomcat工作方式" title="Java-Tomcat-01"></p>
<p><img src="/images/Java-Tomcat-02.png" alt="URL" title="Java-Tomcat-02"></p>
<h3 id="Tomcat结构目录"><a href="#Tomcat结构目录" class="headerlink" title="Tomcat结构目录"></a>Tomcat结构目录</h3><p><img src="/images/Java-Tomcat-03.png" alt="目录结构" title="Java-Tomcat-03"></p>
<p>目录的简单介绍</p>
<ul>
<li>bin：启动和关闭tomcat的bat文件</li>
</ul>
<ul>
<li>conf：配置文件<ul>
<li>server.xml该文件用于配置server相关的信息，比如tomcat启动的端口号，配置主机(Host)</li>
<li>web.xml文件配置与web应用（web应用相当于一个web站点）</li>
<li>tomcat-user.xml配置用户名密码和相关权限.</li>
</ul>
</li>
<li>lib：该目录放置运行tomcat运行需要的jar包</li>
<li>logs：存放日志，当我们需要查看日志的时候，可以查询信息</li>
<li>webapps：放置我们的web应用</li>
<li>work工作目录：该目录用于存放jsp被访问后生成对应的server文件和.class文件</li>
</ul>
<h4 id="webapps目录的详细说明"><a href="#webapps目录的详细说明" class="headerlink" title="webapps目录的详细说明"></a>webapps目录的详细说明</h4><p>在webapps中建立了web1目录，下面放置我们的html文件，jsp文件，图片等等，则web1就被当做web应用管理起来。</p>
<p>例子：在webapps下创建一个web站点，在web站点下创建一个html文件，访问html文件</p>
<p><img src="/images/Java-Tomcat-04.png" alt="Hello World" title="Java-Tomcat-04"></p>
<p>web站点的目录是有规范的</p>
<p><img src="/images/Java-Tomcat-05.png" alt="Web目录规范" title="Java-Tomcat-05"></p>
<p>为什么要这样设置web站点目录呢？</p>
<ul>
<li>需求：我有多个html文件，想把其中的一个html文件作为我web站点的首页。</li>
<li>如果没有WEB-INF目录下的web.xml文件支持，是无法解决我的需求的</li>
<li>这个规范是约定熟成的。</li>
</ul>
<p>下面将web站点下的helloword2.xml文件作为站点的首页</p>
<ol>
<li>新建一个WEB-INF目录</li>
</ol>
<p><img src="/images/Java-Tomcat-06.png" alt="目录结构" title="Java-Tomcat-06"></p>
<ol>
<li>在WEB-INF目录下创建一个web.xml</li>
</ol>
<p><img src="/images/Java-Tomcat-07.png" alt="目录结构" title="Java-Tomcat-07"></p>
<ol>
<li>web.xml我们不可能会写，所以可以在webapps目录下其他的站点中抄一份过来【复制ROOT/WEB-INF/web.xml的文件到自己的站点中】</li>
<li>在web.xml中添加以下代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;welcome-file-list&gt;</div><div class="line">      &lt;welcome-file&gt;helloword2.html&lt;/welcome-file&gt;</div><div class="line">&lt;/welcome-file-list&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/images/Java-Tomcat-08.png" alt="web.xml文件" title="Java-Tomcat-08"></p>
<ol>
<li>访问web站点【helloword2.html已经是web站点的首页了，所以不需要指定资源访问了】</li>
</ol>
<p><img src="/images/Java-Tomcat-09.png" alt="Hello World" title="Java-Tomcat-09"></p>
<h3 id="配置虚拟目录"><a href="#配置虚拟目录" class="headerlink" title="配置虚拟目录"></a>配置虚拟目录</h3><h4 id="为什么需要配置虚拟目录"><a href="#为什么需要配置虚拟目录" class="headerlink" title="为什么需要配置虚拟目录"></a>为什么需要配置虚拟目录</h4><ul>
<li>如果把所有web站点的目录都放在webapps下，可能导致磁盘空间不够用，也不利于对web站点目录的管理【如果存在非常多的web站点目录】</li>
<li>把web站点的目录分散到其他磁盘管理就需要配置虚拟目录【默认情况下，只有webapps下的目录才能被Tomcat自动管理成一个web站点】</li>
<li>把web应用所在目录交给web服务器管理，这个过程称之为虚拟目录的映射</li>
</ul>
<h4 id="Method-One"><a href="#Method-One" class="headerlink" title="Method One"></a>Method One</h4><ol>
<li>在其他盘符下创建一个web站点目录，并创建WEB-INF目录和一个html文件。<br><img src="/images/Java-Tomcat-10.png" alt="Method One" title="Java-Tomcat-10"></li>
<li>找到Tomcat目录下/conf/server.xml文件<br><img src="/images/Java-Tomcat-11.png" alt="Method One" title="Java-Tomcat-11"></li>
<li>在server.xml中的节点下添加如下代码。path表示的是访问时输入的web项目名，docBase表示的是站点目录的绝对路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/images/Java-Tomcat-12.png" alt="Method One" title="Java-Tomcat-12"></p>
<ol>
<li>访问配置好的web站点<br><img src="/images/Java-Tomcat-13.png" alt="Method One" title="Java-Tomcat-13"></li>
</ol>
<h4 id="Method-Two"><a href="#Method-Two" class="headerlink" title="Method Two"></a>Method Two</h4><ol>
<li>进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。</li>
</ol>
<p><img src="/images/Java-Tomcat-14.png" alt="Method Two" title="Java-Tomcat-14"></p>
<ol>
<li><p>xml文件的代码如下，docBase是你web站点的绝对路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line">&lt;Context </div><div class="line">    docBase=&quot;D:\web1&quot; </div><div class="line">    reloadable=&quot;true&quot;&gt; </div><div class="line">&lt;/Context&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>访问web站点下的html资源</p>
</li>
</ol>
<p><img src="/images/Java-Tomcat-15.png" alt="Method Two" title="Java-Tomcat-15"></p>
<h3 id="设置虚拟主机"><a href="#设置虚拟主机" class="headerlink" title="设置虚拟主机"></a>设置虚拟主机</h3><h4 id="什么是虚拟主机？"><a href="#什么是虚拟主机？" class="headerlink" title="什么是虚拟主机？"></a>什么是虚拟主机？</h4><p>多个不同域名的网站共存于一个Tomcat中</p>
<h4 id="为什么需要用到虚拟主机？"><a href="#为什么需要用到虚拟主机？" class="headerlink" title="为什么需要用到虚拟主机？"></a>为什么需要用到虚拟主机？</h4><p>例子：我现在开发了4个网站，有4个域名。如果我不配置虚拟主机，一个Tomcat服务器运行一个网站，我就需要4台电脑才能把4个网站运行起来。</p>
<h4 id="配置虚拟主机的步骤"><a href="#配置虚拟主机的步骤" class="headerlink" title="配置虚拟主机的步骤"></a>配置虚拟主机的步骤</h4><ol>
<li>在tomcat的server.xml文件中添加主机名<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Host name=&quot;zhongfucheng&quot; appBase=&quot;D:\web1&quot;&gt;</div><div class="line">		&lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt;</div><div class="line">&lt;/Host&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/images/Java-Tomcat-16.png" alt="配置虚拟主机" title="Java-Tomcat-16"></p>
<ol>
<li>访问虚拟主机下的web站点</li>
</ol>
<p><img src="/images/Java-Tomcat-17.png" alt="配置虚拟主机" title="Java-Tomcat-17"></p>
<h3 id="Tomcat体系结构"><a href="#Tomcat体系结构" class="headerlink" title="Tomcat体系结构"></a>Tomcat体系结构</h3><p><img src="/images/Java-Tomcat-18.png" alt="Tomcat体系结构" title="Java-Tomcat-18"></p>
<h3 id="浏览器访问WEB资源的流程图"><a href="#浏览器访问WEB资源的流程图" class="headerlink" title="浏览器访问WEB资源的流程图"></a>浏览器访问WEB资源的流程图</h3><p><img src="/images/Java-Tomcat-19.png" alt="工作流程" title="Java-Tomcat-19"></p>
<blockquote>
<p>参考<br><a href="https://juejin.im/post/5a75b0be5188254e761781d7" target="_blank" rel="external">Tomcat就是这么简单</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h3&gt;&lt;p&gt;Tomcat简单的说就是一个运行JAVA的网络服务器，底层是Socket的一个程序，它也是JSP和Serlvet的一个容器。
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java|Servlet基础知识</title>
    <link href="http://yoursite.com/2018/03/01/Java-Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/03/01/Java-Servlet基础知识/</id>
    <published>2018-03-01T09:07:13.000Z</published>
    <updated>2018-03-01T02:48:02.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>Servlet实际上是ServerApplet–小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。与常用的协议，如DNS，TCP/IP，HTTP类似，Servlet是作为一整套规范存在的；同时作为J2EE标准的一部分，定义了javaweb开发的标准。Servlet制定了java处理WEB请求的一系列标准，我们只需要按照标准规定的去做就可以了。</p>
<p>实际上，无论是Struts2的FilterDispatcher还是SpringMvc的DispatcherServlet,其底层都是通过实现Sevlet或者Servlet类型的扩展【如：GenericServlet】来实现的。</p>
<p>Java Web服务器处理用户请求的基本过程：用户在客户端点击一个链接，浏览器会向Web应用服务器发送一个URL请求，该URL会指向一个servlet；Web容器看出这个请求指向某个servlet A，就会创建两个对象（HttpServletRequest和HttpServletResponse），并分配或创建一个线程，调用servlet A对应的service方法（上述请求和响应对象作为参数）；service根据HTTP请求区分出客户端发来的是GET还是POST请求，并调用对应的doGet()或doPost()方法；在doGet()或doPost()方法中进行业务逻辑的处理，处理完成后的结果通过响应对象返回写回给客户端。</p>
<p>而Servlet容器又是什么呢？各个请求总要找到对应的servlet吧？每个请求总有一些状态需要管理吧？好了，servlet容器就是干这个的，它负责初始化并创建这些servlet，将请求解析成具体的类等一系列操作。比如我们常见的tomcat就是使用范围最广的servlet容器，其他的还有Jetty、jboss等。</p>
<p><img src="/images/Java-Servlet-05.png" alt="Tomcat与Servlet的关系" title="Java-Servlet-05"></p>
<h3 id="How-it-work"><a href="#How-it-work" class="headerlink" title="How it work?"></a>How it work?</h3><p>要想更好地理解Servlet是怎工作的，我们需要问自己这些问题：<strong>Servlet是如何工作的？Servlet 如何实例化、共享变量、并进行多线程处理</strong>？</p>
<p>假设我有一个运行了大量 Servlet 的 web 服务器。通过 Servlet 之间传输信息得到 Servlet 上下文，并设置 session 变量。</p>
<p>现在，如果有两名或更多使用者向这个服务发送请求，接下来 session 变量会发生什么变化？究竟是所有用户都是用共同的变量？还是不同的用户使用的变量都不一样？如果是后者，服务器如何区分不同用户？</p>
<p>另一个相似的问题，如果有 <em>n</em> 名用户访问一个特定的 Servlet，那么该 Servlet 是仅在第一个用户首次访问的时候实例化，还是分别为每个用户实例化？</p>
<p>当然，要回答上面的问题，我们首先要知道一下的内容：</p>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>当 Servlet 容器（比如 Apache Tomcat）启动后，会部署和加载所有 web 应用。当web 应用被加载，Servlet 容器会创建一次 ServletContext，然后将其保存在服务器的内存中。web 应用的 web.xml 被解析，找到其中所有 servlet、filter 和 Listener 或 @WebServlet、@WebFilter 和 @WebListener 注解的内容，创建一次并保存到服务器的内存中。<strong>对于所有过滤器会立即调用 init()</strong>。当 Servlet 容器停止，将卸载所有 web 应用，调用所有初始化的 Servlet 和过滤器的 destroy() 方法，最后回收 ServletContext 和所有 Servlet、Filter 与 Listener 实例。</p>
<p>当问题中的 Servlet 配置的 load-on-startup 或者 @WebServlet(loadOnStartup) 设置了一个大于 0 的值，则同样会在启动的时候立即调用 init() 方法。“load-on-startup”中的值表示那些 Servlet 会以相同顺序初始化。如果配置的值相同，会遵循 web.xml 中指定的顺序或 @WebServlet 类加载的顺序。另外，如果不设置 “load-on-startup” 值，init() 方法只在第一次 HTTP 请求命中问题中的 Servlet 时才被调用。</p>
<h4 id="HttpServletRequest-与-HttpServletResponse"><a href="#HttpServletRequest-与-HttpServletResponse" class="headerlink" title="HttpServletRequest 与 HttpServletResponse"></a>HttpServletRequest 与 HttpServletResponse</h4><p>Servlet 容器附加在一个 web 服务上，这个 web 服务会在某个端口号上监听 HTTP 请求，在开发环境中这个端口通常为 8080，生产环境中通常为 80。当客户端（web 浏览器）发送了一个 HTTP 请求，Servlet 容器会创建新的 HttpServletRequest 和 HttpServletResponse 对象，传递给已创建好并且请求的 URL 匹配 url-pattern 的 Filter 和 Servlet 实例中的方法，所有工作都在同一个线程中处理。</p>
<p>request 对象可以访问所有该 HTTP 请求中的信息，例如 request header 和 request body。response 对象为你提供需要的控制和发送 HTTP 响应方法，例如设置 header 和 body（通常会带有 JSP 文件中的 HTML 内容）。提交并完成HTTP 响应后，将回收 request 和 response 对象。</p>
<h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><p>当用户第一次访问该 web 应用时，会通过 request.getSession() 第一次获得 HttpSession。之后 Servlet 容器将会创建 HttpSession，生成一个唯一的 ID（可以通过 session.getId() 获取）并储存在<strong>服务器内存</strong>中。然后 Servlet 容器在该次 HTTP 响应的 Set-Cookie 头部设置一个 Cookie，以 JSESSIONID 作为 Cookie 名字，那个唯一的 session ID 作为 Cookie 的值。</p>
<p>按照 HTTP cookie 规则（正常 web 浏览器和 web 服务端必须遵循的标准），当 cookie 有效时，要求客户端（浏览器）在后续请求的 Cookie 头中返回这个 cookie。使用浏览器内置的 HTTP 流量监控器，你可以查看它们（在 Chrome、Firefox23+、IE9+ 中按 F12，然后查看 Net/Network 标签）。Servlet 容器将会确定每个进入的 HTTP 请求的 Cookie 头中是否存在名为JSESSIONID 的 cookie，然后用它的值（session ID）从服务端内存中找到关联的 HttpSession。</p>
<p>你可以在 web.xml 中设置 session-timeout ，默认值为 30 分钟。超时到达之前 HttpSession 会一直存活。所以当客户端不再访问该 web 应用超过 30 分钟后，Servlet 容器就会回收这个 session。后续每个请求，即使指定 cookie 名称也不能再访问到相同的 session。Servlet 容器会创建一个新的 Cookie。</p>
<p>另一方面，客户端上的 session cookie 有一个默认存活时间，该事件和该浏览器实例运行时间一样长。所以，当客户端关闭该浏览器实例（所有标签和窗口）后，这个 session 就会被客户端回收。新浏览器实例不再发送与该 session 关联的 cookie。一个新的 request.getSession() 将会返回新的 HttpSession 并设置一个拥有新 session ID 的 cookie。</p>
<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><ul>
<li>ServletContext 与 web 应用存活时间一样长。它被所有 session 中的所有请求共享。</li>
<li>只要客户端一直与相同浏览器实例的web应用交互并且没有超时，HttpSession就会存在。</li>
<li>HttpServletRequest 和 HttpServletResponse 的存活时间为客户端发送完成到完整的响应（web 页面）到达的这段时间。不会被其他地方共享。</li>
<li>所有 Servlet、Filter 和 Listener 对象在 web 应用运行时都是活跃的。它们被所有 session 中的请求共享。</li>
<li>你设置在 HttpServletRequest、HttpServletResponse 和 HttpSession 中的所有属性在问题中的对象存活时都会一直保持存活。</li>
</ul>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>通过上述内容，我们知道Servlet 和 filter 被所有请求共享。那是 Java 的一个优点，使得多个不同线程（读取 HTTP 请求）可以使用同一个实例。否则为每个请求重新创建线程的开销实在过于昂贵。</p>
<p>但你应该也意识到永远不要将任何 request 或 session 域中的数据赋值给 servlet 或 filter 的实例变量。它将会被所有其他 session 中的所有请求共享。<strong>那是非线程安全的！</strong></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>我们先看一段简单的servlet请求响应的代码片段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//HelloServlet类</div><div class="line">public class HelloServlet extends HttpServlet&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</div><div class="line">        String name  = req.getParameter(&quot;name&quot;);</div><div class="line">        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);</div><div class="line">        PrintWriter printWriter = resp.getWriter();</div><div class="line">        printWriter.write(&quot;&lt;html&gt;&lt;head&gt;&lt;head&gt;&lt;body&gt;&lt;h1&gt;&quot;);</div><div class="line">        printWriter.write(&quot;Hello &quot;+name);</div><div class="line">        printWriter.write(&quot;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);</div><div class="line">        printWriter.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在web.xml注册此servlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;web-app version=&quot;3.0&quot;</div><div class="line">        xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</div><div class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;display-name&gt;wthfeng 的mvc练习项目&lt;/display-name&gt;</div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;com.wthfeng.mymvc.servlet.HelloServlet&lt;/servlet-class&gt;</div><div class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">      &lt;servlet-name&gt;hello&lt;/servlet-name&gt;</div><div class="line">      &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<p>启动项目，效果如下图所示：</p>
<p><img src="/images/Java-Servlet-01.png" alt="效果" title="Java-Servlet-01"></p>
<p>这样我们就写完了一个简单的servlet，有关这个例子，我们需要知道：</p>
<ol>
<li>编写Servlet必须继承HttpServlet或GenericServlet或直接实现Servlet接口。HttpServlet已经为我们封装了有关http请求的相关参数，一般情况下我们直接继承此类即可。</li>
<li>此servlet重写了doGet方法，也就是它可以响应/myprojectName/hello?name=xxx 的请求，并在页面打印xxx的内容。</li>
</ol>
<h4 id="Servlet的创建和初始化"><a href="#Servlet的创建和初始化" class="headerlink" title="Servlet的创建和初始化"></a>Servlet的创建和初始化</h4><p>好了，这些逻辑符合上面所说的，浏览器发出请求/hello，一个名为hello的 servlet被命中，接受请求处理后返回。这里我们再深入一些，为什么要把servlet的定义在web.xml中？web.xml又和servlet容器有什么关系？</p>
<p><strong>web.xml是web项目的入口文件。在项目启动过程中，servlet容器（如tomcat）会读取web.xml并进行相应配置以初始化该项目</strong>。</p>
<p>具体容器启动流程如下（以tomcat为例）：</p>
<ol>
<li><p>先解析tomcat路径下的conf/web.xml等web.xml文件,它们是全局web配置文件，做一些基本配置工作。如注册了default、jsp等servlet。</p>
</li>
<li><p>解析web.xml，将其各个配置项（包括servlet、filter、listener)经处理包装后设在Tomcat的Context容器中，一个 Web 应用对应一个 Context 容器。</p>
</li>
<li><p>创建servlet并初始化。load-on-startup大于1的servlet会在此时初始化。初始化servlet就是调用servlet的init方法。注意：若不设置 此 值，init() 方法只在第一次 HTTP 请求命中时才被调用。此时servlet容器就算启动了。</p>
</li>
</ol>
<p><strong>简而言之就是，web.xml是项目和servlet容器（服务器）关联的桥梁。通过在web.xml注册servlet、filter、listener等，使得项目具有处理特定请求的功能。</strong></p>
<p><img src="/images/Java-Servlet-06.png" alt="生命周期" title="Java-Servlet-06"></p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>在容器启动时，XXXServlet在JVM的管理下被实例化为一个对象，这时候它还不是servlet，需要在容器的管理下调用init()方法进行初始化，获得ServletConfig和ServletContext对象的引用后，才称为一个真正的Servlet。</p>
<p><img src="/images/Java-Servlet-02.png" alt="生命周期" title="Java-Servlet-02"></p>
<ol>
<li>init()<ul>
<li>何时调用？servlet实例创建后，并在servlet能为客户请求提供服务之前，容器需要通过init方法初始化servlet。</li>
<li>作用？初始化servlet实例，使之获得web容器的相关信息</li>
<li>是否会被覆盖？有可能</li>
</ul>
</li>
<li>service()<ul>
<li>何时调用？当一个客户请求到来时，容器会创建（或从线程池分配一个线程），并调用servlet的service方法</li>
<li>作用？这个方法会确定HTTP方法（GET or POST），并调用对应的servlet方法——doGet或doPost；</li>
<li>是否会被覆盖？可以，但是不会</li>
</ul>
</li>
<li>doGet()或doPost()<ul>
<li>何时调用？</li>
<li>作用？具体的业务逻辑</li>
<li>是否会被覆盖？至少要覆盖其中之一</li>
</ul>
</li>
</ol>
<p><strong>关键点：每个请求都在一个单独的线程中运行！</strong></p>
<p><img src="/images/Java-Servlet-04.png" alt="工作方式" title="Java-Servlet-04"></p>
<h3 id="Servlet的继承体系"><a href="#Servlet的继承体系" class="headerlink" title="Servlet的继承体系"></a>Servlet的继承体系</h3><ul>
<li>servlet接口：javax.servlet.Servlet，表示所有的Servlet都有这5个方法，其中init、service和destroy三个方法和servlet的生命周期有关</li>
<li>GenericServlet：javax.servlet.GenericServlet，这是一个抽象类，它实现了开发者需要的大部分基本servlet方法，大多数servlet的“servlet行为”都来自这个类；</li>
<li>HttpServlet：javax.servlet.http.HttpServlet，这也是一个抽象类，它实现了自己的service()方法，处理servlet的HTTP特性（service方法不仅仅只处理HTTP请求）。</li>
<li>MyTestServlet：这是开发者自己编写的处理类，一般只需要实现doGet()和doPost()方法。</li>
</ul>
<p><img src="/images/Java-Servlet-03.png" alt="继承体系" title="Java-Servlet-03"></p>
<h3 id="HTTP相关API"><a href="#HTTP相关API" class="headerlink" title="HTTP相关API"></a>HTTP相关API</h3><h4 id="HTTP请求的API"><a href="#HTTP请求的API" class="headerlink" title="HTTP请求的API"></a>HTTP请求的API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>getHeader()</td>
<td>可以获取首部信息，例如request.getHeader(“User-Agent”)可以获取客户端的平台和浏览器信息</td>
</tr>
<tr>
<td>getIntHeader()</td>
<td>如果首部信息中的“key/value”对中的value是int类型的，可以使用这个方法直接获取值而不需要显式类型转换</td>
</tr>
<tr>
<td>getCookies()</td>
<td>可以获取与请求相关的cookie</td>
</tr>
<tr>
<td>getSession()</td>
<td>可以获取与请求相关的会话</td>
</tr>
<tr>
<td>getMethod()</td>
<td>可以获取http方法</td>
</tr>
<tr>
<td>getInputStream()</td>
<td>可以获取请求的输入流</td>
</tr>
<tr>
<td>getParameter(String name)</td>
<td>可以获取HTTP请求的请求参数，对于GET请求，可以获取查询字符串中的数据、对于POST请求，可以获取请求体中的数据</td>
</tr>
<tr>
<td>getRemotePort()</td>
<td>获取客户端的端口号</td>
</tr>
<tr>
<td>getServerPort()</td>
<td>获取服务端接受请求的端口号（请求一开始发送服务端的哪个端口？）</td>
</tr>
<tr>
<td>getLocalPort()</td>
<td>获取服务端处理请求的端口号（请求最后是发送到服务端的哪个端口？）</td>
</tr>
</tbody>
</table>
<h4 id="HTTP响应的API"><a href="#HTTP响应的API" class="headerlink" title="HTTP响应的API"></a>HTTP响应的API</h4><p>大多数情况下，使用响应只是为了向客户发回数据。会对响应调用两个方法：setContentType()和getWriter()。在此之后，可以将HTML或其他内容写入到流。不过，你也可以使用响应设置首部、发送错误或增加Cookie。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>setContentType()</td>
<td>设置响应返回的MIME类型</td>
</tr>
<tr>
<td>getOutputStream()</td>
<td>获取HTTP输出字节流</td>
</tr>
<tr>
<td>getWriter()</td>
<td>获取HTTP输出字符流</td>
</tr>
<tr>
<td>addCookie(Cookie cookie)</td>
<td>给响应首部中增加cookie对象，注意这里不是增加“key/value”对</td>
</tr>
<tr>
<td>addHeader()</td>
<td>在响应首部中添加一个“key/value”对</td>
</tr>
<tr>
<td>setHeader()</td>
<td>在响应首部中设置一个“key/value”对；<strong>和addHeader()的区别是，如果响应首部中已经有对应的key存在，setHeader()会覆盖现有的值，而addHeder()会新增一个“key/value”对，使用时需要注意</strong>；</td>
</tr>
<tr>
<td>encodeRedirectURL()</td>
<td>对包含session ID的URL进行编码。<strong>使用场景：在浏览器不支持使用cookie跟踪会话时，可以使用URL重写（即将URL重定向到另一个URL，而这个URL的后面会带上session id传给客户端，这个URL在返回给客户端之前需要经过编码）</strong></td>
</tr>
<tr>
<td>sendError()</td>
<td>给客户端返回错误的响应（错误码、错误信息），在该方法被调用之后，就意味着响应已经被返回给客户端，也就不能再调用response的任何方法，否则会报IllegalStateException。</td>
</tr>
<tr>
<td>setStatus()</td>
<td>设置响应的状态码</td>
</tr>
<tr>
<td>sendRedirect()</td>
<td>用于URL重定向，告诉客户端去访问另一个URL来完成需求，如果location没有以“/”开头，则它是相对路径，容器会负责将这个相对路径转化成该web应用的绝对路径；否则容器会把它当做绝对路径处理。</td>
</tr>
</tbody>
</table>
<h4 id="重定向和请求派发"><a href="#重定向和请求派发" class="headerlink" title="重定向和请求派发"></a>重定向和请求派发</h4><ul>
<li>重定向是让浏览器访问新的URL完成工作，用户会在浏览器地址栏看到新的URL,通过httpServlet的sendDirect(String location)方法。</li>
<li>请求派发是服务端的工作，是当前servlet委托另外的servlet完成请求，并给客户端发回响应，用户的浏览器地址栏的URL没有改变,是通过requestDispatcher对象的forward(httpServletRequest req,HttpServletResponse res)方法来实现的。其中getRequestDispatcher方法的参数，必须以“／”开头，表示web的根目录，比如要<br>跳转：　“<a href="http://locahost:8080/servlet/servet/LifeCycleServlet" target="_blank" rel="external">http://locahost:8080/servlet/servet/LifeCycleServlet</a>“, 则参数为”/servlet/LifeCycleServlet”.</li>
</ul>
<h3 id="获取初始化参数"><a href="#获取初始化参数" class="headerlink" title="获取初始化参数"></a>获取初始化参数</h3><ol>
<li><p>在 web.xml中配置servlet时，可以配置一些初始化参数，在servlet可以通过servletConfig接口提供的接口获取这些参数。</p>
<ul>
<li><p>在web.xml中配置init-param 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;servlet&gt;</div><div class="line">        </div><div class="line">        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;&lt;!-- servlet的名字 --&gt;</div><div class="line">        &lt;servlet-class&gt;servlet.HelloServlet&lt;/servlet-class&gt;&lt;!-- servlet的具体类型，需要带包名 --&gt;</div><div class="line">        &lt;init-param&gt;</div><div class="line">            &lt;param-name&gt;username&lt;/param-name&gt;</div><div class="line">            &lt;param-value&gt;forezp&lt;/param-value&gt;</div><div class="line">        &lt;/init-param&gt;</div><div class="line">    &lt;/servlet&gt;</div></pre></td></tr></table></figure>
<ul>
<li>在servlet中获取</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class HelloServlet extends HttpServlet &#123;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void init() throws ServletException &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        super.init();</div><div class="line">        String name=this.getInitParameter(&quot;username&quot;);</div><div class="line">        System.out.println(name);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>+ 部署项目，访问helloServlet就可以看见在控制台打印了forezp
</code></pre><ol>
<li>也可以配置一些全局的参数:context-param.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;web-app version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee </div><div class="line">    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;</div><div class="line">    &lt;display-name&gt;&lt;/display-name&gt;</div><div class="line">    &lt;welcome-file-list&gt;</div><div class="line">        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;</div><div class="line">    &lt;/welcome-file-list&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;context-param&gt;</div><div class="line">        &lt;param-name&gt;haha&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;xixi&lt;/param-value&gt;</div><div class="line">    &lt;/context-param&gt;</div><div class="line">    </div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<pre><code>+ 获取方式：servlet中通过getServletContext()获取servletContext对象，使用ServletContext的getInitParameter()方法获取制定参数名来获取参数。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ServletContext servletContext=getServletConfig().getServletContext();</div><div class="line">String str=servletContext.getInitParameter(&quot;haha&quot;);</div><div class="line">System.out.println(str);</div></pre></td></tr></table></figure>
<h3 id="随便讲讲Filter和Listener"><a href="#随便讲讲Filter和Listener" class="headerlink" title="随便讲讲Filter和Listener"></a>随便讲讲Filter和Listener</h3><p>在有关web servlet的配置中，常能在web.xml看到filter、listener的配置。实际上，filter是过滤器，listener是监听器。这两项配置都是servlet中的重要部分。我们一一来看。</p>
<h4 id="fliter-过滤器"><a href="#fliter-过滤器" class="headerlink" title="fliter(过滤器)"></a>fliter(过滤器)</h4><p>先来个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class MyFilter implements Filter &#123;</div><div class="line"></div><div class="line">    private String param; </div><div class="line">     </div><div class="line">    //初始化方法，在容器启动时调用</div><div class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</div><div class="line">        //做一些初始化操作</div><div class="line">        param = filterConfig.getInitParameter(&quot;myParam&quot;);</div><div class="line">        System.out.println(&quot;filter:&quot;+param);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</div><div class="line">            throws IOException, ServletException &#123;</div><div class="line">        //处理请求</div><div class="line">        chain.doFilter(request,response); //调用下一个过滤器</div><div class="line">        //处理响应</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void destroy() &#123;</div><div class="line">      //在servlet销毁后销毁</div><div class="line">      //做一些销毁后的善后工作</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 web.xml中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> &lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;com.wthfeng.mymvc.filter.MyFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;myParam&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;myValue&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>配置后filter就会拦截所有servlet请求，需注意：</p>
<p>所有的filter在容器启动时即初始化。<br>filter的调用顺序为在web.xml中的定义顺序。若多余一个会形成过滤链依次处理。</p>
<h4 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener(监听器)"></a>Listener(监听器)</h4><p>servlet 监听器用于监听servlet容器中事件变化，当指定事件变化时，会触发注册该事件的监听器。监听器基于观察者模式。</p>
<p>Servlet监听器分为3类，分别用于监听ServletContent（Servlet上下文）、HttpSession（Session）,HttpRequest(Request)。</p>
<p>主要有以下几个类：</p>
<ul>
<li><p>ServletContextListener //监听Servlet容器创建销毁<br>ServletContextAttributeListener  //监听Servlet容器级别属性的添加及删除</p>
</li>
<li><p>HttpSessionListener  //监听Session创建销毁<br>HttpSessionAttributeListener //监听Session属性创建删除</p>
</li>
<li><p>ServletRequestListener  //监听请求创建及销毁<br>ServletRequestAttributeListener  //监听请求属性变化</p>
</li>
</ul>
<p>如我们常见的Spring项目中的如下片段，就是Spring的监听器。其实现了ServletContextListener，用于监听Servlet上下文，以便在项目初始化时加载Spring的必要配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> &lt;listener&gt;</div><div class="line">       &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Servlet-、Filter、Listerer-执行顺序"><a href="#Servlet-、Filter、Listerer-执行顺序" class="headerlink" title="Servlet 、Filter、Listerer 执行顺序"></a>Servlet 、Filter、Listerer 执行顺序</h4><p>分别了解了servlet、filter、listener后，来确定一下他们之间的执行顺序。我们已经知道，filter在servlet之前，那listener呢？</p>
<p>应该想到，监听器负责监听事件变化，应该有最先执行的权限，测试一下，我把上述三种都加了日志，打印结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//开启服务器并请求</div><div class="line">listener 容器初始化开始  //servletContent 监听器 contextInitialized()</div><div class="line">filter初始化        //filter init()</div><div class="line">初始化servlet       //servlet init()</div><div class="line">listener request初始化  // request 监听器requestInitialized()</div><div class="line">开始filter            //fiter doFilter() chain.doFilter前</div><div class="line">执行servlet        //servlet service()</div><div class="line">结束filter          //fiter doFilter() chain.doFilter后</div><div class="line">listener request销毁  //request 监听器 requestInitialized()</div><div class="line"></div><div class="line">//关闭服务器</div><div class="line">servlet销毁</div><div class="line">filter销毁</div><div class="line">listener 容器销毁</div></pre></td></tr></table></figure></p>
<p>从此我们可以得出结论：</p>
<ul>
<li>对于涉及3者的部分，顺序为 listener - filter - servlet</li>
<li>filter和servlet的初始化部分，先filter后servlet</li>
<li>销毁或结束顺序为加载顺序的反序</li>
</ul>
<blockquote>
<p>参考 </p>
<ul>
<li><a href="http://blog.wthfeng.com/javaweb/servlet/2017/04/30/Servlet%E5%92%8CServlet%E5%AE%B9%E5%99%A8/" target="_blank" rel="external">Servlet工作机制解析</a></li>
<li><a href="https://www.jianshu.com/p/fc7f31b664d5" target="_blank" rel="external">Servlet请求和响应</a></li>
<li><a href="https://www.jianshu.com/p/4d71ec3e1b99" target="_blank" rel="external">当Java遇见了Html–Servlet篇</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h3&gt;&lt;p&gt;Servlet实际上是ServerApplet–小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java|监听器基础</title>
    <link href="http://yoursite.com/2018/03/01/Java-%E7%9B%91%E5%90%AC%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/03/01/Java-监听器基础/</id>
    <published>2018-02-28T23:36:30.000Z</published>
    <updated>2018-02-28T16:21:07.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>这里有三个概念，<strong>监听的事件源</strong>，<strong>监听者</strong>，<strong>事件</strong>，举个栗子来说是这样的，警察抓小偷，警察是监听者，小偷是被监听的事件源，抓小偷这个动作就是事件，什么时候会抓小偷呢？在小偷偷东西的时候。<br>这个概念在前端开发中比较常用，但是在Java服务器端用的相对比较少，比如你在浏览网页的过程中，第一次进入并不会全部加载页面的信息，而是加载一部分，你向下浏览网页，网页才会加载，这也是监听的一种体现形式，你向下滑动网页的过程就是监听的事件源，加载网页就是事件，监听者就是服务器程序咯，可能这些用词不是太准确，但是也算是表达了这个意思。</p>
<p>JavaWeb中，监听的事件源有三个：</p>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><ul>
<li><p>ServletContextListener：用于对Servlet整个上下文进行监听（创建、销毁）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//上下文初始化</div><div class="line">public void contextInitialized(ServletContextEvent sce);</div><div class="line">//上下文销毁</div><div class="line">public void contextDestroyed(ServletContextEvent sce);</div><div class="line">//ServletContextEvent事件：取得一个ServletContext（application）对象</div><div class="line">public ServletContext getServletContext();</div></pre></td></tr></table></figure>
</li>
<li><p>ServletContextAttributeListener：对Servlet上下文属性的监听（增删改属性）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//增加属性</div><div class="line">public void attributeAdded(ServletContextAttributeEvent scab);</div><div class="line">//属性删除</div><div class="line">public void attributeRemoved(ServletContextAttributeEvent scab);</div><div class="line">//属性替换（第二次设置同一属性）</div><div class="line">public void attributeRepalced(ServletContextAttributeEvent scab);</div><div class="line">//ServletContextAttributeEvent事件：能取得设置属性的名称与内容</div><div class="line">//得到属性名称</div><div class="line">public String getName();</div><div class="line">//取得属性的值</div><div class="line">public Object getValue();</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><p>Session属于http协议下的内容，接口位于javax.servlet.http.*包下。</p>
<ul>
<li><p>HttpSessionListener接口：对Session的整体状态的监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//session创建</div><div class="line">public void sessionCreated(HttpSessionEvent se);</div><div class="line">//session销毁</div><div class="line">public void sessionDestroyed(HttpSessionEvent se);</div><div class="line">//HttpSessionEvent事件：</div><div class="line">//取得当前操作的session</div><div class="line">public HttpSession getSession();</div></pre></td></tr></table></figure>
</li>
<li><p>HttpSessionAttributeListener接口：对session的属性监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void attributeAdded(HttpSessionBindingEvent se);//增加属性</div><div class="line">public void attributeRemoved(HttpSessionBindingEvent se);//删除属性</div><div class="line">public void attributeReplaced(HttpSessionBindingEvent se);//替换属性</div><div class="line">//HttpSessionBindingEvent事件：</div><div class="line">public String getName();//取得属性的名称</div><div class="line">public Object getValue();//取得属性的值</div><div class="line">public HttpSession getSession();//取得当前的session</div></pre></td></tr></table></figure>
</li>
</ul>
<p>session的销毁有两种情况：</p>
<ul>
<li><p>session超时，web.xml配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;session-config&gt;</div><div class="line">    &lt;session-timeout&gt;120&lt;/session-timeout&gt;&lt;!--session120分钟后超时销毁--&gt;</div><div class="line">&lt;/session-config&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>手工使session失效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//使session失效方法。session.invalidate();</div><div class="line">public void invalidate();</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h4><ul>
<li><p>ServletRequestListener：用于对Request请求进行监听（创建、销毁）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void requestInitialized(ServletRequestEvent sre);//request初始化</div><div class="line">public void requestDestroyed(ServletRequestEvent sre);//request销毁</div><div class="line">//ServletRequestEvent事件：</div><div class="line">public ServletRequest getServletRequest();//取得一个ServletRequest对象</div><div class="line">public ServletContext getServletContext();//取得一个ServletContext（application）对象</div></pre></td></tr></table></figure>
</li>
<li><p>ServletRequestAttributeListener：对Request属性的监听（增删改属性）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void attributeAdded(ServletRequestAttributeEvent srae);//增加属性</div><div class="line">public void attributeRemoved(ServletRequestAttributeEvent srae);//属性删除</div><div class="line">public void attributeReplaced(ServletRequestAttributeEvent srae);//属性替换（第二次设置同一属性）</div><div class="line">//ServletRequestAttributeEvent事件：能取得设置属性的名称与内容</div><div class="line">public String getName();//得到属性名称</div><div class="line">public Object getValue();//取得属性的值</div></pre></td></tr></table></figure>
</li>
</ul>
<p>它都会监听什么呢？</p>
<ul>
<li>监听域对象的创建和销毁的监听器</li>
<li>监听域对象操作域属性的监听器</li>
<li>监听HttpSession的监听器</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * ServletContextListener实现类</div><div class="line"> * contextDestroyed() -- 在ServletContext对象被销毁前调用</div><div class="line"> * contextInitialized() --  -- 在ServletContext对象被创建后调用</div><div class="line"> * ServletContextEvent -- 事件类对象</div><div class="line"> *     该类有getServletContext()，用来获取ServletContext对象，即获取事件源对象</div><div class="line"> */</div><div class="line">public class MyServletContextListener implements ServletContextListener &#123;</div><div class="line">    public void contextDestroyed(ServletContextEvent evt) &#123;</div><div class="line">        System.out.println(&quot;销毁ServletContext对象&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void contextInitialized(ServletContextEvent evt) &#123;</div><div class="line">        System.out.println(&quot;创建ServletContext对象&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时，需要在web.xml中部署：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;listener&gt;</div><div class="line">    &lt;listener-class&gt;net.sailfish.listener.MyServletContextListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure>
<p><strong>需要注意的是</strong>：Listener配置信息必须在Filter和Servlet配置之前，Listener的初始化（ServletContentListener初始化）比Servlet和Filter都优先，而销毁比Servlet和Filter都慢。</p>
<p>总结一下：</p>
<ul>
<li>监听器要在web.xml中进行配置</li>
<li>监听器的方法都是类似的，这里列出的是域对象的创建和销毁的监听器</li>
<li>ServletContextListener在tomcat启动时创建，在tomcat关闭的时候销毁</li>
</ul>
<h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><p>Listener的应用实例</p>
<ul>
<li>利用HttpSessionListener统计最多在线用户人数</li>
<li>Spring使用ContextLoaderListener加载ApplicationContext配置信息</li>
<li>Spring使用Log4jConfigListener配置Log4j日志</li>
<li>Spring使用IntrospectorCleanupListener清理缓存</li>
</ul>
<h4 id="Listener应用实例"><a href="#Listener应用实例" class="headerlink" title="Listener应用实例"></a>Listener应用实例</h4><p>利用HttpSessionListener统计最多在线用户人数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import java.text.DateFormat;</div><div class="line">import java.text.SimpleDateFormat;</div><div class="line">import java.util.Date;</div><div class="line">import javax.servlet.ServletContext;</div><div class="line">import javax.servlet.http.HttpSessionEvent;</div><div class="line">import javax.servlet.http.HttpSessionListener;</div><div class="line">public class HttpSessionListenerImpl implements HttpSessionListener &#123;</div><div class="line">    public void sessionCreated(HttpSessionEvent event) &#123;</div><div class="line">        ServletContext app = event.getSession().getServletContext();</div><div class="line">        int count = Integer.parseInt(app.getAttribute(&quot;onLineCount&quot;).toString());</div><div class="line">        count++;</div><div class="line">        app.setAttribute(&quot;onLineCount&quot;, count);</div><div class="line">        int maxOnLineCount = Integer.parseInt(app.getAttribute(&quot;maxOnLineCount&quot;).toString());</div><div class="line">        if (count &gt; maxOnLineCount) &#123;</div><div class="line">            //记录最多人数是多少</div><div class="line">            app.setAttribute(&quot;maxOnLineCount&quot;, count);</div><div class="line">            DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">            //记录在那个时刻达到上限</div><div class="line">            app.setAttribute(&quot;date&quot;, df.format(new Date()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //session注销、超时时候调用，停止tomcat不会调用</div><div class="line">    public void sessionDestroyed(HttpSessionEvent event) &#123;</div><div class="line">        ServletContext app = event.getSession().getServletContext();</div><div class="line">        int count = Integer.parseInt(app.getAttribute(&quot;onLineCount&quot;).toString());</div><div class="line">        count--;</div><div class="line">        app.setAttribute(&quot;onLineCount&quot;, count);    </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Spring使用ContextLoaderListener加载ApplicationContext配置信息"><a href="#Spring使用ContextLoaderListener加载ApplicationContext配置信息" class="headerlink" title="Spring使用ContextLoaderListener加载ApplicationContext配置信息"></a>Spring使用ContextLoaderListener加载ApplicationContext配置信息</h4><p>ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。</p>
<p>ContextLoaderListener如何查找ApplicationContext.xml的配置位置以及配置多个xml：如果在web.xml中不写任何参数配置信息，默认的路径是”/WEB-INF/applicationContext.xml”，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml（在MyEclipse中把xml文件放置在src目录下）。如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;</div><div class="line">    &lt;!-- 采用的是通配符方式，查找WEB-INF/spring目录下xml文件。如有多个xml文件，以“,”分隔。 --&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;listener&gt;</div><div class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Spring使用Log4jConfigListener配置Log4j日志"><a href="#Spring使用Log4jConfigListener配置Log4j日志" class="headerlink" title="Spring使用Log4jConfigListener配置Log4j日志"></a>Spring使用Log4jConfigListener配置Log4j日志</h4><p>Spring使用Log4jConfigListener的好处：</p>
<ul>
<li>动态的改变记录级别和策略，不需要重启Web应用。</li>
<li>把log文件定在 /WEB-INF/logs/ 而不需要写绝对路径。因为系统把web目录的路径压入一个叫webapp.root的系统变量。这样写log文件路径时不用写绝对路径了。</li>
<li>可以把log4j.properties和其他properties一起放在/WEB-INF/ ，而不是Class-Path。</li>
<li>设置log4jRefreshInterval时间，开一条watchdog线程每隔段时间扫描一下配置文件的变化。</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;webAppRootKey&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;project.root&lt;/param-value&gt;&lt;!-- 用于定位log文件输出位置在web应用根目录下，log4j配置文件中写输出位置：log4j.appender.FILE.File=$&#123;project.root&#125;/logs/project.log --&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt;&lt;!-- 载入log4j配置文件 --&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;60000&lt;/param-value&gt;&lt;!--Spring刷新Log4j配置文件的间隔60秒,单位为millisecond--&gt;</div><div class="line">&lt;/context-param&gt;</div><div class="line">&lt;listener&gt;</div><div class="line">    &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Spring使用IntrospectorCleanupListener清理缓存"><a href="#Spring使用IntrospectorCleanupListener清理缓存" class="headerlink" title="Spring使用IntrospectorCleanupListener清理缓存"></a>Spring使用IntrospectorCleanupListener清理缓存</h4><p>这个监听器的作用是在web应用关闭时刷新JDK的JavaBeans的Introspector缓存，以确保Web应用程序的类加载器以及其加载的类正确的释放资源。</p>
<p>如果JavaBeans的Introspector已被用来分析应用程序类，系统级的Introspector缓存将持有这些类的一个硬引用。因此，这些类和Web应用程序的类加载器在Web应用程序关闭时将不会被垃圾收集器回收！而IntrospectorCleanupListener则会对其进行适当的清理，已使其能够被垃圾收集器回收。</p>
<p>唯一能够清理Introspector的方法是刷新整个Introspector缓存，没有其他办法来确切指定应用程序所引用的类。这将删除所有其他应用程序在服务器的缓存的Introspector结果。</p>
<p>在使用Spring内部的bean机制时，不需要使用此监听器，因为Spring自己的introspection results cache将会立即刷新被分析过的JavaBeans Introspector cache，而仅仅会在应用程序自己的ClassLoader里面持有一个cache。虽然Spring本身不产生泄漏，注意，即使在Spring框架的类本身驻留在一个“共同”类加载器（如系统的ClassLoader）的情况下，也仍然应该使用使用IntrospectorCleanupListener。在这种情况下，这个IntrospectorCleanupListener将会妥善清理Spring的introspection cache。</p>
<p>应用程序类，几乎不需要直接使用JavaBeans Introspector，所以，通常都不是Introspector resource造成内存泄露。相反，许多库和框架，不清理Introspector，例如： Struts和Quartz。</p>
<p>需要注意的是一个简单Introspector泄漏将会导致整个Web应用程序的类加载器不会被回收！这样做的结果，将会是在web应用程序关闭时，该应用程序所有的静态类资源（比如：单实例对象）都没有得到释放。而导致内存泄露的根本原因其实并不是这些未被回收的类！</p>
<p>注意：IntrospectorCleanupListener应该注册为web.xml中的第一个Listener，在任何其他Listener之前注册，比如在Spring’s ContextLoaderListener注册之前，才能确保IntrospectorCleanupListener在Web应用的生命周期适当时机生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;listener&gt;&lt;!-- memory clean --&gt;</div><div class="line">    &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h3&gt;&lt;p&gt;这里有三个概念，&lt;strong&gt;监听的事件源&lt;/strong&gt;，&lt;strong&gt;监听者&lt;/strong&gt;，&lt;strong&gt;事
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java|过滤器基础</title>
    <link href="http://yoursite.com/2018/03/01/Java-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/03/01/Java-过滤器基础/</id>
    <published>2018-02-28T21:54:21.000Z</published>
    <updated>2018-02-28T16:32:17.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it?"></a>What is it?</h3><p>过滤器是Servlet的高级特性之一，也别把它想得那么高深，只不过是实现Filter接口的Java类罢了！</p>
<p>首先，我们来看看过滤器究竟Web容器的哪处:</p>
<p><img src="/images/Java-过滤器-01.png" alt="Java 过滤器" title="Java-过滤器-01"></p>
<p>上面的图我们可以发现，当浏览器发送请求给服务器的时候，先执行过滤器，然后才访问Web的资源。服务器响应Response，从Web资源抵达浏览器之前，也会途径过滤器。。</p>
<p><img src="/images/Java-过滤器-05.png" alt="Java 过滤器" title="Java-过滤器-05"></p>
<p>我们很容易发现，过滤器可以比喻成一张滤网。我们想想现实中的滤网可以做什么：在泡茶的时候，过滤掉茶叶。那滤网是怎么过滤茶叶的呢？规定大小的网孔，只要网孔比茶叶小，就可以实现过滤了！</p>
<p>引申在Web容器中，过滤器可以做：过滤一些敏感的字符串【规定不能出现敏感字符串】、避免中文乱码【规定Web资源都使用UTF-8编码】、权限验证【规定只有带Session或Cookie的浏览器，才能访问web资源】等等等，过滤器的作用非常大，只要发挥想象就可以有意想不到的效果</p>
<p>也就是说：当需要限制用户访问某些资源时、在处理请求时提前处理某些资源、服务器响应的内容对其进行处理再返回、我们就是用过滤器来完成的！</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>Filter功能</p>
<ul>
<li>在HttpServletRequest 到达 Servlet 之前，拦截客户的 HttpServletRequest 。根据需要检查 HttpServletRequest ，也可以修改HttpServletRequest 头和数据。</li>
<li>在HttpServletResponse 到达客户端之前，拦截HttpServletResponse 。根据需要检查 HttpServletResponse ，也可以修改HttpServletResponse头和数据。</li>
</ul>
<p>举例子来说明吧：</p>
<h4 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h4><p><strong>方法一</strong>：如果我没有用到过滤器：浏览器通过http请求发送数据给Servlet，如果存在中文，就必须指定编码，否则就会乱码！</p>
<p>jsp页面提交中文数据给Servlet处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/Demo1&quot; method=&quot;post&quot;&gt;</div><div class="line"></div><div class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</div><div class="line"></div><div class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</div><div class="line"></div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>Servlet没有指定编码的情况下，获取得到的是乱码：</p>
<p><img src="/images/Java-过滤器-02.png" alt="中文乱码" title="Java-过滤器-02"></p>
<p>也就是说：如果我每次接受客户端带过来的中文数据，在Serlvet中都要设定编码。这样代码的重复率太高了！！！！</p>
<p><strong>方法二</strong>：用过滤器解决中文乱码问题。有过滤器的情况就不一样了：只要我在过滤器中指定了编码，可以使全站的Web资源都是使用该编码，并且重用性是非常理想的！还有一个好处是：如果需要换另一种编码，只需要改变一处。</p>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>要使用过滤器，只要Java类实现了Filter接口就可以称为过滤器！Filter接口的方法也十分简单：</p>
<p><img src="/images/Java-过滤器-03.png" alt="实现接口" title="Java-过滤器-03"></p>
<p>其中init()和destory()方法就不用多说了，他俩跟Servlet是一样的。只有在Web服务器加载和销毁的时候被执行，只会被执行一次！</p>
<p>值得注意的是doFilter()方法,它有三个参数(ServletRequest,ServletResponse,FilterChain),从前两个参数我们可以发现：过滤器可以完成任何协议的过滤操作！</p>
<p>那FilterChain是什么东西呢？我们看看：</p>
<p><img src="/images/Java-过滤器-04.png" alt="enter description here" title="Java-过滤器-04"></p>
<p>FilterChain是一个接口，里面又定义了doFilter()方法。这究竟是怎么回事啊？？？？？？</p>
<p>FilterChain接口you容器实现，容器将其实例作为参数传入过滤器对象的doFilter()方法中。过滤器对象使用FilterChain对象调用过滤器链中的下一个过滤器，如果该过滤器是链中的最后一个过滤器，那么将调用目标资源。</p>
<p>我们可以这样理解：过滤器不单单只有一个，那么我们怎么管理这些过滤器呢？在Java中就使用了链式结构。把所有的过滤器都放在FilterChain里边，如果符合条件，就执行下一个过滤器（如果没有过滤器了，就执行目标资源）。</p>
<p>上面的话好像有点拗口，我们可以想象生活的例子：现在我想在茶杯上能过滤出石头和茶叶出来。石头在一层，茶叶在一层。所以茶杯的过滤装置应该有两层滤网。这个过滤装置就是FilterChain，过滤石头的滤网和过滤茶叶的滤网就是Filter。在石头滤网中，茶叶是属于下一层的，就把茶叶放行，让茶叶的滤网过滤茶叶。过滤完茶叶了，剩下的就是茶（茶就可以比喻成我们的目标资源）</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Filter开发两步走</p>
<ul>
<li>编写java类实现Filter接口，并实现其doFilter方法。</li>
<li>在 web.xml 文件中使用和元素对编写的filter类进行注册，并设置它所能拦截的资源。</li>
</ul>
<p>写一个简单的过滤器。</p>
<ol>
<li><p>实现Filter接口的Java类就被称作为过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class FilterDemo1 implements Filter &#123;</div><div class="line">	    public void destroy() &#123;</div><div class="line">	    &#125;</div><div class="line">	</div><div class="line">	    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line">	</div><div class="line">	        //执行这一句，说明放行（让下一个过滤器执行，如果没有过滤器了，就执行执行目标资源）</div><div class="line">	        chain.doFilter(req, resp);</div><div class="line">	    &#125;</div><div class="line">	</div><div class="line">	    public void init(FilterConfig config) throws ServletException &#123;</div><div class="line">	        </div><div class="line">	    &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>filter部署(过滤器和Servlet是一样的，需要部署到Web服务器上的。)</p>
<ul>
<li><p>第一种方式：在web.xml文件中配置</p>
<ul>
<li><p>filter<br><filter>用于注册过滤器</filter></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">      &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt;</div><div class="line">     &lt;filter-class&gt;FilterDemo1&lt;/filter-class&gt;</div><div class="line">     &lt;init-param&gt;</div><div class="line">	 &lt;param-name&gt;word_file&lt;/param-name&gt;	</div><div class="line">	 &lt;param-value&gt;/WEB-INF/word.txt&lt;/param-value&gt;</div><div class="line">     &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line"></div><div class="line">&lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空。</div><div class="line">&lt;filter-class&gt;元素用于指定过滤器的完整的限定类名。</div><div class="line">&lt;init-param&gt;元素用于为过滤器指定初始化参数，它的子元素指定参数的名字，&lt;param-value&gt;指定参数的值。在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。</div></pre></td></tr></table></figure>
</li>
<li><p>filter-mapping<br><filter-mapping>元素用于设置一个Filter 所负责拦截的资源。<br>一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径。</filter-mapping></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">    &lt;dispatcher&gt;REQUEST&lt;dispatcher&gt;</div><div class="line">&lt;/filter-mapping&gt;</div><div class="line"></div><div class="line">&lt;filter-name&gt;子元素用于设置filter的注册名称。该值必须是在元素中声明过的过滤器的名字</div><div class="line">&lt;url-pattern&gt;设置 filter 所拦截的请求路径(过滤器关联的URL样式)</div><div class="line">&lt;servlet-name&gt;指定过滤器所拦截的Servlet名称。</div><div class="line">&lt;dispatcher&gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&lt;dispatcher&gt; 子元素用来指定 Filter 对资源的多种调用方式进行拦截。</div></pre></td></tr></table></figure>
</li>
<li><p>dispatcher<br>子元素可以设置的值及其意义：</p>
<ul>
<li>REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。</li>
<li>INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li>
<li>FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li>
<li>ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li>
</ul>
</li>
</ul>
</li>
<li><p>第二种方式：通过注解配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@WebFilter(filterName = &quot;FilterDemo1&quot;,urlPatterns = &quot;/*&quot;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>上面的配置是“/*”，所有的Web资源都需要途径过滤器</p>
<p>如果想要部分的Web资源进行过滤器过滤则需要指定Web资源的名称即可！</p>
<h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><p>过滤器的应用场景</p>
<ul>
<li>执行目标资源之前做预处理工作，例如设置编码，这种试通常都会放行，只是在目标资源执行之前做一些准备工作；</li>
<li>通过条件判断是否放行，例如校验当前用户是否已经登录，或者用户IP是否已经被禁用；</li>
<li>在目标资源执行后，做一些后续的特殊处理工作，例如把目标资源输出的数据进行处理</li>
</ul>
<h4 id="编码过滤器"><a href="#编码过滤器" class="headerlink" title="编码过滤器"></a>编码过滤器</h4><p>目的：解决全站的乱码问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">      //将request和response强转成http协议的</div><div class="line">      HttpServletRequest httpServletRequest = (HttpServletRequest) req;</div><div class="line">      HttpServletResponse httpServletResponse = (HttpServletResponse) resp;</div><div class="line"></div><div class="line">      httpServletRequest.setCharacterEncoding(&quot;UTF-8&quot;);</div><div class="line">      httpServletResponse.setCharacterEncoding(&quot;UTF-8&quot;);</div><div class="line">      httpServletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);</div><div class="line">      </div><div class="line">      chain.doFilter(httpServletRequest, httpServletResponse);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="敏感词的过滤器"><a href="#敏感词的过滤器" class="headerlink" title="敏感词的过滤器"></a>敏感词的过滤器</h4><p>如果用户输入了敏感词（傻b、尼玛、操蛋等等不文明语言时），我们要将这些不文明用于屏蔽掉，替换成符号！<br>要实现这样的功能也很简单，用户输入的敏感词肯定是在getParameter()获取的，我们在getParameter()得到这些数据的时候，判断有没有敏感词汇，如果有就替换掉就好了！简单来说：就是要增强request对象</p>
<p><strong>增强request对象</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class MyDirtyRequest extends HttpServletRequestWrapper &#123;</div><div class="line">	</div><div class="line">	    HttpServletRequest request;</div><div class="line">	</div><div class="line">	    //定义一堆敏感词汇</div><div class="line">	    private List&lt;String&gt; list = Arrays.asList(&quot;傻b&quot;, &quot;尼玛&quot;, &quot;操蛋&quot;);</div><div class="line">	</div><div class="line">	    public MyDirtyRequest(HttpServletRequest request) &#123;</div><div class="line">	        super(request);</div><div class="line">	        this.request = request;</div><div class="line">	    &#125;</div><div class="line">	</div><div class="line">	    @Override</div><div class="line">	    public String getParameter(String name) &#123;</div><div class="line">	</div><div class="line">	        String value = this.request.getParameter(name);</div><div class="line">	</div><div class="line">	        if (value == null) &#123;</div><div class="line">	            return null;</div><div class="line">	        &#125;</div><div class="line">	</div><div class="line">	        //遍历list集合，看看获取得到的数据有没有敏感词汇</div><div class="line">	        for (String s : list) &#123;</div><div class="line">	</div><div class="line">	            if (s.equals(value)) &#123;</div><div class="line">	                value = &quot;*****&quot;;</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">	</div><div class="line">	        return value ;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>开发过滤器</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">       //将request和response强转成http协议的</div><div class="line">       HttpServletRequest httpServletRequest = (HttpServletRequest) req;</div><div class="line">       HttpServletResponse httpServletResponse = (HttpServletResponse) resp;</div><div class="line"></div><div class="line">       MyDirtyRequest dirtyRequest = new MyDirtyRequest(httpServletRequest);</div><div class="line"></div><div class="line">       //传送给目标资源的是被增强后的request对象</div><div class="line">       chain.doFilter(dirtyRequest, httpServletResponse);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="压缩资源过滤器"><a href="#压缩资源过滤器" class="headerlink" title="压缩资源过滤器"></a>压缩资源过滤器</h4><p>按照过滤器的执行顺序：执行完目标资源，过滤器后面的代码还会执行。所以，我们在过滤器中可以获取执行完目标资源后的response对象！<br>我们知道sun公司提供的response对象调用write()方法，是直接把数据返回给浏览器的。我们要想实现压缩的功能，write()方法就不能直接把数据写到浏览器上！<br>这和上面是类似的，过滤器传递给目标资源的response对象就需要被我们增强，使得目标资源调用writer()方法的时候不把数据直接写到浏览器上！</p>
<p><strong>增强response对象</strong></p>
<p>response对象可能会使用PrintWriter或者ServletOutputStream对象来调用writer()方法的，所以我们增强response对象的时候，需要把getOutputSteam和getWriter()重写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">class MyResponse extends HttpServletResponseWrapper&#123;</div><div class="line"></div><div class="line">    private ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</div><div class="line"></div><div class="line">    private PrintWriter printWriter ;</div><div class="line"></div><div class="line">    private HttpServletResponse response;</div><div class="line">    public MyResponse(HttpServletResponse response) &#123;</div><div class="line">        super(response);</div><div class="line">        this.response = response;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ServletOutputStream getOutputStream() throws IOException &#123;</div><div class="line"></div><div class="line">        //这个的ServletOutputSteam对象调用write()方法的时候，把数据是写在byteArrayOutputSteam上的</div><div class="line">        return new MyServletOutputStream(byteArrayOutputStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public PrintWriter getWriter() throws IOException &#123;</div><div class="line">        printWriter = new PrintWriter(new OutputStreamWriter(byteArrayOutputStream, this.response.getCharacterEncoding()));</div><div class="line"></div><div class="line">        return printWriter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public byte[] getBuffer() &#123;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line"></div><div class="line">            //防止数据在缓存中，要刷新一下！</div><div class="line">            if (printWriter != null) &#123;</div><div class="line">                printWriter.close();</div><div class="line">            &#125;</div><div class="line">            if (byteArrayOutputStream != null) &#123;</div><div class="line">                byteArrayOutputStream.flush();</div><div class="line">                return byteArrayOutputStream.toByteArray();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>过滤器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line"></div><div class="line"></div><div class="line">        HttpServletRequest request = (HttpServletRequest) req;</div><div class="line">        HttpServletResponse response = (HttpServletResponse) resp;</div><div class="line">        MyResponse myResponse = new MyResponse(response);</div><div class="line"></div><div class="line">        //把被增强的response对象传递进去，目标资源调用write()方法的时候就不会直接把数据写在浏览器上了</div><div class="line">        chain.doFilter(request, myResponse);</div><div class="line"></div><div class="line">        //得到目标资源想要返回给浏览器的数据</div><div class="line">        byte[] bytes = myResponse.getBuffer();</div><div class="line"></div><div class="line">        //输出原来的大小</div><div class="line">        System.out.println(&quot;压缩前：&quot;+bytes.length);</div><div class="line"></div><div class="line">        </div><div class="line">        //使用GZIP来压缩资源，再返回给浏览器</div><div class="line">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</div><div class="line">        GZIPOutputStream gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);</div><div class="line">        gzipOutputStream.write(bytes);</div><div class="line">        </div><div class="line">        //得到压缩后的数据</div><div class="line">        byte[] gzip = byteArrayOutputStream.toByteArray();</div><div class="line">        </div><div class="line">        System.out.println(&quot;压缩后：&quot; + gzip.length);</div><div class="line">        </div><div class="line">        //还要设置头，告诉浏览器，这是压缩数据！</div><div class="line">        response.setHeader(&quot;content-encoding&quot;, &quot;gzip&quot;);</div><div class="line">        response.setContentLength(gzip.length);</div><div class="line">        response.getOutputStream().write(gzip);</div><div class="line">     </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="HTML转义过滤器"><a href="#HTML转义过滤器" class="headerlink" title="HTML转义过滤器"></a>HTML转义过滤器</h4><p>只要把getParameter()获取得到的数据转义一遍，就可以完成功能了。</p>
<p><strong>增强request</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">class MyHtmlRequest extends HttpServletRequestWrapper&#123;</div><div class="line"></div><div class="line">    private HttpServletRequest request;</div><div class="line"></div><div class="line">    public MyHtmlRequest(HttpServletRequest request) &#123;</div><div class="line">        super(request);</div><div class="line">        this.request = request;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getParameter(String name) &#123;</div><div class="line"></div><div class="line">        String value = this.request.getParameter(name);</div><div class="line">        return this.Filter(value);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String Filter(String message) &#123;</div><div class="line">        if (message == null)</div><div class="line">            return (null);</div><div class="line"></div><div class="line">        char content[] = new char[message.length()];</div><div class="line">        message.getChars(0, message.length(), content, 0);</div><div class="line">        StringBuffer result = new StringBuffer(content.length + 50);</div><div class="line">        for (int i = 0; i &lt; content.length; i++) &#123;</div><div class="line">            switch (content[i]) &#123;</div><div class="line">                case &apos;&lt;&apos;:</div><div class="line">                    result.append(&quot;&amp;lt;&quot;);</div><div class="line">                    break;</div><div class="line">                case &apos;&gt;&apos;:</div><div class="line">                    result.append(&quot;&amp;gt;&quot;);</div><div class="line">                    break;</div><div class="line">                case &apos;&amp;&apos;:</div><div class="line">                    result.append(&quot;&amp;amp;&quot;);</div><div class="line">                    break;</div><div class="line">                case &apos;&quot;&apos;:</div><div class="line">                    result.append(&quot;&amp;quot;&quot;);</div><div class="line">                    break;</div><div class="line">                default:</div><div class="line">                    result.append(content[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return (result.toString());</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>过滤器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    HttpServletRequest request = (HttpServletRequest) req;</div><div class="line">    HttpServletResponse response = (HttpServletResponse) resp;</div><div class="line">    MyHtmlRequest myHtmlRequest = new MyHtmlRequest(request);</div><div class="line"></div><div class="line">    //传入的是被增强的request！</div><div class="line">    chain.doFilter(myHtmlRequest, response);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓存数据到内存中"><a href="#缓存数据到内存中" class="headerlink" title="缓存数据到内存中"></a>缓存数据到内存中</h4><p>在前面我们已经做过了，让浏览器不缓存数据【验证码的图片是不应该缓存的】。<br>现在我们要做的是：缓存数据到内存中【如果某个资源重复使用，不轻易变化，应该缓存到内存中】<br>这个和压缩数据的Filter非常类似的，因为让数据不直接输出给浏览器，把数据用一个容器（ByteArrayOutputSteam）存起来。如果已经有缓存了，就取缓存的。没有缓存就执行目标资源！</p>
<p><strong>增强response对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">class MyResponse extends HttpServletResponseWrapper &#123;</div><div class="line"></div><div class="line">    private ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</div><div class="line"></div><div class="line">    private PrintWriter printWriter ;</div><div class="line"></div><div class="line">    private HttpServletResponse response;</div><div class="line">    public MyResponse(HttpServletResponse response) &#123;</div><div class="line">        super(response);</div><div class="line">        this.response = response;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ServletOutputStream getOutputStream() throws IOException &#123;</div><div class="line"></div><div class="line">        //这个的ServletOutputSteam对象调用write()方法的时候，把数据是写在byteArrayOutputSteam上的</div><div class="line">        return new MyServletOutputStream(byteArrayOutputStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public PrintWriter getWriter() throws IOException &#123;</div><div class="line">        printWriter = new PrintWriter(new OutputStreamWriter(byteArrayOutputStream, this.response.getCharacterEncoding()));</div><div class="line"></div><div class="line">        return printWriter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public byte[] getBuffer() &#123;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line"></div><div class="line">            //防止数据在缓存中，要刷新一下！</div><div class="line">            if (printWriter != null) &#123;</div><div class="line">                printWriter.close();</div><div class="line">            &#125;</div><div class="line">            if (byteArrayOutputStream != null) &#123;</div><div class="line">                byteArrayOutputStream.flush();</div><div class="line">                return byteArrayOutputStream.toByteArray();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//增强ServletOutputSteam，让writer方法不把数据直接返回给浏览器</div><div class="line"></div><div class="line">class MyServletOutputStream extends ServletOutputStream &#123;</div><div class="line"></div><div class="line">    private ByteArrayOutputStream byteArrayOutputStream;</div><div class="line"></div><div class="line">    public MyServletOutputStream(ByteArrayOutputStream byteArrayOutputStream) &#123;</div><div class="line">        this.byteArrayOutputStream = byteArrayOutputStream;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //当调用write()方法的时候，其实是把数据写byteArrayOutputSteam上</div><div class="line">    @Override</div><div class="line">    public void write(int b) throws IOException &#123;</div><div class="line">        this.byteArrayOutputStream.write(b);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>过滤器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">    //定义一个Map集合，key为页面的地址，value为内存的缓存</div><div class="line">    Map&lt;String, byte[]&gt; map = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    HttpServletRequest request = (HttpServletRequest) req;</div><div class="line">    HttpServletResponse response = (HttpServletResponse) resp;</div><div class="line"></div><div class="line">    //得到客户端想要请求的资源</div><div class="line">    String uri = request.getRequestURI();</div><div class="line">    byte[] bytes = map.get(uri);</div><div class="line"></div><div class="line">    //如果有缓存，直接返回给浏览器就行了，就不用执行目标资源了</div><div class="line">    if (bytes != null) &#123;</div><div class="line">        response.getOutputStream().write(bytes);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //如果没有缓存，就让目标执行</div><div class="line">    MyResponse myResponse = new MyResponse(response);</div><div class="line">    chain.doFilter(request, myResponse);</div><div class="line"></div><div class="line">    //得到目标资源想要发送给浏览器的数据</div><div class="line">    byte[] b = myResponse.getBuffer();</div><div class="line"></div><div class="line">    //把数据存到集合中</div><div class="line">    map.put(uri, b);</div><div class="line"></div><div class="line">    //把数据返回给浏览器</div><div class="line">    response.getOutputStream().write(b);</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用Filter验证用户登录安全控制"><a href="#使用Filter验证用户登录安全控制" class="headerlink" title="使用Filter验证用户登录安全控制"></a>使用Filter验证用户登录安全控制</h4><p>先在web.xml配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;SessionFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;com.action.login.SessionFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;logonStrings&lt;/param-name&gt;&lt;!-- 对登录页面不进行过滤 --&gt;</div><div class="line">        &lt;param-value&gt;/project/index.jsp;login.do&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;includeStrings&lt;/param-name&gt;&lt;!-- 只对指定过滤参数后缀进行过滤 --&gt;</div><div class="line">        &lt;param-value&gt;.do;.jsp&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;redirectPath&lt;/param-name&gt;&lt;!-- 未通过跳转到登录界面 --&gt;</div><div class="line">        &lt;param-value&gt;/index.jsp&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;disabletestfilter&lt;/param-name&gt;&lt;!-- Y:过滤无效 --&gt;</div><div class="line">        &lt;param-value&gt;N&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;SessionFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
<p>接着编写FilterServlet.java：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">package com.action.login;</div><div class="line">import java.io.IOException;</div><div class="line">import javax.servlet.Filter;</div><div class="line">import javax.servlet.FilterChain;</div><div class="line">import javax.servlet.FilterConfig;</div><div class="line">import javax.servlet.ServletException;</div><div class="line">import javax.servlet.ServletRequest;</div><div class="line">import javax.servlet.ServletResponse;</div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line">import javax.servlet.http.HttpServletResponseWrapper;</div><div class="line">/**</div><div class="line"> *    判断用户是否登录,未登录则退出系统</div><div class="line"> */</div><div class="line">public class SessionFilter implements Filter &#123;</div><div class="line">    </div><div class="line">    public FilterConfig config;</div><div class="line">    </div><div class="line">    public void destroy() &#123;</div><div class="line">        this.config = null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static boolean isContains(String container, String[] regx) &#123;</div><div class="line">        boolean result = false;</div><div class="line">        for (int i = 0; i &lt; regx.length; i++) &#123;</div><div class="line">            if (container.indexOf(regx[i]) != -1) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</div><div class="line">        HttpServletRequest hrequest = (HttpServletRequest)request;</div><div class="line">        HttpServletResponseWrapper wrapper = new HttpServletResponseWrapper((HttpServletResponse) response);</div><div class="line">        </div><div class="line">        String logonStrings = config.getInitParameter(&quot;logonStrings&quot;);        // 登录登陆页面</div><div class="line">        String includeStrings = config.getInitParameter(&quot;includeStrings&quot;);    // 过滤资源后缀参数</div><div class="line">        String redirectPath = hrequest.getContextPath() + config.getInitParameter(&quot;redirectPath&quot;);// 没有登陆转向页面</div><div class="line">        String disabletestfilter = config.getInitParameter(&quot;disabletestfilter&quot;);// 过滤器是否有效</div><div class="line">        </div><div class="line">        if (disabletestfilter.toUpperCase().equals(&quot;Y&quot;)) &#123;    // 过滤无效</div><div class="line">            chain.doFilter(request, response);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        String[] logonList = logonStrings.split(&quot;;&quot;);</div><div class="line">        String[] includeList = includeStrings.split(&quot;;&quot;);</div><div class="line">        </div><div class="line">        if (!this.isContains(hrequest.getRequestURI(), includeList)) &#123;// 只对指定过滤参数后缀进行过滤</div><div class="line">            chain.doFilter(request, response);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (this.isContains(hrequest.getRequestURI(), logonList)) &#123;// 对登录页面不进行过滤</div><div class="line">            chain.doFilter(request, response);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        String user = ( String ) hrequest.getSession().getAttribute(&quot;useronly&quot;);//判断用户是否登录</div><div class="line">        if (user == null) &#123;</div><div class="line">            wrapper.sendRedirect(redirectPath);</div><div class="line">            return;</div><div class="line">        &#125;else &#123;</div><div class="line">            chain.doFilter(request, response);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</div><div class="line">        config = filterConfig;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样既可完成对用户所有请求，均要经过这个Filter进行验证用户登录</p>
<h4 id="Spring-Hibernate的OpenSessionInViewFilter控制session的开关"><a href="#Spring-Hibernate的OpenSessionInViewFilter控制session的开关" class="headerlink" title="Spring+Hibernate的OpenSessionInViewFilter控制session的开关"></a>Spring+Hibernate的OpenSessionInViewFilter控制session的开关</h4><p>当hibernate+spring配合使用的时候，如果设置了lazy=true（延迟加载）,那么在读取数据的时候，当读取了父数据后，hibernate 会自动关闭session，这样，当要使用与之关联数据、子数据的时候，系统会抛出lazyinit的错误，这时就需要使用spring提供的OpenSessionInViewFilter过滤器。</p>
<p>OpenSessionInViewFilter主要是保持Session状态直到request将全部页面发送到客户端，直到请求结束后才关闭session，这样就可以解决延迟加载带来的问题。</p>
<p>注意：OpenSessionInViewFilter配置要写在struts2的配置前面。因为tomcat容器在加载过滤器的时候是按照顺序加载的，如果配置文件先写的是struts2的过滤器配置，然后才是OpenSessionInViewFilter过滤器配置，所以加载的顺序导致，action在获得数据的时候session并没有被spring管理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;&lt;!-- lazy loading enabled in spring --&gt;</div><div class="line">    &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;org.springframework.orm.hibernate3.support.OpenSessionInViewFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;sessionFactoryBeanName&lt;/param-name&gt;&lt;!-- 可缺省。默认是从spring容器中找id为sessionFactory的bean，如果id不为sessionFactory，则需要配置如下，此处SessionFactory为spring容器中的bean。 --&gt;</div><div class="line">        &lt;param-value&gt;sessionFactory&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;singleSession&lt;/param-name&gt;&lt;!-- singleSession默认为true,若设为false则等于没用OpenSessionInView --&gt;</div><div class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<h3 id="FilterConfig接口"><a href="#FilterConfig接口" class="headerlink" title="FilterConfig接口"></a>FilterConfig接口</h3><p>用户在配置filter时，可以使用为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得以下内容：</p>
<pre><code>String getFilterName();//得到filter的名称。 
String getInitParameter(String name);//返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. 
Enumeration getInitParameterNames();//返回过滤器的所有初始化参数的名字的枚举集合。 
public ServletContext getServletContext();//返回Servlet上下文对象的引用。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What-is-it&quot;&gt;&lt;a href=&quot;#What-is-it&quot; class=&quot;headerlink&quot; title=&quot;What is it?&quot;&gt;&lt;/a&gt;What is it?&lt;/h3&gt;&lt;p&gt;过滤器是Servlet的高级特性之一，也别把它想得那么高深，只不过是实现
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>机器学习|2-逻辑回归</title>
    <link href="http://yoursite.com/2018/02/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-2-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2018/02/28/机器学习-2-逻辑回归/</id>
    <published>2018-02-28T10:54:56.000Z</published>
    <updated>2018-02-28T03:24:11.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分类-Classification"><a href="#分类-Classification" class="headerlink" title="分类(Classification)"></a>分类(Classification)</h3><p>和回归(Regression)一样，分类(Classification)问题也是机器学习里面很大的一块。</p>
<blockquote>
<p>分类问题是机器学习非常重要的一个组成部分，它的目标是根据已知样本的某些特征，判断一个新的样本属于哪种已知的样本类。</p>
</blockquote>
<p>其实常见的例子很多，判断一个邮件是否是垃圾邮件之类的，预测一个用户是否对我的商品感兴趣，以及图像处理里面对图像进行的分类。</p>
<p><img src="/images/机器学习-逻辑回归-01.jpg" alt="机器学习-逻辑回归" title="机器学习-逻辑回归-01"></p>
<p>分类问题有简单的二分类也有多分类。</p>
<h3 id="逻辑回归LR-Logistic-Regression"><a href="#逻辑回归LR-Logistic-Regression" class="headerlink" title="逻辑回归LR(Logistic Regression)"></a>逻辑回归LR(Logistic Regression)</h3><p>看到名字的时候你可能会有一些奇怪，为什么明明叫逻辑“回归”却用在分类问题上。虽然这个名字似乎指示着什么，但是逻辑回归实际上是分类算法。我猜它之所以这样命名是因为在它的学习方法上和线性回归相似，但是损失(loss)和梯度(gradient)函数的表达不同。特别的，逻辑回归使用 S型函数(sigmoid)而不是线性回归的连续输出。当我们深入到实现中去，我们会了解到更多。</p>
<p>首先我们先把逻辑回归放到一边，之前也说了逻辑回归是用来解决分类问题的，对于分类问题，我们实际上是希望得到一个分类器(Classifier)，当输入数据之后，这个分类器能给我预测这个数据属于某一类的概率，也就是说我们需要的是一个<strong>概率</strong>。</p>
<p>上一节我们介绍的线性回归，其输出的是预测值，其假设函数(Hypothesis Function)也就是输出预测值的函数是这样的。</p>
<p><img src="/images/机器学习-逻辑回归-02.jpg" alt="机器学习-逻辑回归" title="机器学习-逻辑回归-02"></p>
<p>而逻辑回归则是预测属于某一类的概率，所以我们让其假设函数是下面这个：</p>
<p><img src="/images/机器学习-逻辑回归-03.jpg" alt="机器学习-逻辑回归" title="机器学习-逻辑回归-03"></p>
<p>这个函数的意义其实是<strong>当输入为x时，输出y=1的概率</strong>，其实就是二分类问题里面是某个东西的概率。读者现在可能会对这个函数有所疑问，比如为什么是这个函数，这个留在后面会讨论。</p>
<p><img src="/images/机器学习-逻辑回归-04.jpg" alt="机器学习-逻辑回归" title="机器学习-逻辑回归-04"></p>
<blockquote>
<p>这里出现了条件概率，实际上就是指事件A在另外一个事件B已经发生条件下的发生概率。</p>
</blockquote>
<p>我们把这个函数g(z)叫做sigmoid函数，很明显这个函数的值域是0到1的开区间。接下来我们会详细介绍一下这个函数。</p>
<h4 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h4><p>Sigmoid函数的函数表达式如下:</p>
<p><img src="/images/机器学习-逻辑回归-05.jpg" alt="Sigmoid函数" title="机器学习-逻辑回归-05"></p>
<p><img src="/images/机器学习-逻辑回归-06.jpg" alt="Sigmoid函数图像" title="机器学习-逻辑回归-06"></p>
<h4 id="损失函数-Loss-Function"><a href="#损失函数-Loss-Function" class="headerlink" title="损失函数(Loss Function)"></a>损失函数(Loss Function)</h4><p>上一小节我们也说过，为了修正参数Θ我们需要有个手段来衡量当前参数Θ的优秀程度。损失函数(Loss Function)就是用来衡量假设函数(hypothesis function)的准确性。</p>
<p>对于逻辑回归来说，我们希望的是当预测概率约接近实际情况(0或1)的时候误差最小，而且不希望曲线是一条直线，而是对于越接近的地方变化越小，约远离的地方变化越大的函数。</p>
<p>下面就是逻辑回归的损失函数。</p>
<p><img src="/images/机器学习-逻辑回归-07.jpg" alt="损失函数" title="机器学习-逻辑回归-07"></p>
<p><img src="/images/机器学习-逻辑回归-08.jpg" alt="损失函数" title="机器学习-逻辑回归-08"></p>
<p>我们可以将函数合并一下，毕竟这种分段函数处理起来不是很舒服，其实就是下图这样，也很好理解，毕竟二分类训练数据y只有0和1两个值。</p>
<p><img src="/images/机器学习-逻辑回归-09.jpg" alt="enter description here" title="机器学习-逻辑回归-09"></p>
<p>这样我们就可以算出在一个训练集中基于当前参数Θ得到结果的误差了。</p>
<p><img src="/images/机器学习-逻辑回归-10.jpg" alt="enter description here" title="机器学习-逻辑回归-10"></p>
<h4 id="矢量化编程"><a href="#矢量化编程" class="headerlink" title="矢量化编程"></a>矢量化编程</h4><p>矢量化编程是提高算法速度的一种有效方法。为了提升特定数值运算操作（如矩阵相乘、矩阵相加、矩阵-向量乘法等）的速度，数值计算和并行计算的研究人员已经努力了几十年。矢量化编程的思想就是尽量使用这些被高度优化的数值运算操作来实现我们的学习算法。</p>
<p>换句话说就是尽量避免使用for循环，毕竟矩阵相乘这种场景非常适合并行计算，在巨量的数据面前性能收益非常明显。</p>
<p>如果刚刚的损失函数用矢量化编程的思想来表示的话</p>
<p><img src="/images/机器学习-逻辑回归-11.jpg" alt="矢量化编程" title="机器学习-逻辑回归-11"></p>
<p>如果一时不理解的话我先解释一下，我们先假设共m个数据，而这个模型中变量有n个。则矩阵h就是(m, n) X (n, 1)也就是(m,1)矩阵，矩阵h的意义就是这m个数据的预测值。<br>损失函数中y的转置为(1, m)，相乘后得到(1, 1)也就是一个值，这两个矩阵相乘的意义则是对应的预测值取对数乘以对应的实际值，最后加在一起。</p>
<blockquote>
<p>(m,n)表示维度为m行n列的矩阵，如果学过矩阵的乘法应该知道矩阵相乘(m, n) X (n, k)得到的矩阵是(m, k)</p>
</blockquote>
<h4 id="逻辑回归的梯度下降法-Gradient-Descent"><a href="#逻辑回归的梯度下降法-Gradient-Descent" class="headerlink" title="逻辑回归的梯度下降法(Gradient Descent)"></a>逻辑回归的梯度下降法(Gradient Descent)</h4><p>我们刚刚知道了怎么评价当前参数Θ的好坏，现在我们需要做的是使用梯度下降法来调整参数。</p>
<p><img src="/images/机器学习-逻辑回归-12.jpg" alt="" title="机器学习-逻辑回归-12"></p>
<p>依旧是对损失函数求偏导数，别忘记α是学习速率的意思。</p>
<p><img src="/images/机器学习-逻辑回归-13.jpg" alt="" title="机器学习-逻辑回归-13"></p>
<p>矢量化表示为</p>
<p><img src="/images/机器学习-逻辑回归-14.jpg" alt="" title="机器学习-逻辑回归-14"></p>
<h5 id="损失函数偏导数求解过程-选修"><a href="#损失函数偏导数求解过程-选修" class="headerlink" title="损失函数偏导数求解过程(选修)"></a>损失函数偏导数求解过程(选修)</h5><p><img src="/images/机器学习-逻辑回归-15.jpg" alt="损失函数偏导数求解过程" title="机器学习-逻辑回归-15"></p>
<h3 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h3><p>对于一个训练数据集，可视化后如下图所示。</p>
<p><img src="/images/机器学习-逻辑回归-16.jpg" alt="" title="机器学习-逻辑回归-16"></p>
<p>对于三个不同的分类器划分出的边界的三种情况，我们对其有不同的称呼.</p>
<p><img src="/images/机器学习-逻辑回归-17.jpg" alt="" title="机器学习-逻辑回归-17"></p>
<p>第一种，分类非常不准，这种我们叫欠拟合(underfitting)<br>第二种，分类得恰到好处，这种其实没有特别的称呼。<br>第三种，分类太过于契合训练数据了。这种我们称为过拟合(overfitting)<br>过拟合所产生的问题也很明显，它实在太过于契合训练集了，对于我们来说，第二个曲线才是我们想要的，过拟合的结果太过于契合训练数据，实用性可想而知的低。</p>
<p>而解决过拟合的方法主要有两种</p>
<ul>
<li>减少特征的数量，这个很好理解，更多的特征意味着划分出来的函数曲线可以越复杂。这个可以扩展到以后会讲的特征工程(Feature Engineering)</li>
<li>使用正则化项， 保持所有的特征，但是保证参数θj不会变得巨大。正则化项非常适合在我们拥有很多稍微有点用的特征的时候。</li>
</ul>
<h4 id="正则化项-regularizer"><a href="#正则化项-regularizer" class="headerlink" title="正则化项(regularizer)"></a>正则化项(regularizer)</h4><p>正则化项其实也叫惩罚项(penalty term)，其作用是减缓过拟合问题，其实就是在损失函数后面加一个含有各个Θ的项，这样做的目的是让Θ也参与损失函数的计算，这样由于我们需要求的是损失函数的最小值，这个项就会限制Θ的大小。</p>
<p>这个正则化项的目的其实是一个权衡，我们即希望参数Θ能在训练数据集上表现得比较好，又不希望参数Θ训练出来的值非常大而产生一些奇葩的划分曲线，就像下图这样的。</p>
<p><img src="/images/机器学习-逻辑回归-18.jpg" alt="过拟合" title="机器学习-逻辑回归-18"></p>
<blockquote>
<p>转载 <a href="https://juejin.im/post/5a40e8e46fb9a0450671dd2f" target="_blank" rel="external">https://juejin.im/post/5a40e8e46fb9a0450671dd2f</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分类-Classification&quot;&gt;&lt;a href=&quot;#分类-Classification&quot; class=&quot;headerlink&quot; title=&quot;分类(Classification)&quot;&gt;&lt;/a&gt;分类(Classification)&lt;/h3&gt;&lt;p&gt;和回归(Regr
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/machine/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习|1-线性回归</title>
    <link href="http://yoursite.com/2018/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-1-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2018/02/27/机器学习-1-线性回归/</id>
    <published>2018-02-26T18:37:58.000Z</published>
    <updated>2018-02-26T15:46:51.948Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<blockquote>
<p>机器学习(Machine Learning, ML)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p>
</blockquote>
<p>自己作为计算机专业的一员，在写了几个只要增删改查的项目后，发现自己对写代码这个活动不是很有兴趣了，有点厌倦了。现在业内人都在说人工智能、机器学习等高大尚的东西，起初自己认为这些东西不是本科生能掌握的东西，但接触后发现自己错了，也就是那么一回事。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章的主角是线性回归，也就是LR(Linear Regression)，是机器学习得基础算法。</p>
<p>回归(Regression)问题是机器学习里面很大的一块。</p>
<blockquote>
<p>统计学中，回归分析（regression analysis)指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。回归分析按照涉及的变量的多少，分为一元回归和多元回归分析；按照因变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析。</p>
</blockquote>
<p>不玩定义，直接上例子，设想一下这样的场景： 如果我现在有了一组(身高, 体重)的数据集，可以令身高为x值，体重为y值将其画在纸上，就和下图一样。</p>
<p><img src="/images/机器学习-线性回归-01.png" alt="机器学习-线性回归" title="机器学习-线性回归-01"></p>
<p>那么现在问题来了，假设我身高为1.8m，能不能预测出我的体重？这就是回归要解决的问题，我希望得到一个函数，我输入我的身高之后他能够帮我预测出我的体重。<br>在这个例子里，我假设身高和体重的关系是线性关系，所以假设模型是y=kx+b这种一次函数，为了确定变量k和b，我需要利用之前的数据去学习出这两个参数。<br>尽管上面的例子误差很大。因为体重的函数肯定不单单由身高这一个特征(feature)决定，而且即使只有身高一个特征，最佳函数也很可能不是一次函数。</p>
<h4 id="回归问题相关概念"><a href="#回归问题相关概念" class="headerlink" title="回归问题相关概念"></a>回归问题相关概念</h4><p>通常，这类预测问题可以用回归(regression)模型进行解决，回归模型定义了输入与输出的关系，输入即现有知识，而输出则为预测。<br>一个预测问题在回归模型下的解决步骤为：</p>
<ul>
<li>积累知识： 我们将储备的知识称之为训练集(Training Set)，毕竟预测是需要过去的数据作为参考的，这个很好理解。</li>
<li>学习：当我们有了数据的时候，我们就需要去学习这些数据，为什么说机器学习智能？因为当我告诉计算机我的模型是线性(一次函数)或其他类型的函数然后把数据直接倒进去之后它就能返回给我最后的函数(参数都训练好了)。</li>
<li>预测：学习完成后，当接受了新的数据（输入）后，我们就能通过学习阶段获得的对应关系来预测输出。</li>
</ul>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>这篇博客主要讲的是线性回归(Linear regression)，经过前言后大家也知道了，回归里面用到的函数有多种多样的，这个需要开发者自己去选择，这次先介绍最简单的线性回归(Linear regression)。</p>
<h4 id="线性回归LR-Linear-Regression"><a href="#线性回归LR-Linear-Regression" class="headerlink" title="线性回归LR(Linear Regression)"></a>线性回归LR(Linear Regression)</h4><p>从数学上来说，给定由d个属性描述的示例x=(x1;x2;…;xd),其中xi是x在第i个属性上的取值，线性模型试图学得一个通过属性的线性组合来进行预测的函数，即:</p>
<p><img src="/images/机器学习-线性回归-02.png" alt="机器学习-线性回归" title="机器学习-线性回归-02"></p>
<p>一般用向量形式:</p>
<p><img src="/images/机器学习-线性回归-03.png" alt="机器学习-线性回归" title="机器学习-线性回归-03"></p>
<p>好了，现在我们知道了线性回归模型的基本形式了，那么我们现在的任务就是要去学习出这个w向量和b这些参数的值，有了这个值我们才能去做预测。</p>
<p>一般来说，我们会给w和b一个初始值，然后我们去修正这些值来让这些值符合预期，那么我们怎么去修正这些值呢？我们需要一个<strong>损失函数</strong>(loss function)，这个函数用来指明我的预测值和训练数据实际值的差别。<br>那么这个损失函数(loss function)是什么，以及我们怎么用它来修正我们的参数w和b，看下面。</p>
<h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>不知道大家知不知道启发式搜索(Heuristically Search)？</p>
<blockquote>
<p>启发式搜索(Heuristically Search)又称为有信息搜索(Informed Search)，它是利用问题拥有的启发信息来引导搜索，达到减少搜索范围、降低问题复杂度的目的，这种利用启发信息的搜索过程称为启发式搜索。——百度百科</p>
</blockquote>
<p>举个例子，大一大二在大学里面的时候我是有单车的，晚上下课的时候在停车场里面经常忘记自己的车停在哪，要找半天才能找得到，这种就叫盲目搜索，广度优先搜索(BFS)和宽度优先搜索(DFS)都是盲目搜索。</p>
<p>那么如果我手里有个黑科技，能够告诉我我现在距离我的爱车多远，那么我是不是可以以此为依据，往距离逐渐减少的方向去搜索呢？这就是启发式搜索(Heuristically Search)，Astar(A*)寻路算法等就是启发式搜索。<br>启发式搜索与机器学习有一些概念是共通的，那么对于机器学习来说，我也同样需要一个和“距离我爱车多远”这样一个指标来判断我现在参数距离我最优参数有“多远”。我们可以统一的把这种东西叫做损失函数(loss function)</p>
<h4 id="损失函数-Loss-Function"><a href="#损失函数-Loss-Function" class="headerlink" title="损失函数(Loss Function)"></a>损失函数(Loss Function)</h4><p>我们给之前例子里的函数一个名字，叫假设函数(hypothesis function)，意为预估值函数。损失函数则是用来衡量假设函数(hypothesis function)的准确性，具体衡量指标有很多，这里我们和吴恩达教程里面一样采用平方差的方式计算。</p>
<p><img src="/images/机器学习-线性回归-04.png" alt="机器学习-线性回归" title="机器学习-线性回归-04"></p>
<p>其中函数J就是损失函数(为什么是J我好好奇)，函数h是假设函数，可以看到后面是平方差的平均值然后除以了个2。</p>
<blockquote>
<p>公式2*m里面的2其实就是为了后面求偏导的时候可以把分数消掉，没什么太大的实际意义。</p>
</blockquote>
<h4 id="梯度下降算法-Gradient-descent-algorithm"><a href="#梯度下降算法-Gradient-descent-algorithm" class="headerlink" title="梯度下降算法(Gradient descent algorithm)"></a>梯度下降算法(Gradient descent algorithm)</h4><p>既然我们现在知道了当前怎么评价当前参数的好坏，那么我怎么去修正参数让参数更好(损失函数的最小值)呢？</p>
<p>高中生都知道，在一元函数里面，导数的几何意义就是函数变化增加最快的方向。梯度其实类似，也是类似的，说白了就是一个向量，表示上升最快的方向。</p>
<p>那么我们就可以得到一个修正的公式，我们迭代这个公式许多次来修正参数。</p>
<p><img src="/images/机器学习-线性回归-05.png" alt="机器学习-线性回归" title="机器学习-线性回归-05"></p>
<p>这里是减号是因为梯度表示上升最快，所以用的是负梯度。</p>
<p>然后其中其中α表示学习速率(learning rate)，这个值越大每次修正的就越多，不过这个不是越高越好，如果太高了可能会一直在最低点“摆动”而无法收敛。也有的使用可变的学习速率，一开始设置较高，接近最低点的过程中逐渐降低。</p>
<p><img src="/images/机器学习-线性回归-06.png" alt="机器学习-线性回归" title="机器学习-线性回归-06"></p>
<p>接下来我们看一下求导之后的结果:</p>
<p><img src="/images/机器学习-线性回归-07.png" alt="机器学习-线性回归" title="机器学习-线性回归-07"></p>
<blockquote>
<p>这里有一点值得注意的是，在这个梯度下降中我们每次迭代都使用了所有的m个训练数据，这种也叫批量梯度下降法Batch Gradient Descent，BGD<br>这样每次迭代都将对m个样本进行计算，计算量大。所以有些优化方案，有兴趣的可以去看一下</p>
</blockquote>
<p>现在我们知道了如何去修正参数了，但我们实际上修正之后得到的是损失函数(loss function)的极小值而不一定是最小值.</p>
<p><img src="/images/机器学习-线性回归-08.png" alt="机器学习-线性回归" title="机器学习-线性回归-08"></p>
<p><img src="/images/机器学习-线性回归-09.png" alt="机器学习-线性回归" title="机器学习-线性回归-09"></p>
<ol>
<li>由于起始点(起始参数)的不同，最后可能得到的并不是全局的最优解(损失函数最小)。我说一下从西瓜书上看到的几个优化方法。</li>
<li>以多组不同的参数值初始化，反正就是找多个起点选最好的结果。</li>
<li>使用“模拟退火”(Simulated Annealing)技术，模拟退火在每一步都以一定概率接受比当前解更差的结果，从而有助于“跳出”局部极小。在每步迭代过程中，接受“次优解”的概率会随着时间的推移而逐步降低，从而保证算法的稳定。</li>
<li>使用随机梯度下降，它在计算梯度的时候加入了随机因素，所以即使陷入了局部极小值，它计算出来的梯度仍然可能不为0，这样就有机会跳出局部极小继续搜索。</li>
</ol>
<blockquote>
<p>转载 <a href="https://juejin.im/post/5a37b4cf6fb9a045023bbe25" target="_blank" rel="external">https://juejin.im/post/5a37b4cf6fb9a045023bbe25</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]]}
});
&lt;/script&gt;

&lt;script type=&quot;te
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/machine/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java|自己撸一个SpringMVC框架</title>
    <link href="http://yoursite.com/2018/02/25/Java-%E5%BE%92%E6%89%8B%E6%92%B8%E6%A1%86%E6%9E%B6-%E5%AE%9E%E7%8E%B0SpringMVC%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/02/25/Java-徒手撸框架-实现SpringMVC框架/</id>
    <published>2018-02-24T18:37:19.000Z</published>
    <updated>2018-02-24T14:53:24.619Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架对于Java后端程序员来说再熟悉不过了，以前只知道它用的反射实现的，但了解之后才知道有很多巧妙的设计在里面。如果不看Spring的源码，你将会失去一次和大师学习的机会：它的代码规范，设计思想很值得学习。我们程序员大部分人都是野路子，不懂什么叫代码规范。写了一个月的代码，最后还得其他老司机花3天时间重构，相信大部分老司机都很头疼看新手的代码。</p>
<p>废话不多说，我们进入今天的正题，在Web应用程序设计中，MVC模式已经被广泛使用。SpringMVC以DispatcherServlet为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。想要实现自己的SpringMVC框架，需要从以下几点入手：</p>
<ul>
<li>了解SpringMVC运行流程及九大组件</li>
<li>自己实现SpringMVC的功能分析</li>
<li>手写SpringMVC框架</li>
</ul>
<h3 id="了解SpringMVC运行流程及九大组件"><a href="#了解SpringMVC运行流程及九大组件" class="headerlink" title="了解SpringMVC运行流程及九大组件"></a>了解SpringMVC运行流程及九大组件</h3><h4 id="SpringMVC的运行流程"><a href="#SpringMVC的运行流程" class="headerlink" title="SpringMVC的运行流程"></a>SpringMVC的运行流程</h4><p><img src="/images/springMVC-01.jpg" alt="springMVC" title="springMVC-01"></p>
<ul>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>
<li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器<br>执行处理器(Controller，也叫后端控制器)。</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体View</li>
<li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ul>
<p>从上面可以看出，DispatcherServlet有接受请求，响应结果，转发等作用。有了DispatcherServlet之后，可以减少组件之间的耦合度。</p>
<h4 id="SpringMVC的九大组件"><a href="#SpringMVC的九大组件" class="headerlink" title="SpringMVC的九大组件"></a>SpringMVC的九大组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">protected void initStrategies(ApplicationContext context) &#123;</div><div class="line">	//用于处理上传请求。处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File.</div><div class="line">	initMultipartResolver(context);</div><div class="line">	//SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。</div><div class="line">	initLocaleResolver(context); </div><div class="line">	//用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、</div><div class="line">	//如图片、css样式等。SpringMVC的主题也支持国际化， </div><div class="line">	initThemeResolver(context);</div><div class="line">	//用来查找Handler的。</div><div class="line">	initHandlerMappings(context);</div><div class="line">	//从名字上看，它就是一个适配器。Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。</div><div class="line">	//如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情</div><div class="line">	initHandlerAdapters(context);</div><div class="line">	//其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？</div><div class="line">	//这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。</div><div class="line">	initHandlerExceptionResolvers(context);</div><div class="line">	//有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，</div><div class="line">	//如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。</div><div class="line">	initRequestToViewNameTranslator(context);</div><div class="line">	//ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。</div><div class="line">	//View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。</div><div class="line">	initViewResolvers(context);</div><div class="line">	//用来管理FlashMap的，FlashMap主要用在redirect重定向中传递参数。</div><div class="line">	initFlashMapManager(context); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自己实现SpringMVC功能分析"><a href="#自己实现SpringMVC功能分析" class="headerlink" title="自己实现SpringMVC功能分析"></a>自己实现SpringMVC功能分析</h3><p>本片文章只实现SpringMVC的配置加载、实例化扫描的包、HandlerMapping的url映射到对应的Controller的method上、异常的拦截和动态调用后返回结果输出给浏览器的功能。其余SpringMVC功能读者可以尝试自己实现。</p>
<h4 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h4><p><img src="/images/springMVC-02.png" alt="springMVC" title="springMVC-02"></p>
<p> 从图中可以看出，SpringMVC本质上是一个Servlet,这个 Servlet 继承自 HttpServlet。FrameworkServlet负责初始化SpringMVC的容器，并将Spring容器设置为父容器。因为本文只是实现SpringMVC，对于Spring容器不做过多讲解。</p>
<p> 为了读取web.xml中的配置，我们用到ServletConfig这个类，它代表当前Servlet在web.xml中的配置信息。通过web.xml中加载我们自己写的MyDispatcherServlet和读取配置文件。</p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>在上文中，我们知道了DispatcherServlet的initStrategies方法会初始化9大组件，但是本文将实现一些SpringMVC的最基本的组件而不是全部，按顺序包括：</p>
<ul>
<li>加载配置文件</li>
<li>初始化所有相关联的类，扫描用户设定的包下面所有的类</li>
<li>拿到扫描到的类，通过反射机制，实例化。并且放到ioc容器中(Map的键值对  beanName-bean) beanName默认是首字母小写</li>
<li>初始化HandlerMapping，其实就是将一个Map的键值对 key是url，value是所调用的方法put进去(将url和method对应上)</li>
</ul>
<h4 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h4><p>每一次请求将会调用doGet或doPost方法，所以统一运行阶段都放在doDispatch方法里处理，它会根据url请求去HandlerMapping中匹配到对应的Method，然后利用反射机制调用Controller中的方法，并得到结果返回。按顺序包括以下功能：</p>
<ul>
<li>异常的拦截</li>
<li>获取请求传入的参数并处理参数</li>
<li>通过初始化好的handlerMapping的Map容器中拿出url对应的方法名，反射调用</li>
</ul>
<h3 id="手写SpringMVC框架"><a href="#手写SpringMVC框架" class="headerlink" title="手写SpringMVC框架"></a>手写SpringMVC框架</h3><p> 工程文件及目录：</p>
<p> <img src="/images/springMVC-03.png" alt="springMVC" title="springMVC-03"></p>
<p>首先，新建一个maven项目，在pom.xml中导入以下依赖。为了方便，博主直接导入了Springboot的web包，里面有我们需要的所有web开发的东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line">  &lt;groupId&gt;com.liugh&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;liughMVC&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</div><div class="line">  </div><div class="line"> &lt;dependencyManagement&gt;</div><div class="line">		&lt;dependencies&gt;</div><div class="line">			&lt;dependency&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;1.4.3.RELEASE&lt;/version&gt;</div><div class="line">				&lt;type&gt;pom&lt;/type&gt;</div><div class="line">				&lt;scope&gt;import&lt;/scope&gt;</div><div class="line">			&lt;/dependency&gt;</div><div class="line">		&lt;/dependencies&gt;</div><div class="line">	&lt;/dependencyManagement&gt;</div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</div><div class="line">		&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</div><div class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line">	</div><div class="line">	&lt;dependencies&gt;</div><div class="line">  		&lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">    &lt;/dependencies&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure></p>
<p>接着，我们在WEB-INF下创建一个web.xml，如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</div><div class="line">	version=&quot;3.0&quot;&gt;</div><div class="line">	&lt;servlet&gt;</div><div class="line">		&lt;servlet-name&gt;MySpringMVC&lt;/servlet-name&gt;</div><div class="line">		&lt;servlet-class&gt;com.liugh.servlet.MyDispatcherServlet&lt;/servlet-class&gt;</div><div class="line">		&lt;init-param&gt;</div><div class="line">			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">			&lt;param-value&gt;application.properties&lt;/param-value&gt;</div><div class="line">		&lt;/init-param&gt;</div><div class="line">		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">	&lt;/servlet&gt;</div><div class="line">	&lt;servlet-mapping&gt;</div><div class="line">		&lt;servlet-name&gt;MySpringMVC&lt;/servlet-name&gt;</div><div class="line">		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">	&lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<p>application.properties文件中只是配置要扫描的包到SpringMVC容器中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scanPackage=com.liugh.core</div></pre></td></tr></table></figure></p>
<p>创建自己的Controller注解，它只能标注在类上面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.liugh.annotation;</div><div class="line"></div><div class="line">import java.lang.annotation.Documented;</div><div class="line">import java.lang.annotation.ElementType;</div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.RetentionPolicy;</div><div class="line">import java.lang.annotation.Target;</div><div class="line"></div><div class="line">@Target(ElementType.TYPE)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface MyController &#123;</div><div class="line">	/**</div><div class="line">     * 表示给controller注册别名</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    String value() default &quot;&quot;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RequestMapping注解，可以在类和方法上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.liugh.annotation;</div><div class="line"></div><div class="line">import java.lang.annotation.Documented;</div><div class="line">import java.lang.annotation.ElementType;</div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.RetentionPolicy;</div><div class="line">import java.lang.annotation.Target;</div><div class="line"></div><div class="line">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface MyRequestMapping &#123;</div><div class="line">	/**</div><div class="line">     * 表示访问该方法的url</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    String value() default &quot;&quot;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RequestParam注解,只能注解在参数上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.liugh.annotation;</div><div class="line"></div><div class="line">import java.lang.annotation.Documented;</div><div class="line">import java.lang.annotation.ElementType;</div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.RetentionPolicy;</div><div class="line">import java.lang.annotation.Target;</div><div class="line"></div><div class="line">@Target(ElementType.PARAMETER)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface MyRequestParam &#123;</div><div class="line">	/**</div><div class="line">     * 表示参数的别名，必填</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    String value();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后创建MyDispatcherServlet这个类，去继承HttpServlet，重写init方法、doGet、doPost方法，以及加上我们第二步分析时要实现的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div></pre></td><td class="code"><pre><div class="line">package com.liugh.servlet;</div><div class="line"></div><div class="line">import java.io.File;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.lang.reflect.Method;</div><div class="line">import java.net.URL;</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.List;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.Map.Entry;</div><div class="line">import java.util.Properties;</div><div class="line"></div><div class="line">import javax.servlet.ServletConfig;</div><div class="line">import javax.servlet.ServletException;</div><div class="line">import javax.servlet.http.HttpServlet;</div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import com.liugh.annotation.MyController;</div><div class="line">import com.liugh.annotation.MyRequestMapping;</div><div class="line"></div><div class="line">public class MyDispatcherServlet extends HttpServlet&#123;</div><div class="line">	</div><div class="line">	private Properties properties = new Properties();</div><div class="line">	</div><div class="line">	private List&lt;String&gt; classNames = new ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	private Map&lt;String, Object&gt; ioc = new HashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	private Map&lt;String, Method&gt; handlerMapping = new  HashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	private Map&lt;String, Object&gt; controllerMap  =new HashMap&lt;&gt;();</div><div class="line">	</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void init(ServletConfig config) throws ServletException &#123;</div><div class="line">		</div><div class="line">		//1.加载配置文件</div><div class="line">		doLoadConfig(config.getInitParameter(&quot;contextConfigLocation&quot;));</div><div class="line">		</div><div class="line">		//2.初始化所有相关联的类,扫描用户设定的包下面所有的类</div><div class="line">		doScanner(properties.getProperty(&quot;scanPackage&quot;));</div><div class="line">		</div><div class="line">		//3.拿到扫描到的类,通过反射机制,实例化,并且放到ioc容器中(k-v  beanName-bean) beanName默认是首字母小写</div><div class="line">		doInstance();</div><div class="line">		</div><div class="line">		//4.初始化HandlerMapping(将url和method对应上)</div><div class="line">		initHandlerMapping();</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</div><div class="line">		this.doPost(req,resp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</div><div class="line">		try &#123;</div><div class="line">			//处理请求</div><div class="line">			doDispatch(req,resp);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			resp.getWriter().write(&quot;500!! Server Exception&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	private void doDispatch(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;</div><div class="line">		if(handlerMapping.isEmpty())&#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		String url =req.getRequestURI();</div><div class="line">		String contextPath = req.getContextPath();</div><div class="line">		</div><div class="line">		url=url.replace(contextPath, &quot;&quot;).replaceAll(&quot;/+&quot;, &quot;/&quot;);</div><div class="line">		</div><div class="line">		if(!this.handlerMapping.containsKey(url))&#123;</div><div class="line">			resp.getWriter().write(&quot;404 NOT FOUND!&quot;);</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Method method =this.handlerMapping.get(url);</div><div class="line">		</div><div class="line">		//获取方法的参数列表</div><div class="line">		Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">	</div><div class="line">		//获取请求的参数</div><div class="line">		Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();</div><div class="line">		</div><div class="line">		//保存参数值</div><div class="line">		Object [] paramValues= new Object[parameterTypes.length];</div><div class="line">		</div><div class="line">		//方法的参数列表</div><div class="line">        for (int i = 0; i&lt;parameterTypes.length; i++)&#123;  </div><div class="line">            //根据参数名称，做某些处理  </div><div class="line">            String requestParam = parameterTypes[i].getSimpleName();  </div><div class="line">            </div><div class="line">            </div><div class="line">            if (requestParam.equals(&quot;HttpServletRequest&quot;))&#123;  </div><div class="line">                //参数类型已明确，这边强转类型  </div><div class="line">            	paramValues[i]=req;</div><div class="line">                continue;  </div><div class="line">            &#125;  </div><div class="line">            if (requestParam.equals(&quot;HttpServletResponse&quot;))&#123;  </div><div class="line">            	paramValues[i]=resp;</div><div class="line">                continue;  </div><div class="line">            &#125;</div><div class="line">            if(requestParam.equals(&quot;String&quot;))&#123;</div><div class="line">            	for (Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123;</div><div class="line">         			String value =Arrays.toString(param.getValue()).replaceAll(&quot;\\[|\\]&quot;, &quot;&quot;).replaceAll(&quot;,\\s&quot;, &quot;,&quot;);</div><div class="line">         			paramValues[i]=value;</div><div class="line">         		&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;  </div><div class="line">		//利用反射机制来调用</div><div class="line">		try &#123;</div><div class="line">			method.invoke(this.controllerMap.get(url), paramValues);//obj是method所对应的实例 在ioc容器中</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	private void  doLoadConfig(String location)&#123;</div><div class="line">		//把web.xml中的contextConfigLocation对应value值的文件加载到留里面</div><div class="line">		InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(location);</div><div class="line">		try &#123;</div><div class="line">			//用Properties文件加载文件里的内容</div><div class="line">			properties.load(resourceAsStream);</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;finally &#123;</div><div class="line">			//关流</div><div class="line">			if(null!=resourceAsStream)&#123;</div><div class="line">				try &#123;</div><div class="line">					resourceAsStream.close();</div><div class="line">				&#125; catch (IOException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private void doScanner(String packageName) &#123;</div><div class="line">		//把所有的.替换成/</div><div class="line">		URL url  =this.getClass().getClassLoader().getResource(&quot;/&quot;+packageName.replaceAll(&quot;\\.&quot;, &quot;/&quot;));</div><div class="line">		File dir = new File(url.getFile());</div><div class="line">		for (File file : dir.listFiles()) &#123;</div><div class="line">			if(file.isDirectory())&#123;</div><div class="line">				//递归读取包</div><div class="line">				doScanner(packageName+&quot;.&quot;+file.getName());</div><div class="line">			&#125;else&#123;</div><div class="line">				String className =packageName +&quot;.&quot; +file.getName().replace(&quot;.class&quot;, &quot;&quot;);</div><div class="line">				classNames.add(className);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">	private void doInstance() &#123;</div><div class="line">		if (classNames.isEmpty()) &#123;</div><div class="line">			return;</div><div class="line">		&#125;	</div><div class="line">		for (String className : classNames) &#123;</div><div class="line">			try &#123;</div><div class="line">				//把类搞出来,反射来实例化(只有加@MyController需要实例化)</div><div class="line">				Class&lt;?&gt; clazz =Class.forName(className);</div><div class="line">			   if(clazz.isAnnotationPresent(MyController.class))&#123;</div><div class="line">					ioc.put(toLowerFirstWord(clazz.getSimpleName()),clazz.newInstance());</div><div class="line">				&#125;else&#123;</div><div class="line">					continue;</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">				continue;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	private void initHandlerMapping()&#123;</div><div class="line">		if(ioc.isEmpty())&#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		try &#123;</div><div class="line">			for (Entry&lt;String, Object&gt; entry: ioc.entrySet()) &#123;</div><div class="line">				Class&lt;? extends Object&gt; clazz = entry.getValue().getClass();</div><div class="line">				if(!clazz.isAnnotationPresent(MyController.class))&#123;</div><div class="line">					continue;</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				//拼url时,是controller头的url拼上方法上的url</div><div class="line">				String baseUrl =&quot;&quot;;</div><div class="line">				if(clazz.isAnnotationPresent(MyRequestMapping.class))&#123;</div><div class="line">					MyRequestMapping annotation = clazz.getAnnotation(MyRequestMapping.class);</div><div class="line">					baseUrl=annotation.value();</div><div class="line">				&#125;</div><div class="line">				Method[] methods = clazz.getMethods();</div><div class="line">				for (Method method : methods) &#123;</div><div class="line">					if(!method.isAnnotationPresent(MyRequestMapping.class))&#123;</div><div class="line">						continue;</div><div class="line">					&#125;</div><div class="line">					MyRequestMapping annotation = method.getAnnotation(MyRequestMapping.class);</div><div class="line">					String url = annotation.value();</div><div class="line">					</div><div class="line">					url =(baseUrl+&quot;/&quot;+url).replaceAll(&quot;/+&quot;, &quot;/&quot;);</div><div class="line">					handlerMapping.put(url,method);</div><div class="line">					controllerMap.put(url,clazz.newInstance());</div><div class="line">					System.out.println(url+&quot;,&quot;+method);</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 把字符串的首字母小写</div><div class="line">	 * @param name</div><div class="line">	 * @return</div><div class="line">	 */</div><div class="line">	private String toLowerFirstWord(String name)&#123;</div><div class="line">		char[] charArray = name.toCharArray();</div><div class="line">		charArray[0] += 32;</div><div class="line">		return String.valueOf(charArray);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">		</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们就开发完了自己的SpringMVC，现在我们测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package com.liugh.core.controller;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">import com.liugh.annotation.MyController;</div><div class="line">import com.liugh.annotation.MyRequestMapping;</div><div class="line">import com.liugh.annotation.MyRequestParam;</div><div class="line"></div><div class="line">@MyController</div><div class="line">@MyRequestMapping(&quot;/test&quot;)</div><div class="line">public class TestController &#123;</div><div class="line">	</div><div class="line"></div><div class="line">	</div><div class="line">	 @MyRequestMapping(&quot;/doTest&quot;)</div><div class="line">    public void test1(HttpServletRequest request, HttpServletResponse response,</div><div class="line">    		@MyRequestParam(&quot;param&quot;) String param)&#123;</div><div class="line"> 		System.out.println(param);</div><div class="line">	    try &#123;</div><div class="line">            response.getWriter().write( &quot;doTest method success! param:&quot;+param);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	 </div><div class="line">	 </div><div class="line">	 @MyRequestMapping(&quot;/doTest2&quot;)</div><div class="line">    public void test2(HttpServletRequest request, HttpServletResponse response)&#123;</div><div class="line">        try &#123;</div><div class="line">            response.getWriter().println(&quot;doTest2 method success!&quot;);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:8080/liughMVC/test/doTest?param=liugh如下：" target="_blank" rel="external">http://localhost:8080/liughMVC/test/doTest?param=liugh如下：</a></p>
<p><img src="/images/springMVC-04.jpg" alt="test" title="springMVC-04"></p>
<p>访问一个不存在的试试：<br><img src="/images/springMVC-05.jpg" alt="test" title="springMVC-05"></p>
<p>到这里我们就大功告成了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring框架对于Java后端程序员来说再熟悉不过了，以前只知道它用的反射实现的，但了解之后才知道有很多巧妙的设计在里面。如果不看Spring的源码，你将会失去一次和大师学习的机会：它的代码规范，设计思想很值得学习。我们程序员大部分人都是野路子，不懂什么叫代码规范。写了一
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福机器学习课程|第一周(1)认识机器学习</title>
    <link href="http://yoursite.com/2018/02/22/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B-%E7%AC%AC%E4%B8%80%E5%91%A8-1-%E8%AE%A4%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/02/22/斯坦福机器学习课程-第一周-1-认识机器学习/</id>
    <published>2018-02-22T11:08:52.000Z</published>
    <updated>2018-02-22T03:47:46.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生活中机器学习的影子"><a href="#生活中机器学习的影子" class="headerlink" title="生活中机器学习的影子"></a>生活中机器学习的影子</h3><p>在生活中，每天你都可能在不知不觉中使用了各种各样的机器学习算法。比如，当你每一次使用像诸如谷歌 (Google)或必应 (Bing) 的搜索引擎时，它们运作得如此之好的原因之一便是，由Google或微软实现的一种学习算法可以“学会”如何对网页进行排名；每当你使用脸书 (Facebook)或苹果 (Apple) 的照片处理应用时，它们都能自动识别出你朋友的照片，这也是机器学习的一种；每当你阅读电子邮件时，你的垃圾邮件过滤器帮你免受大量垃圾邮件的困扰，这也是通过一种学习算法实现的。还有一个让我兴奋的理由，是一个关于人工智能的梦想：有朝一日，我们能创造出像你我一样聪明的机器，尽管我们离这个目标仍有很长的距离，但许多的人工智能专家相信，实现这一目标最好的途径是通过学习算法，来模拟人类大脑的学习方式。</p>
<p>话说，为什么机器学习在当今如此流行呢？ 机器学习发源于人工智能领域 我们希望能够创造出具有智慧的机器。我们通过编程来让机器完成一些基础的工作，比如如何找到从A到B的最短路径，但在大多数情况下，我们并不知道如何显式地编写人工智能程序，来做一些更有趣的任务。比如网页搜索，标记照片和拦截垃圾邮件等。人们意识到唯一能够达成这些目标的方法，就是让机器自己学会如何去做。因而，机器学习已经发展成为计算机的一项新能力，并且与工业界和基础科学界有着紧密的联系。</p>
<p>身处机器学习领域。我常常会在短短一周中与形形色色的人打交道 如直升机飞行员、生物学家、还有许多计算机系统专家。比如我在斯坦福的同事们，同时平均每周我还会数次收到来自硅谷的业界人士的email，咨询我是否有兴趣将机器学习算法应用到他们所遇到的实际问题中，以上的例子都彰显了机器学习所能处理的问题范围之广。在硅谷，机器学习引导着大量的课题。如自主机器人、计算生物学等。机器学习的实例还有很多，比如数据库挖掘。机器学习变得如此流行的原因之一，便是网络和自动化算法的爆炸性增长，这意味着我们掌握了比以往多得多的数据集。举例来说，当今有数不胜数的硅谷企业，在收集有关网络点击的数据 (Clickstream Data) 并试图在这些数据上运用机器学习的算法来更好的理解和服务用户，这在硅谷已经成为了一项巨大的产业。随着电子自动化的发展，我们现在拥有了电子医疗记录，如果我们能够将这些记录转变为医学知识，那我们就能对各种疾病了解的更深入，同时，计算生物学也在电子自动化的辅助下快速发展。生物学家收集了大量有关基因序列以及DNA序列的数据，通过对其应用机器学习的算法来帮助我们跟深入地理解人类基因组，及其对我们人类的意义，几乎工程界的所有领域，都在使用机器学习算法来分析日益增长的海量数据集。有些机器应用我们并不能够通过手工编程来实现，比如说，我个人对自动直升机有着许多年的研究，想要写出一个能让直升机自主飞行的程序几乎是不可能的任务。唯一可行的解决方案就是让一台计算机能够自主地学会如何让直升机飞行。再比如手写识别，如今将大量的邮件，按地址分类寄送到全美甚至全球的代价大大降低，其中重要的理由之一便是每当你写下这样一封信时 一个机器学习的算法已经学会如何读懂你的笔迹并自动地将你的信件发往它的目的地.所以邮寄跨越上万里的信件的费用也很低。你也许曾经接触过自然语言处理和计算机视觉，事实上，这些领域都是试图通过人工智能来理解人类的语言和图像，如今大多数的自然语言处理和计算机视觉都是对机器学习的一种应用。</p>
<p><strong>机器学习算法也在用户自定制化程序(self-customizing program)中有着广泛的应用</strong>，每当你使用亚马逊、Netflix或iTunes Genius的服务时，都会收到它们为你量身推荐的电影或产品。这就是通过学习算法来实现的。可以相信，这些应用都有着上千万的用户，而针对这些海量的用户编写千万个不同的程序显然是不可能的。唯一有效的解决方案就是开发出能够自我学习，定制出符合你喜好的并据此进行推荐的软件，最后，机器学习算法已经被应用于探究人类的学习方式，并试图理解人类的大脑。我们也将会了解到研究者是如何运用机器学习的工具，来一步步实现人工智能的梦想。</p>
<h3 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h3><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p>来个例子：</p>
<p>假设你想预测房价（无比需要啊！)，之前，某学生已经从某地收集了数据集（不是中国的，囧） 其中一个数据集是这样的。</p>
<p><img src="/images/机器学习-监督学习-01.png" alt="机器学习-监督学习-01" title="机器学习-监督学习-01"></p>
<p>这是横坐标，即不同房子的面积，单位平方脚（^-^） 纵轴上是房价，单位 千美元。 根据给定数据，假设你朋友有栋房子，750平尺（70平米） 想知道这房子能卖多少，好卖掉。 那么，学习算法怎么帮你呢？学习算法可以： 绘出一条直线，让直线尽可能匹配到所有数据。</p>
<p><img src="/images/机器学习-监督学习-02.png" alt="机器学习-监督学习-02" title="机器学习-监督学习-02"></p>
<p>于此，看上去，那个房子应该、可能、也许、大概 卖到15万美元（一平米两千刀！）。但这不是唯一的学习算法。可能还有更好的。比如不用直线了，可能平方函数会更好，即二次多项式更符合数据集。如果你这样做，预测结果就应该是20万刀（一平三千刀，涨价好快）。</p>
<p><img src="/images/机器学习-监督学习-03.png" alt="机器学习-监督学习-03" title="机器学习-监督学习-03"></p>
<p>对于应该选择直线还是曲线，不是我们现在关心的问题。我们需要知道的是这是一个监督学习得例子。术语监督学习，意指给出一个算法，需要部分数据集已经有正确答案。比如给定房价数据集， 对于里面每个数据，算法都知道对应的正确房价，即这房子实际卖出的价格。算法的结果就是算出更多的正确价格，比如那个新房子，你朋友想卖的那个。</p>
<p>用更术语的方式来定义，监督学习又叫回归问题，（应该是回归属于监督中的一种）意指要预测一个连续值的输出，比如房价。虽然从技术上，一般把房价记到美分单位。所以实际还是个离散值，但通常把它看作实际数字，是一个标量值，一个连续值的数，而术语回归，意味着要预测这类连续值属性的种类。</p>
<h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><p>在监督学习中，我们用到的例子中的数据集，每个样本，都已经被标明为正样本或者负样本，即良性或恶性肿瘤。</p>
<p>因此，对于监督学习中的每一个样本，我们已经被清楚地告知了什么是所谓的正确答案，即它们是良性还是恶性。在无监督学习中，我们用的数据会和监督学习里的看起来有些不一样。在无监督学习中，没有属性或标签这一概念，也就是说所有的数据都是一样的，没有区别。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;生活中机器学习的影子&quot;&gt;&lt;a href=&quot;#生活中机器学习的影子&quot; class=&quot;headerlink&quot; title=&quot;生活中机器学习的影子&quot;&gt;&lt;/a&gt;生活中机器学习的影子&lt;/h3&gt;&lt;p&gt;在生活中，每天你都可能在不知不觉中使用了各种各样的机器学习算法。比如，当你每
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/machine/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>运维|安装Octave</title>
    <link href="http://yoursite.com/2018/02/22/%E8%BF%90%E7%BB%B4-%E5%AE%89%E8%A3%85Octave/"/>
    <id>http://yoursite.com/2018/02/22/运维-安装Octave/</id>
    <published>2018-02-22T10:42:45.000Z</published>
    <updated>2018-02-22T03:47:05.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What-is-Octave"><a href="#What-is-Octave" class="headerlink" title="What is Octave"></a>What is Octave</h3><p>Octave是一个旨在提供与Matlab语法兼容的开放源代码科学计算及数值分析的工具。Octave是在GNU协议下被开放的，这意味着它一直是可以免费下载的。</p>
<h3 id="在Windows下安装Octave"><a href="#在Windows下安装Octave" class="headerlink" title="在Windows下安装Octave"></a>在Windows下安装Octave</h3><p>使用这个链接来在Windows安装Octave:</p>
<blockquote>
<p><a href="http://wiki.octave.org/Octave_for_Microsoft_Windows" target="_blank" rel="external">http://wiki.octave.org/Octave_for_Microsoft_Windows</a></p>
</blockquote>
<h3 id="在GNU-Linux上安装Octave"><a href="#在GNU-Linux上安装Octave" class="headerlink" title="在GNU/Linux上安装Octave"></a>在GNU/Linux上安装Octave</h3><ul>
<li>在Ubuntu上，你可以使用：<ul>
<li>sudo apt-get update &amp;&amp; sudo apt-get install octave</li>
</ul>
</li>
<li>在Fedora上，你可以使用：<ul>
<li>sudo yum install octave-forge</li>
</ul>
</li>
<li>在Red Hat Enterprise/CentOS上，你可以使用：<ul>
<li>Method One:<ul>
<li><blockquote>
<p>yum install epel-release<br>  yum install octave</p>
</blockquote>
</li>
</ul>
</li>
<li>Method Two:<ul>
<li><blockquote>
<p>wget <a href="http://url/to/latest/epel-release-6-7.noarch.rpm" target="_blank" rel="external">http://url/to/latest/epel-release-6-7.noarch.rpm</a><br> yum localinstall epel-release-6-7.noarch.rpm </p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在CentOS上，可以到 <a href="https://fedoraproject.org/wiki/EPEL" target="_blank" rel="external">https://fedoraproject.org/wiki/EPEL</a> 中选择自己需要的Octave版本。</p>
<p>Octave is available for Red Hat Enterprise Linux distributions through the <a href="https://fedoraproject.org/wiki/EPEL" target="_blank" rel="external">EPEL</a> repository. This section applies to CentOS, Scientific Linux, and other Red Hat Enterprise rebuild distributions as well.</p>
<blockquote>
<p>参考 <a href="http://wiki.octave.org/Octave_for_GNU/Linux" target="_blank" rel="external">http://wiki.octave.org/Octave_for_GNU/Linux</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What-is-Octave&quot;&gt;&lt;a href=&quot;#What-is-Octave&quot; class=&quot;headerlink&quot; title=&quot;What is Octave&quot;&gt;&lt;/a&gt;What is Octave&lt;/h3&gt;&lt;p&gt;Octave是一个旨在提供与Matlab语法
    
    </summary>
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Octave" scheme="http://yoursite.com/tags/Octave/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP安全性开发</title>
    <link href="http://yoursite.com/2018/02/21/PHP-PHP%E5%AE%89%E5%85%A8%E6%80%A7%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/02/21/PHP-PHP安全性开发/</id>
    <published>2018-02-21T11:28:02.000Z</published>
    <updated>2018-02-24T11:05:07.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>“php给了开发者极大的灵活性，但是这也为安全问题带来了潜在的隐患，近期需要总结一下以往的问题，在这里借翻译一篇文章同时加上自己开发的一些感触总结一下。”</p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>当开发一个互联网服务的时候，必须时刻牢记==安全观念==，并在开发的代码中体现。PHP脚本语言对安全问题并不关心，特别是对大多数没有经验的开发者来说。每当你讲任何涉及到钱财事务等交易问题时，需要特别注意安全问题的考虑，例如开发一个论坛或者是一个购物车等。</p>
<h3 id="安全保护一般性要点"><a href="#安全保护一般性要点" class="headerlink" title="安全保护一般性要点"></a>安全保护一般性要点</h3><h4 id="不相信表单"><a href="#不相信表单" class="headerlink" title="不相信表单"></a>不相信表单</h4><p>对于一般的Javascript前台验证，由于无法得知用户的行为，例如关闭了浏览器的javascript引擎，这样通过POST恶意数据到服务器。需要在服务器端进行验证，对每个php脚本验证传递到的数据，防止XSS攻击和SQL注入</p>
<h4 id="不相信用户"><a href="#不相信用户" class="headerlink" title="不相信用户"></a>不相信用户</h4><p>要假设你的网站接收的每一条数据都是存在恶意代码的，存在隐藏的威胁，要对每一条数据都进行清理</p>
<h4 id="服务器方面"><a href="#服务器方面" class="headerlink" title="服务器方面"></a>服务器方面</h4><h5 id="打开php的安全模式"><a href="#打开php的安全模式" class="headerlink" title="打开php的安全模式"></a>打开php的安全模式</h5><p>php的安全模式是个非常重要的内嵌的安全机制，能够控制一些php中的函数，比如system()，同时把很多文件操作函数进行了权限控制，也不允许对某些关键文件的文件，比如/etc/passwd，但是默认的php.ini是没有打开安全模式的，我们把它打开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode = on</div></pre></td></tr></table></figure></p>
<h5 id="用户组安全"><a href="#用户组安全" class="headerlink" title="用户组安全"></a>用户组安全</h5><p>当safe_mode打开时，safe_mode_gid被关闭，那么php脚本能够对文件进行访问，而且相同组的用户也能够对文件进行访问。</p>
<p>建议设置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode_gid = off</div></pre></td></tr></table></figure></p>
<p>如果不进行设置，可能我们无法对我们服务器网站目录下的文件进行操作了，比如我们需要对文件进行操作的时候。</p>
<p>安全模式下执行程序主目录如果安全模式打开了，但是却是要执行某些程序的时候，可以指定要执行程序的主目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode_exec_dir = D:/usr/bin</div></pre></td></tr></table></figure></p>
<p>一般情况下是不需要执行什么程序的，所以推荐不要执行系统程序目录，可以指向一个目录，然后把需要执行的程序拷贝过去，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode_exec_dir = D:/tmp/cmd</div></pre></td></tr></table></figure></p>
<p>但是，我更推荐不要执行任何程序，那么就可以指向我们网页目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode_exec_dir = D:/usr/www</div></pre></td></tr></table></figure></p>
<p>安全模式下包含文件如果要在安全模式下包含某些公共文件，那么就修改一下选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">safe_mode_include_dir = D:/usr/www/include/</div></pre></td></tr></table></figure></p>
<p>其实一般php脚本中包含文件都是在程序自己已经写好了，这个可以根据具体需要设置。</p>
<h5 id="控制php脚本能访问的目录"><a href="#控制php脚本能访问的目录" class="headerlink" title="控制php脚本能访问的目录"></a>控制php脚本能访问的目录</h5><p>使用open_basedir选项能够控制PHP脚本只能访问指定的目录，这样能够避免PHP脚本访问不应该访问的文件，一定程度上限制了phpshell的危害，我们一般可以设置为只能访问网站目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open_basedir = D:/usr/www</div></pre></td></tr></table></figure></p>
<h5 id="关闭危险函数"><a href="#关闭危险函数" class="headerlink" title="关闭危险函数"></a>关闭危险函数</h5><p>如果打开了安全模式，那么函数禁止是可以不需要的，但是我们为了安全还是考虑进去。比如，<br>我们觉得不希望执行包括system()等在那的能够执行命令的php函数，或者能够查看php信息的<br>phpinfo()等函数，那么我们就可以禁止它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disable_functions = system,passthru,exec,shell_exec,popen,phpinfo</div></pre></td></tr></table></figure></p>
<p>如果你要禁止任何文件和目录的操作，那么可以关闭很多文件操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disable_functions = chdir,chroot,dir,getcwd,opendir,readdir,scandir,fopen,unlink,delete,copy,mkdir, rmdir,rename,file,file_get_contents,fputs,fwrite,chgrp,chmod,chown</div></pre></td></tr></table></figure></p>
<p>以上只是列了部分不叫常用的文件处理函数，你也可以把上面执行命令函数和这个函数结合，就能够抵制大部分的phpshell了。</p>
<h5 id="关闭PHP版本信息"><a href="#关闭PHP版本信息" class="headerlink" title="关闭PHP版本信息"></a>关闭PHP版本信息</h5><p>关闭PHP版本信息在http头中的泄漏我们为了防止黑客获取服务器中php版本的信息，可以关闭该信息斜路在http头中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expose_php = Off</div></pre></td></tr></table></figure></p>
<p>比如黑客在 telnet www.12345.com 80 的时候，那么将无法看到PHP的信息。</p>
<h5 id="关闭注册全局变量"><a href="#关闭注册全局变量" class="headerlink" title="关闭注册全局变量"></a>关闭注册全局变量</h5><p>在PHP中提交的变量，包括使用POST或者GET提交的变量，都将自动注册为全局变量，能够直接访问，这是对服务器非常不安全的，所以我们不能让它注册为全局变量，就把注册全局变量选项关闭：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">register_globals = Off</div></pre></td></tr></table></figure></p>
<p>当然，如果这样设置了，那么获取对应变量的时候就要采用合理方式，比如获取GET提交的变量var，那么就要用$_GET[‘var’]来进行获取，这个php程序员要注意。</p>
<h5 id="打开magic-quotes-gpc来防止SQL注入"><a href="#打开magic-quotes-gpc来防止SQL注入" class="headerlink" title="打开magic_quotes_gpc来防止SQL注入"></a>打开magic_quotes_gpc来防止SQL注入</h5><p>SQL注入是非常危险的问题，小则网站后台被入侵，重则整个服务器沦陷，所以一定要小心。php.ini中有一个设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">magic_quotes_gpc = Off</div></pre></td></tr></table></figure></p>
<p>这个默认是关闭的，如果它打开后将自动把用户提交对sql的查询进行转换，比如把 ‘ 转为 &#39;等，这对防止sql注射有重大作用。所以我们推荐设置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">magic_quotes_gpc = On</div></pre></td></tr></table></figure></p>
<h5 id="错误信息控制"><a href="#错误信息控制" class="headerlink" title="错误信息控制"></a>错误信息控制</h5><p>一般php在没有连接到数据库或者其他情况下会有提示错误，一般错误信息中会包含php脚本当前的路径信息或者查询的SQL语句等信息，这类信息提供给黑客后，是不安全的，所以一般服务器建议禁止错误提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display_errors = Off</div></pre></td></tr></table></figure></p>
<p>如果你却是是要显示错误信息，一定要设置显示错误的级别，比如只显示警告以上的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error_reporting = E_WARNING &amp; E_ERROR</div></pre></td></tr></table></figure></p>
<p>当然，我还是建议关闭错误提示。</p>
<p><strong>同时，错误日志建议在关闭display_errors后能够把错误信息记录下来，便于查找服务器运行的原因</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log_errors = On</div></pre></td></tr></table></figure></p>
<p>同时也要设置错误日志存放的目录，建议根apache的日志存在一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error_log = D:/usr/local/apache2/logs/php_error.log</div></pre></td></tr></table></figure></p>
<p>注意：日志文件必须允许apache用户的和组具有写的权限。</p>
<h4 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h4><p>对于操作数据库的SQL语句，需要特别注意安全性，因为用户可能输入特定语句使得原有的SQL语句改变了功能。类似下面的例子：</p>
<blockquote>
<p>$sql = “select * from pinfo where product = ‘$product’”;</p>
</blockquote>
<p>此时如果用户输入的$product参数为：</p>
<blockquote>
<p>39’; DROP pinfo; SELECT ‘FOO</p>
</blockquote>
<p>那么最终SQL语句就变成了如下的样子：</p>
<blockquote>
<p>select product from pinfo where product = ‘39’; DROP pinfo; SELECT ‘FOO’</p>
</blockquote>
<p>这样就会变成三条SQL语句，会造成pinfo表被删除，这样会造成严重的后果。</p>
<p>这个问题可以简单的使用PHP的内置函数解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$sql = &apos;Select * from pinfo where product = &apos;&quot;&apos;</div><div class="line">mysql_real_escape_string($product) . &apos;&quot;&apos;;</div></pre></td></tr></table></figure></p>
<h5 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h5><h6 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h6><p>主要就是一些数据没有经过严格的验证，然后直接拼接 SQL 去查询。导致漏洞产生，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$id  = $_GET[&apos;id&apos;];</div><div class="line">$sql = &quot;SELECT name FROM users WHERE id = $id&quot;;</div></pre></td></tr></table></figure></p>
<p>因为没有对 $_GET[‘id’] 做数据类型验证，注入者可提交任何类型的数据，比如 “ and 1= 1 or “ 等不安全的数据。如果按照下面方式写，就安全一些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$id  = intval($_GET[&apos;id&apos;]);</div><div class="line">$sql = &quot;SELECT name FROM users WHERE id = $id&quot;;</div></pre></td></tr></table></figure></p>
<p>把 id 转换成 int 类型，就可以去掉不安全的东西。</p>
<h6 id="验证数据"><a href="#验证数据" class="headerlink" title="验证数据"></a>验证数据</h6><p>防止注入的第一步就是验证数据，可以根据相应类型进行严格的验证。比如 int 类型直接同过 intval 进行转换就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$id =intval( $_GET[&apos;id&apos;]);</div></pre></td></tr></table></figure></p>
<p>字符处理起来比较复杂些，首先通过 sprintf 函数格式话输出，确保它是一个字符串。然后通过一些安全函数去掉一些不合法的字符，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$str = addslashes(sprintf(&quot;%s&quot;,$str));</div></pre></td></tr></table></figure></p>
<p>也可以用 mysqli_real_escape_string　函数替代addslashes这样处理以后会比较安全。当然还可以进一步去判断字符串长度，去防止「缓冲区溢出攻击」比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$str = addslashes(sprintf(&quot;%s&quot;,$str));　</div><div class="line">$str = substr($str,0,40); //最大长度为40</div></pre></td></tr></table></figure></p>
<h6 id="参数化绑定"><a href="#参数化绑定" class="headerlink" title="参数化绑定"></a>参数化绑定</h6><p>参数化绑定，防止 SQL 注入的又一道屏障。php MySQLi 和 PDO 均提供这样的功能。比如 MySQLi 可以这样去查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$mysqli = new mysqli(&apos;localhost&apos;, &apos;my_user&apos;, &apos;my_password&apos;, &apos;world&apos;);</div><div class="line">$stmt = $mysqli-&gt;prepare(&quot;INSERT INTO my_table VALUES (?, ?, ?, ?)&quot;);</div><div class="line">$code = &apos;DEU&apos;;</div><div class="line">$language = &apos;Bavarian&apos;;</div><div class="line">$official = &quot;F&quot;;</div><div class="line">$percent = 11.2;</div><div class="line">$stmt-&gt;bind_param(&apos;sssd&apos;, $code, $language, $official, $percent);</div></pre></td></tr></table></figure>
<p>PDO 的更是方便，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Execute a prepared statement by passing an array of values */</div><div class="line">$sql = &apos;SELECT name, colour, calories  </div><div class="line">FROM fruit</div><div class="line">WHERE calories &lt; :calories AND colour = :colour&apos;; $sth = $dbh-&gt;prepare($sql, array(PDO::ATTR_CURSOR =&gt; PDO::CURSOR_FWDONLY));</div><div class="line">$sth-&gt;execute(array(&apos;:calories&apos; =&gt; 150, &apos;:colour&apos; =&gt; &apos;red&apos;));</div><div class="line">$red = $sth-&gt;fetchAll();</div><div class="line">$sth-&gt;execute(array(&apos;:calories&apos; =&gt; 175, &apos;:colour&apos; =&gt; &apos;yellow&apos;));</div><div class="line">$yellow = $sth-&gt;fetchAll();</div></pre></td></tr></table></figure></p>
<p>我们多数使用 php 的框架进行编程，所以最好不要自己拼写 SQL，按照框架给定参数绑定进行查询。遇到较为复杂的 SQL 语句，一定要自己拼写的时候，一定要注意严格的判断。没有用 PDO 或者 MySQLi 也可以自己写个 prepared，比如 wordprss db 查询语句，可以看出也是经过严格的类型验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function prepare( $query, $args ) &#123;</div><div class="line">    if ( is_null( $query ) )</div><div class="line">         return;</div><div class="line">    // This is not meant to be foolproof -- </div><div class="line">           but it will catch obviously incorrect usage.</div><div class="line">    if ( strpos( $query, &apos;%&apos; ) === false ) &#123;</div><div class="line">         _doing_it_wrong( &apos;wpdb::prepare&apos; , </div><div class="line">         sprintf ( __( &apos;The query argument of %s</div><div class="line">                 must have a placeholder.&apos; ), &apos;wpdb::prepare()&apos; ), &apos;3.9&apos; );</div><div class="line">   &#125;</div><div class="line">    $args = func_get_args();</div><div class="line">    array_shift( $args );</div><div class="line">    // If args were passed as an array (as in vsprintf), move them up</div><div class="line">    if ( isset( $args[ 0] ) &amp;&amp; is_array( $args[0]) )</div><div class="line">         $args = $args [0];</div><div class="line">    $query = str_replace( &quot;&apos;%s&apos;&quot;, &apos;%s&apos; , $query ); </div><div class="line">        // in case someone mistakenly already singlequoted it</div><div class="line">    $query = str_replace( &apos;&quot;%s&quot;&apos;, &apos;%s&apos; , $query ); </div><div class="line">        // doublequote unquoting</div><div class="line">    $query = preg_replace( &apos;|(?&lt;!%)%f|&apos; , &apos;%F&apos; , $query ); </div><div class="line">        // Force floats to be locale unaware</div><div class="line">    $query = preg_replace( &apos;|(?&lt;!%)%s|&apos;, &quot;&apos;%s&apos;&quot; , $query ); </div><div class="line">        // quote the strings, avoiding escaped strings like %%s</div><div class="line">    array_walk( $args, array( $this, &apos;escape_by_ref&apos; ) );</div><div class="line">    return @ vsprintf( $query, $args );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="防止基本的XSS攻击"><a href="#防止基本的XSS攻击" class="headerlink" title="防止基本的XSS攻击"></a>防止基本的XSS攻击</h4><p>XSS攻击不像其他攻击，这种攻击在客户端进行，最基本的XSS工具就是<strong>防止一段javascript脚本在用户待提交的表单页面，将用户提交的数据和cookie偷取过来</strong>。</p>
<p>XSS工具比SQL注入更加难以防护，各大公司网站都被XSS攻击过，虽然这种攻击与php语言无关，但可以使用php来筛选用户数据达到保护用户数据的目的，这里主要使用的是对用户的数据进行过滤，一般过滤掉HTML标签，特别是a标签。下面是一个普通的过滤方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function transform_HTML($string, $length = null) &#123;</div><div class="line">    // Helps prevent XSS attacks</div><div class="line">    // Remove dead space.</div><div class="line">    $string = trim($string);</div><div class="line">    // Prevent potential Unicode codec problems.</div><div class="line">    $string = utf8_decode($string);</div><div class="line">    // HTMLize HTML-specific characters.</div><div class="line">    $string = htmlentities($string, ENT_NOQUOTES);</div><div class="line">    $string = str_replace(&quot;#&quot;, &quot;#&quot;, $string);</div><div class="line">    $string = str_replace(&quot;%&quot;, &quot;%&quot;, $string);</div><div class="line">    $length = intval($length);</div><div class="line">    if ($length &gt; 0) &#123;</div><div class="line">        $string = substr($string, 0, $length);</div><div class="line">    &#125;</div><div class="line">    return $string;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数将HTML的特殊字符转换为了HTML实体，浏览器在渲染这段文本的时候以纯文本形式显示。如bold会被显示为：</p>
<strong>BoldText</strong>

<p>上述函数的核心就是==htmlentities函数==，这个函数将html特殊标签转换为html实体字符，这样可以过滤大部分的XSS攻击。</p>
<p>但是对于有经验的XSS攻击者，有更加巧妙的办法进行攻击：将他们的恶意代码使用十六进制或者utf-8编码，而不是普通的ASCII文本，例如可以使用下面的方式进行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;http://host/a.php?variable=%22%3e %3c%53%43%52%49%50%54%3e%44%6f%73%6f%6d%65%74%68%69%6e%67%6d%61%6c%69%63%69%6f%75%73%3c%2f%53%43%52%49%50%54%3e&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>这样浏览器渲染的结果其实是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;http://host/a.php?variable=&quot;&gt;                   &lt;SCRIPT&gt;Dosomethingmalicious&lt;/SCRIPT&gt;</div><div class="line">&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>这样就达到了攻击的目的。为了防止这种情况，需要在transform_HTML函数的基础上再将#和%转换为他们对应的实体符号，同时加上了$length参数来限制提交的数据的最大长度。</p>
<h4 id="使用SafeHTML防止XSS攻击"><a href="#使用SafeHTML防止XSS攻击" class="headerlink" title="使用SafeHTML防止XSS攻击"></a>使用SafeHTML防止XSS攻击</h4><p>上述关于XSS攻击的防护非常简单，但是不包含用户的所有标记，同时有上百种绕过过滤函数提交javascript代码的方法，也没有办法能完全阻止这个情况。</p>
<p>目前，没有一个单一的脚本能保证不被攻击突破，但是总有相对来说防护程度更好的。一共有两个安全防护的方式：白名单和黑名单。其中白名单更加简单和有效。</p>
<p>一种白名单解决方案就是SafeHTML，它足够智能能够识别有效的HTML，然后就可以去除任何危险的标签。这个需要基于HTMLSax包来进行解析。</p>
<blockquote>
<p>安装使用SafeHTML的方法：<br>1、前往<a href="http://pixel-apes.com/safehtml/?page=safehtml" target="_blank" rel="external">http://pixel-apes.com/safehtml/?page=safehtml</a> 下载最新的SafeHTML<br>2、将文件放入服务器的classes 目录，这个目录包含所有的SafeHTML和HTMLSax库<br>3、在自己的脚本中包含SafeHTML类文件<br>4、建立一个SafeHTML对象<br>5、使用parse方法进行过滤</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    /* If you&apos;re storing the HTMLSax3.php in the /classes directory, along</div><div class="line">    with the safehtml.php script, define XML_HTMLSAX3 as a null string. */</div><div class="line">    define(XML_HTMLSAX3, &apos;&apos;);</div><div class="line">    // Include the class file.</div><div class="line">    require_once(&apos;classes/safehtml.php&apos;);</div><div class="line">    // Define some sample bad code.</div><div class="line">    $data = &quot;This data would raise an alert &lt;script&gt;alert(&apos;XSS Attack&apos;)&lt;/script&gt;&quot;;</div><div class="line">    // Create a safehtml object.</div><div class="line">    $safehtml = new safehtml();</div><div class="line">    // Parse and sanitize the data.</div><div class="line">    $safe_data = $safehtml-&gt;parse($data);</div><div class="line">    // Display result.</div><div class="line">    echo &apos;The sanitized data is &lt;br /&gt;&apos; . $safe_data;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>SafeHTML并不能完全防止XSS攻击，只是一个相对复杂的脚本来检验的方式。</p>
<p>使用单向HASH加密方式来保护数据</p>
<p>单向hash加密保证对每个用户的密码都是唯一的，而且不能被破译的，只有最终用户知道密码，系统也是不知道原始密码的。这样的一个好处是在系统被攻击后攻击者也无法知道原始密码数据。</p>
<p>加密和Hash是不同的两个过程。与加密不同，Hash是无法被解密的，是单向的；同时两个不同的字符串可能会得到同一个hash值，并不能保证hash值的唯一性。</p>
<p>MD5函数处理过的hash值基本不能被破解，但是总是有可能性的，而且网上也有MD5的hash字典。</p>
<h4 id="使用mcrypt加密数据"><a href="#使用mcrypt加密数据" class="headerlink" title="使用mcrypt加密数据"></a>使用mcrypt加密数据</h4><p>MD5 hash函数可以在可读的表单中显示数据，但是对于存储用户的信用卡信息的时候，需要进行加密处理后存储，并且需要之后进行解密。</p>
<p>最好的方法是使用mcrypt模块，这个模块包含了超过30中加密方式来保证只有加密者才能解密数据。</p>
<blockquote>
<p>mcrypt函数需要以下信息：<br>1、待加密数据<br>2、用来加密和解密数据的key<br>3、用户选择的加密数据的特定算法（cipher：如 MCRYPT_TWOFISH192,MCRYPT_SERPENT_256， MCRYPT_RC2, MCRYPT_DES, and MCRYPT_LOKI97）<br>4、用来加密的模式<br>5、加密的种子，用来起始加密过程的数据，是一个额外的二进制数据用来初始化加密算法<br>6、加密key和种子的长度，使用mcrypt_get_key_size函数和mcrypt_get_block_size函数可以获取</p>
</blockquote>
<p>如果数据和key都被盗取，那么攻击者可以遍历ciphers寻找开行的方式即可，因此我们需要将加密的key进行MD5一次后保证安全性。同时由于mcrypt函数返回的加密数据是一个二进制数据，这样保存到数据库字段中会引起其他错误，使用了base64encode将这些数据转换为了十六进制数方便保存。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>安全性很重要，也可以看出一个人基本功，项目漏洞百出，扩展性和可维护性再好也没有用。平时多留意，树立安全意识，养成一种习惯，一些基本的安全当然也不会占用用 coding 的时间。养成这个习惯，即便在项目急，时间短的情况一下，依然可以做的质量很高。不要等到自己以后负责的东西，数据库都被拿走了，造成损失才重视。共勉！</p>
<p>虽然国内很多PHP程序员仍在依靠addslashes防止SQL注入，还是建议大家加强中文防止SQL注入的检查。addslashes的问题在于黑客可以用0xbf27来代替单引号，而addslashes只是将0xbf27修改为0xbf5c27，成为一个有效的多字节字符，其中的0xbf5c仍会被看作是单引号，所以addslashes无法成功拦截。</p>
<p>当然addslashes也不是毫无用处，它是用于单字节字符串的处理，多字节字符还是用mysql_real_escape_string吧。</p>
<blockquote>
<p>引用 <a href="https://www.daijiale.cn/back-end-dev/【php】php安全性开发.html" target="_blank" rel="external">https://www.daijiale.cn/back-end-dev/【php】php安全性开发.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;“php给了开发者极大的灵活性，但是这也为安全问题带来了潜在的隐患，近期需要总结一下以往的问题，在这里借翻译一篇文
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>展望|2018</title>
    <link href="http://yoursite.com/2018/02/20/%E5%B1%95%E6%9C%9B-2018/"/>
    <id>http://yoursite.com/2018/02/20/展望-2018/</id>
    <published>2018-02-19T23:18:19.000Z</published>
    <updated>2018-02-19T15:18:19.513Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>爬虫|解读http的秘密&lt;进阶篇&gt;</title>
    <link href="http://yoursite.com/2018/02/12/%E7%88%AC%E8%99%AB-%E8%A7%A3%E8%AF%BBhttp%E7%9A%84%E7%A7%98%E5%AF%86-%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>http://yoursite.com/2018/02/12/爬虫-解读http的秘密-进阶篇/</id>
    <published>2018-02-12T15:47:52.000Z</published>
    <updated>2018-02-12T08:20:06.118Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们介绍了爬虫中HTTP的基础内容，相信看过的朋友们应该对HTTP已经有个初步的认识了。本篇博主将分享一些HTTP的高级内容，以及在爬虫中的应用，让大家更深入理解。这些内容包括：</p>
<ul>
<li>Cookie解读</li>
<li>Session解读</li>
<li>HTTPs解读</li>
</ul>
<h3 id="Cookie解读"><a href="#Cookie解读" class="headerlink" title="Cookie解读"></a>Cookie解读</h3><h4 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h4><p>==Cookie==原意是”小甜点”的意思，但是在互联网上被用作储存在用户本地终端上的数据。</p>
<p>百度百科是这么解释的：</p>
<blockquote>
<p>Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session<br>跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于 RFC2109 和 2965 中的都已废弃，最新取代的规范是<br>RFC6265。（可以叫做浏览器缓存）</p>
</blockquote>
<h4 id="为什么要使用Cookie？"><a href="#为什么要使用Cookie？" class="headerlink" title="为什么要使用Cookie？"></a>为什么要使用Cookie？</h4><p>首先，需要明确一个很重要的概念：HTTP是一个无状态的协议。</p>
<p>什么意思呢？举一个简单的例子来理解一下。</p>
<h5 id="lt-应用一-gt"><a href="#lt-应用一-gt" class="headerlink" title="&lt;应用一&gt;"></a>&lt;应用一&gt;</h5><p>比如，我们网上购物的时候，浏览了几个网页，选了几样商品放入了购物车。但是由于HTTP的无状态特点，当我们结账的时候服务器并不知道操作的用户是谁，即无法记录上下文的信息，这严重的妨碍了web应用程序交互式的操作。</p>
<p>为了解决HTTP的无状态的问题，Cookie就应运而生了。Cookie绕开了HTTP的无状态性，提供了一种”额外手段”维护了用户跟服务器会话中的状态。<strong>说白了，Cookie就是一小段数据储存在本地，记录并标识了用户身份，以便服务器辨认。</strong>这其实相当于让一个失忆的人从此有了记忆。因此，无论当我们购买几次商品，退货，结账等，服务器都能通过这个标识来判断出你是谁。</p>
<p>还有一个常见的例子，就是==登录==。</p>
<h4 id="lt-应用二-gt"><a href="#lt-应用二-gt" class="headerlink" title="&lt;应用二&gt;"></a>&lt;应用二&gt;</h4><p>当我们登录某个网站输入用户名和密码后，一般浏览器会提示是”是否保存密码”。我们通常会勾选保存，那么这样带来的好处就是在以后的一段时间我们访问该网站都会自动登录而不必每次都去敲用户名和密码了。</p>
<p>也正是这个原因，简化了爬虫中模拟登录的问题，每次登录只要post一个Cookie信息就可以了，而避免了每次都post登录信息。当然，这只针对一部分网站而言，一些复杂的网站会定期的变换一些算法，使得Cookie频繁的失效，这时候就需要post登录信息了或者模拟找到算法的规律。</p>
<p>关于==爬虫模拟登录==的详细内容后续后专门开一篇和大家分享。</p>
<h3 id="Cookie的分类"><a href="#Cookie的分类" class="headerlink" title="Cookie的分类"></a>Cookie的分类</h3><p>Cookie有两种类型：持久化Cookie，非持久化Cookie。</p>
<ul>
<li>持久化Cookie：表示Cookie会保存到本地磁盘上，关闭浏览器再次打开，Cookie依然有效直到设置的expire时间。</li>
<li>非持久化Cookie：表示Cookie会在本地内存中，生命周期会受浏览器开关状态影响，只要浏览器关闭，Cookie则失效。</li>
</ul>
<h3 id="HTTP-Cookie的交互过程"><a href="#HTTP-Cookie的交互过程" class="headerlink" title="HTTP+Cookie的交互过程"></a>HTTP+Cookie的交互过程</h3><p>下面是HTTP请求中使用Cookie所实现的整个web交互过程。</p>
<p><img src="/images/爬虫-http-07.jpg" alt="爬虫--cookie" title="爬虫-http-07"></p>
<p>博主以一个==访问豆瓣==的实际例子作为上述过程的具体说明和描述。</p>
<h4 id="步骤1的请求头"><a href="#步骤1的请求头" class="headerlink" title="步骤1的请求头"></a>步骤1的请求头</h4><p><img src="/images/爬虫-http-08.jpg" alt="爬虫--cookie" title="爬虫-http-08"></p>
<p>看到请求头里面没有Cookie，只是常规的头域字段信息。</p>
<h4 id="步骤2-gt-3的响应头"><a href="#步骤2-gt-3的响应头" class="headerlink" title="步骤2-&gt;3的响应头"></a>步骤2-&gt;3的响应头</h4><p><img src="/images/爬虫-http-09.jpg" alt="爬虫--cookie" title="爬虫-http-09"></p>
<p>服务器根据==POST请求==（用户名密码等）生成一个Cookie，并通过响应头的==set-Cookie字段==返回此Cookie信息。</p>
<h4 id="步骤5的请求头"><a href="#步骤5的请求头" class="headerlink" title="步骤5的请求头"></a>步骤5的请求头</h4><p><img src="/images/爬虫-http-10.jpg" alt="爬虫--cookie" title="爬虫-http-10"></p>
<p>再一次刷新页面的请求头中就有了获取Cookie信息。</p>
<h4 id="步骤7的响应头"><a href="#步骤7的响应头" class="headerlink" title="步骤7的响应头"></a>步骤7的响应头</h4><p><img src="/images/爬虫-http-11.jpg" alt="爬虫--cookie" title="爬虫-http-11"></p>
<p>第二次的响应头==无set-Cookie==字段信息，因为服务器已经辨别了这个用户刚刚提交的Cookie信息。</p>
<h3 id="5-Cookie的格式和属性"><a href="#5-Cookie的格式和属性" class="headerlink" title="5.Cookie的格式和属性"></a>5.Cookie的格式和属性</h3><p>==格式==</p>
<ul>
<li>客户端发送Cookie（键值对）：Cookie：key1=value1; key2=value2; key3=value3</li>
<li>服务器响应Cookie：Set-Cookie: name=value；expires=date；path=path；domain=domain_name；secure</li>
</ul>
<p>==属性==</p>
<ul>
<li>name：为一个Cookie的名称。</li>
<li>domain：为可以访问此Cookie的域名，该域名可以使多个web服务器共享Cookie。</li>
<li>path：表示Cookie所在目录，“/”表示根目录。</li>
<li>expires/max-age：为Cookie的生命周期。若设置该值，则到此时间Cookie会失效。若没有设置该值，默认与session一起失效。浏览器关闭，Cookie失效。</li>
<li>secure：布尔值，指定Cookie的传输方式，默认是不安全的HTTP连接。</li>
<li>http：Cookie的httponly属性，若此属性为true，则只能在http的请求头中携带Cookie信息。</li>
</ul>
<h3 id="Session解读"><a href="#Session解读" class="headerlink" title="Session解读"></a>Session解读</h3><h4 id="什么是Session？"><a href="#什么是Session？" class="headerlink" title="什么是Session？"></a>什么是Session？</h4><p>百度百科是这么解释的：</p>
<blockquote>
<p>Session: 在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。</p>
</blockquote>
<h4 id="为什么要使用Session？"><a href="#为什么要使用Session？" class="headerlink" title="为什么要使用Session？"></a>为什么要使用Session？</h4><p>同样是因为HTTP是一个无状态协议。Session和Cookie的存在都是为了解决这个问题的。</p>
<p>由于服务器本身并不会维持用户的上下文，因此为了实现会话的跟踪，不得不想出一种办法。<br>==Session正是一种保存上下文的机制==，对于每一个用户来讲，用户所产生的变量值都保存在了服务器端，这样就使得整个会话都衔接的上，而每个用户有自己独一无二的ID，我们叫做==SessionID==。</p>
<h4 id="Session和Cookie有什么联系？"><a href="#Session和Cookie有什么联系？" class="headerlink" title="Session和Cookie有什么联系？"></a>Session和Cookie有什么联系？</h4><p>这个要从SessionID说起。我们上面提到服务器会每个用户创建一个SessionID，那么我们该如何使用它呢?</p>
<h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>这是我们最常用的方式，Cookie相当于一个SessionID的高级应用，是SessionID的载体或者容器。我们说Cookie可以用来识别用户身份，也是因为SessionID的缘故。</p>
<p><strong>因此，可以说Session是服务端的解决方案，实现了web的会话跟踪，而Cookie是客户端的解决方案，实现了跟踪过程的用户识别。</strong></p>
<p>Session是真正解决HTTP无状态的方案，而Cookie只是实现了Session过程中的SessionID方式。</p>
<h5 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h5><p>Cookie的使用给用户带来了极大的方便，以及很好的用户体验。但是Cookie存在着一些安全问题，Cookie储存在本地会很大程度暴露用户信息。因此，用户可以选择禁用Cookie。</p>
<p>那么另一种实现SessionID的方式就是URL重写。URL重写就是把SessionID附加在URL里，可以作为URL路径附加信息或者查询字符串附加在URL后面。</p>
<p><strong>就是说用户所有的请求的URL中都要有==sesssionID==这个东西，否则无法保持会话的持久状态。</strong></p>
<h5 id="表单隐藏字段"><a href="#表单隐藏字段" class="headerlink" title="表单隐藏字段"></a>表单隐藏字段</h5><p>服务器会修改表单，设置一个SessionID的隐藏字段，用户需要将SessionID填写到隐藏字段中提交表单，以让服务器知道用户身份。</p>
<p><strong>隐藏字段也是爬虫中的反爬策略之一</strong>，如果我们爬虫提交的表单没有填写隐藏字段，那么服务器会认为这是一种爬虫行为而禁掉，或者提交的内容不正确也可能造成同样的后果。因此，每次爬取前有必要查看一下是否存在隐藏字段。当然，关于隐藏字段还有更复杂的玩法这里就不详细介绍了。</p>
<h4 id="Session的关闭"><a href="#Session的关闭" class="headerlink" title="Session的关闭"></a>Session的关闭</h4><h5 id="关闭浏览器"><a href="#关闭浏览器" class="headerlink" title="关闭浏览器"></a>关闭浏览器</h5><p>有时候我们可能会误以为关闭了浏览器，Session就消失了。其实，Session并没有消失（session存储在服务器中），如果消失，消失的也是Cookie（如果储存在内存的话）。</p>
<p><strong>Session是储存在服务端的，注意是服务端</strong>。而服务端是不会知道浏览器什么时候关闭了的，但是服务端又不能一直开着Session，那样会损耗服务器资源。因此，为了解决这个问题，服务端一般会设置Session超时，通过检测用户活动状态来判断是否超时。如果超时，那么整个会话Session才真正消失，不然还是会开着直到超时。</p>
<p>如果Cookie是本地储存在磁盘上的，在我们关闭浏览器的很短一段时间内再次打开浏览器，还是会回到刚才那个Session会话。但是如果Cookie储存在内存中，再次打开时浏览器已经忘记了Cookie，那么就无法和刚才的会话连接上了。</p>
<p>结论是：==关闭浏览器并不会使服务端Session对象消失。==</p>
<h5 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h5><p>注销和关闭浏览器有着本质的区别，注销实际上会使Session对象消失。就比如我们在网页上点击注销一样，用户信息就都被清空了。如果需要连接Session，需要重新创建Session。</p>
<p>结论是：==注销会使服务端Session对象消失。==</p>
<h3 id="HTTPs解读"><a href="#HTTPs解读" class="headerlink" title="HTTPs解读"></a>HTTPs解读</h3><h4 id="什么是HTTPs"><a href="#什么是HTTPs" class="headerlink" title="什么是HTTPs?"></a>什么是HTTPs?</h4><blockquote>
<p>HTTPS（全称：Hyper Text Transfer Protocol over Secure SocketLayer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>它是一个URIscheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器NetscapeNavigator中，提供了身份验证与加密通讯方法。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>
</blockquote>
<h4 id="HTTPs与HTTP的区别"><a href="#HTTPs与HTTP的区别" class="headerlink" title="HTTPs与HTTP的区别"></a>HTTPs与HTTP的区别</h4><blockquote>
<p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。<br>HTTPS和HTTP的区别主要为以下四点：</p>
<ul>
<li>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。</li>
<li>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li>
<li>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
</blockquote>
<h4 id="HTTPs对爬虫的影响"><a href="#HTTPs对爬虫的影响" class="headerlink" title="HTTPs对爬虫的影响"></a>HTTPs对爬虫的影响</h4><p>乍一看感觉HTTPs有点像反爬的手段，通过上面的了解，我们发现HTTPs是对服务器端的验证，通过CA证书保证了我们访问的网站是有身份的，而非其他假网站。相反，我们爬虫模拟的是客户端，并不受HTTPs的限制。</p>
<p><strong>因此，HTTPs不影响我们爬虫</strong>。</p>
<p>但是，我们在爬虫的过程仍然也会遇到过类似SSL不通过之类的错误。比如，博主以前用requests访问HTTPs的时候遇到过这样的坑，但最后究其原因是同时打开了fiddler造成的。</p>
<blockquote>
<p>转载 <a href="https://segmentfault.com/a/1190000013074959" target="_blank" rel="external">https://segmentfault.com/a/1190000013074959</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇我们介绍了爬虫中HTTP的基础内容，相信看过的朋友们应该对HTTP已经有个初步的认识了。本篇博主将分享一些HTTP的高级内容，以及在爬虫中的应用，让大家更深入理解。这些内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cookie解读&lt;/li&gt;
&lt;li&gt;Session解读&lt;/li
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫|解读http的秘密&lt;基础篇&gt;</title>
    <link href="http://yoursite.com/2018/02/12/%E7%88%AC%E8%99%AB-%E8%A7%A3%E8%AF%BBhttp%E7%9A%84%E7%A7%98%E5%AF%86-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2018/02/12/爬虫-解读http的秘密-基础篇/</id>
    <published>2018-02-12T14:57:36.000Z</published>
    <updated>2018-02-12T07:44:58.924Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>在学习爬虫的过程中，相信大家对HTTP这个词已经不陌生了，它好像从未离开过我们的视线。被迫所需，我们每次都要使用开发者工具去查看请求头，响应头，以及头中的各个字段，使用别人封装好的模块填入信息，敲几行代码就解决了。面对简单的爬取任务，我们也许根本不用管它是什么，但可能等我们真正遇到问题的时候，却无从下手。</p>
<p>认识并深刻理解HTTP对于爬虫的实现过程是非常有帮助的。为了更好的让大家理解爬虫中的HTTP，博主将分为两篇对HTTP进行讲述，&lt;基础篇&gt; 和 &lt;高阶篇&gt;。本篇为基础篇，将从以下几个部分进行阐述。</p>
<ul>
<li>什么是HTTP</li>
<li>一个完整的HTTP请求过程</li>
<li>HTTP请求报文</li>
</ul>
<h3 id="什么是HTTP？"><a href="#什么是HTTP？" class="headerlink" title="什么是HTTP？"></a>什么是HTTP？</h3><h4 id=""><a href="#" class="headerlink" title=""></a><http的介绍></http的介绍></h4><p>引自百度百科的权威回答：</p>
<blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)<br>是互联网上应用最为广泛的一种网络协议。所有WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。<br>1960年美国人TedNelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。TedNelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（InternetEngineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。<br><strong>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传输协议</strong>。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
</blockquote>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a><http的模型></http的模型></h4><p>HTTP采用了浏览器/服务器这种请求/响应模型，浏览器永远是HTTP请求的发起者，服务器为响应者。</p>
<p><img src="/images/爬虫-http-01.jpg" alt="爬虫-http-01" title="爬虫-http-01"></p>
<p>这样在浏览器客户端没有发起请求的情况下，服务器是不能主动推送消息给客户端的。这也可以说是http协议的一个缺点吧。</p>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a><http的定位></http的定位></h4><p>HTTP是一个<strong>应用层协议</strong>，是我们想从服务器端获取信息的最直观的请求。比如，在爬虫中使用的<strong><urllib模块></urllib模块></strong>，<strong><requests模块></requests模块></strong>等都是封装了HTTP协议，作为一个HTTP客户端实现了博文，图片，视频等信息源的下载。</p>
<p>但是HTTP也不是直接就可以用的，它的请求是建立在一些底层协议的基础上完成的。如<strong>TCP/IP</strong>协议栈中，HTTP需要TCP的三次握手连接成功后才能向服务器发起请求。当然，如果是<strong>HTTPS</strong>的话，还需要<strong>TSL</strong>和<strong>SSL</strong>安全层。</p>
<p><img src="/images/爬虫-http-02.jpg" alt="爬虫-http-02" title="爬虫-http-02"></p>
<h3 id="一个完整的HTTP请求过程"><a href="#一个完整的HTTP请求过程" class="headerlink" title="一个完整的HTTP请求过程"></a>一个完整的HTTP请求过程</h3><p>既然==HTTP==协议需要建立在其它底层协议基础上，我们来看看一个完整的HTTP请求是什么样的。</p>
<p>当我们点击一个链接或者输入一个链接的时候，整个HTTP的请求过程就开始了，然后经过以下步骤得到最后的信息，我们这里简单介绍一下前四个步骤，旨在了解HTTP。</p>
<p><img src="/images/爬虫-http-03.jpg" alt="爬虫-http-03" title="爬虫-http-03"></p>
<ul>
<li><strong>域名解析</strong>：首先会搜索各种本地DNS缓存，如果没有就会向DNS服务器（互联网提供商）发起域名解析，以获取IP地址。</li>
<li><strong>建立TCP连接</strong>：当获取IP后，将创建套接字socket连接，也就是TCP的3次握手连接，默认端口号80。</li>
<li><strong>HTTP请求</strong>：一旦TCP连接成功后，浏览器/爬虫就可以向服务器发起HTTP请求报文了，报文内容包含请求行、请求头部、请求主体。</li>
<li><strong>服务器响应</strong>：服务器响应，并返回一个HTTP响应包（如果成功会返回状态码200）和请求的HTML代码。</li>
</ul>
<p>上面的步骤<3>和<4>可以简单的示意如下，更方便大家理解。其中，请求和响应都包含特定格式的信息，具体我们接下来会继续解读。</4></3></p>
<p><img src="/images/爬虫-http-04.jpg" alt="爬虫-http-04" title="爬虫-http-04"></p>
<p>响应HTTP请求会返回响应状态码，根据状态码可以知道返回信息的状态。状态码规定如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">1xx: 信息响应类，表示接收到请求并且继续处理 </div><div class="line">100——必须继续发出请求 </div><div class="line">101——要求服务器根据请求转换HTTP协议版本</div><div class="line">2xx: 处理成功响应类，表示动作被成功接收、理解和接受 </div><div class="line">200——交易成功</div><div class="line">201——提示知道新文件的URL</div><div class="line">202——接受和处理、但处理未完成</div><div class="line">203——返回信息不确定或不完整</div><div class="line">204——请求收到，但返回信息为空</div><div class="line">205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</div><div class="line">206——服务器已经完成了部分用户的GET请求</div><div class="line"></div><div class="line">3xx: 重定向响应类，为了完成指定的动作，必须接受进一步处理</div><div class="line">300——请求的资源可在多处得到</div><div class="line">301——删除请求数据</div><div class="line">302——在其他地址发现了请求数据</div><div class="line">303——建议客户访问其他URL或访问方式</div><div class="line">304——客户端已经执行了GET，但文件未变化</div><div class="line">305——请求的资源必须从服务器指定的地址得到</div><div class="line">306——前一版本HTTP中使用的代码，现行版本中不再使用</div><div class="line">307——申明请求的资源临时性删除</div><div class="line"></div><div class="line">4xx: 客户端错误，客户请求包含语法错误或者是不能正确执行</div><div class="line">400——错误请求，如语法错误</div><div class="line">401——未授权</div><div class="line">402——保留有效ChargeTo头响应</div><div class="line">403——禁止访问</div><div class="line">404——没有发现文件、查询或URl</div><div class="line">405——在Request-Line字段定义的方法不允许</div><div class="line">406——根据发送的Accept，请求资源不可访问</div><div class="line">407——用户必须首先在代理服务器上得到授权</div><div class="line">408——客户端没有在指定的时间内完成请求</div><div class="line">409——对当前资源状态，请求不能完成</div><div class="line">410——服务器不再有此资源且无进一步地址</div><div class="line">411——服务器拒绝用户定义的Content-Length</div><div class="line">412——一个或多个请求头字段在当前请求中错误</div><div class="line">413——请求的资源大于服务器允许的大小</div><div class="line">414——请求的资源URL长于服务器允许的长度</div><div class="line">415——请求资源不支持请求项目格式</div><div class="line">416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</div><div class="line">417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</div><div class="line">5xx: 服务端错误，服务器不能正确执行一个正确的请求</div><div class="line">500——内部服务器错误</div><div class="line">501——未实现</div><div class="line">502——网关错误</div></pre></td></tr></table></figure>
<h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p>相信你已经对HTTP的请求过程有了大致的了解了，下面我们来详细介绍HTTP请求的==报文信息==。<br>报文内容包含==请求行==、==请求头部==、==请求主体==</p>
<p><img src="/images/爬虫-http-05.jpg" alt="爬虫--http-05" title="爬虫-http-05"></p>
<p>下面我们来看一下通过开发者工具请求网址<a href="https://www.baidu.com/截取下来的HTTP请求报文内容，对比一下上面的标准格式。" target="_blank" rel="external">https://www.baidu.com/截取下来的HTTP请求报文内容，对比一下上面的标准格式。</a></p>
<p><img src="/images/爬虫-http-06.jpg" alt="爬虫-http-06" title="爬虫-http-06"></p>
<p>我们发现请求报文的格式与上面基本一致，正式我们想要的。那么，接下来我们将要逐个的介绍以上各个信息</p>
<h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>==GET==是HTTP的请求方式之一，HTTP/1.1协议中共定义了8种方法与服务器交互，有 GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT，其中比较常用的是==GET==和==POST==方法了。</p>
<ul>
<li>HEAD: 从服务器得到除了请求体与GET请求一样的响应</li>
<li>GET：通过URL获取查询资源信息（爬虫特定URL爬取）</li>
<li>POST：提交表单（爬虫中的模拟登录）</li>
<li>PUT：上传文件（浏览器不支持）</li>
<li>DELETE：删除</li>
<li>OPTIONS：返回服务器对特定资源支持的HTTP请求方法</li>
<li>TRACE：返回服务器收到的请求，用于测试或诊断 </li>
<li>CONNECT：预留给管道连接方式的代理服务</li>
</ul>
<p>==GET==请求方法后URL（这里是/）和版本1.1，别忘了空格。</p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>HTTP的头域包括==通用头==、==请求头==、==响应头==和==实体头==四部分。因为在爬虫过程中，我们经常会提交headers请求头信息用于伪装，所以我们这里对请求头着重讲解一下。</p>
<p>请求头是请求报文特有的，它向服务器提交了一些额外的信息，例如通过Accept字段信息，我们客户端可以告诉服务器我们接受一些什么类型的数据。而我们其实可以把这些字段信息就当成==键值对==对待。</p>
<p>下面我们看看这些字段都代表了什么意思？</p>
<h4 id="Accept"><a href="#Accept" class="headerlink" title="==Accept=="></a>==Accept==</h4><p>内容：text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8<br>含义：告诉浏览器我们接受MIME的类型</p>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="==Accept-Encoding=="></a>==Accept-Encoding==</h4><p>内容：gzip, deflate, br<br>含义：如果有这个字段，则代表客户端支持压缩将内容编码，去掉后会支持任意编码。<br>注意：爬虫时一般不要把它加上，博主最开始就是不懂全都复制过来，结果因为这个就是不好使卡住好长时间。</p>
<h4 id="Accept-Lanague"><a href="#Accept-Lanague" class="headerlink" title="==Accept-Lanague=="></a>==Accept-Lanague==</h4><p>内容：zh-CN,zh;q=0.9<br>含义：告诉服务器能够接受的语言，没有则代表任何语言</p>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="==Connection=="></a>==Connection==</h4><p>内容：keep-alive<br>含义：告诉服务器需要持久有效的连接状态（HTTP1.1默认会进行持久连接）</p>
<h4 id="Host"><a href="#Host" class="headerlink" title="==Host=="></a>==Host==</h4><p>内容：www.baidu.com<br>含义：客户端指定自己想访问的web服务器域名/IP地址和端口号</p>
<h4 id="Cache-control"><a href="#Cache-control" class="headerlink" title="==Cache-control=="></a>==Cache-control==</h4><p>内容：max-age=0<br>含义：(引自百度百科)</p>
<blockquote>
<p>Cache-Control<br>是最重要的规则。这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。这些指令指定用于阻止缓存对请求或响应造成不利干扰的行为。这些指令通常覆盖默认缓存算法。缓存指令是单向的，即请求中存在一个指令并不意味着响应中将存在同一个指令。<br>网页的缓存是由HTTP消息头中的“Cache-control”来控制的，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。</p>
</blockquote>
<p>但是HTTP请求和响应的Cache-Control是不完全一样的。<br>常见的请求Cache-Control取值有==no-cache==, ==no-store==, ==max-age==, ==max-stale==, ==min-fresh==, ==only-if-cached==。</p>
<p>响应的Cache-Control取值有==public==, ==private==,==no-cache==, ==no- store==, ==no-transform==, ==must-revalidate==, ==proxy-revalidate==, ==max-age==。</p>
<p>我们这里主要介绍请求时的常见Cache-Control取值。</p>
<h5 id="max-age-lt-0"><a href="#max-age-lt-0" class="headerlink" title="max-age&lt;=0"></a><1>max-age&lt;=0</1></h5><p>本例中使用max-age=0，表示每次请求会访问服务器，通过Last-Modified来判断文件是否被修改，如果被修改，返回状态码200并得到最新文件，否则将返回304状态码并读取缓存文件。</p>
<h5 id="max-age-gt-0"><a href="#max-age-gt-0" class="headerlink" title="max-age&gt;0"></a><2>max-age&gt;0</2></h5><p>表示会直接从浏览器提取缓存。</p>
<h5 id="no-cache"><a href="#no-cache" class="headerlink" title="no-cache"></a><3>no-cache</3></h5><p>表示不会在浏览器缓存进行提取，而是强制的向服务器发出请求，这样可以保证客户端能够收到最权威的回应。</p>
<h5 id="no-store"><a href="#no-store" class="headerlink" title="no-store"></a><4>no-store</4></h5><p>所有内容都不会被缓存到缓存或Internet临时文件中。</p>
<h4 id="Upgrade-Insecure-Requests"><a href="#Upgrade-Insecure-Requests" class="headerlink" title="==Upgrade-Insecure-Requests=="></a>==Upgrade-Insecure-Requests==</h4><p>内容：1<br>含义：表示浏览器/爬虫可以处理HTTPS协议，并能自动升级请求从HTTP到HTTPS。</p>
<h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="==User-Agent=="></a>==User-Agent==</h4><p>内容：Mozilla/5.0 (Windows NT 6.1; WOW64) ..Safari/537.36<br>含义：（这个是爬虫中最常用了）用于伪装成浏览器身份请求网页。它的意思自然就是表示浏览器的身份，说明是用的哪种浏览器进行的操作。</p>
<h4 id="Cookies"><a href="#Cookies" class="headerlink" title="==Cookies=="></a>==Cookies==</h4><p>含义：（这个也是爬虫中很重要的了，通常用于模拟登录）<br>Cookies是用于维持服务端的会话状态，由服务器端写入，然后在后续请求中，供服务器读取使用。</p>
<p><em>以上就是本例中出现的所有字段信息内容。当然，还有其它一些常用字段信息，这里也一起说明一下。</em></p>
<h3 id="其它请求头字段信息"><a href="#其它请求头字段信息" class="headerlink" title="其它请求头字段信息"></a>其它请求头字段信息</h3><h4 id="Referer"><a href="#Referer" class="headerlink" title="==Referer=="></a>==Referer==</h4><p>含义：（这个也是爬虫常用到的 ==防盗链==）<br>客户端通过当前URL代表的页面出发访问我们请求的页面。爬虫中，一般我们只要把它设置成请求的网页链接就好了。</p>
<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="==Accept-Charset=="></a>==Accept-Charset==</h4><p>含义：（这个也是爬虫常用到的）<br>表示浏览器可接受的字符集，可以是utf-8，gbk等</p>
<h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="==If-Modified-Since=="></a>==If-Modified-Since==</h4><p>内容：Thu, 10 Apr 2008 09:14:42 GMT<br>含义：请求的内容在指定日期以后一旦被修改就被返回对象内容，否则返回“Not Modified”</p>
<h4 id="Pragma"><a href="#Pragma" class="headerlink" title="==Pragma=="></a>==Pragma==</h4><blockquote>
<p>Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。</p>
</blockquote>
<h4 id="Range"><a href="#Range" class="headerlink" title="==Range=="></a>==Range==</h4><p>含义：告诉浏览器自己想取对象的哪个部分。例如，Range: bytes=1173546</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;在学习爬虫的过程中，相信大家对HTTP这个词已经不陌生了，它好像从未离开过我们的视线。被迫所需，我们每次都要使用开发者工具去
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>运维|CentOS搭建JavaWeb环境</title>
    <link href="http://yoursite.com/2018/02/11/%E8%BF%90%E7%BB%B4-CentOS%E6%90%AD%E5%BB%BAJavaWeb%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/02/11/运维-CentOS搭建JavaWeb环境/</id>
    <published>2018-02-11T11:59:39.000Z</published>
    <updated>2018-02-12T06:36:15.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置要求"><a href="#配置要求" class="headerlink" title="配置要求"></a>配置要求</h3><p>这里列出的软件版本仅代表写作本文档使用的版本。操作时，请您以实际软件版本为准。</p>
<p>操作系统：CentOS 7.4<br>Tomcat 版本：Tomcat 8.0.49<br>JDK 版本：JDK 1.8.0_141</p>
<h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><p>CentOS 7.4 系统默认开启了防火墙。您可以关闭防火墙，也可以参考官网文档在防火墙里添加规则，放行 80、443 或 8080 端口入方向规则。</p>
<p>关闭防火墙：</p>
<blockquote>
<p>systemctl stop firewalld.service</p>
</blockquote>
<p>关闭防火墙开机自启动功能：</p>
<blockquote>
<p>systemctl disable firewalld.service</p>
</blockquote>
<p>创建一般用户 www，运行 tomcat：</p>
<blockquote>
<p>useradd www</p>
</blockquote>
<p>在安全组中放行 8080 端口。具体操作，请参考 添加安全组规则(如果在阿里云服务器)。</p>
<p>创建网站根目录：</p>
<blockquote>
<p>mkdir -p /data/wwwroot/default</p>
</blockquote>
<p>新建 Tomcat 测试页面：</p>
<blockquote>
<p>echo Tomcat test &gt; /data/wwwroot/default/index.jsp<br>chown -R www.www /data/wwwroot</p>
</blockquote>
<p>下载源代码</p>
<blockquote>
<p>wget <a href="https://mirrors.aliyun.com/apache/tomcat/tomcat-8/v8.0.49/bin/apache-tomcat-8.0.49.tar.gz" target="_blank" rel="external">https://mirrors.aliyun.com/apache/tomcat/tomcat-8/v8.0.49/bin/apache-tomcat-8.0.49.tar.gz</a></p>
</blockquote>
<p>说明：源代码版本会不断升级。您可以在 <strong><a href="https://mirrors.aliyun.com/apache/tomcat/tomcat-8/" target="_blank" rel="external">https://mirrors.aliyun.com/apache/tomcat/tomcat-8/</a></strong> 目录下获取合适的安装包地址。</p>
<blockquote>
<p>wget <a href="http://mirrors.linuxeye.com/jdk/jdk-8u141-linux-x64.tar.gz" target="_blank" rel="external">http://mirrors.linuxeye.com/jdk/jdk-8u141-linux-x64.tar.gz</a></p>
</blockquote>
<p>说明：源代码版本会不断升级。您可以在 <strong><a href="http://mirrors.linuxeye.com/jdk/" target="_blank" rel="external">http://mirrors.linuxeye.com/jdk/</a></strong> 目录下获取合适的安装包地址。</p>
<h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><p>按以下步骤安装 JDK。</p>
<p>1.新建一个目录：</p>
<blockquote>
<p>mkdir /usr/java</p>
</blockquote>
<p>解压 jdk-8u141-linux-x64.tar.gz 到 /usr/java。</p>
<blockquote>
<p>tar xzf jdk-8u141-linux-x64.tar.gz -C /usr/java</p>
</blockquote>
<p>设置环境变量：</p>
<p>编辑 /etc/profile：<strong>vi /etc/profile</strong>。</p>
<p>按 i 键进入编辑模式。</p>
<p>在 /etc/profile 文件中添加以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#set java environment</div><div class="line">export JAVA_HOME=/usr/java/jdk1.8.0_141</div><div class="line">export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib</div><div class="line">export PATH=$JAVA_HOME/bin:$PATH</div></pre></td></tr></table></figure></p>
<p>按 Esc 键退出编辑模式，输入 :wq 保存并关闭文件。</p>
<p>加载环境变量：<strong>source /etc/profile</strong>。</p>
<p>查看 jdk 版本。当出现 jdk 版本信息时，表示 JDK 已经安装成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java -version</div><div class="line">java version &quot;1.8.0_141&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</div></pre></td></tr></table></figure></p>
<h3 id="安装-Tomcat"><a href="#安装-Tomcat" class="headerlink" title="安装 Tomcat"></a>安装 Tomcat</h3><p>按以下步骤安装 Tomcat。</p>
<ol>
<li>依次运行以下命令解压 apache-tomcat-8.5.23.tar.gz，重命名 Tomcat 目录，并设置用户权限。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar xzf apache-tomcat-8.0.49.tar.gz</div><div class="line">mv apache-tomcat-8.0.49 /usr/local/tomcat/</div><div class="line">chown -R www.www /usr/local/tomcat/</div></pre></td></tr></table></figure>
</li>
</ol>
<p>说明：</p>
<p>在 /usr/local/tomcat/ 目录里：</p>
<ul>
<li>bin 目录中存放 Tomcat 的一些脚本文件，包含启动和关闭 Tomcat 服务脚本。</li>
<li>conf：存放 Tomcat 服务器的各种全局配置文件，其中最重要的是 server.xml 和 web.xml。</li>
<li>webapps：Tomcat 的主要 Web 发布目录，默认情况下把 Web 应用文件放于此目录。</li>
<li>logs：存放 Tomcat 执行时的日志文件。</li>
</ul>
<p>2.配置 server.xml 文件：</p>
<p>切换到 /usr/local/tomcat/conf/ 目录：<strong>cd /usr/local/tomcat/conf/</strong>。</p>
<p>重命名 server.xml 文件：<strong>mv server.xml server.xml_bk</strong>。</p>
<p>创建一个新的 server.xml 文件：</p>
<p>运行命令 <strong>vi server.xml</strong>。</p>
<p>按 i 键进入编辑模式。</p>
<p>添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line"> &lt;Server port=&quot;8006&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</div><div class="line">&lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;/&gt;</div><div class="line">&lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;/&gt;</div><div class="line">&lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;/&gt;</div><div class="line">&lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot;/&gt;</div><div class="line">&lt;GlobalNamingResources&gt;</div><div class="line">  &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;</div><div class="line">            type=&quot;org.apache.catalina.UserDatabase&quot;</div><div class="line">            description=&quot;User database that can be updated and saved&quot;</div><div class="line">            factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</div><div class="line">            pathname=&quot;conf/tomcat-users.xml&quot;/&gt;</div><div class="line">&lt;/GlobalNamingResources&gt;</div><div class="line">&lt;Service name=&quot;Catalina&quot;&gt;</div><div class="line">  &lt;Connector port=&quot;8080&quot;</div><div class="line">            protocol=&quot;HTTP/1.1&quot;</div><div class="line">            connectionTimeout=&quot;20000&quot;</div><div class="line">            redirectPort=&quot;8443&quot;</div><div class="line">            maxThreads=&quot;1000&quot;</div><div class="line">            minSpareThreads=&quot;20&quot;</div><div class="line">            acceptCount=&quot;1000&quot;</div><div class="line">            maxHttpHeaderSize=&quot;65536&quot;</div><div class="line">            debug=&quot;0&quot;</div><div class="line">            disableUploadTimeout=&quot;true&quot;</div><div class="line">            useBodyEncodingForURI=&quot;true&quot;</div><div class="line">            enableLookups=&quot;false&quot;</div><div class="line">            URIEncoding=&quot;UTF-8&quot;/&gt;</div><div class="line">  &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</div><div class="line">    &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</div><div class="line">      &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</div><div class="line">             resourceName=&quot;UserDatabase&quot;/&gt;</div><div class="line">    &lt;/Realm&gt;</div><div class="line">    &lt;Host name=&quot;localhost&quot; appBase=&quot;/data/wwwroot/default&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</div><div class="line">      &lt;Context path=&quot;&quot; docBase=&quot;/data/wwwroot/default&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; crossContext=&quot;true&quot;/&gt;</div><div class="line">      &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</div><div class="line">        prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</div><div class="line">    &lt;/Host&gt;</div><div class="line">  &lt;/Engine&gt;</div><div class="line">&lt;/Service&gt;</div><div class="line">&lt;/Server&gt;</div></pre></td></tr></table></figure></p>
<p>设置 JVM 内存参数：</p>
<p>运行命令 <strong>vi /usr/local/tomcat/bin/setenv.sh</strong>， 创建 /usr/local/tomcat/bin/setenv.sh。<br>按 i 键进入编辑模式。<br>添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JAVA_OPTS=’-Djava.security.egd=file:/dev/./urandom -server -Xms256m -Xmx496m -Dfile.encoding=UTF-8’</div></pre></td></tr></table></figure></p>
<p>按 Esc 键退出编辑模式，输入 :wq 保存并退出文件。</p>
<p>-server:一定要作为第一个参数，在多个CPU时性能佳<br>-Xms：初始Heap大小，使用的最小内存,cpu性能高时此值应设的大一些<br>-Xmx：java heap最大值，使用的最大内存<br>上面两个值是分配JVM的最小和最大内存，取决于硬件物理内存的大小，建议均设为物理内存的一半。<br>-XX:PermSize:设定内存的永久保存区域<br>-XX:MaxPermSize:设定最大内存的永久保存区域<br>-XX:MaxNewSize:<br>-Xss 15120 这使得JBoss每增加一个线程（thread)就会立即消耗15M内存，而最佳值应该是128K,默认值好像是512k.<br>+XX:AggressiveHeap 会使得 Xms没有意义。这个参数让jvm忽略Xmx参数,疯狂地吃完一个G物理内存,再吃尽一个G的swap。<br>-Xss：每个线程的Stack大小<br>-verbose:gc 现实垃圾收集信息<br>-Xloggc:gc.log 指定垃圾收集日志文件<br>-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一<br>-XX:+UseParNewGC ：缩短minor收集的时间<br>-XX:+UseConcMarkSweepGC ：缩短major收集的时间</p>
<p>3.设置 Tomcat 自启动脚本。</p>
<p>下载脚本：<strong>wget <a href="https://github.com/lj2007331/oneinstack/raw/master/init.d/Tomcat-init" target="_blank" rel="external">https://github.com/lj2007331/oneinstack/raw/master/init.d/Tomcat-init</a></strong></p>
<p>重命名 Tomcat-init。<strong>mv Tomcat-init /etc/init.d/tomcat</strong></p>
<p>添加执行权限：<strong>chmod +x /etc/init.d/tomcat</strong></p>
<p>设置启动脚本 JAVA_HOME：<strong>sed -i ‘s@^export JAVA_HOME=.*@export JAVA_HOME=/usr/java/jdk1.8.0_141@’ /etc/init.d/tomcat</strong></p>
<p>4.设置自启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chkconfig --add tomcat</div><div class="line">chkconfig tomcat on</div></pre></td></tr></table></figure></p>
<p>5.启动 Tomcat。</p>
<blockquote>
<p>service tomcat start</p>
</blockquote>
<p>6.在浏览器地址栏中输入 <a href="http://ip:8080" target="_blank" rel="external">http://ip:8080</a> 进行访问。出现如图所示页面时表示安装成功。</p>
<p><img src="/images/搭建JavaWeb服务器.png" alt="enter description here" title="搭建JavaWeb服务器"></p>
<h3 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h3><h4 id="卸载老版本MySQL"><a href="#卸载老版本MySQL" class="headerlink" title="卸载老版本MySQL"></a>卸载老版本MySQL</h4><p>查找并删除mysql有关的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">find / -name mysql</div><div class="line">rm -rf 上边查找到的路径，多个路径用空格隔开</div><div class="line">#或者下边一条命令即可</div><div class="line">find / -name mysql|xargs rm -rf</div></pre></td></tr></table></figure></p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><blockquote>
<p>wget <a href="http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.33-linux-glibc2.5-x86_64.tar.gz" target="_blank" rel="external">http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.33-linux-glibc2.5-x86_64.tar.gz</a></p>
</blockquote>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><blockquote>
<p>tar -zxvf mysql-5.6.33-linux-glibc2.5-x86_64.tar.gz</p>
</blockquote>
<h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><blockquote>
<p>mv mysql-5.6.33-linux-glibc2.5-x86_64/  /usr/local/mysql</p>
</blockquote>
<h4 id="添加mysql用户组和mysql用户"><a href="#添加mysql用户组和mysql用户" class="headerlink" title="添加mysql用户组和mysql用户"></a>添加mysql用户组和mysql用户</h4><p>先检查是否有mysql用户组和mysql用户</p>
<blockquote>
<p>groups mysql</p>
</blockquote>
<p>若无，则添加；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">groupadd mysql</div><div class="line">useradd -r -g mysql mysql</div></pre></td></tr></table></figure></p>
<h4 id="进入mysql目录更改权限"><a href="#进入mysql目录更改权限" class="headerlink" title="进入mysql目录更改权限"></a>进入mysql目录更改权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/mysql</div><div class="line">chown -R mysql:mysql ./</div></pre></td></tr></table></figure>
<h4 id="执行安装脚本"><a href="#执行安装脚本" class="headerlink" title="执行安装脚本"></a>执行安装脚本</h4><blockquote>
<p>./scripts/mysql_install_db –user=mysql</p>
</blockquote>
<p>安装完之后修改当前目录拥有者为root用户，修改data目录拥有者为mysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chown -R root:root ./</div><div class="line">chown -R mysql:mysql data</div></pre></td></tr></table></figure>
<h4 id="更改mysql密码"><a href="#更改mysql密码" class="headerlink" title="更改mysql密码"></a>更改mysql密码</h4><p>上一步安装脚本执行输出的日志中告诉我们如何更改密码了</p>
<p><img src="/images/搭建JavaWeb服务器-mysql.png" alt="搭建JavaWeb服务器--mysql" title="搭建JavaWeb服务器-mysql"></p>
<p>但是如果直接执行这两条命令就会报错<br><img src="/images/搭建JavaWeb服务器--mysql.png" alt="搭建JavaWeb服务器--mysql" title="搭建JavaWeb服务器--mysql"></p>
<p>因为这时还没有启动mysql，这算是一个坑。启动方法如下：</p>
<blockquote>
<p>./support-files/mysql.server start</p>
</blockquote>
<p><img src="/images/搭建JavaWeb服务器---mysql.png" alt="搭建JavaWeb服务器---mysql" title="搭建JavaWeb服务器---mysql"></p>
<p>如果MySQL启动报错，则可能是已经存在MySQL进程，杀掉即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ps aux|grep mysql</div><div class="line">kill -9 上边的进程号</div><div class="line">#或者下边一条命令即可杀掉所有MySQL进程</div><div class="line">ps aux|grep mysql|awk &apos;&#123;print $2&#125;&apos;|xargs kill -9</div></pre></td></tr></table></figure></p>
<p>MySQL启动之后再执行如下命令更改密码：</p>
<blockquote>
<p>./bin/mysqladmin -u root -h localhost.localdomain password ‘root’</p>
</blockquote>
<p>密码更改后即可登录MySQL</p>
<blockquote>
<p>./bin/mysql -h127.0.0.1 -uroot -proot</p>
</blockquote>
<p><img src="/images/搭建JavaWeb服务器----mysql.png" alt="搭建JavaWeb服务器----mysql" title="搭建JavaWeb服务器----mysql"></p>
<p>登录之后将其他用户的密码也可改为root<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">update mysql.user set password=password(&apos;root&apos;) where user=&apos;root&apos;;</div><div class="line">flush privileges;</div></pre></td></tr></table></figure></p>
<h4 id="增加远程登录权限"><a href="#增加远程登录权限" class="headerlink" title="增加远程登录权限"></a>增加远程登录权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grant all privileges on *.* to root@&apos;%&apos; identified by &apos;root&apos;;</div><div class="line">flush privileges;</div></pre></td></tr></table></figure>
<h4 id="将MySQL加入Service系统服务"><a href="#将MySQL加入Service系统服务" class="headerlink" title="将MySQL加入Service系统服务"></a>将MySQL加入Service系统服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cp support-files/mysql.server /etc/init.d/mysqld</div><div class="line">chkconfig --add mysqld</div><div class="line">chkconfig mysqld on</div><div class="line">service mysqld restart</div><div class="line">service mysqld status</div></pre></td></tr></table></figure>
<p><img src="/images/搭建JavaWeb服务器-----mysql.png" alt="搭建JavaWeb服务器-----mysql" title="搭建JavaWeb服务器-----mysql"></p>
<h4 id="配置my-cnf-配置可能会出错-这一步可以忽"><a href="#配置my-cnf-配置可能会出错-这一步可以忽" class="headerlink" title="配置my.cnf[配置可能会出错|这一步可以忽]"></a>配置my.cnf[配置可能会出错|这一步可以忽]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vim my.cnf</div><div class="line">#添加以下两条语句并保存退出</div><div class="line">default-character-set=utf8</div><div class="line">lower_case_table_names=1</div><div class="line">max_allowed_packet=100M</div></pre></td></tr></table></figure>
<p>配置好之后，重启mysqld服务</p>
<p><img src="/images/搭建JavaWeb服务器#mysql.png" alt="搭建JavaWeb服务器#mysql" title="搭建JavaWeb服务器#mysql"></p>
<blockquote>
<p>引用 <a href="https://help.aliyun.com/document_detail/51376.html?spm=a2c4g.11186623.2.6.f7qoYA" target="_blank" rel="external">https://help.aliyun.com/document_detail/51376.html?spm=a2c4g.11186623.2.6.f7qoYA</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;配置要求&quot;&gt;&lt;a href=&quot;#配置要求&quot; class=&quot;headerlink&quot; title=&quot;配置要求&quot;&gt;&lt;/a&gt;配置要求&lt;/h3&gt;&lt;p&gt;这里列出的软件版本仅代表写作本文档使用的版本。操作时，请您以实际软件版本为准。&lt;/p&gt;
&lt;p&gt;操作系统：CentOS 7.4
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java|徒手撸框架--实现Aop</title>
    <link href="http://yoursite.com/2018/02/10/Java-%E5%BE%92%E6%89%8B%E6%92%B8%E6%A1%86%E6%9E%B6-%E5%AE%9E%E7%8E%B0Aop/"/>
    <id>http://yoursite.com/2018/02/10/Java-徒手撸框架-实现Aop/</id>
    <published>2018-02-10T15:50:24.000Z</published>
    <updated>2018-02-10T08:20:36.397Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架有两大特性，一个是IOC,另一个是AOP.对于Spring Aop的实现讲解的都不太透彻，大部分文章介绍了Spring Aop的底层技术使用了动态代理，至于Spring Aop的具体实现都语焉不详。这类文章看以后以后，我脑子里浮现的就是这样一个画面：</p>
<p><img src="/images/徒手鲁框架--04.jpg" alt="徒手鲁框架--04" title="徒手鲁框架--04"></p>
<p>我的想法就是，带领大家，首先梳理 Spring Aop的实现，然后屏蔽细节，自己实现一个Aop框架。加深对Spring Aop的理解。在了解上图1-4步骤的同时，补充 4 到 5 步骤之间的其他细节。</p>
<p>读完这篇文章你将会了解：</p>
<ul>
<li>Aop是什么？</li>
<li>为什么要使用Aop？</li>
<li>Spirng 实现Aop的思路是什么</li>
<li>自己根据Spring 思想实现一个 Aop框架</li>
</ul>
<h3 id="Aop-是什么？"><a href="#Aop-是什么？" class="headerlink" title="Aop 是什么？"></a>Aop 是什么？</h3><p>面向切面的程序设计（aspect-oriented programming，AOP）。通过预编译方式和运行期动态代理实现程序功能统一维护的一种技术。</p>
<h3 id="为什么需要使用Aop？"><a href="#为什么需要使用Aop？" class="headerlink" title="为什么需要使用Aop？"></a>为什么需要使用Aop？</h3><p>面向切面编程，实际上就是通过预编译或者动态代理技术在不修改源代码的情况下给原来的程序统一添加功能的一种技术。我们看几个关键词，第一个是“动态代理技术”，这个就是Spring Aop实现底层技术。第二个“不修改源代码”，这个就是Aop最关键的地方，也就是我们平时所说的非入侵性。。第三个“添加功能”，不改变原有的源代码，为程序添加功能。</p>
<p>举个例子：如果某天你需要统计若干方法的执行时间，如果不是用Aop技术，你要做的就是为每一个方法开始的时候获取一个开始时间，在方法结束的时候获取结束时间。二者之差就是方法的执行时间。如果对每一个需要统计的方法都做如上的操作，那代码简直就是灾难。如果我们使用Aop技术，在不修改代码的情况下，添加一个统计方法执行时间的切面。代码就变得十分优雅。具体这个切面怎么实现？看完下面的文章你一定就会知道。</p>
<h3 id="Spring-Aop-是怎么实现的？"><a href="#Spring-Aop-是怎么实现的？" class="headerlink" title="Spring Aop 是怎么实现的？"></a>Spring Aop 是怎么实现的？</h3><p>所谓：</p>
<blockquote>
<p>计算机程序 = 数据结构 + 算法</p>
</blockquote>
<p>在阅读过Spring源码之后，你就会对这个说法理解更深入了。</p>
<p>Spring Aop实现的代码非常非常的绕。也就是说 Spring 为了灵活做了非常深层次的抽象。同时 Spring为了兼容 @AspectJ 的Aop协议，使用了很多 Adapter （适配器）模式又进一步的增加了代码的复杂程度。</p>
<p>Spring 的 Aop 实现主要以下几个步骤：</p>
<ul>
<li>初始化 Aop 容器。</li>
<li>读取配置文件。</li>
<li>将配置文件装换为 Aop 能够识别的数据结构 – Advisor。这里展开讲一讲这个advisor。Advisor对象中包又含了两个重要的数据结构，一个是 Advice，一个是 Pointcut。Advice的作用就是描述一个切面的行为，pointcut描述的是切面的位置。两个数据结的组合就是”在哪里，干什么“。这样 Advisor 就包含了”在哪里干什么“的信息，就能够全面的描述切面了。</li>
<li>Spring 将这个 Advisor 转换成自己能够识别的数据结构 – AdvicedSupport。Spirng 动态的将这些方法拦截器织入到对应的方法。</li>
<li>生成动态代理代理。</li>
<li>提供调用，在使用的时候，调用方调用的就是代理方法。也就是已经织入了增强方法的方法。</li>
</ul>
<h3 id="自己实现一个-Aop-框架"><a href="#自己实现一个-Aop-框架" class="headerlink" title="自己实现一个 Aop 框架"></a>自己实现一个 Aop 框架</h3><p>同样，我也是参考了Aop的设计。只实现了基于方法的拦截器。去除了很多的实现细节。</p>
<p>使用上一讲的 IoC 框架管理对象。使用 Cglib 作为动态代理的基础类。使用 maven 管理 jar 包和 module。所以上一讲的 IoC 框架会作为一个 modules 引入项目。</p>
<p>下面我们就来实现我们的Aop 框架吧。</p>
<p>首先来看看代码的基本结构。</p>
<p><img src="/images/徒手鲁框架--05.jpg" alt="徒手鲁框架--05" title="徒手鲁框架--05"></p>
<p>我们首先对包每个包都干了什么做一个简单介绍。</p>
<ul>
<li>invocation 描述的就是一个方法的调用。注意这里指的是“方法的调用”，而不是调用这个动作。</li>
<li>interceptor 大家最熟悉的拦截器，拦截器拦截的目标就是 invcation 包里面的调用。</li>
<li>advisor 这个包里的对象，都是用来描述切面的数据结构。</li>
<li>adapter 这个包里面是一些适配器方法。对于”适配器”不了解的同学可以去看看”设计模式”里面的”适配模式”。他的作用就是将 advice 包里的对象适配为 interceptor。</li>
<li>bean 描述我们 json 配置文件的对象。</li>
<li>core 我们框架的核心逻辑。</li>
</ul>
<p>这个时候宏观的看我们大概梳理出了一条路线， adaper 将 advisor 适配为 interceptor 去拦截 invoction。</p>
<p>下面我们从这个链条的最末端讲起：</p>
<h4 id="invcation"><a href="#invcation" class="headerlink" title="invcation"></a>invcation</h4><p>首先 MethodInvocation 作为所有方法调用的接口。要描述一个方法的调用包含三个方法，获取方法本身getMethod,获取方法的参数getArguments，还有执行方法本身proceed()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface MethodInvocation &#123;</div><div class="line">    Method getMethod();</div><div class="line">    Object[] getArguments();</div><div class="line">    Object proceed() throws Throwable;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ProxyMethodInvocation 看名字就知道，是代理方法的调用，增加了一个获取代理的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ProxyMethodInvocation extends MethodInvocation &#123;</div><div class="line">    Object getProxy();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="interceptor"><a href="#interceptor" class="headerlink" title="interceptor"></a>interceptor</h4><p>AopMethodInterceptor 是 Aop 容器所有拦截器都要实现的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface AopMethodInterceptor &#123;</div><div class="line">    Object invoke(MethodInvocation mi) throws Throwable;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时我们实现了两种拦截器BeforeMethodAdviceInterceptor和AfterRunningAdviceInterceptor,顾名思义前者就是在方法执行以前拦截，后者就在方法运行结束以后拦截：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class BeforeMethodAdviceInterceptor implements AopMethodInterceptor &#123;</div><div class="line">    private BeforeMethodAdvice advice;</div><div class="line">    public BeforeMethodAdviceInterceptor(BeforeMethodAdvice advice) &#123;</div><div class="line">        this.advice = advice;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</div><div class="line">        advice.before(mi.getMethod(),mi.getArguments(),mi);</div><div class="line">        return mi.proceed();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class AfterRunningAdviceInterceptor implements AopMethodInterceptor &#123;</div><div class="line">    private AfterRunningAdvice advice;</div><div class="line"></div><div class="line">    public AfterRunningAdviceInterceptor(AfterRunningAdvice advice) &#123;</div><div class="line">        this.advice = advice;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;</div><div class="line">        Object returnVal = mi.proceed();</div><div class="line">        advice.after(returnVal,mi.getMethod(),mi.getArguments(),mi);</div><div class="line">        return returnVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看了上面的代码我们发现，实际上 mi.proceed()才是执行原有的方法。而advice我们上文就说过，是描述增强的方法”干什么“的数据结构，所以对于这个before拦截器，我们就把advice对应的增强方法放在了真正执行的方法前面。而对于after拦截器而言，就放在了真正执行的方法后面。</p>
<p>这个时候我们过头来看最关键的 ReflectioveMethodeInvocation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class ReflectioveMethodeInvocation implements ProxyMethodInvocation &#123;</div><div class="line">    public ReflectioveMethodeInvocation(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList) &#123;</div><div class="line">        this.proxy = proxy;</div><div class="line">        this.target = target;</div><div class="line">        this.method = method;</div><div class="line">        this.arguments = arguments;</div><div class="line">        this.interceptorList = interceptorList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected final Object proxy;</div><div class="line"></div><div class="line">    protected final Object target;</div><div class="line"></div><div class="line">    protected final Method method;</div><div class="line"></div><div class="line">    protected Object[] arguments = new Object[0];</div><div class="line"></div><div class="line">    //存储所有的拦截器</div><div class="line">    protected final List&lt;AopMethodInterceptor&gt; interceptorList;</div><div class="line"></div><div class="line">    private int currentInterceptorIndex = -1;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getProxy() &#123;</div><div class="line">        return proxy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Method getMethod() &#123;</div><div class="line">        return method;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object[] getArguments() &#123;</div><div class="line">        return arguments;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object proceed() throws Throwable &#123;</div><div class="line"></div><div class="line">        //执行完所有的拦截器后，执行目标方法</div><div class="line">        if(currentInterceptorIndex == this.interceptorList.size() - 1) &#123;</div><div class="line">            return invokeOriginal();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //迭代的执行拦截器。回顾上面的讲解，我们实现的拦击都会执行 im.proceed() 实际上又会调用这个方法。实现了一个递归的调用，直到执行完所有的拦截器。</div><div class="line">        AopMethodInterceptor interceptor = interceptorList.get(++currentInterceptorIndex);</div><div class="line">        return interceptor.invoke(this);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected Object invokeOriginal() throws Throwable&#123;</div><div class="line">        return ReflectionUtils.invokeMethodUseReflection(target,method,arguments);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实际的运用中，我们的方法很可能被多个方法的拦截器所增强。所以我们，使用了一个list来保存所有的拦截器。所以我们需要递归的去增加拦截器。当处理完了所有的拦截器之后，才会真正调用调用被增强的方法。我们可以认为，前文所述的动态的织入代码就发生在这里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class CglibMethodInvocation extends ReflectioveMethodeInvocation &#123;</div><div class="line"></div><div class="line">    private MethodProxy methodProxy;</div><div class="line"></div><div class="line">    public CglibMethodInvocation(Object proxy, Object target, Method method, Object[] arguments, List&lt;AopMethodInterceptor&gt; interceptorList, MethodProxy methodProxy) &#123;</div><div class="line">        super(proxy, target, method, arguments, interceptorList);</div><div class="line">        this.methodProxy = methodProxy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected Object invokeOriginal() throws Throwable &#123;</div><div class="line">        return methodProxy.invoke(target,arguments);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CglibMethodInvocation 只是重写了 invokeOriginal 方法。使用代理类来调用被增强的方法。</p>
<h4 id="advisor"><a href="#advisor" class="headerlink" title="advisor"></a>advisor</h4><p>这个包里面都是一些描述切面的数据结构，我们讲解两个重要的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Data</div><div class="line">public class Advisor &#123;</div><div class="line">    //干什么</div><div class="line">    private Advice advice;</div><div class="line">    //在哪里</div><div class="line">    private Pointcut pointcut;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上文所说，advisor 描述了在哪里，干什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Data</div><div class="line">public class AdvisedSupport extends Advisor &#123;</div><div class="line">    //目标对象</div><div class="line">    private TargetSource targetSource;</div><div class="line">    //拦截器列表</div><div class="line">    private List&lt;AopMethodInterceptor&gt; list = new LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">    public void addAopMethodInterceptor(AopMethodInterceptor interceptor)&#123;</div><div class="line">        list.add(interceptor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void addAopMethodInterceptors(List&lt;AopMethodInterceptor&gt; interceptors)&#123;</div><div class="line">        list.addAll(interceptors);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个AdvisedSupport就是 我们Aop框架能够理解的数据结构，这个时候问题就变成了–对于哪个目标，增加哪些拦截器。</p>
<h4 id="core"><a href="#core" class="headerlink" title="core"></a>core</h4><p>有了上面的准备，我们就开始讲解核心逻辑了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@Data</div><div class="line">public class CglibAopProxy implements AopProxy&#123;</div><div class="line">    private AdvisedSupport advised;</div><div class="line">    private Object[] constructorArgs;</div><div class="line">    private Class&lt;?&gt;[] constructorArgTypes;</div><div class="line">    public CglibAopProxy(AdvisedSupport config)&#123;</div><div class="line">        this.advised = config;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getProxy() &#123;</div><div class="line">        return getProxy(null);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Object getProxy(ClassLoader classLoader) &#123;</div><div class="line">        Class&lt;?&gt; rootClass = advised.getTargetSource().getTagetClass();</div><div class="line">        if(classLoader == null)&#123;</div><div class="line">            classLoader = ClassUtils.getDefultClassLoader();</div><div class="line">        &#125;</div><div class="line">        Enhancer enhancer = new Enhancer();</div><div class="line">        enhancer.setSuperclass(rootClass.getSuperclass());</div><div class="line">        //增加拦截器的核心方法</div><div class="line">        Callback callbacks = getCallBack(advised);</div><div class="line">        enhancer.setCallback(callbacks);</div><div class="line">        enhancer.setClassLoader(classLoader);</div><div class="line">        if(constructorArgs != null &amp;&amp; constructorArgs.length &gt; 0)&#123;</div><div class="line">            return enhancer.create(constructorArgTypes,constructorArgs);</div><div class="line">        &#125;</div><div class="line">        return enhancer.create();</div><div class="line">    &#125;</div><div class="line">    private Callback getCallBack(AdvisedSupport advised) &#123;</div><div class="line">        return new DynamicAdvisedIcnterceptor(advised.getList(),advised.getTargetSource());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CglibAopProxy就是我们代理对象生成的核心方法。使用 cglib 生成代理类。我们可以与之前ioc框架的代码。比较发现区别就在于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Callback callbacks = getCallBack(advised);</div><div class="line">enhancer.setCallback(callbacks);</div></pre></td></tr></table></figure></p>
<p>callback与之前不同了，而是写了一个getCallback()的方法，我们就来看看 getCallback 里面的 DynamicAdvisedIcnterceptor到底干了啥。</p>
<p>篇幅问题，这里不会介绍 cglib 的使用，对于callback的作用，不理解的同学需要自行学习。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class DynamicAdvisedInterceptor implements MethodInterceptor&#123;</div><div class="line"></div><div class="line">    protected final List&lt;AopMethodInterceptor&gt; interceptorList;</div><div class="line">    protected final TargetSource targetSource;</div><div class="line"></div><div class="line">    public DynamicAdvisedInterceptor(List&lt;AopMethodInterceptor&gt; interceptorList, TargetSource targetSource) &#123;</div><div class="line">        this.interceptorList = interceptorList;</div><div class="line">        this.targetSource = targetSource;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</div><div class="line">        MethodInvocation invocation = new CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</div><div class="line">        return invocation.proceed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要注意，DynamicAdvisedInterceptor这个类实现的 MethodInterceptor 是 gclib的接口，并非我们之前的 AopMethodInterceptor。</p>
<p>我们近距离观察 intercept 这个方法我们看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MethodInvocation invocation = new CglibMethodInvocation(obj,targetSource.getTagetObject(),method, args,interceptorList,proxy);</div></pre></td></tr></table></figure></p>
<p>通过这行代码，我们的整个逻辑终于连起来了。也就是这个动态的拦截器，把我们通过 CglibMethodInvocation 织入了增强代码的方法，委托给了 cglib 来生成代理对象。</p>
<p>至此我们的 Aop 的核心功能就实现了。</p>
<p><strong>AopBeanFactoryImpl</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public class AopBeanFactoryImpl extends BeanFactoryImpl&#123;</div><div class="line"></div><div class="line">    private static final ConcurrentHashMap&lt;String,AopBeanDefinition&gt; aopBeanDefinitionMap = new ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    private static final ConcurrentHashMap&lt;String,Object&gt; aopBeanMap = new ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getBean(String name) throws Exception &#123;</div><div class="line">        Object aopBean = aopBeanMap.get(name);</div><div class="line"></div><div class="line">        if(aopBean != null)&#123;</div><div class="line">            return aopBean;</div><div class="line">        &#125;</div><div class="line">        if(aopBeanDefinitionMap.containsKey(name))&#123;</div><div class="line">            AopBeanDefinition aopBeanDefinition = aopBeanDefinitionMap.get(name);</div><div class="line">            AdvisedSupport advisedSupport = getAdvisedSupport(aopBeanDefinition);</div><div class="line">            aopBean = new CglibAopProxy(advisedSupport).getProxy();</div><div class="line">            aopBeanMap.put(name,aopBean);</div><div class="line">            return aopBean;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return super.getBean(name);</div><div class="line">    &#125;</div><div class="line">    protected void registerBean(String name, AopBeanDefinition aopBeanDefinition)&#123;</div><div class="line">        aopBeanDefinitionMap.put(name,aopBeanDefinition);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private AdvisedSupport getAdvisedSupport(AopBeanDefinition aopBeanDefinition) throws Exception &#123;</div><div class="line"></div><div class="line">        AdvisedSupport advisedSupport = new AdvisedSupport();</div><div class="line">        List&lt;String&gt; interceptorNames = aopBeanDefinition.getInterceptorNames();</div><div class="line">        if(interceptorNames != null &amp;&amp; !interceptorNames.isEmpty())&#123;</div><div class="line">            for (String interceptorName : interceptorNames) &#123;</div><div class="line"></div><div class="line">                Advice advice = (Advice) getBean(interceptorName);</div><div class="line"></div><div class="line">                Advisor advisor = new Advisor();</div><div class="line">                advisor.setAdvice(advice);</div><div class="line"></div><div class="line">                if(advice instanceof BeforeMethodAdvice)&#123;</div><div class="line">                    AopMethodInterceptor interceptor = BeforeMethodAdviceAdapter.getInstants().getInterceptor(advisor);</div><div class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if(advice instanceof AfterRunningAdvice)&#123;</div><div class="line">                    AopMethodInterceptor interceptor = AfterRunningAdviceAdapter.getInstants().getInterceptor(advisor);</div><div class="line">                    advisedSupport.addAopMethodInterceptor(interceptor);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        TargetSource targetSource = new TargetSource();</div><div class="line">        Object object = getBean(aopBeanDefinition.getTarget());</div><div class="line">        targetSource.setTagetClass(object.getClass());</div><div class="line">        targetSource.setTagetObject(object);</div><div class="line">        advisedSupport.setTargetSource(targetSource);</div><div class="line">        return advisedSupport;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AopBeanFactoryImpl是我们产生代理对象的工厂类，继承了上一讲我们实现的 IoC 容器的BeanFactoryImpl。重写了 getBean方法，如果是一个切面代理类，我们使用Aop框架生成代理类，如果是普通的对象，我们就用原来的IoC容器进行依赖注入。<br>getAdvisedSupport就是获取 Aop 框架认识的数据结构。</p>
<p>剩下没有讲到的类都比较简单，大家看源码就行。与核心逻辑无关。</p>
<h4 id="写个方法测试一下"><a href="#写个方法测试一下" class="headerlink" title="写个方法测试一下"></a>写个方法测试一下</h4><p>我们需要统计一个方法的执行时间。面对这个需求我们怎么做？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class StartTimeBeforeMethod implements BeforeMethodAdvice&#123;</div><div class="line">    @Override</div><div class="line">    public void before(Method method, Object[] args, Object target) &#123;</div><div class="line">        long startTime = System.currentTimeMillis();</div><div class="line">        System.out.println(&quot;开始计时&quot;);</div><div class="line">        ThreadLocalUtils.set(startTime);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class EndTimeAfterMethod implements AfterRunningAdvice &#123;</div><div class="line">    @Override</div><div class="line">    public Object after(Object returnVal, Method method, Object[] args, Object target) &#123;</div><div class="line">        long endTime = System.currentTimeMillis();</div><div class="line">        long startTime = ThreadLocalUtils.get();</div><div class="line">        ThreadLocalUtils.remove();</div><div class="line">        System.out.println(&quot;方法耗时：&quot; + (endTime - startTime) + &quot;ms&quot;);</div><div class="line">        return returnVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法开始前，记录时间，保存到 ThredLocal里面，方法结束记录时间，打印时间差。完成统计。</p>
<p>目标类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class TestService &#123;</div><div class="line">    public void testMethod() throws InterruptedException &#123;</div><div class="line">        System.out.println(&quot;this is a test method&quot;);</div><div class="line">        Thread.sleep(1000);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;</div><div class="line">    &quot;name&quot;:&quot;beforeMethod&quot;,</div><div class="line">    &quot;className&quot;:&quot;com.xilidou.framework.aop.test.StartTimeBeforeMethod&quot;</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    &quot;name&quot;:&quot;afterMethod&quot;,</div><div class="line">    &quot;className&quot;:&quot;com.xilidou.framework.aop.test.EndTimeAfterMethod&quot;</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    &quot;name&quot;:&quot;testService&quot;,</div><div class="line">    &quot;className&quot;:&quot;com.xilidou.framework.aop.test.TestService&quot;</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    &quot;name&quot;:&quot;testServiceProxy&quot;,</div><div class="line">    &quot;className&quot;:&quot;com.xilidou.framework.aop.core.ProxyFactoryBean&quot;,</div><div class="line">    &quot;target&quot;:&quot;testService&quot;,</div><div class="line">    &quot;interceptorNames&quot;:[</div><div class="line">      &quot;beforeMethod&quot;,</div><div class="line">      &quot;afterMethod&quot;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MainTest &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        AopApplictionContext aopApplictionContext = new AopApplictionContext(&quot;application.json&quot;);</div><div class="line">        aopApplictionContext.init();</div><div class="line">        TestService testService = (TestService) aopApplictionContext.getBean(&quot;testServiceProxy&quot;);</div><div class="line">        testService.testMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终我们的执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">开始计时</div><div class="line">this is a test method</div><div class="line">方法耗时：1015ms</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure></p>
<p>至此 Aop 框架完成。</p>
<blockquote>
<p>引用 <a href="https://www.xilidou.com/2018/01/13/spring-aop/" target="_blank" rel="external">https://www.xilidou.com/2018/01/13/spring-aop/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring框架有两大特性，一个是IOC,另一个是AOP.对于Spring Aop的实现讲解的都不太透彻，大部分文章介绍了Spring Aop的底层技术使用了动态代理，至于Spring Aop的具体实现都语焉不详。这类文章看以后以后，我脑子里浮现的就是这样一个画面：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java|徒手撸框架--实现IoC</title>
    <link href="http://yoursite.com/2018/02/10/Java-%E5%BE%92%E6%89%8B%E6%92%B8%E6%A1%86%E6%9E%B6-%E5%AE%9E%E7%8E%B0IoC/"/>
    <id>http://yoursite.com/2018/02/10/Java-徒手撸框架-实现IoC/</id>
    <published>2018-02-10T14:45:42.000Z</published>
    <updated>2018-02-11T15:15:00.338Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h3><p>Spring 作为 J2ee 开发事实上的标准，是每个Java开发人员都需要了解的框架。但是Spring 的 IoC 和 Aop 的特性，对于初级的Java开发人员来说还是比较难于理解的。所以我就想写一系列的文章给大家讲解这些特性。从而能够进一步深入了解 Spring 框架。</p>
<p>读完这篇文章，你将会了解：</p>
<ul>
<li>什么是依赖注入和控制反转</li>
<li>Ioc有什么用</li>
<li>Spring的 Ioc 是怎么实现的</li>
<li>按照Spring的思路开发一个简单的Ioc框架</li>
</ul>
<h3 id="IoC-是什么？"><a href="#IoC-是什么？" class="headerlink" title="IoC 是什么？"></a>IoC 是什么？</h3><p>wiki百科的解释是：</p>
<blockquote>
<p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p>
</blockquote>
<h3 id="Ioc-有什么用？"><a href="#Ioc-有什么用？" class="headerlink" title="Ioc 有什么用？"></a>Ioc 有什么用？</h3><p>看完上面的解释你一定没有理解什么是 Ioc，因为是第一次看见上面的话也觉得云里雾里。</p>
<p>不过通过上面的描述我们可以大概的了解到，使用IoC的目的是为了解耦。也就是说IoC 是解耦的一种方法。</p>
<p>我们知道Java 是一门面向对象的语言，在 Java 中 Everything is Object，我们的程序就是由若干对象组成的。当我们的项目越来越大，合作的开发者越来越多的时候，我们的类就会越来越多，类与类之间的引用就会成指数级的增长。如下图所示：</p>
<p><img src="/images/徒手鲁框架--01.jpg" alt="徒手鲁框架--01" title="徒手鲁框架--01"></p>
<p>这样的工程简直就是灾难，如果我们引入 Ioc 框架。由框架来维护类的生命周期和类之间的引用。我们的系统就会变成这样：</p>
<p><img src="/images/徒手鲁框架--02.jpg" alt="徒手鲁框架--02" title="徒手鲁框架--02"></p>
<p>这个时候我们发现，我们类之间的关系都由 IoC 框架负责维护类，同时将类注入到需要的类中。也就是类的使用者只负责使用，而不负责维护。把专业的事情交给专业的框架来完成。大大的减少开发的复杂度。</p>
<p>用一个类比来理解这个问题。Ioc框架就是我们生活中的房屋中介，首先中介会收集市场上的房源，分别和各个房源的房东建立联系。当我们需要租房的时候，并不需要我们四处寻找各类租房信息。我们直接找房屋中介，中介就会根据你的需求提供相应的房屋信息。大大提升了租房的效率，减少了你与各类房东之间的沟通次数。</p>
<h3 id="Spring-的-IoC-是怎么实现的"><a href="#Spring-的-IoC-是怎么实现的" class="headerlink" title="Spring 的 IoC 是怎么实现的"></a>Spring 的 IoC 是怎么实现的</h3><p>了解Spring框架最直接的方法就阅读Spring的源码。但是Spring的代码抽象的层次很高，且处理的细节很高。对于大多数人来说不是太容易理解。我读了Spirng的源码以后以我的理解做一个总结,Spirng IoC 主要是以下几个步骤。</p>
<ul>
<li><ol>
<li>初始化 IoC 容器。</li>
</ol>
</li>
<li><ol>
<li>读取配置文件。</li>
</ol>
</li>
<li><ol>
<li>将配置文件转换为容器识别对的数据结构（这个数据结构在Spring中叫做 BeanDefinition</li>
</ol>
</li>
<li><ol>
<li>利用数据结构依次实例化相应的对象</li>
</ol>
</li>
<li><ol>
<li>注入对象之间的依赖关系</li>
</ol>
</li>
</ul>
<h3 id="自己实现一个IoC框架"><a href="#自己实现一个IoC框架" class="headerlink" title="自己实现一个IoC框架"></a>自己实现一个IoC框架</h3><p>为了方便，我们参考Spirng的IoC实现，去除所有与核心原理无关的逻辑。极简的实现 IoC 的框架。 项目使用 json 作为配置文件。使用 maven 管理 jar 包的依赖。</p>
<p>在这个框架中我们的对象都是单例的，并不支持Spirng的多种作用域。框架的实现使用了cglib和Java的反射。项目中我还使用了lombok用来简化代码。</p>
<p>下面我们就来编写 IoC 框架吧。</p>
<p>首先我们看看这个框架的基本结构：</p>
<p><img src="/images/徒手鲁框架--03.jpg" alt="徒手鲁框架--03" title="徒手鲁框架--03"></p>
<p>从宏观上观察一下这个框架，包含了2个package、在包 bean 中定义了我们框架的数据结构。core 是我们框架的核心逻辑所在。utils 是一些通用工具类。接下来我们就逐一讲解一下：</p>
<h4 id="1-bean-定义了框架的数据结构"><a href="#1-bean-定义了框架的数据结构" class="headerlink" title="1. bean 定义了框架的数据结构"></a>1. bean 定义了框架的数据结构</h4><p>BeanDefinition 是我们项目的核心数据结构。用于描述我们需要 IoC 框架管理的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Data</div><div class="line">@ToString</div><div class="line">public class BeanDefinition &#123;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    private String className;</div><div class="line"></div><div class="line">    private String interfaceName;</div><div class="line"></div><div class="line">    private List&lt;ConstructorArg&gt; constructorArgs;</div><div class="line"></div><div class="line">    private List&lt;PropertyArg&gt; propertyArgs;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>包含了对象的 name，class的名称。如果是接口的实现，还有该对象实现的接口。以及构造函数的传参的列表 constructorArgs 和需要注入的参数列表 propertyArgList。</p>
<h4 id="2-再看看我们的工具类包里面的对象："><a href="#2-再看看我们的工具类包里面的对象：" class="headerlink" title="2. 再看看我们的工具类包里面的对象："></a>2. 再看看我们的工具类包里面的对象：</h4><p>ClassUtils 负责处理 Java 类的加载,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class ClassUtils &#123;</div><div class="line">    public static ClassLoader getDefultClassLoader()&#123;</div><div class="line">        return Thread.currentThread().getContextClassLoader();</div><div class="line">    &#125;</div><div class="line">    public static Class loadClass(String className)&#123;</div><div class="line">        try &#123;</div><div class="line">            return getDefultClassLoader().loadClass(className);</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们只写了一个方法，就是通过 className 这个参数获取对象的 Class。</p>
<p>BeanUtils 负责处理对象的实例化，这里我们使用了 cglib 这个工具包，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class BeanUtils &#123;</div><div class="line">    public static &lt;T&gt; T instanceByCglib(Class&lt;T&gt; clz,Constructor ctr,Object[] args) &#123;</div><div class="line">        Enhancer enhancer = new Enhancer();</div><div class="line">        enhancer.setSuperclass(clz);</div><div class="line">        enhancer.setCallback(NoOp.INSTANCE);</div><div class="line">        if(ctr == null)&#123;</div><div class="line">            return (T) enhancer.create();</div><div class="line">        &#125;else &#123;</div><div class="line">            return (T) enhancer.create(ctr.getParameterTypes(),args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ReflectionUtils 主要通过 Java 的反射原理来完成对象的依赖注入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class ReflectionUtils &#123;</div><div class="line"></div><div class="line">    public static void injectField(Field field,Object obj,Object value) throws IllegalAccessException &#123;</div><div class="line">        if(field != null) &#123;</div><div class="line">            field.setAccessible(true);</div><div class="line">            field.set(obj, value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>injectField(Field field,Object obj,Object value) 这个方法的作用就是，设置 obj 的 field 为 value。</p>
<p>JsonUtils 的作用就是为了解析我们的json配置文件。代码比较长，与我们的 IoC 原理关系不大，感兴趣的同学可以自行从github上下载代码看看。</p>
<p>有了这几个趁手的工具，我们就可以开始完成 Ioc 框架的核心代码了。</p>
<h4 id="3-核心逻辑"><a href="#3-核心逻辑" class="headerlink" title="3. 核心逻辑"></a>3. 核心逻辑</h4><p>我的 IoC 框架，目前只支持一种 ByName 的注入。所以我们的 BeanFactory 就只有一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface BeanFactory &#123;</div><div class="line">    Object getBean(String name) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们实现了这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">public class BeanFactoryImpl implements BeanFactory&#123;</div><div class="line"></div><div class="line">    private static final ConcurrentHashMap&lt;String,Object&gt; beanMap = new ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    private static final ConcurrentHashMap&lt;String,BeanDefinition&gt; beanDefineMap= new ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    private static final Set&lt;String&gt; beanNameSet = Collections.synchronizedSet(new HashSet&lt;&gt;());</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getBean(String name) throws Exception &#123;</div><div class="line">        //查找对象是否已经实例化过</div><div class="line">        Object bean = beanMap.get(name);</div><div class="line">        if(bean != null)&#123;</div><div class="line">            return bean;</div><div class="line">        &#125;</div><div class="line">        //如果没有实例化，那就需要调用createBean来创建对象</div><div class="line">        bean =  createBean(beanDefineMap.get(name));</div><div class="line">        </div><div class="line">        if(bean != null) &#123;</div><div class="line"></div><div class="line">            //对象创建成功以后，注入对象需要的参数</div><div class="line">            populatebean(bean);</div><div class="line">            </div><div class="line">            //再吧对象存入Map中方便下次使用。</div><div class="line">            beanMap.put(name,bean;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //结束返回</div><div class="line">        return bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void registerBean(String name, BeanDefinition bd)&#123;</div><div class="line">        beanDefineMap.put(name,bd);</div><div class="line">        beanNameSet.add(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Object createBean(BeanDefinition beanDefinition) throws Exception &#123;</div><div class="line">        String beanName = beanDefinition.getClassName();</div><div class="line">        Class clz = ClassUtils.loadClass(beanName);</div><div class="line">        if(clz == null) &#123;</div><div class="line">            throw new Exception(&quot;can not find bean by beanName&quot;);</div><div class="line">        &#125;</div><div class="line">        List&lt;ConstructorArg&gt; constructorArgs = beanDefinition.getConstructorArgs();</div><div class="line">        if(constructorArgs != null &amp;&amp; !constructorArgs.isEmpty())&#123;</div><div class="line">            List&lt;Object&gt; objects = new ArrayList&lt;&gt;();</div><div class="line">            for (ConstructorArg constructorArg : constructorArgs) &#123;</div><div class="line">                objects.add(getBean(constructorArg.getRef()));</div><div class="line">            &#125;</div><div class="line">            return BeanUtils.instanceByCglib(clz,clz.getConstructor(),objects.toArray());</div><div class="line">        &#125;else &#123;</div><div class="line">            return BeanUtils.instanceByCglib(clz,null,null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void populatebean(Object bean) throws Exception &#123;</div><div class="line">        Field[] fields = bean.getClass().getSuperclass().getDeclaredFields();</div><div class="line">        if (fields != null &amp;&amp; fields.length &gt; 0) &#123;</div><div class="line">            for (Field field : fields) &#123;</div><div class="line">                String beanName = field.getName();</div><div class="line">                beanName = StringUtils.uncapitalize(beanName);</div><div class="line">                if (beanNameSet.contains(field.getName())) &#123;</div><div class="line">                    Object fieldBean = getBean(beanName);</div><div class="line">                    if (fieldBean != null) &#123;</div><div class="line">                        ReflectionUtils.injectField(field,bean,fieldBean);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先我们看到在 BeanFactory 的实现中。我们有两 HashMap，beanMap 和 beanDefineMap。 beanDefineMap 存储的是对象的名称和对象对应的数据结构的映射。</p>
<p>容器初始化的时候，会调用 BeanFactoryImpl.registerBean 方法。把 对象的 BeanDefination 数据结构，存储起来。</p>
<p>当我们调用 getBean() 的方法的时候。会先到 beanMap 里面查找，有没有实例化好的对象。如果没有，就会qubeanDefineMap查找这个对象对应的 BeanDefination。再利用DeanDefination去实例化一个对象。</p>
<p>对象实例化成功以后，我们还需要注入相应的参数，调用 populatebean()这个方法。在 populateBean 这个方法中，会扫描对象里面的Field，如果对象中的 Field 是我们IoC容器管理的对象，那就会调用 我们上文实现的 ReflectionUtils.injectField来注入对象。</p>
<p>一切准备妥当之后，我们对象就完成了整个 IoC 流程。最后这个对象放入 beanMap 中,方便下一次使用。</p>
<p>所以我们可以知道 BeanFactory 是管理和生成对象的地方。</p>
<h4 id="4-容器"><a href="#4-容器" class="headerlink" title="4. 容器"></a>4. 容器</h4><p>我们所谓的容器，就是对BeanFactory的扩展，负责管理 BeanFactory。我们的这个IoC 框架使用 Json 作为配置文件，所以我们容器就命名为 JsonApplicationContext。当然之后你愿意实现 XML 作为配置文件的容器你就可以自己写一个 XmlApplicationContext，如果基于注解的容器就可以叫AnnotationApplcationContext。这些实现留个大家去完成。</p>
<p>我们看看 ApplicationContext 的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class JsonApplicationContext extends BeanFactoryImpl&#123;</div><div class="line">    private String fileName;</div><div class="line">    public JsonApplicationContext(String fileName) &#123;</div><div class="line">        this.fileName = fileName;</div><div class="line">    &#125;</div><div class="line">    public void init()&#123;</div><div class="line">        loadFile();</div><div class="line">    &#125;</div><div class="line">    private void loadFile()&#123;</div><div class="line">        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);</div><div class="line">        List&lt;BeanDefinition&gt; beanDefinitions = JsonUtils.readValue(is,new TypeReference&lt;List&lt;BeanDefinition&gt;&gt;()&#123;&#125;);</div><div class="line">        if(beanDefinitions != null &amp;&amp; !beanDefinitions.isEmpty()) &#123;</div><div class="line">            for (BeanDefinition beanDefinition : beanDefinitions) &#123;</div><div class="line">                registerBean(beanDefinition.getName(), beanDefinition);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个容器的作用就是 读取配置文件。将配置文件转换为容器能够理解的 BeanDefination。然后使用 registerBean 方法。注册这个对象。</p>
<p>至此，一个简单版的 IoC 框架就完成。</p>
<h4 id="5-框架的使用"><a href="#5-框架的使用" class="headerlink" title="5. 框架的使用"></a>5. 框架的使用</h4><p>我们写一个测试类来看看我们这个框架怎么使用：</p>
<p>首先我们有三个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Hand &#123;</div><div class="line">    public void waveHand()&#123;</div><div class="line">        System.out.println(&quot;挥一挥手&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Mouth &#123;</div><div class="line">    public void speak()&#123;</div><div class="line">        System.out.println(&quot;say hello world&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Robot &#123;</div><div class="line">    //需要注入 hand 和 mouth </div><div class="line">    private Hand hand;</div><div class="line">    private Mouth mouth;</div><div class="line"></div><div class="line">    public void show()&#123;</div><div class="line">        hand.waveHand();</div><div class="line">        mouth.speak();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们需要为我们的 Robot 机器人注入 hand 和 mouth。</p>
<p>配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;</div><div class="line">    &quot;name&quot;:&quot;robot&quot;,</div><div class="line">    &quot;className&quot;:&quot;com.xilidou.framework.ioc.entity.Robot&quot;</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    &quot;name&quot;:&quot;hand&quot;,</div><div class="line">    &quot;className&quot;:&quot;com.xilidou.framework.ioc.entity.Hand&quot;</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    &quot;name&quot;:&quot;mouth&quot;,</div><div class="line">    &quot;className&quot;:&quot;com.xilidou.framework.ioc.entity.Mouth&quot;</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>这个时候写一个测试类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        JsonApplicationContext applicationContext = new JsonApplicationContext(&quot;application.json&quot;);</div><div class="line">        applicationContext.init();</div><div class="line">        Robot aiRobot = (Robot) applicationContext.getBean(&quot;robot&quot;);</div><div class="line">        aiRobot.show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以后输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">挥一挥手</div><div class="line">say hello world</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure></p>
<p>可以看到我们成功的给我的 aiRobot 注入了 hand 和 mouth。</p>
<p>至此我们 Ioc 框架开发完成。</p>
<blockquote>
<p>引用<a href="https://www.xilidou.com/2018/01/08/spring-ioc/" target="_blank" rel="external">https://www.xilidou.com/2018/01/08/spring-ioc/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h3&gt;&lt;p&gt;Spring 作为 J2ee 开发事实上的标准，是每个Java开发人员都需要了解的框架。但是Spring 的 IoC 和 A
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
