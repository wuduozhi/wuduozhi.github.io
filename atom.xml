<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-21T14:13:50.103Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解计算机系统|虚拟存储器</title>
    <link href="http://yoursite.com/2018/06/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://yoursite.com/2018/06/22/深入理解计算机系统-虚拟存储器/</id>
    <published>2018-06-21T19:46:49.000Z</published>
    <updated>2018-06-21T14:13:50.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>你是否疑惑过为什么两个进程可以拥有同一个地址，明明某个地址处的物理内存只有一块啊。这其实是系统提供的一种对主存的一种抽象，叫做虚拟存储器。它为每个进程提供了一个大的、一致的、和私有的地址空间。虚拟存储器提供了三个重要的能力：</p>
<ol>
<li>将主存作为一个存储在磁盘上的地址空间的缓存。</li>
<li>为每个进程提供一致的地址空间。</li>
<li>保护每个进程的地址空间不被其他进程破坏。</li>
</ol>
<h3 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h3><p>计算机系统的主存被组织成一个有M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址(physical address)。在这种简单的结构中，CPU要访问存储器，最简单的方式就是使用存储器的物理地址，也成为<strong>物理寻址</strong>。</p>
<p><img src="/images/虚拟存储器-02.png" alt=""></p>
<p>当然还有另一种寻址方式，<strong>虚拟寻址</strong>。CPU生成一个虚拟地址来访问主存，这个虚拟地址经过地址翻译生成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。就像异常处理一样，地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做存储器管理单元(Memory Management Unit，MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理。</p>
<p><img src="/images/虚拟存储器-01.png" alt=""></p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>地址空间(adress space)是一个非整数地址的有序集合：{0,1,2,…}。</p>
<p>如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间(linear address space)。在一个带虚拟存储器的系统中，CPU从一个有N = 2 ^ n个地址空间中生成虚拟地址，这个地址空间称为<strong>虚拟地址空间(virtual address space)</strong>：{0,1,2,3,…,N-1}。</p>
<p>一个地址空间的大小是由表示最大地址所需要的倍数来描述的。例如，一个包含N=2^n个地址的虚拟地址空间叫做一个n位地址空间。现在系统典型地支持32位或者64位虚拟地址空间。</p>
<p>一个系统还有一个<strong>物理地址空间(physical addresss space)</strong>，它与系统中物理存储器的M字节相对应：{0,1,2,…M-1}。</p>
<p>地址空间的概念是很重要的，因为它清楚地区分了<strong>数据对象(字节)</strong>和它们的<strong>属性(地址)</strong>。一旦认识到了这种区别，那么我们就可以将其推广，<strong>允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间</strong>。这就是虚拟存储器的基本思想。主存中每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
<h3 id="内存是磁盘的Cache"><a href="#内存是磁盘的Cache" class="headerlink" title="内存是磁盘的Cache"></a>内存是磁盘的Cache</h3><p>概念上而言，虚拟存储器被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。磁盘上的数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘(较低层)上的数据被分割成块，这些块作为磁盘和主存(较高层)之间的传输单元。VM系统通过将虚拟存储器分割称为<strong>虚拟页(Vitual Page，VP)</strong>的大小固定的块来处理这个问题。每个虚拟页的大小为P = 2 ^ n字节。类似地，物理存储器被分割为<strong>物理页(Physical Page，PP)</strong>，大小也为P字节(物理页也称为<strong>页帧(page frame))</strong>。</p>
<p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p>
<ul>
<li>未分配的：VM系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。(没有调用malloc或者mmap的)</li>
<li>缓存的：当前缓存在物理存储中的已分配页。(已经调用malloc和mmap的，在程序中正在引用的)</li>
<li>未缓存的：没有缓存在物理存储器中的已分配页。(已经调用malloc和mmap的，在程序中还没有被引用的)</li>
</ul>
<p><img src="/images/虚拟存储器-03.png" alt=""></p>
<p>上图中，虚拟页0和3还没有被分配，因此在磁盘上还不存在。虚拟页1、4和6被缓存在物理存储器中。页2、5和7已经被分配了，但是当前并未缓存在主存中，只存在于磁盘中。</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到DRAM中，替换这个牺牲页。</p>
<p>这些功能是由许多软硬件联合提供的，包括操作系统软件，MMU(存储器管理单元)中地址翻译硬件和一个存放在物理存储器中叫做<strong>页表(page table)</strong>的数据结构，页表将虚拟页映射到物理页。<strong>页表就是一个页表条目(Page Table Entry，PTE)的数组。</strong>为了简化，设PTE由一个有效位和一个n位地址字段组成。设置了有效位表明虚拟页为已缓存的，地址指向DRAM中相应物理页的起始位置；未设置有效位且地址为空表明虚拟页未分配，否则地址指向磁盘上虚拟页的起始位置。</p>
<p><img src="/images/虚拟存储器-04.png" alt=""></p>
<p>当CPU读取的字在某一虚拟页，且该页已缓存，则称为<strong>页命中</strong>。DRAM缓存不命中称为<strong>缺页</strong>，它触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序选择一个牺牲页，如果该页已经被修改，内核将它写回磁盘，然后内核更新页并返回，异常处理程序返回时会重新启动导致缺页的指令。</p>
<p>在磁盘和存储器之间传送页称为<strong>交换或页面调度</strong>。现代系统采用<strong>按需页面</strong>调度的策略，即当有不命中发生时才换入页面。</p>
<p>局部性原理使程序引用的页面趋向于在一个较小的活动页面集合上工作，该集合称为工作集（常驻集合）。通常虚拟存储器系统工作得很好，但如果工作集的大小超出了物理存储器的大小，那么程序会产生颠簸，即页面不断换进换出。</p>
<p>操作系统为每个进程都提供了一个独立的页表，即一个独立的虚拟地址空间。多个虚拟页面可以映射到同一个共享物理页面上。这带来了很多好处：</p>
<ul>
<li><p>简化链接。独立的地址空间使进程可以为它的存储器映像使用相同的基本格式，而不管代码和数据在物理存储器的实际存放位置。Linux进程的存储器映像可以见前面章节。文本区、栈、共享库、操作系统代码和数据总是从固定的位置开始。</p>
</li>
<li><p>简化共享。独立的地址空间提供了一个管理用户进程和操作系统自身之间共享的一致机制。操作系统将不同进程中的一些虚拟页映射到相同的物理页来使它们共享这部分代码。</p>
</li>
<li><p>简化存储器分配。虚拟存储器是一个向用户进程分配额外存储器的机制。页面可以随机地分散在物理存储器中。</p>
</li>
<li><p>简化加载。虚拟存储器简化了加载可执行文件和已共享目标文件，只需将虚拟页标识为无效的（未缓存）并将PTE指向目标文件的适当位置。实际中加载器并不从磁盘复制数据到存储器，而是在页面被引用时再按需调度。</p>
</li>
</ul>
<p><img src="/images/虚拟存储器-05.png" alt=""></p>
<p>虚拟存储器也可以提供对存储器的访问保护，可以通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问。指令违反许可条件时，CPU触发一个一般保护故障的异常，Linux将它报告为段错误。</p>
<h5 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h5><p>如下图，当CPU读包含在VP2中的虚拟存储器的一个字时，会怎么样呢？从图中，我们知道VP2是被缓存在DRAM中的。地址翻译硬件将虚拟地址作为一个索引来定位<code>PTE2</code>，并从存储器中读取PTE2的的内容。因为设置了有效位，那么地址翻译硬件就知道VP2是缓存在存储器中的了，所以使用PTE2的内容来构造物理地址。</p>
<p><img src="/images/虚拟存储器-06.png" alt=""></p>
<h5 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h5><p>还是刚刚的图，如果CPU访问VP3，我们知道VP3的内容不再DRAM中，那么会发生什么呢？这时会触发一个<strong>缺页异常</strong>。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如下图，选择了PP3中的VP4。</p>
<p><img src="/images/虚拟存储器-07.png" alt=""></p>
<p>如果VP4已经被修改了，那么内核就会将它拷贝回磁盘。无论哪种情况，内核都会修改VP4的页表条目（如上图），反映出VP4已经被换出，不在缓存在内存中的事实。接下来，内核从磁盘拷贝VP3到主存中的PP3，更新VP3的页表条目，然后返回，重启导致缺页的指令。此时，VP3已经在内存中，就会发生页命中。</p>
<h5 id="页分配"><a href="#页分配" class="headerlink" title="页分配"></a>页分配</h5><p>下图展示了操作系统分配一个新的虚拟存储页后对我们页表的影响。例如，当我们调用alloc时，在磁盘上创建空间并更新页表的VP5，让它指向磁盘上一个新的页面。同时，我们也能发现，刚分配的空间，并没有立即在内存中分配空间，只是在页表里添加了一个磁盘的映射。</p>
<p><img src="/images/虚拟存储器-08.png" alt=""></p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>地址翻译是N元素虚拟地址空间（VAS）的元素和M元素物理地址空间（PAS）的元素之间的映射 <code>MAP:VAS-&gt; PAS U Φ</code>。</p>
<ul>
<li>MAP(A) = A’，若虚拟地址A处的数据在物理地址A’处。</li>
<li>MAP(A) = Φ，若虚拟地址A处的数据不在物理存储器中。</li>
</ul>
<p><img src="/images/虚拟存储器-09.png" alt=""></p>
<p>CPU中的<code>页表基址寄存器（PTBR）</code>指向当前页表。n位的虚拟地址包含p位的<code>VPO（虚拟页面偏移</code>）和<code>n-p位的VPN（虚拟页号）</code>两部分，MMU利用<code>VPN</code>选择<code>PTE</code>，将PTE中的<code>PPN（物理页号</code>）和虚拟地址中的<code>VPO</code>串联，得到相应的物理地址。<code>PPO（物理页面偏移）</code>和<code>VPO</code>是相同的。</p>
<h4 id="页命中-1"><a href="#页命中-1" class="headerlink" title="页命中"></a>页命中</h4><p>下图展示了当页命中时，CPU硬件执行的步骤：</p>
<ol>
<li>CPU生成虚拟地址，传送给MMU。</li>
<li>MMU生成PTE地址，向高速缓存/主存请求它。</li>
<li>高速缓存/主存向MMU返回PTE。</li>
<li>MMU构造物理地址，传送给高速缓存/主存。</li>
<li>高速缓存/主存返回所请求的数据。</li>
</ol>
<p><img src="/images/虚拟存储器-10.png" alt=""></p>
<h4 id="缺页-1"><a href="#缺页-1" class="headerlink" title="缺页"></a>缺页</h4><p><img src="/images/虚拟存储器-11.png" alt=""></p>
<p>缺页时，硬件和系统内核协作：</p>
<ol>
<li>和页面命中时前三步相同。</li>
<li>PTE有效位为0，MMU触发异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。 </li>
<li>缺页处理程序确定物理存储器中的牺牲页，若该页已被修改，把它页面换出到磁盘。 </li>
<li>缺页处理程序调入新的页面，更新存储器中的PTE。 </li>
<li>缺页处理程序返回到原来的进程，重新启动导致缺页的指令。重新发送给MMU，页面命中。</li>
</ol>
<h4 id="cache和虚拟存储器的结合"><a href="#cache和虚拟存储器的结合" class="headerlink" title="cache和虚拟存储器的结合"></a>cache和虚拟存储器的结合</h4><p>现在我们将虚拟存储器和之前学过的cache结合起来。高速缓存通常是物理寻址的，地址翻译发生在高速缓存查找之前。所以一次访问的过程如下图：</p>
<p><img src="/images/虚拟存储器-12.png" alt=""></p>
<h4 id="利用TLB加速地址翻译"><a href="#利用TLB加速地址翻译" class="headerlink" title="利用TLB加速地址翻译"></a>利用TLB加速地址翻译</h4><p>为消除查找PTE的开销，在MMU中包含一个PTE的小缓存，称为<strong>TLB（翻译后备缓冲器）</strong>，它是一个小的虚拟寻址的缓存，每行保存一个单个PTE组成的块。TLB有高度的相联性。</p>
<p>若TLB有T = 2^t个组，TLB索引（TLBI）由VPN的t个最低位组成，TLB标记（TLBT）由VPN的剩余的位组成。如下图：</p>
<p><img src="/images/虚拟存储器-13.png" alt=""></p>
<h5 id="TLB命中"><a href="#TLB命中" class="headerlink" title="TLB命中"></a>TLB命中</h5><p>下图展示了TLB命中时的访问步骤：</p>
<ol>
<li>CPU生成虚拟地址，传送给MMU。</li>
<li>MMU从TLB取出相应的PTE</li>
<li>MMU构造物理地址，传送给高速缓存/主存。</li>
<li>高速缓存/主存返回所请求的数据。</li>
</ol>
<p><img src="/images/虚拟存储器-14.png" alt=""></p>
<h5 id="TLB不命中"><a href="#TLB不命中" class="headerlink" title="TLB不命中"></a>TLB不命中</h5><p>当TLB不命中时，MMU需要从L1cache中取出相应的PTE（如下图），新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p>
<p><img src="/images/虚拟存储器-15.png" alt=""></p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>对于32位地址空间、4KB的页面，若PTE为4字节，则页表会达到4MB，64位的地址空间的页表就更加庞大。实际中的系统使用多级页表来压缩页表。这样只有一级页表才需要总在主存中。</p>
<p>k级页表的地址翻译中，虚拟地址被划分为k个VPN和1个VPO。第k级页表中的PTE指向物理页面的PPN。</p>
<p><img src="/images/虚拟存储器-17.png" alt=""></p>
<p>多级页表下的TLB地址组成：</p>
<p><img src="/images/虚拟存储器-16.png" alt=""></p>
<p>讲述到这里，虚拟存储器的内容几乎讲完啦，下面我们用一个图来总结这一切：</p>
<p><img src="/images/虚拟存储器-18.png" alt=""></p>
<h3 id="一些商业系统示例"><a href="#一些商业系统示例" class="headerlink" title="一些商业系统示例"></a>一些商业系统示例</h3><p>在Pentium存储器系统中，有32位地址空间、4KB的页大小、TLB、L1、L2为4路组相联：</p>
<ul>
<li>指令TLB：32个条目、8组。</li>
<li>数据TLB：64个条目、16组。</li>
<li>L1 i-cache和d-cache：16KB、128组、32B块大小。</li>
<li>L2高速缓存：128KB ~ 2MB、32B块大小。</li>
</ul>
<p>Pentium系统使用两级页表，第一级页表称为页面目录，包含1024个32位的PDE（页面目录条目），PDE指向二级页表，每个二级页表包含1024个32位的PTE，PTE指向物理存储器或磁盘上的页面。每个进程有唯一的页面目录和页表集合，页表可以换进换出，页表目录和已分配页面的相关页表常驻存储器。PDBR（页面目录基址寄存器）指向页表目录的起始位置。</p>
<p><img src="/images/虚拟存储器-19.png" alt=""></p>
<p>在Linux系统中，虚拟存储器中位于 0xc0000000 之上的部分为内核虚拟存储器，它包含内核的代码和数据，部分区域映射到所有进程共享的物理页面，其他区域包含每个进程不同的数据。同时，虚拟存储器被组织成区域（段）的集合，区域是已分配的连续组块，以某种方式相关联。不属于某区域的虚拟页是不存在的，不能被引用。区域允许了虚拟地址空间有间隙。</p>
<p><img src="/images/虚拟存储器-20.png" alt=""></p>
<p>内核为每个进程维护一个任务结构 task_struct ，结构中包含运行进程所需的信息。其中一个条目指向 mm_struct ，它描述了虚拟存储器的当前状态。其中两个字段， pgd 指向页面目录表的基址， mmap 指向 vm_area_struct 链表。每个 vm_area_struct 描述当前虚拟地址空间的一个区域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** &lt;linux/mm_types.h&gt; */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;         <span class="comment">/* 区域开始处 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;           <span class="comment">/* 区域结束处 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span> <span class="comment">/* 链表中下一个区域结构 */</span></div><div class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;          <span class="comment">/* 区域内所有页面的读写权限 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;         <span class="comment">/* 区域内的页面是共享的还是私有的, ... */</span></div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="地址翻译示例"><a href="#地址翻译示例" class="headerlink" title="地址翻译示例"></a>地址翻译示例</h3><p>下面，我们来完成一个端到端的地址翻译示例，来综合刚刚讲的内容。</p>
<p>首先，我们做出如下假设：</p>
<ul>
<li>存储器按字节寻址</li>
<li>存储器访问是针对一字节的字的（不是4字节的字）</li>
<li>虚拟地址是14位长的 (n=14)</li>
<li>物理地址是12位长的 (m=12)</li>
<li>页面大小是64字节的 (P=64)</li>
<li>TLB是四路组相连的，总共有16个条目</li>
<li>L1 d-cache是物理寻址、直接映射的，行大小为4字节，总共有16个组</li>
</ul>
<p>下面是相应的虚拟地址和物理地址的格式。</p>
<p><img src="/images/虚拟存储器-21.png" alt=""></p>
<p>下面是讲解例子要使用的小存储器系统的一个快照，包括TLB、页表的一部分和Cahce。</p>
<ul>
<li>TLB地址格式和TLB快照：</li>
</ul>
<p><img src="/images/虚拟存储器-22.png" alt=""></p>
<ul>
<li>页表的部分快照：</li>
</ul>
<p><img src="/images/虚拟存储器-23.png" alt=""></p>
<ul>
<li>cahce快照</li>
</ul>
<p><img src="/images/虚拟存储器-24.png" alt=""></p>
<h4 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h4><p>现在，让我们看看当CPU执行一条读地址<code>0x03d4</code>处字节的加载指令会发生什么。</p>
<p>首先，我们先分析虚拟地址：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>虚拟地址</td>
<td>0x03d4</td>
</tr>
<tr>
<td>二进制表示</td>
<td>00-0011-1101-0100</td>
</tr>
<tr>
<td>VPN</td>
<td>0000-1111 -&gt; 0x0f</td>
</tr>
<tr>
<td>VPO</td>
<td>01-0100 -&gt; 0x14</td>
</tr>
<tr>
<td>TLBI</td>
<td>11 -&gt; 0x03</td>
</tr>
<tr>
<td>TLBT</td>
<td>000011 -&gt; 0x03</td>
</tr>
</tbody>
</table>
<p>从虚拟地址中，我们分解出 <code>VPN</code>,然后得到TLB的 <code>TLBI</code>好<code>TLBT</code> ,接着，我们检查TLB，看它是否因为前面的某个存储器引用，缓存了PTE<code>0x0f</code>的一个拷贝。很幸运，我们找到了，如下图：</p>
<p><img src="/images/虚拟存储器-25.png" alt=""></p>
<p>我们得到了<code>PPN (0x0D)</code> ,返回给MMU。现在，MMU就有了形成物理地址所需要的所有东西了：将来自PTE的<code>PPN (0x0D)</code>和来自虚拟地址的 <code>VPO(0x14)</code>拼接起来，得到了<strong>物理地址 <code>0x354</code></strong>。</p>
<p>接下来，我们分析下物理地址：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理地址</td>
<td>0x345</td>
</tr>
<tr>
<td>二进制表示</td>
<td>0011-0101-0100</td>
</tr>
<tr>
<td>CO</td>
<td>0x0</td>
</tr>
<tr>
<td>CI</td>
<td>0x05</td>
</tr>
<tr>
<td>CT</td>
<td>0x0d</td>
</tr>
<tr>
<td>PPN</td>
<td>0x0d</td>
</tr>
<tr>
<td>PPO</td>
<td>0x14</td>
</tr>
</tbody>
</table>
<p>幸运女神在一次光临我们，我们在cache中找到了地址<code>0x354</code>的拷贝，如下图：</p>
<p><img src="/images/虚拟存储器-26.png" alt=""></p>
<p>所以从cache中读出偏移量CO处的数据字节<code>0x36</code>，并将它返回给MMU，随后MMC返回给CPU。</p>
<p>当然，我们不可能都这么幸运，每次都能在缓存中找到拷贝。</p>
<ul>
<li>如果在TLB中没有缓存，那么MMU就需要从主存的页表中取出相应的PTE。</li>
<li>如果页表中的PTE是无效的，需要产生一个缺页异常，然后内核调入合适的页面。</li>
<li>如果cache中没有缓存，需要根据物理地址到主存中取数据。</li>
</ul>
<p><a href="http://www.yeolar.com/note/2012/03/29/virtual-memory/" target="_blank" rel="external">Linux系统学习笔记：虚拟存储器</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;你是否疑惑过为什么两个进程可以拥有同一个地址，明明某个地址处的物理内存只有一块啊。这其实是系统提供的一种对主存的一种抽象，叫做虚拟存储器。它
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>python|Multiprocessing多进程</title>
    <link href="http://yoursite.com/2018/06/21/python-Multiprocessing%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/06/21/python-Multiprocessing多进程/</id>
    <published>2018-06-20T23:47:38.000Z</published>
    <updated>2018-06-21T17:04:25.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要使用python多进程？"><a href="#为什么要使用python多进程？" class="headerlink" title="为什么要使用python多进程？"></a>为什么要使用python多进程？</h3><p>因为python使用全局解释器锁(GIL)，他会将进程中的线程序列化，也就是多核cpu实际上并不能达到并行提高速度的目的，而使用多进程则是不受限的，所以实际应用中都是推荐多进程的。</p>
<p>如果每个子进程执行需要消耗的时间非常短（执行+1操作等），这不必使用多进程，因为进程的启动关闭也会耗费资源。</p>
<p>当然使用多进程往往是用来处理CPU密集型（科学计算）的需求，如果是IO密集型（文件读取，爬虫等）则可以使用多线程去处理。</p>
<h3 id="multiprocessing常用组件及功能"><a href="#multiprocessing常用组件及功能" class="headerlink" title="multiprocessing常用组件及功能"></a>multiprocessing常用组件及功能</h3><p>创建管理进程模块：</p>
<ul>
<li>Process（用于创建进程模块）</li>
<li>Pool（用于创建管理进程池）</li>
<li>Queue（用于进程通信，资源共享）</li>
<li>Value，Array（用于进程通信，资源共享）</li>
<li>Pipe（用于管道通信）</li>
<li>Manager（用于资源共享）</li>
</ul>
<p>同步子进程模块：</p>
<ul>
<li>Condition</li>
<li>Event</li>
<li>Lock</li>
<li>RLock</li>
<li>Semaphore</li>
</ul>
<h4 id="Process模块"><a href="#Process模块" class="headerlink" title="Process模块"></a>Process模块</h4><p>Process模块用来创建子进程，是Multiprocessing核心模块，使用方式与Threading类似，可以实现多进程的创建，启动，关闭等操作。</p>
<p>构造方法：</p>
<ul>
<li>Process([group [, target [, name [, args [, kwargs]]]]])</li>
<li>group: 线程组，目前还没有实现，库引用中提示必须是None；</li>
<li>target: 要执行的方法；</li>
<li>name: 进程名；</li>
<li>args/kwargs: 要传入方法的参数。</li>
</ul>
<p>实例方法：</p>
<ul>
<li>is_alive()：返回进程是否在运行。</li>
<li>join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。</li>
<li>start()：进程准备就绪，等待CPU调度。</li>
<li>run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。</li>
<li>terminate()：不管任务是否完成，立即停止工作进程。</li>
</ul>
<p>属性：</p>
<ul>
<li>authkey</li>
<li>daemon：和线程的setDeamon功能一样（将父进程设置为守护进程，当父进程结束时，子进程也结束）。</li>
<li>exitcode(进程在运行时为None、如果为–N，表示被信号N结束）。</li>
<li>name：进程名字。</li>
<li>pid：进程号。</li>
</ul>
<h4 id="使用Process创建子进程"><a href="#使用Process创建子进程" class="headerlink" title="使用Process创建子进程"></a>使用Process创建子进程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process  <span class="comment">#导入Process模块 </span></div><div class="line"><span class="keyword">import</span> os  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(name)</span>:</span></div><div class="line">	<span class="string">'''</span></div><div class="line">	函数输出当前进程ID，以及其父进程ID。</div><div class="line">	此代码应在Linux下运行，因为windows下os模块不支持getppid()</div><div class="line">	'''</div><div class="line">    <span class="keyword">print</span> <span class="string">"Process ID： %s"</span> % (os.getpid())  </div><div class="line">    <span class="keyword">print</span> <span class="string">"Parent Process ID： %s"</span> % (os.getppid())  </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </div><div class="line">	<span class="string">'''</span></div><div class="line">	windows下，创建进程的代码一下要放在main函数里面</div><div class="line">	''' </div><div class="line">    proc = Process(target=test, args=(<span class="string">'nmask'</span>,))  </div><div class="line">    proc.start()  </div><div class="line">    proc.join()</div></pre></td></tr></table></figure>
<h4 id="使用Process类继承创建子进程"><a href="#使用Process类继承创建子进程" class="headerlink" title="使用Process类继承创建子进程"></a>使用Process类继承创建子进程</h4><p>通过继承Process类，修改run函数代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></div><div class="line"><span class="string">'''</span></div><div class="line">继承Process类，类似threading.Thread</div><div class="line">'''</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></div><div class="line">        super(MyProcess, self).__init__()</div><div class="line">        <span class="comment">#multiprocessing.Process.__init__(self)</span></div><div class="line">        self.arg = arg</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    重构run函数</div><div class="line">    '''</div><div class="line">        <span class="keyword">print</span> <span class="string">'nMask'</span>, self.arg</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        p = MyProcess(i)</div><div class="line">        p.start()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    	p.join()</div></pre></td></tr></table></figure>
<p>重点讲两个方法：<code>run</code> 和<code>join</code></p>
<ul>
<li>run：如果在创建Process对象的时候不指定target，那么就会默认执行Process的run方法</li>
<li>join方法:阻塞当前进程，直到调用join方法的那个进程执行完，再继续执行当前进程。</li>
</ul>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>.Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行它。在共享资源时，只能使用Multiprocessing.Manager类，而不能使用Queue或者Array。</p>
<p>Pool类用于需要执行的目标很多，而手动限制进程数量又太繁琐时，如果目标少且不用控制进程数量则可以用Process类。</p>
<p>构造方法</p>
<ul>
<li>Pool([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])</li>
<li>processes ：使用的工作进程的数量，如果processes是None那么使用 os.cpu_count()返回的数量。</li>
<li>initializer： 如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)</li>
<li>maxtasksperchild：工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。</li>
<li>context: 用在制定工作进程启动时的上下文，一般使用 multiprocessing.Pool() 或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context。</li>
</ul>
<p>实例方法</p>
<ul>
<li>apply_async(func[, args[, kwds[, callback]]]) 它是非阻塞。</li>
<li>apply(func[, args[, kwds]])是阻塞的。</li>
<li>close() 关闭pool，使其不在接受新的任务。</li>
<li>terminate() 关闭pool，结束工作进程，不在处理未完成的任务。</li>
<li>join() 主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。</li>
</ul>
<h4 id="Pool使用方法"><a href="#Pool使用方法" class="headerlink" title="Pool使用方法"></a>Pool使用方法</h4><h5 id="Pool-map函数"><a href="#Pool-map函数" class="headerlink" title="Pool+map函数"></a>Pool+map函数</h5><p>说明：此写法缺点在于只能通过map向函数传递一个参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">print</span> i</div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	lists=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">	pool=Pool(processes=<span class="number">2</span>) <span class="comment">#定义最大的进程数</span></div><div class="line">	pool.map(test,lists)        <span class="comment">#p必须是一个可迭代变量。</span></div><div class="line">	pool.close()</div><div class="line">	pool.join()</div></pre></td></tr></table></figure>
<h5 id="异步进程池（非阻塞）"><a href="#异步进程池（非阻塞）" class="headerlink" title="异步进程池（非阻塞）"></a>异步进程池（非阻塞）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">from multiprocessing import Pool</div><div class="line">def test(i):</div><div class="line">    print i</div><div class="line">if __name__==&quot;__main__&quot;:</div><div class="line">	pool = Pool(processes=10)</div><div class="line">	for i  in xrange(500):</div><div class="line">		&apos;&apos;&apos;</div><div class="line">		For循环中执行步骤：</div><div class="line">		（1）循环遍历，将500个子进程添加到进程池（相对父进程会阻塞）</div><div class="line">		（2）每次执行10个子进程，等一个子进程执行完后，立马启动新的子进程。（相对父进程不阻塞）</div><div class="line">		</div><div class="line">		apply_async为异步进程池写法。</div><div class="line">		异步指的是启动子进程的过程，与父进程本身的执行（print）是异步的，而For循环中往进程池添加子进程的过程，与父进程本身的执行却是同步的。</div><div class="line">		&apos;&apos;&apos;</div><div class="line">	    pool.apply_async(test, args=(i,)) #维持执行的进程总数为10，当一个进程执行完后启动一个新进程.       </div><div class="line">	print “test”</div><div class="line">	pool.close()</div><div class="line">	pool.join()</div></pre></td></tr></table></figure>
<p>执行顺序：For循环内执行了2个步骤，第一步：将500个对象放入进程池（阻塞）。第二步：同时执行10个子进程（非阻塞），有结束的就立即添加，维持10个子进程运行。（apply_async方法的会在执行完for循环的添加步骤后，直接执行后面的print语句，而apply方法会等所有进程池中的子进程运行完以后再执行后面的print语句）</p>
<p>注意：调用join之前，先调用close或者terminate方法，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束。</p>
<h5 id="同步进程池（阻塞）"><a href="#同步进程池（阻塞）" class="headerlink" title="同步进程池（阻塞）"></a>同步进程池（阻塞）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(p)</span>:</span></div><div class="line">       <span class="keyword">print</span> p</div><div class="line">       time.sleep(<span class="number">3</span>)</div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	pool = Pool(processes=<span class="number">10</span>)</div><div class="line">	<span class="keyword">for</span> i  <span class="keyword">in</span> xrange(<span class="number">500</span>):</div><div class="line">	<span class="string">'''</span></div><div class="line">	实际测试发现，for循环内部执行步骤：</div><div class="line">	（1）遍历500个可迭代对象，往进程池放一个子进程</div><div class="line">	（2）执行这个子进程，等子进程执行完毕，再往进程池放一个子进程，再执行。（同时只执行一个子进程）</div><div class="line">	for循环执行完毕，再执行print函数。</div><div class="line">	'''</div><div class="line">	    pool.apply(test, args=(i,))   <span class="comment">#维持执行的进程总数为10，当一个进程执行完后启动一个新进程.</span></div><div class="line">	<span class="keyword">print</span> “test”</div><div class="line">	pool.close()</div><div class="line">	pool.join()</div></pre></td></tr></table></figure>
<p>说明：for循环内执行的步骤顺序，往进程池中添加一个子进程，执行子进程，等待执行完毕再添加一个子进程…..等500个子进程都执行完了，再执行print “test”。（从结果来看，并没有多进程并发）</p>
<h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h3><p>在使用多进程的过程中，最好不要使用共享资源，如果非得使用，则请往下看。Multiprocessing类中共享资源可以使用3种方式，分别是<code>Queue</code>，<code>Array</code>，<code>Manager</code>。这三个都是Multiprocessing自带的组件，使用起来也非常方便。</p>
<p>注意：<strong>普通的全局变量是不能被子进程所共享的，只有通过Multiprocessing组件构造的数据结构可以被共享。</strong></p>
<h4 id="Queue类"><a href="#Queue类" class="headerlink" title="Queue类"></a>Queue类</h4><p>使用Multiprocessing.Queue类，共享资源（share memory）（只适用Process类）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(queue)</span>:</span>  </div><div class="line">    queue.put(<span class="string">"Hello World"</span>)  </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    q = Queue()  </div><div class="line">    p = Process(target=test, args=(q,))  <span class="comment">#需要将q对象传递给子进程</span></div><div class="line">    p.start()</div><div class="line">    <span class="keyword">print</span> q.get()</div></pre></td></tr></table></figure>
<p>缺点：不能再Pool进程池中使用</p>
<h4 id="Array、Value类"><a href="#Array、Value类" class="headerlink" title="Array、Value类"></a>Array、Value类</h4><p>使用Multiprocessing.Array类，共享资源（share memory）（只适用于Process类）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Array</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</div><div class="line">        a[i] = -a[i]</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    arr = Array(<span class="string">'i'</span>, range(<span class="number">10</span>))</div><div class="line">    p = Process(target=test, args=(arr))  <span class="comment">#需要将arr对象传递给子进程</span></div><div class="line">    p.start()</div><div class="line">    p.join()</div><div class="line">    <span class="keyword">print</span> arr[:]</div></pre></td></tr></table></figure>
<p>缺点：无法与Pool一起使用。</p>
<h4 id="Manager类"><a href="#Manager类" class="headerlink" title="Manager类"></a>Manager类</h4><p>使用Multiprocessing.Manager类，共享资源。（可以适用Pool类）</p>
<p>说明：由于windows操作系统下，创建Multiprocessing类对象代码一定要放在main()函数下，而linux不需要，因此这里区分2个版本。</p>
<p>实例目的：父进程在执行子进程的过程中，同步判断一个公共资源值，如果满足条件则结束所有进程。</p>
<p>linux版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from multiprocessing import Manager,Pool</div><div class="line">lists=Manager().list()    ##定义可被子进程共享的全局变量lists</div><div class="line">def test(i):</div><div class="line">     print i</div><div class="line">     lists.append(i)</div><div class="line">if __name__==&quot;__main__&quot;:</div><div class="line">    pool=Pool()</div><div class="line">    for i in xrange(10000000):</div><div class="line">    	&apos;&apos;&apos;</div><div class="line">    	判断如果lists长度大于0，则不再往进程池中添加进程。</div><div class="line">    	&apos;&apos;&apos;</div><div class="line">        if len(lists)&lt;=0:</div><div class="line">            pool.apply_async(test,args=(i,))</div><div class="line">        else:</div><div class="line">            break</div><div class="line">     pool.close()</div><div class="line">     pool.join()</div></pre></td></tr></table></figure>
<p>优点：可以跟Pool一起用，且速度比较快。</p>
<p>windows版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(i,lists)</span>:</span></div><div class="line">     <span class="keyword">print</span> i</div><div class="line">     lists.append(i)</div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">    pool=Pool()</div><div class="line">    lists=Manager().list() <span class="comment">#Manager类实例化代码只能写在main()函数里面</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10000000</span>):</div><div class="line">        <span class="keyword">if</span> len(lists)&lt;=<span class="number">0</span>:</div><div class="line">        	<span class="string">'''</span></div><div class="line">        	在创建子进程时，需要将lists对象传入，不然无法共享。</div><div class="line">        	'''</div><div class="line">            pool.apply_async(test,args=(i,lists))<span class="comment">##需要将lists对象传递给子进程，这里比较耗资源，原因可能是因为Manager类是基于通信的。</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>说明：与linux版本代码相比，windows下代码将lists的引用放在了main()之后，因为windows下只能在main函数下引用多进程。而在实例化子进程时，必须把Manager对象传递给子进程，否则lists无法被共享，而这个过程会消耗巨大资源，因此性能很差。<br>缺点：速度很慢，因此在windows下想要提前结束所有进程，可以使用获取返回值的方式</p>
<p><a href="https://thief.one/2016/11/23/Python-multiprocessing/" target="_blank" rel="external">【Multiprocessing系列】Multiprocessing基础</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要使用python多进程？&quot;&gt;&lt;a href=&quot;#为什么要使用python多进程？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用python多进程？&quot;&gt;&lt;/a&gt;为什么要使用python多进程？&lt;/h3&gt;&lt;p&gt;因为python使用全局解释
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python|python中的一些妙招</title>
    <link href="http://yoursite.com/2018/06/16/python-python%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A6%99%E6%8B%9B/"/>
    <id>http://yoursite.com/2018/06/16/python-python中的一些妙招/</id>
    <published>2018-06-16T15:58:25.000Z</published>
    <updated>2018-06-21T07:41:03.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近准备入坑python,但又不想从基础的学起，又深知要想掌握一门语言，需要了解其的特性，所以以此文来记录日常发现的一些特性。</p>
<h3 id="python-中的-1"><a href="#python-中的-1" class="headerlink" title="python 中的[::-1]"></a>python 中的[::-1]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> rang(<span class="number">10</span>)涉及的数字倒序输出：</div><div class="line"></div><div class="line">　　<span class="keyword">for</span> value <span class="keyword">in</span> rang(<span class="number">10</span>)[::<span class="number">-1</span>]涉及的数字倒序输出：</div></pre></td></tr></table></figure>
<p>这个是python的slice notation的特殊用法。</p>
<p><code>a = [0,1,2,3,4,5,6,7,8,9]</code><br><code>b = a[i:j]</code> 表示复制a[i]到a[j-1]，以生成新的list对象<br><code>b = a[1:3]</code>那么，b的内容是 [1,2]<br>当i缺省时，默认为0，即 a[:3]相当于 a[0:3]<br>当j缺省时，默认为len(alist), 即a[1:]相当于a[1:10]<br>当i,j都缺省时，a[:]就相当于完整复制一份a了。</p>
<p><code>b = a[i:j:s]</code>这种格式呢，i,j与上面的一样，但s表示步进，缺省为1.<br>所以a[i:j:1]相当于a[i:j]<br>当s&lt;0时，i缺省时，默认为-1. j缺省时，默认为-len(a)-1<br>所以<code>a[::-1]</code>相当于 <code>a[-1:-len(a)-1:-1]</code>，也就是从最后一个元素到第一个元素复制一遍。所以你看到一个倒序的东东。</p>
<h3 id="Python函数-int"><a href="#Python函数-int" class="headerlink" title="Python函数 int()"></a>Python函数 <code>int()</code></h3><p>int(x, [base])</p>
<p>作用：</p>
<p>将一个数字或base类型的字符串转换成整数。</p>
<p>int(x=0)</p>
<p>int(x, base=10)，base缺省值为10，也就是说不指定base的值时，函数将x按十进制处理。</p>
<p>注：</p>
<ol>
<li><p>x 可以是数字或字符串，但是base被赋值后 x 只能是字符串</p>
</li>
<li><p>x 作为字符串时必须是 base 类型，也就是说 x 变成数字时必须能用 base 进制表示</p>
</li>
</ol>
<p>实例：</p>
<ol>
<li><p>x 是数字的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 int(3.14)            # 3</div><div class="line">2 int(2e2)             # 200</div><div class="line">3 int(100, 2)          # 出错，base 被赋值后函数只接收字符串</div></pre></td></tr></table></figure>
</li>
<li><p>x 是字符串的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 int(&apos;23&apos;, 16)      # 35</div><div class="line">2 int(&apos;Pythontab&apos;, 8)      # 出错，Pythontab不是个8进制数</div></pre></td></tr></table></figure>
</li>
<li><p>base 可取值范围是 2~36，囊括了所有的英文字母(不区分大小写)，十六进制中F表示15，那么G将在二十进制中表示16，依此类推….Z在三十六进制中表示35</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 int(&apos;FZ&apos;, 16)      # 出错，FZ不能用十六进制表示</div><div class="line">2 int(&apos;FZ&apos;, 36)      # 575</div></pre></td></tr></table></figure>
</li>
<li><p>字符串 0x 可以出现在十六进制中，视作十六进制的符号，同理 0b 可以出现在二进制中，除此之外视作数字 0 和字母 x</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int(&apos;0x10&apos;, 16)  # 16，0x是十六进制的符号</div><div class="line">int(&apos;0x10&apos;, 17)  # 出错，&apos;0x10&apos;中的 x 被视作英文字母 x</div><div class="line">int(&apos;0x10&apos;, 36)  # 42804，36进制包含字母 x</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Python函数-bin"><a href="#Python函数-bin" class="headerlink" title="Python函数 bin()"></a>Python函数 <code>bin()</code></h3><p>描述</p>
<p>bin() 返回一个整数 int 或者长整数 long int 的二进制表示。<br>语法</p>
<p>以下是 bin() 方法的语法:</p>
<p>bin(x)</p>
<p>参数</p>
<pre><code>x -- int 或者 long int 数字
</code></pre><p>返回值:字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = bin(3) </div><div class="line">&gt;&gt;&gt; b</div><div class="line">&apos;0b11&apos;</div><div class="line">&gt;&gt;&gt; type(b) #获取b的类型</div><div class="line">&lt;class &apos;str&apos;&gt;</div></pre></td></tr></table></figure>
<h3 id="Python-join-方法"><a href="#Python-join-方法" class="headerlink" title="Python join()方法"></a>Python join()方法</h3><p>描述</p>
<p>Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。<br>语法</p>
<p>join()方法语法：</p>
<pre><code>str.join(sequence)
</code></pre><p>参数</p>
<pre><code>sequence -- 要连接的元素序列。
</code></pre><p>返回值：返回通过指定字符连接序列中元素后生成的新字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line">str = <span class="string">"-"</span>;</div><div class="line">seq = (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>); <span class="comment"># 字符串序列</span></div><div class="line"><span class="keyword">print</span> str.join( seq );</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a-b-c</div></pre></td></tr></table></figure>
<h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>
<p>举个例子，要生成<code>list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>可以用<code>list(range(1, 11))</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; list(range(1, 11))</div><div class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</div></pre></td></tr></table></figure></p>
<p>但如果要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>怎么做？方法一是循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = []</div><div class="line">&gt;&gt;&gt; for x in range(1, 11):</div><div class="line">...    L.append(x * x)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; L</div><div class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></pre></td></tr></table></figure></p>
<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</div><div class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></pre></td></tr></table></figure></p>
<p>写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</div><div class="line">[4, 16, 36, 64, 100]</div></pre></td></tr></table></figure></p>
<p>还可以使用两层循环，可以生成全排列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</div><div class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</div></pre></td></tr></table></figure></p>
<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到</div><div class="line">&gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录</div><div class="line">[&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;]</div></pre></td></tr></table></figure></p>
<p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</div><div class="line">&gt;&gt;&gt; for k, v in d.items():</div><div class="line">...     print(k, &apos;=&apos;, v)</div><div class="line">...</div><div class="line">y = B</div><div class="line">x = A</div><div class="line">z = C</div></pre></td></tr></table></figure></p>
<p>因此，列表生成式也可以使用两个变量来生成list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</div><div class="line">&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()]</div><div class="line">[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</div></pre></td></tr></table></figure></p>
<p>最后把一个list中所有的字符串变成小写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]</div><div class="line">&gt;&gt;&gt; [s.lower() for s in L]</div><div class="line">[&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;]</div></pre></td></tr></table></figure></p>
<h3 id="python-range-xrange-区别"><a href="#python-range-xrange-区别" class="headerlink" title="python  range() xrange() 区别"></a>python  range() xrange() 区别</h3><p><code>range()函数</code>：</p>
<p>函数说明：<code>range([start,] stop[, step])</code>，根据start与stop指定的范围以及step设定的步长，生成一个序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; #一个参数的range()</div><div class="line">...</div><div class="line">&gt;&gt;&gt; range(10)</div><div class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line">&gt;&gt;&gt; #两个参数的range()</div><div class="line">...</div><div class="line">&gt;&gt;&gt; range(1,20)</div><div class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</div><div class="line">&gt;&gt;&gt; #带步长的range()函数</div><div class="line">...</div><div class="line">&gt;&gt;&gt; range(1,20,2)</div><div class="line">[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</div></pre></td></tr></table></figure>
<p><code>xrange()函数</code><br>函数说明：用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; xrange(10)</div><div class="line">xrange(10)</div><div class="line">&gt;&gt;&gt; list(xrange(10))</div><div class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line">&gt;&gt;&gt; xrange(1,10)</div><div class="line">xrange(1, 10)</div><div class="line">&gt;&gt;&gt; list(xrange(1,10))</div><div class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line">&gt;&gt;&gt; xrange(1,20,2)</div><div class="line">xrange(1, 21, 2)</div><div class="line">&gt;&gt;&gt; list(xrange(1,21,2))</div><div class="line">[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = range(0,100)</div><div class="line">&gt;&gt;&gt; print type(b)</div><div class="line">&lt;type &apos;list&apos;&gt;</div><div class="line">&gt;&gt;&gt; print b</div><div class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</div><div class="line">&gt;&gt;&gt; print b[0],b[10]</div><div class="line">0 10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = xrange(1,100)</div><div class="line">&gt;&gt;&gt; print type(c)</div><div class="line">&lt;type &apos;xrange&apos;&gt;</div><div class="line">&gt;&gt;&gt; print c</div><div class="line">xrange(1, 100)</div><div class="line">&gt;&gt;&gt; print c[1],c[2]</div><div class="line">2 3</div></pre></td></tr></table></figure>
<p>由上面的示例可以知道：要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间，这两个基本上都是在循环的时候用，可以说是延迟执行的。</p>
<p>range会直接生成一个list对象,而xrange则不会直接生成一个list，而是每次调用返回其中的一个值。所以xrange做循环的性能比range好，尤其是返回很大的时候，尽量用xrange吧，除非你是要返回一个列表。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;最近准备入坑python,但又不想从基础的学起，又深知要想掌握一门语言，需要了解其的特性，所以以此文来记录日常发现的一些特性。&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>干货|如何设计安全的api接口</title>
    <link href="http://yoursite.com/2018/06/14/%E5%B9%B2%E8%B4%A7-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%89%E5%85%A8%E7%9A%84api%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/06/14/干货-如何设计安全的api接口/</id>
    <published>2018-06-13T23:26:42.000Z</published>
    <updated>2018-06-13T16:16:10.863Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.nsfocus.net/rest-api-d/esign-safety" target="_blank" rel="external">REST API 安全设计指南</a><br><a href="https://www.cnblogs.com/codelir/p/5327462.html" target="_blank" rel="external">开放api接口签名验证</a><br><a href="https://www.xncoding.com/2016/07/29/web/form.html" target="_blank" rel="external">防止表单重复提交</a><br><a href="https://mrxf.github.io/2017/09/25/using-the-jwt-for-api-to-add-authentication/" target="_blank" rel="external">前后端分离的身份认证(一)：JSON WEB TOKEN介绍</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.nsfocus.net/rest-api-d/esign-safety&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;REST API 安全设计指南&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnbl
    
    </summary>
    
      <category term="干货" scheme="http://yoursite.com/categories/%E5%B9%B2%E8%B4%A7/"/>
    
    
      <category term="干货" scheme="http://yoursite.com/tags/%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>干货|理解OAuth 2.0</title>
    <link href="http://yoursite.com/2018/06/12/%E5%B9%B2%E8%B4%A7-%E7%90%86%E8%A7%A3OAuth-2-0/"/>
    <id>http://yoursite.com/2018/06/12/干货-理解OAuth-2-0/</id>
    <published>2018-06-12T12:27:44.000Z</published>
    <updated>2018-06-12T05:34:56.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OAuth2-0是什么"><a href="#OAuth2-0是什么" class="headerlink" title="OAuth2.0是什么"></a>OAuth2.0是什么</h3><p>OAuth2.0是什么——豆瓣和QQ的故事</p>
<p>OAuth简单说就是一种授权的协议，只要授权方和被授权方遵守这个协议去写代码提供服务，那双方就是实现了OAuth模式。</p>
<p>举个例子，你想登录豆瓣去看看电影评论，但你丫的从来没注册过豆瓣账号，又不想新注册一个再使用豆瓣，怎么办呢？不用担心，豆瓣已经为你这种懒人做了准备，用你的qq号可以授权给豆瓣进行登录，请看。</p>
<p><a href="https://www.cnblogs.com/flashsun/p/7424071.html" target="_blank" rel="external">一张图搞定OAuth2.0</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">理解OAuth 2.0</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OAuth2-0是什么&quot;&gt;&lt;a href=&quot;#OAuth2-0是什么&quot; class=&quot;headerlink&quot; title=&quot;OAuth2.0是什么&quot;&gt;&lt;/a&gt;OAuth2.0是什么&lt;/h3&gt;&lt;p&gt;OAuth2.0是什么——豆瓣和QQ的故事&lt;/p&gt;
&lt;p&gt;OAuth
    
    </summary>
    
      <category term="干货" scheme="http://yoursite.com/categories/%E5%B9%B2%E8%B4%A7/"/>
    
    
      <category term="干货" scheme="http://yoursite.com/tags/%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|链接器</title>
    <link href="http://yoursite.com/2018/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5%E5%99%A8/"/>
    <id>http://yoursite.com/2018/06/05/深入理解计算机系统-链接器/</id>
    <published>2018-06-04T19:41:08.000Z</published>
    <updated>2018-06-05T10:49:21.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>链接（Linking）是把各种代码和数据部分收集起来并组合成为一个单一文件的过程。</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>个简单的C语言的例子：</p>
<p>main.c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">int</span> buf[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	swap();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>swap.c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> buf[];</div><div class="line"></div><div class="line"><span class="keyword">int</span> *bufp0 = &amp;buf[<span class="number">0</span>];</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> *bufp1;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    bufp1 = &amp;buf[<span class="number">1</span>];</div><div class="line">    temp = *bufp0;</div><div class="line">    *bufp0 = *bufp1;</div><div class="line">    *bufp1 = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unix&gt; gcc -O2 -g -o p main.c swap.c</div><div class="line">unix&gt; ./p</div></pre></td></tr></table></figure></p>
<p>这个方法就是使用了静态链接。</p>
<p><img src="/images/链接-01.png" alt=""></p>
<p>首先，把源代码分别使用Translators(cpp)进行预处理。</p>
<p><code>cpp [other args] main.c /tmp/main.i</code><br>接下来，驱动程序运行C编译器(cc1)，把main.i翻译为ASCII汇编语言文件main.s</p>
<p><code>cc1 –O2 [other args] /tmp/main.i main.c -o /tmp/main.s</code><br>然后，运行汇编器(as)，把main.s翻译成一个可重定位目标文件(relocatable object file) main.o</p>
<p><code>as [other args] /tmp/main.s -o /tmp/main.o</code><br>最后，运行连接器程序(ld)，把main.o和swap.o以及一些必要的系统文件结合起来，创建一个可执行目标文件(executable object file)m。</p>
<p><code>ld [system obj files and args] /tmp/main.o /tmp/swap.o -o p</code></p>
<p>要需要运行可执行文件m，只需要在shell中输入它的名字就可以运行了。</p>
<p><code>$ ./p</code></p>
<p>shell会调用一个叫做加载器的函数，它拷贝可执行文件m中的代码和数据到存储器，然后转移控制到这个程序的开头。</p>
<h3 id="为什么要用链接"><a href="#为什么要用链接" class="headerlink" title="为什么要用链接"></a>为什么要用链接</h3><p><code>模块化</code></p>
<ul>
<li>程序不用写成一个巨大的源文件，而是可以分成多个更小、更好管理的源文件（模块）</li>
<li>可以创建一些公用的函数库，例如数学库、标准C库等</li>
</ul>
<p><code>效率(Efficiency)</code></p>
<ul>
<li>时间上: 分别编译<ul>
<li> 修改一个源文件，重新编译，然后重新链接</li>
<li> 不必重编译其他源文件</li>
</ul>
</li>
<li>空间上: 使用库 ，无需包含共享库所有代码<ul>
<li> 常用的函数可以聚合到单个文件</li>
<li> 而可执行文件和运行时的内存中只包含它们实际调用的函数的代码，不需要包含整个共享库</li>
</ul>
</li>
</ul>
<p>当程序很小的时候，效率就不会成为一个重要的问题。但是当一个程序大到包含千千万万个模块，那么每次编译都需要把所有的代码都编译一遍吗？这未免太夸张了。对于一个操作系统级别的程序，整体编译一遍会特别耗时间。使用了链接之后，就不必重新编译所有的文件。</p>
<h3 id="链接做什么"><a href="#链接做什么" class="headerlink" title="链接做什么"></a>链接做什么</h3><p><code>符号解析(Symbol resolution)</code></p>
<ul>
<li><p>程序中有定义和引用的符号 (包括变量和函数等)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;…&#125; <span class="comment">/* 定义符号swap */</span></div><div class="line">swap(); <span class="comment">/* 引用符号swap */</span></div><div class="line"><span class="keyword">int</span> *xp = &amp;x; <span class="comment">/* 定义符号 xp, 引用符号 x */</span></div></pre></td></tr></table></figure>
</li>
<li><p>编译器将符号的定义储存在一个符号表（symbol table）中</p>
<ul>
<li>符号表是一个结构数组</li>
<li>每个条目包含符号的名称、长度和位置信息</li>
</ul>
</li>
<li>链接器将每个符号的引用都与一个符号定义关联起来</li>
</ul>
<p><code>重定位</code></p>
<ul>
<li><p>将多个代码段与数据段分别合并为一个统一的代码段和数据段（从地址0开始）</p>
</li>
<li><p>将.o文件中的每个符号从相对位置重新定位到可执行文件中的最终绝对内存位置</p>
</li>
<li><p>将这些符号在符号表中的位置信息更新为重定位后的位置信息</p>
</li>
</ul>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><ul>
<li>静态链接器(UNIX ld 程序)<br> 输入：一组可重定位的目标文件<br> 输出：一个完全链接的可以加载运行的可执</li>
</ul>
<h4 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h4><p>下图展示了一个典型的ELF可重定位目标文件的格式：</p>
<p><img src="/images/链接-02.png" alt="ELF"></p>
<ul>
<li><p>.text：已编译程序的机器代码。</p>
</li>
<li><p>.rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。</p>
</li>
<li><p>.data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。</p>
</li>
<li><p>.bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。</p>
</li>
<li><p>.symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。</p>
</li>
<li><p>.rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。</p>
</li>
<li><p>.rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。</p>
</li>
<li><p>.debug：一个调试符号表，其有些表目是程序中定义的局部变量和类型定义，有些表目是程序中定义和引用的全局变量，有些是原始的C源文件。只有以-g选项调用编译驱动程序时，才会得到这张表。</p>
</li>
<li><p>.line：原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译驱动程序时，才会得到这张表。</p>
</li>
<li><p>.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。</p>
</li>
</ul>
<h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>每个可重定位目标模块m都有一个符号表，它包含了在m中定义和引用的所有符号。有三种链接器符号：</p>
<ul>
<li>Global symbols（模块内部定义的全局符号）<ul>
<li>由模块m定义并能被其他模块引用的符号。例如，非static C函数和非static的C全局变量（指不static的全局变量）</li>
<li>如，main.c 中的全局变量名buf</li>
</ul>
</li>
<li>External symbols（外部定义的全局符号）<ul>
<li>由其他模块定义并被模块m引用的全局符号</li>
<li>如，main.c 中的函数名swap</li>
</ul>
</li>
<li>Local symbols（本模块的本地符号）<ul>
<li>仅由模块m定义和引用的本地符号。例如，在模块m中定义的带static的C函数和全局变量</li>
<li>如，swap.c 中的static变量名bufp1</li>
</ul>
</li>
</ul>
<p>需要注意的是：链接器本地符号不是指程序中的局部变量（分配在栈中的临时性变量）,链接器不关心这种局部变量。</p>
<p><img src="/images/链接-03.png" alt="符号例子"></p>
<h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>符号表（.symtab节）中每个条目的结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    int name; /*指向符号对应字符串在strtab表中的偏移*/</div><div class="line">    int value; /*在对应section中的偏移量，可执行文件中是虚拟地址*/</div><div class="line">    int size; /*符号对应目标所占字节数*/</div><div class="line">    char type: 4, /*符号对应目标的类型：数据、函数、节、源文件名*/</div><div class="line">         binding: 4; /*符号对应目标是本地符号还是全局符号*/</div><div class="line">    char reserved;</div><div class="line">    char section; /*符号对应目标所在的section的节头表索引，或伪节*/</div><div class="line">&#125; Elf_Symbol;</div></pre></td></tr></table></figure></p>
<p>三个伪节：ABS表示不该被重定位；UNDEF表示未定义；COMMON表示未初始化数据（.bss），此时，value表示对齐要求，size给出最小大小。</p>
<p>下面是main.o的符号表：</p>
<p><img src="/images/链接-04.png" alt="main符号表"></p>
<p>buf是main.o中第3节（.data）偏移为0的符号，是全局变量，占8B； main是第1节（.text）偏移为0的符号，是全局函数，占18B； swap是main.o中未定义的符号，不知道类型和大小，全局的（在其他模块定义）。</p>
<p>下面是swap.o的符号表：</p>
<p><img src="/images/链接-05.png" alt="swap符号表"></p>
<h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><p>目的：将每个模块中引用的符号与某个目标模块中的定义符号建立关联。</p>
<ul>
<li><p>每个定义符号在代码段或数据段中都被分配了存储空间，将引用符号与对应定义符号建立关联后，就可在重定位时将引用符号的地址重定位为相关联的定义符号的地址。</p>
</li>
<li><p>本地符号在本模块内定义并引用，因此，其解析较简单，只要与本模块内唯一的定义符号关联即可。</p>
</li>
<li><p>全局符号（外部定义的、内部定义的）的解析涉及多个模块，故较复杂</p>
</li>
</ul>
<p>“符号的定义”其实质是什么？是指符号被分配了虚拟地址空间。</p>
<ul>
<li>符号为函数名即指其代码所在区；</li>
<li>符号为变量即指其占的静态数据区</li>
</ul>
<h5 id="全局符号处理的问题"><a href="#全局符号处理的问题" class="headerlink" title="全局符号处理的问题"></a>全局符号处理的问题</h5><ul>
<li>编译器遇到一个不在当前模块定义的符号<ul>
<li>生成一个链接器符号表，交给链接器处理</li>
<li>链接器如果在所有输入模块中找不到这个被引用的符号,链接器输出错误信息并终止</li>
</ul>
</li>
<li>多个目标文件可能定义相同的符号<ul>
<li>链接器标志一个错误，输出错误信息并终止</li>
<li>或按某种方法选择一个定义，抛弃其他定义</li>
</ul>
</li>
<li>编译器 、 汇编器和链接器之间协作进行处理</li>
<li>程序员不清楚这个流程会带来麻烦]</li>
</ul>
<p>程序的全局符号不是强符号就是弱符号:</p>
<ul>
<li>Strong:函数名和已初始化的全局变量名是强符号</li>
<li>Weak:未初始化的全局变量名是弱符号</li>
</ul>
<p><img src="/images/链接-06.png" alt=""></p>
<p>符号解析的例子：</p>
<p><img src="/images/链接-07.png" alt=""></p>
<p><code>链接器的符号解析规则</code></p>
<ul>
<li>Rule 1: 强符号不能多次定义<ul>
<li>强符号只能被定义一次，否则链接错误</li>
</ul>
</li>
<li>Rule 2: 强符号覆盖同名的弱符号（若一个符号被定义为一次强符号和多次弱符号，则按强符号定义为准）<ul>
<li>对弱符号的引用被解析为其同名的强符号</li>
</ul>
</li>
<li>Rule 3: 若有多个弱符号定义，则选择其中任意一个<ul>
<li>使用命令 gcc –fno-common链接时，会告诉链接器在遇到多个弱符号定义的全局符号时输出一条警告信息。</li>
</ul>
</li>
</ul>
<p>多重定义符号的解析示例:</p>
<p><img src="/images/链接-08.png" alt=""></p>
<p>避免多重定义全局符号的建议：</p>
<ul>
<li>尽量避免使用全局变量</li>
<li>一定需要用的话，就按以下规则使用<br> 尽量使用本地变量（static）<br> 全局变量要赋初值<br> 外部全局变量要使用extern</li>
</ul>
<p>多重定义全局变量会造成一些意想不到的错误，而且是默默发生的，编译系统不会警告，并会在程序执行很久后才能表现出来，且远离错误引发处。特别是在一个具有几百个模块的大型软件中，这类错误很难修正。</p>
<p>大部分程序员并不了解链接器如何工作，因而养成良好的编程习惯是非常重要的。</p>
<h4 id="与静态链接库链接"><a href="#与静态链接库链接" class="headerlink" title="与静态链接库链接"></a>与静态链接库链接</h4><p><code>静态库 (.a archive files)</code></p>
<ul>
<li>通过索引将所有相关的可重定位目标文件（目标模块）打包为一个单独的文件，称为静态库 ，也称为存档（archive）</li>
<li>增强链接器，使其试图通过查找一个或多个存档的符号来解析无法解析的外部引用</li>
<li>如果存档中某个成员文件解析了引用，就将该成员文件链接到可执行文件（链接器只拷贝静态库里被程序引用的目标模块）</li>
<li>在gcc命令行中无需显示指定C标准库libc.a(默认库)</li>
</ul>
<h5 id="静态库的创建"><a href="#静态库的创建" class="headerlink" title="静态库的创建"></a>静态库的创建</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unix&gt; gcc –c atoi.c printf.c … random.c</div><div class="line">unix&gt; ar rs libc.a atoi.o printf.o … random.o</div></pre></td></tr></table></figure>
<p><img src="/images/链接-09.png" alt=""></p>
<p>为了使我们对库的理解更加深刻，假设我们想在一个叫做libvector.a的链接库中提供addvec.c和multvec.c的向量处理程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* addvec.c */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y,<span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">	z[i] = x[i] + y[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* multvec.c */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">multvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y,<span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">	z[i] = x[i] * y[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了创建该库，我们使用AR工具，具体操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unix&gt; gcc -c addvec.c multvec.c</div><div class="line">unix&gt; ar rcs libvector.a addvec.o multvec.o</div></pre></td></tr></table></figure>
<p>为了使用这个库，我们编写一个应用，如下main2.c：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* main2.c */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    addvec(x, y, z, <span class="number">2</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"z = [%d %d]\n"</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*vector.h*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y,<span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">multvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y,<span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span> </span>;</div></pre></td></tr></table></figure>
<p>我们编译这个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">unix&gt; gcc –O2 –c main2.c</div><div class="line">unix&gt; gcc –static –o p2 main2.o ./libvector.a</div><div class="line">unix&gt; ./p2</div><div class="line">z = [4 6]</div></pre></td></tr></table></figure>
<p><code>-static</code>参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标程序，它可以加载到存储器并执行，在加载时无需更进一步的链接。下图描述了这个过程：</p>
<p><img src="/images/链接-10.png" alt=""></p>
<h5 id="链接器使用静态库解析外部引用的过程"><a href="#链接器使用静态库解析外部引用的过程" class="headerlink" title="链接器使用静态库解析外部引用的过程"></a>链接器使用静态库解析外部引用的过程</h5><ul>
<li>从左到右扫描命令行中的可重定位目标文件（.o文件）和存档文件（.a 文件）</li>
<li>所有.c文件会被链接器自动翻译成.o文件</li>
<li>链接器在扫描过程中维护三个集合<ul>
<li>可重定位目标文件<code>集合E</code> ：集合中所有文件最终会被合并以组成可执行文件</li>
<li>未解析的符号的<code>集合U</code>：引用了但尚未定义的符号</li>
<li>已定义的符号<code>集合D</code>：前面输入文件中已定义的所有符号</li>
</ul>
</li>
<li>E、U、D初始为空</li>
</ul>
<h5 id="链接器解析外部引用的算法"><a href="#链接器解析外部引用的算法" class="headerlink" title="链接器解析外部引用的算法"></a>链接器解析外部引用的算法</h5><p>对每个命令行输入文件f，判断是目标文件还是存档</p>
<ul>
<li>f 是目标文件<ul>
<li>链接器把f添加到E，修改U和D来反映f中的符号定义和引用</li>
<li>继续下一个输入文件</li>
</ul>
</li>
<li>f 是存档文件<ul>
<li>链接器尝试匹配U中未解析符号和存档文件中成员定义符号</li>
<li>如果在存档成员m，定义了一个符号解析U中的引用，将m加入到E，修改U和D来反映m中的符号定义和引用</li>
<li>对存档文件所有成员目标文件反复进行上述过程，直到U和D不再发<br>生变化</li>
<li>不包含在E中的成员目标文件被直接丢弃</li>
<li>链接器继续处理下一个输入文件</li>
</ul>
</li>
<li>完成命令行上输入文件的扫描<ul>
<li>如果U是非空，链接器输出错误并终止；</li>
<li>如果U为空，合并E中所有目标文件，构建输出可执行文件；</li>
</ul>
</li>
</ul>
<h5 id="链接顺序问题"><a href="#链接顺序问题" class="headerlink" title="链接顺序问题"></a>链接顺序问题</h5><p><img src="/images/链接-11.png" alt=""></p>
<h3 id="重定位与动态链接"><a href="#重定位与动态链接" class="headerlink" title="重定位与动态链接"></a>重定位与动态链接</h3><p>符号解析完成后，可进行重定位工作，由两步组成：</p>
<ul>
<li>对节和符号定义进行重定位<ul>
<li>将集合E的所有目标模块中相同的节合并成新的聚合节，并将运行时的虚拟地址赋给每个新节中所有定义的符号。</li>
<li>例如，所有.text节合并作为可执行文件中的.text节，并为每个.text节确定在新.text节中的绝对地址，从而为其中定义的函数确定首地址（含有多个函数时），进而确定每条指令的地址。</li>
<li>完成这一步后，每条指令和每个全局变量都有唯一的运行时地址。</li>
</ul>
</li>
<li>对节中的符号引用进行重定位<ul>
<li>修改.text节和.data节中对每个符号的引用（指向正确的运行时地址）。</li>
<li>需要用到在.rel_data和.rel_text节中保存的重定位信息。</li>
</ul>
</li>
</ul>
<p>下图是链接的目的：</p>
<p><img src="/images/链接-12.png" alt=""></p>
<h4 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h4><p>当汇编器生成一个目标模块时，它并不知道数据和代码最终将存放在存储器的什么位置，也不知道当前模块引用的任何外部定义的函数或全局变量的位置。汇编器遇到对位置未知的目标引用时，生成一个<code>重定位条目</code>，已初始化数据引用的重定位条目在<code>.rel_data</code>节中,指令中引用的重定位条目在<code>.rel_text</code>节中。</p>
<p>ELF中重定位条目的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </div><div class="line">    <span class="keyword">int</span> offset;     <span class="comment">/* offset of the reference to relocate */</span> </div><div class="line">    <span class="keyword">int</span> symbol:<span class="number">24</span>,  <span class="comment">/* symbol the reference should point to */</span> </div><div class="line">	type:<span class="number">8</span>;     <span class="comment">/* relocation type */</span> </div><div class="line">&#125; Elf32_Rel</div></pre></td></tr></table></figure>
<p>有两种最基本的重定位类型（11种重定位类型）</p>
<ul>
<li><code>R_386_PC32</code>: 使用32位PC相对地址的引用，PC为下条指令地址</li>
<li><code>R_386_32</code>: 使用32位绝对地址</li>
</ul>
<p>在main.o的<code>.rel_text</code>节中有重定位条目:</p>
<p><img src="/images/链接-13.png" alt=""></p>
<p>说明在<code>.text</code>节中偏移为0x7的地方需重定位,引用的符号为swap,按PC相对地址方式修改。</p>
<h5 id="重定位算法伪代码"><a href="#重定位算法伪代码" class="headerlink" title="重定位算法伪代码"></a>重定位算法伪代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">foreach section s &#123;</div><div class="line">   foreach relocation entry r &#123;</div><div class="line">   refptr = s + r.offset; <span class="comment">/* ptr to reference to be relocated*/</span></div><div class="line">   <span class="comment">/* relocate a pc-relative reference*/</span></div><div class="line">   <span class="keyword">if</span> ( r.type == R_386_PC32) &#123;</div><div class="line">       refaddr = ADDR(s) + r.offset; <span class="comment">/*ref’s run-time address*/</span></div><div class="line">       *refptr = (<span class="keyword">unsigned</span>)(ADDR(r.symbol) + *refptr – refaddr);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">/*relocate an absolute reference */</span></div><div class="line">  <span class="keyword">if</span> ( r.type == R_386_32)</div><div class="line">      *refptr = (<span class="keyword">unsigned</span>) (ADDR(r.symbol)+ *refptr);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>算法描述 ：</p>
<ul>
<li>1-2 行 ： 在每个节s 及其关联的重定位条目r 上迭代执行</li>
<li>节s 是字节数组 ， 运行时地址为ADDR(s), 重定位条目r 是Elf32_Rel结构 ， 运行时地址为ADDR(r.symbol)</li>
<li>3 行 ： 计算需要被重定位的引用的数组s 中的地址</li>
<li>5-9 行 ： 使用PC 相对定位寻址计算重定位地址</li>
<li>11-31 行 ：使用绝对寻址计算重定位地址</li>
</ul>
<p>下面让我们来看看main.o重定位前的样子：</p>
<p><img src="/images/链接-14.png" alt=""></p>
<p>从上图中，我们知道：</p>
<ul>
<li>main的定义在.text节中偏移为0处开始，占0x12B</li>
<li>buf的定义在.data节中偏移为0处开始，占8B</li>
<li>在rel_text节中的重定位条目为：<code>r_offset=0x7</code>,<code>r_sym=swap</code>,<code>r_type=R_386_PC32</code>，objdump出来后为<code>“7: R_386_PC32 swap”</code></li>
</ul>
<p>main.o的符号表：</p>
<p><img src="/images/链接-15.png" alt=""></p>
<p>swap是main.o的符号表中第10项，是未定义符号，类型和大小未知，并是全局符号，故在其他模块中定义。</p>
<p>用命令<code>readelf -r main.o</code>或者<code>objdump -r -j .text main.o</code>可以查看目标文件中的重定位信息：偏移值/重定位类型/引用符号。</p>
<p><img src="/images/链接-16.png" alt=""></p>
<h5 id="R-386-PC32-的重定位方式-相对引用"><a href="#R-386-PC32-的重定位方式-相对引用" class="headerlink" title="R_386_PC32 的重定位方式( 相对引用)"></a><code>R_386_PC32</code> 的重定位方式( 相对引用)</h5><p>假定：</p>
<p>ADDR(s) = ADDR(.text) = <code>0x80483b4</code></p>
<p>由于mian函数在<code>.text</code>的起始位置，所以 ADDR(main) = <code>0x80483b4</code>;同时swap紧跟main后，所以swap起始地址: ADDR(swap) = <code>0x80483b4</code>+<code>0x12</code>=<code>0x80483c6</code>,(main占0x12字节)，但是在4字节边界对齐的情况下，ADDR(swap) = <code>0x80483c8</code>。</p>
<p>则重定位后call指令的机器代码是什么？</p>
<ul>
<li>call转移目标地址 = PC+偏移地址，PC=<code>0x80483b4</code>+<code>0x07</code> - init</li>
<li>PC = <code>0x80483b4</code>+<code>0x07</code>-<code>(-4)</code>= <code>0x80483bf</code></li>
<li>重定位值 = 偏移地址 = 转移目标地址-PC=0x80483c8-0x80483bf=0x9</li>
<li>重定位后call指令的机器代码为“e8 09 00 00 00 ” (小端表示)</li>
</ul>
<p>可以总结，PC相对地址方式下，重定位值计算公式为：</p>
<p><img src="/images/链接-17.png" alt=""></p>
<p>main.o中.data和.rel.data节内容：</p>
<p><img src="/images/链接-18.png" alt=""></p>
<p>buf定义在.data节中偏移为0处，占8B，没有需重定位的符号。</p>
<p>swap.o中.data和.rel.data节内容：</p>
<p><img src="/images/链接-19.png" alt=""></p>
<p><img src="/images/链接-20.png" alt=""></p>
<p>bufp0定义在.data节中偏移为0处，占4B，初值为0x0。重定位节<code>.rel.data</code>中有一个重定位表项：<code>r_offset=0x0</code>,<code>r_sym=buf</code>,<code>r_type=R_386_32</code>，OBJDUMP工具解释后显示为<code>“0：R_386_32 buf”</code></p>
<p> swap.o中的符号表中:</p>
<p><img src="/images/链接-21.png" alt=""></p>
<p>buf是swap.o的符号表中第10项，是未定义符号，类型和大小未知，并是全局符号，故在其他模块中定义。</p>
<p>用命令<code>readelf -r swap.o</code>或者<code>objdump -r -j .data swap.o</code>可以查看目标文件中的重定位信息：偏移值/重定位类型/引用符号。</p>
<p><img src="/images/链接-22.png" alt=""></p>
<h5 id="R-386-32-的重定位方式"><a href="#R-386-32-的重定位方式" class="headerlink" title="R_386_32 的重定位方式"></a><code>R_386_32</code> 的重定位方式</h5><p>假定：buf在运行时的存储地址 <code>ADDR(buf)=0x8049454</code></p>
<p>则重定位后，bufp0的地址及内容变为什么？</p>
<ul>
<li>buf和bufp0同属于.data节，故在可执行文件中它们被合并</li>
<li>bufp0紧接在buf后，故地址为0x8049454+8= 0x804945c</li>
<li>因是R_386_32方式，故bufp0内容为buf的绝对地址<code>0x8049454</code>，即“54 94 04 08”</li>
</ul>
<p>可执行目标文件p中.data节的内容:</p>
<p><img src="/images/链接-23.png" alt=""></p>
<p>swap.o重定位信息：</p>
<p><img src="/images/链接-24.png" alt=""></p>
<p><img src="/images/链接-25.png" alt=""></p>
<p>重定位后的可执行程序 (.text)：</p>
<p><img src="/images/链接-26.png" alt=""></p>
<h3 id="可执行目标格式"><a href="#可执行目标格式" class="headerlink" title="可执行目标格式"></a>可执行目标格式</h3><p><img src="/images/链接-27.png" alt=""></p>
<h3 id="可执行目标文件的存储器映像"><a href="#可执行目标文件的存储器映像" class="headerlink" title="可执行目标文件的存储器映像"></a>可执行目标文件的存储器映像</h3><p><img src="/images/链接-28.png" alt=""></p>
<h3 id="加载时的动态链接"><a href="#加载时的动态链接" class="headerlink" title="加载时的动态链接"></a>加载时的动态链接</h3><ul>
<li>静态链接库的缺点:<ul>
<li>存储可执行程序中可能存在同一段公共代码的多个拷贝。（例如： 每个c程序都有c标准库）</li>
<li>多个进程的虚拟存储空间可能有同一段代码的多个拷贝.</li>
<li>对系统库的小的修改都需要每个应用程序显式重新链接</li>
</ul>
</li>
</ul>
<p>现代解决方法: 共享库</p>
<pre><code>- 包含数据和代码的目标文件在加载或执行时动态链接到应用程序中
- 也叫动态链接库, 包括DLLs, .so files
</code></pre><p><img src="/images/链接-29.png" alt=""></p>
<p>为了构造上图中向量运算的的示例程序的共享库libvector.so ,我们调用编译器，给链接器如下特殊指令：</p>
<p><code>unix&gt; gcc -shared -fPIC -o libvector.so addvec.c multvec.c</code></p>
<p><code>-fPIC</code>告诉编译器生成与位置无关的代码，<code>-shared</code>告诉链接器创建一个共享的目标文件。</p>
<p><img src="/images/链接-30.png" alt=""></p>
<p>动态库创建好了，然后我们进行链接到我们的程序中：</p>
<p><code>unix&gt; gcc -o p2 main2.c ./libvector.so</code></p>
<p>这样就创建了一个可执行目标文件p2,而此文件的形式使得它在运行时可以和 libvector.so 链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后程序加载时，动态完成链接过程。</p>
<p>还有一点是需要知道的：<strong>没有任何libvector.so的代码和数据节真的被拷贝到可执行文件p2中。反之，链接器只拷贝了一些重定位和符号表信息，它们使得在运行是可以解析对libvector.so中代码和数据的引用。</strong></p>
<h4 id="运行时的动态链接"><a href="#运行时的动态链接" class="headerlink" title="运行时的动态链接"></a>运行时的动态链接</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *handle;</div><div class="line">    <span class="keyword">void</span> (*addvec)(<span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span>);</div><div class="line">    <span class="keyword">char</span> *error; </div><div class="line"></div><div class="line">    <span class="comment">/* dynamically load the shared library that contains addvec() */</span></div><div class="line">    handle = dlopen(<span class="string">"./libvector.so"</span>, RTLD_LAZY);</div><div class="line">    <span class="keyword">if</span> (!handle) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* get a pointer to the addvec() function we just loaded */</span></div><div class="line">    addvec = dlsym(handle, <span class="string">"addvec"</span>);</div><div class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, error);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Now we can call addvec() it just like any other function */</span></div><div class="line">    addvec(x, y, z, <span class="number">2</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"z = [%d %d]\n"</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    <span class="comment">/* unload the shared library */</span></div><div class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dlopen</code>以指定模式打开指定的动态连接库文件，并返回一个句柄给调用进程，dlerror返回出现的错误，<code>dlsym</code>通过句柄和连接符名称获取函数名或者变量名，    dlclose    来卸载打开的库。 dlopen打开模式如下：</p>
<ul>
<li>RTLD_LAZY 暂缓决定，等有需要时再解出符号 </li>
<li>RTLD_NOW 立即决定，返回前解除所有未决定的符号。</li>
</ul>
<p>我们通过以下命令编译我们的这个程序：</p>
<p><code>unix&gt; gcc -rdynamic -o2 -o p3 dll.c -ldl</code></p>
<p><img src="/images/链接-31.png" alt=""></p>
<p>下面我们通过ldd命令来看看p2，p3所需要的共享库：</p>
<p><img src="/images/链接-32.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h3&gt;&lt;p&gt;链接（Linking）是把各种代码和数据部分收集起来并组合成为一个单一文件的过程。&lt;/p&gt;
&lt;h4 id=&quot;一个例子&quot;&gt;&lt;a
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP的类自动加载机制</title>
    <link href="http://yoursite.com/2018/06/04/PHP-PHP%E7%9A%84%E7%B1%BB%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/06/04/PHP-PHP的类自动加载机制/</id>
    <published>2018-06-03T19:06:12.000Z</published>
    <updated>2018-06-03T14:24:24.453Z</updated>
    
    <content type="html"><![CDATA[<p>在PHP开发过程中，如果希望从外部引入一个class，通常会使用include和require方法，去把定义这个class的文件包含进来。这个在小规模开发的时候，没什么大问题。但在大型的开发项目中，这么做会产生大量的require或者include方法调用，这样不因降低效率，而且使得代码难以维护，况且require_once的代价很大。</p>
<p>在PHP5之前，各个PHP框架如果要实现类的自动加载，一般都是按照某种约定自己实现一个遍历目录，自动加载所有符合约定规则的文件的类或函数。 当然，PHP5之前对面向对象的支持并不是太好，类的使用也没有现在频繁。 在PHP5后，当加载PHP类时，如果类所在文件没有被包含进来，或者类名出错，Zend引擎会自动调用<code>__autoload</code> 函数。此函数需要用户自己实现<code>__autoload</code>函数。 在PHP5.1.2版本后，可以使用<code>spl_autoload_register</code>函数自定义自动加载处理函数。当没有调用此函数，默认情况下会使用SPL自定义的<code>spl_autoload</code>函数。</p>
<h4 id="autoload示例"><a href="#autoload示例" class="headerlink" title="__autoload示例"></a><code>__autoload</code>示例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($class_name)</span> </span>&#123;  </div><div class="line">   <span class="keyword">echo</span> <span class="string">'__autload class:'</span>, $class_name, <span class="string">'&lt;br /&gt;'</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">new</span> Demo();</div></pre></td></tr></table></figure>
<p>以上的代码在最后会输出：__autload class:Demo。<br>并在此之后报错显示： Fatal error: Class ‘Demo’ not found</p>
<p>我们一般使用_autoload自动加载类如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($class_name)</span> </span>&#123;  </div><div class="line">   <span class="keyword">echo</span> <span class="string">'__autload class:'</span>, $class_name, <span class="string">'&lt;br /&gt;'</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">new</span> Demo();</div></pre></td></tr></table></figure>
<p>我们可以看出_autoload至少要做三件事情:</p>
<ul>
<li>第一件事是根据类名确定类文件名</li>
<li>第二件事是确定类文件所在的磁盘路径[在我们的例子是最简单的情况，类与调用它们的PHP程序文件在同一个文件夹下]</li>
<li>第三件事是将类从磁盘文件中加载到系统中。</li>
</ul>
<p>第三步最简单，只需要使用include/require即可。要实现第一步，第二步的功能，必须在开发时约定类名与磁盘文件的映射方法，只有这样我们才能根据类名找到它对应的磁盘文件。 </p>
<p>因此，当有大量的类文件要包含的时候，我们只要确定相应的规则，然后在<code>__autoload()</code>函数中，将类名与实际的磁盘文件对应起来，就可以实现lazy loading的效果。从这里我们也可以看出<code>__autoload()</code>函数的实现中最重要的是类名与实际的磁盘文件映射规则的实现。 </p>
<p>但现在问题来了，假如在一个系统的实现中，假如需要使用很多其它的类库，这些类库可能是由不同的开发工程师开发，其类名与实际的磁盘文件的映射规则不尽相同。这时假如要实现类库文件的自动加载，就必须在<code>__autoload()</code>函数中将所有的映射规则全部实现，因此<code>__autoload()</code>函数有可能会非常复杂，甚至无法实现。最后可能会导致<code>__autoload()</code>函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。在这种情况下，在PHP5引入SPL标准库,一种新的解决方案，即<code>spl_autoload_register()</code>函数。</p>
<h4 id="spl-autoload-register-函数"><a href="#spl-autoload-register-函数" class="headerlink" title="spl_autoload_register()函数"></a>spl_autoload_register()函数</h4><p><strong>此函数的功能就是把函数注册至SPL的<code>__autoload</code>函数栈中，并移除系统默认的<code>__autoload()</code>函数</strong>。下面的例子可以看出：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($class_name)</span> </span>&#123;  </div><div class="line">    <span class="keyword">echo</span> <span class="string">'__autload class:'</span>, $class_name, <span class="string">'&lt;br /&gt;'</span>;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">classLoader</span><span class="params">($class_name)</span> </span>&#123;  </div><div class="line">    <span class="keyword">echo</span> <span class="string">'SPL load class:'</span>, $class_name, <span class="string">'&lt;br /&gt;'</span>;  </div><div class="line">&#125;  </div><div class="line">spl_autoload_register(<span class="string">'classLoader'</span>);  </div><div class="line"><span class="keyword">new</span> Test();<span class="comment">//结果：SPL load class:Test</span></div></pre></td></tr></table></figure>
<p>语法：<code>bool  spl_autoload_register ( [callback $autoload_function] )</code>   接受两个参数：一个是添加到自动加载栈的函数，另外一个是加载器不能找到这个类时是否抛出异常的标志。第一个参数是可选的，并且默认指向<code>spl_autoload()</code>函数，这个函数会自动在路径中查找具有小写类名和.php扩展或者.ini扩展名，或者任何注册到<code>spl_autoload_extensions()</code>函数中的其它扩展名的文件。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalssLoader</span>     </span></div><div class="line">&#123;     </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">loader</span><span class="params">($classname)</span>     </span></div><div class="line">    &#123;     </div><div class="line">        $class_file = strtolower($classname).<span class="string">".php"</span>;     </div><div class="line">        <span class="keyword">if</span> (file_exists($class_file))&#123;     </div><div class="line">            <span class="keyword">require_once</span>($class_file);     </div><div class="line">        &#125;     </div><div class="line">    &#125;     </div><div class="line">&#125;      </div><div class="line"><span class="comment">// 方法为静态方法     </span></div><div class="line">spl_autoload_register(<span class="string">'CalssLoader::loader'</span>);      </div><div class="line">$test = <span class="keyword">new</span> Test();</div></pre></td></tr></table></figure></p>
<p>一旦调用<code>spl_autoload_register()</code>函数，当调用未定义类时，系统会按顺序调用注册到<code>spl_autoload_register()</code>函数的所有函数，而不是自动调用<code>__autoload()</code>函数。如果要避免这种情况，需采用一种更加安全的<code>spl_autoload_register()</code>函数的初始化调用方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">false</span> === spl_autoload_functions())&#123;      </div><div class="line">    <span class="keyword">if</span>(function_exists(<span class="string">'__autoload'</span>))&#123;      </div><div class="line">        spl_autoload_registe(<span class="string">'__autoload'</span>,<span class="keyword">false</span>);      </div><div class="line">    &#125;      </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><code>spl_autoload_functions()</code>函数会返回已注册函数的一个数组,如果SPL自动加载栈还没有被初始化,它会返回布尔值false。然后，检查是否有一个名为<code>__autoload()</code>的函数存在,如果存在，可以将它注册为自动加载栈中的第一个函数，从而保留它的功能。之后，可以继续注册自动加载函数。</p>
<p>还可以调用<code>spl_autoload_register()</code>函数以注册一个回调函数,而不是为函数提供一个字符串名称。如提供一个如<code>array(&#39;class&#39;,&#39;method&#39;)</code>这样的数组,使得可以使用某个对象的方法。</p>
<p>下一步，通过调用<code>spl_autoload_call(&#39;className&#39;)</code>函数，可以手动调用加载器，而不用尝试去使用那个类。这个函数可以和函数<code>class_exists(&#39;className&#39;,false)</code>组合在一起使用以尝试去加载一个类，并且在所有的自动加载器都不能找到那个类的情况下失败。 </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(spl_autoload_call(<span class="string">'className'</span>) &amp;&amp; class_exists(<span class="string">'className'</span>,<span class="keyword">false</span>))&#123;      </div><div class="line">    </div><div class="line">  &#125; <span class="keyword">else</span> &#123;      </div><div class="line">    </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>SPL自动加载功能是由<code>spl_autoload()</code> ,<code>spl_autoload_register()</code>, <code>spl_autoload_functions()</code> ,<code>spl_autoload_extensions()</code>和<code>spl_autoload_call()</code>函数提供的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在PHP开发过程中，如果希望从外部引入一个class，通常会使用include和require方法，去把定义这个class的文件包含进来。这个在小规模开发的时候，没什么大问题。但在大型的开发项目中，这么做会产生大量的require或者include方法调用，这样不因降低效率
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>大学|BAT之路</title>
    <link href="http://yoursite.com/2018/06/03/%E5%A4%A7%E5%AD%A6-BAT%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/06/03/大学-BAT之路/</id>
    <published>2018-06-03T00:43:58.000Z</published>
    <updated>2018-06-02T17:15:16.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>今天胡哥叫了分来来自百度、阿里巴巴、腾讯[BAT] 的学长回来开一场主题为“BAT之路”的分享会，自己还是VIP专属座位呢，很荣幸了。</p>
<p><img src="/images/BAT之路.jpg" alt=""></p>
<h3 id="弦歌-蓝杰学长"><a href="#弦歌-蓝杰学长" class="headerlink" title="弦歌.蓝杰学长"></a>弦歌.蓝杰学长</h3><p>胡鹏威学长即是弦歌的，也是蓝杰的，自己跟学长的经历有点类似了，但相比之下，还是学长经历丰富一点：</p>
<ul>
<li>大二开始实习</li>
<li>创业</li>
<li>金山云</li>
<li>百度</li>
<li>腾讯</li>
</ul>
<p><img src="/images/BAT之路--胡鹏威.jpg" alt=""></p>
<p>这里还是要谢谢学长一下：之前学长有帮忙内推过百度，同时，还指导修改简历，很感动了，虽然最后结局并没有那么美好。自己也有做的不对的地方，事后也应该问一下学长自己为什么没有过，原因在哪里。同时，也可以继续请学长帮忙内推其他部门。记下了。</p>
<p>说到自己，自己暑假也有一个去深信服实习机会，但暑假有小学期，然后自己就犹豫要不要去？今天听了学长的分享，自己下决心了：去！！第一份实习挺难找的，同时，深信服也是一家不错的公司了，听说伙食还很好，没什么理由不去。</p>
<p><strong>如果不能一步到达目的地，那就远的那条路，只要到达了就好了。</strong>学长毕业时，没被腾讯选中，进入自己理想的公司，但是学长先后去了很多公司，58，搜狐，百度，然后才去腾讯，最终还是去了自己想去的公司。是的，我们可能不是那些幸运儿，能一步到达我们想要去的公司，但是我们可以先去其他的公司，把其当做跳板，像跳一跳那样，一步一步去到我们想要去的地方。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;今天胡哥叫了分来来自百度、阿里巴巴、腾讯[BAT] 的学长回来开一场主题为“BAT之路”的分享会，自己还是VIP专属座位呢，很荣幸了。&lt;/p
    
    </summary>
    
      <category term="college" scheme="http://yoursite.com/categories/college/"/>
    
    
      <category term="college" scheme="http://yoursite.com/tags/college/"/>
    
  </entry>
  
  <entry>
    <title>数据库|读sql必知必会</title>
    <link href="http://yoursite.com/2018/05/31/%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%AF%BBsql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>http://yoursite.com/2018/05/31/数据库-读sql必知必会/</id>
    <published>2018-05-31T15:08:58.000Z</published>
    <updated>2018-06-05T16:25:52.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h3><ul>
<li><p><code>百分号(%)通配符</code>：在搜索串中，<strong>%表示任何字符出现任意次数</strong>。</p>
</li>
<li><p><code>下划线(_)通配符</code>：下划线通配符只匹配单个字符而不是多个字符。</p>
</li>
<li><p><code>方括号([])匹配符</code>:方括号([])通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。也可以在前面用^来否定。</p>
</li>
</ul>
<p>通配符何以在搜索模式中任意位置使用，并且可以使用多个通配符，同时，也能混合使用不同的通配符。需要注意的是，通配符搜索的处理一般会花费一定的时间代价。</p>
<h3 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h3><p>存储在数据库表中的数据一般不是应用程序所需要的格式，我们需要直接从数据库中检索出转换、计算或格式化过的数据，而不是检索出数据，然后再在客户机应用程序中重新格式化。</p>
<p>可以通过<code>计算字段</code>、<code>拼接字段</code>、<code>使用别名</code>、<code>执行算术计算</code>的方法来获得我们需要的数据格式。</p>
<h3 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h3><p>与其他计算机语言一样，sql支持利用函数来处理数据，给数据的转换和处理提供了方便。不过，使用函数也会带来一些问题：不同的DBMS提供的函数不同，所以使用函数的sql可移植性不高</p>
<p>一般支持如下函数：</p>
<ul>
<li>用于处理文本串（如删除或填充值，转换为大写或小写）的文本函数</li>
<li>用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数</li>
<li>用于处理日期和时间的时间和日期函数</li>
<li>返回DBMS信息的系统函数</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用通配符进行过滤&quot;&gt;&lt;a href=&quot;#用通配符进行过滤&quot; class=&quot;headerlink&quot; title=&quot;用通配符进行过滤&quot;&gt;&lt;/a&gt;用通配符进行过滤&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;百分号(%)通配符&lt;/code&gt;：在搜索串中，&lt;strong&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|Cache详解</title>
    <link href="http://yoursite.com/2018/05/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-Cache%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/26/深入理解计算机系统-Cache详解/</id>
    <published>2018-05-26T00:08:38.000Z</published>
    <updated>2018-05-29T02:44:20.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>随着工艺的提升最近几十年CPU的频率不断提升，而受制于制造工艺和成本限制，目前计算机的内存主要是DRAM并且在访问速度上没有质的突破。因此，CPU的处理速度和内存的访问速度差距越来越大，甚至可以达到上万倍。这种情况下传统的CPU通过FSB直连内存的方式显然就会因为内存访问的等待，导致计算资源大量闲置，降低CPU整体吞吐量。同时又由于内存数据访问的热点集中性，在CPU和内存之间用较为快速而成本较高的SRAM做一层缓存，就显得性价比极高了。</p>
<h3 id="Cache结构"><a href="#Cache结构" class="headerlink" title="Cache结构"></a>Cache结构</h3><p><img src="/images/cache-01.png" alt="cache结构"></p>
<p>如上图，高速缓存可以用元组（S,E,B，m）来表示。高速缓存是一个高速缓存组的数组，每个组包含一个多个行，每个行包含一个有效位，一些标记位，以及一些数据块。在元组中，S表示有多少组，E表示一个组内有多少行，B表示一个行内有多少个数据块，m 表示存储器[内存]地址的位数。在cpu内部，会将地址按下图划分：</p>
<p><img src="/images/cache-02.png" alt="cache地址划分"></p>
<p>其中，s为组索引且${2^s=S}$,b为块偏移且${s^b=B}$，t为标记位且$t=m-b-s$。</p>
<p>这样划分有利于快速判断CPU请求的数据是否在高速缓存中。通过组索引，我们就能知道要请求的数据必须存储在那个组中，然后，<code>t</code>个标记位可以告诉我们组中的哪一行包含这个字(如果有的话)。当且仅当设置了有效位并且该行的标记位与请求地址中的标记位相匹配时，组中的这一行才包含这个字。一旦我们在由组索引标识的组中定位到了有标号所标识的行，那么<code>b</code> 个块偏移位给出了我们想要的数据的偏移地址。</p>
<p>如果你不是很明白上述所说的，请耐心往下看。</p>
<h3 id="缓存结构的分类"><a href="#缓存结构的分类" class="headerlink" title="缓存结构的分类"></a>缓存结构的分类</h3><p>根据E（每个组的高速缓存行数）高速缓存被分为不同的类。</p>
<h4 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h4><p><img src="/images/cache-03.png" alt="直接映射高速缓存"></p>
<p>每个组只有一行的（E=1）的高速缓存称为<code>直接映射</code>高速缓存(direct-mapped cache)。直接映射高速缓存是最容易理解的，接下来让我们用一个例子来说明这一切。</p>
<p>高速缓存会通过三个步骤来确定一个请求的数据是否在缓存中：</p>
<h5 id="组选择"><a href="#组选择" class="headerlink" title="组选择"></a>组选择</h5><p>在这一步中，高速缓存从 w 的地址中抽取去 s 个组索引位，s 个索引位被解释成一个无符号数。可以换个角度理解，我们可以把高速索引看成是一个关于组的一维数组，s 个索引位被解释成的无符号数就是这个数组的索引。如下图：</p>
<p><img src="/images/cache-04.png" alt="直接映射高速缓存"></p>
<p>上图中，组索引位 [00001] 被解释成一个选择组1的整数索引。</p>
<h5 id="行匹配"><a href="#行匹配" class="headerlink" title="行匹配"></a>行匹配</h5><p>在上一步中，我们确定了组。在接下来的行选择中，要分为2个步骤：</p>
<ul>
<li>检查有效位</li>
<li>检查标记位</li>
</ul>
<p>只有两个步骤都成功了，才能确定请求的数据在高速缓存中，且就在所找到的这个行中。如下图：</p>
<p><img src="/images/cache-05.png" alt="直接映射高速缓存"></p>
<h5 id="字选择"><a href="#字选择" class="headerlink" title="字选择"></a>字选择</h5><p>通过上面两个步骤，我们确定了请求的数据所在的组与行，最后一步就是确定数据在行的块偏移量。还是上图，通过块偏移，我们能得到所需数据的第一个字节的偏移。就像我们把高速缓存看成是组的数组一样，我们把块看成是一个字节的数据，块偏移提供了数组的索引。</p>
<h4 id="来看一个实际的例子"><a href="#来看一个实际的例子" class="headerlink" title="来看一个实际的例子"></a>来看一个实际的例子</h4><p>首先假设我们有一个直接映射的高速缓存，描述如下：<code>(S,E,B,m)=(4,1,2,4)</code>。如果你理解了上述说的内容，那么就一定知道这些参数的意义。换句话说，高速缓存有四个组、每个组一行，每个块两个字节，地址是四位的。首先，我们先对四位的地址的不同的表示位找出来，如图：</p>
<p><img src="/images/cache-13.png" alt="地址划分"></p>
<p>有四个组，所以需要2个二进制位来表示组号；每个块有两个字节，只需要一个bit来表示偏移量即可。注意到存储器一共有 16 个字节的大小，但我们的高速缓存只有 2*4=8 个字节的大小，很显然，高速缓存中不能同时装下所有的存储器中的数据。</p>
<p>有了地址的划分，我们就能根据地址来请求的数据是否能在高速缓存中命中了。如地址<code>0101</code>映射的地址为<code>10</code>也就是在组2中，标记位为<code>0</code>,块偏移位<code>1</code>。</p>
<p>初始时，高速缓存是空的，即每个组的有效位都是0，如下图：</p>
<p><img src="/images/cache-14.png" alt="初始"></p>
<p>需要注意的组号信息是没有存储在高速缓存中的，也就是下图中圈起来的部分：</p>
<p><img src="/images/cache-15.png" alt="初始"></p>
<p>然后，我们以如下地址顺序读取数据：</p>
<ol>
<li><code>0000</code></li>
<li><code>0001</code></li>
<li><code>1101</code></li>
<li><code>1000</code></li>
<li><code>0000</code></li>
</ol>
<h5 id="读地址0000的字"><a href="#读地址0000的字" class="headerlink" title="读地址0000的字"></a>读地址<code>0000</code>的字</h5><p>有地址<code>0000</code>可知映射的高速缓存的内容是：组<code>0</code>，标记<code>0</code>,块偏移<code>0</code>。因为组0的有效位是<code>0</code>,是缓存不命中。高速缓存从存储器（或第一层的高速缓存）取出块0，并存入组0中。然后，高速缓存返回新取出的高速缓存行的块[0]的<code>m[0]</code>(存储器位置0的内容)。此时高速缓存的状态如下图：</p>
<p><img src="/images/cache-16.png" alt="读地址0000"></p>
<p>注意到，我们取地址<code>0000</code>的数据的同时，也把地址<code>0001</code>的数据加载到了高速缓存中了，为什么呢？这里就需要明确<strong>数据总是以<code>块大小</code>为传输单元在第 k 层和第 k+1 层之间来回拷贝的</strong>。高速缓存的块大小为 2 个字节，所以每次都会加载 2 个字节的数据到高速缓存中。</p>
<h5 id="读地址0001的字"><a href="#读地址0001的字" class="headerlink" title="读地址0001的字"></a>读地址<code>0001</code>的字</h5><p>不难发现这会是一个高速缓存命中。高速缓存解析地址后，会发现在组0中有请求地址的数据，并根据块偏移 <code>1</code> 返回<code>组0</code>中块[1]中的m[1],并且高速缓存状态没有变化。</p>
<h5 id="读地址1101的字"><a href="#读地址1101的字" class="headerlink" title="读地址1101的字"></a>读地址<code>1101</code>的字</h5><p>根据地址<code>1101</code>能得到组索引位<code>10</code>，也就是组2。由于组二中的高速缓存行有效位为0，缓存不命中。高速缓存会把访问存储器，把地址<code>1100</code>和地址<code>1101</code>的数据加载在高速缓存的组2中，并返回组2中的块1的数据。如下图：</p>
<p><img src="/images/cache-17.png" alt="读地址1101"></p>
<p>不知道大家有没有疑问：<strong>为什么是加载地址12和地址13的数据而不是加载地址13和地址14的数据呢？原因是地址12和地址13同映射到组2，所以高速缓存会加载加载地址12和地址13的数据而不是加载地址13和地址14的数据。</strong></p>
<h5 id="读地址1000的字"><a href="#读地址1000的字" class="headerlink" title="读地址1000的字"></a>读地址<code>1000</code>的字</h5><p>这会发生缓存不命中。地址<code>1000</code>映射到组0，且组0的有效位为1，但是地址<code>1000</code>的标记位为<code>1</code>,高速缓存组0的标记位<code>0</code>,两者不匹配，所以是缓存不命中。高速缓存将地址8和地址9的数据加载到组0中（替换读地址0是读入的行)，然后返回组0的块0的数据。如下图：</p>
<p><img src="/images/cache-18.png" alt="读地址1000"></p>
<h5 id="读地址0000的字-1"><a href="#读地址0000的字-1" class="headerlink" title="读地址0000的字"></a>读地址<code>0000</code>的字</h5><p>这又会发生缓存不命中。因为在前面读地址<code>1000</code>时，我们正好替换了读地址<code>0000</code>时加载的组0。需要注意的是，这就是<code>冲突不命中</code>,不难发现，此时高速缓存是有空闲空间的，但是因为交替地引用映射到同一个组的块而发生缓存不命中。这也是直接映射的最大的缺点。</p>
<p><img src="/images/cache-17.png" alt="读地址0000"></p>
<h4 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h4><p>直接映射高速缓存中造成冲突不命中的根源是每个组只有一个行，这样，对于高速缓存中的数据，加载到高速缓存中是的位置是唯一确定的，当交替访问映射到同一个组的数据时就会发生冲突不命中。但是组相联高速缓存(set associative cache)放松了限制，每一个组不在是只有一个行，而是有多个行。<strong>一个<code>1&lt;E&lt;C/B</code>的高速缓存通常称为<code>E路组相联高速缓存</code></strong>。结构如下如图：</p>
<p><img src="/images/cache-07.png" alt="组相联高速缓存"></p>
<p>接下来我们分别讨论<code>组相联高速缓存</code>结构的组选择、行匹配和字选择。</p>
<h5 id="组相联高速缓存的组选择"><a href="#组相联高速缓存的组选择" class="headerlink" title="组相联高速缓存的组选择"></a>组相联高速缓存的组选择</h5><p>组相联高速缓存的组选择与直接映射高速缓存的组选择是一样的，都是根据<code>组索引位</code>来标识组。如下图：</p>
<p><img src="/images/cache-08.png" alt="组相联高速缓存"></p>
<h5 id="组相联高速缓存的行匹配"><a href="#组相联高速缓存的行匹配" class="headerlink" title="组相联高速缓存的行匹配"></a>组相联高速缓存的行匹配</h5><p>在行匹配是，有一个总要的思想：<strong>组中的任何一个行都可以包含任何映射到这个组的存储器块</strong>。这也就是说，高速缓存需要搜索组中的每一行，寻找一个有效的行，其标记与地址中的标记相匹配。只有找到了，才能说明缓存名中。具体操作如下如图：</p>
<p><img src="/images/cache-09.png" alt="组相联高速缓存"></p>
<h5 id="组相联高速缓存的字选择"><a href="#组相联高速缓存的字选择" class="headerlink" title="组相联高速缓存的字选择"></a>组相联高速缓存的字选择</h5><p>字选择的方法也与直相联接映射高速缓存的方法一样，也是根据块偏移来得到块的起始位置。</p>
<h4 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h4><p>一个<code>全相链高速缓存</code>（fully associative cache）是由一个包含所有高速缓存行的组（即E=C/B)组成的。如下图：</p>
<p><img src="/images/cache-10.png" alt="全相联高速缓存"></p>
<h5 id="全相联高速缓存的组选择"><a href="#全相联高速缓存的组选择" class="headerlink" title="全相联高速缓存的组选择"></a>全相联高速缓存的组选择</h5><p>全相联高速缓存中的组选择非常简单，因为我们不需要选择。既然这样，那么在地址划分中也不需要划分组索引位了，只需要划分标记位和块偏移位。</p>
<p><img src="/images/cache-11.png" alt="全相联高速缓存"></p>
<h5 id="全相联高速缓存的行匹配和字选择"><a href="#全相联高速缓存的行匹配和字选择" class="headerlink" title="全相联高速缓存的行匹配和字选择"></a>全相联高速缓存的行匹配和字选择</h5><p>全相联高速缓存的行匹配和字选择与组相联高速缓存的方法一致，但是全相联高速缓存只有一个组，包含了所有的行，也就是所每一次都需要去匹配所有行的标记位，看是否有匹配的行。显而易见，如果高速缓存规模稍大的话，标记位匹配会是一个耗时且困难的过程。也正因此，全相联高速缓存只适合做规模小的高速缓存，例如虚拟存储器系统中的<code>翻译备用缓冲器[TLB]</code>,它的作用是缓存页表。</p>
<h4 id="关于为什么选择中间的位来确定组索引"><a href="#关于为什么选择中间的位来确定组索引" class="headerlink" title="关于为什么选择中间的位来确定组索引"></a>关于为什么选择中间的位来确定组索引</h4><p><img src="/images/cache-06.png" alt="为什么选择中间的位来确定组索引"></p>
<p>上图很好说明了原因：如果用高位做索引，那么一些连续的存储器块就会映射到相同的高速缓冲块。例如图中的头四个块映射到第一个高速缓存组，第二个四个块映射到第二个组，依此类推。如果一个程序有良好的<code>局部性</code>,顺序访问一个数组的元素，那么在任何时刻，高速缓存都只保存着一个块大小的数组内容。这样对高速缓存的利用效率就很低。相对而言，用中间位作为索引，相联的块总是映射到不同的高速缓存行。在这种情况下，高速缓存能够存放整个大小为<code>C[高速缓存的大小]</code>的<code>数组片</code>。</p>
<h4 id="有关写的问题"><a href="#有关写的问题" class="headerlink" title="有关写的问题"></a>有关写的问题</h4><ul>
<li><p>处理写命中:</p>
<ul>
<li><p>直写:立即将w的高速缓存块写会到紧接着的下一层。</p>
<ul>
<li>优点:简单</li>
<li>缺点:引起总线流量，速度慢</li>
</ul>
</li>
<li><p>写回:尽可能地推迟操作，只有当替换算法要驱逐时更新。</p>
<ul>
<li>优点:减少总线流量。</li>
<li>缺电:复杂，额外维护一个修改位。</li>
</ul>
</li>
</ul>
</li>
<li><p>处理写不命中</p>
<ul>
<li><p>写分配:加载相应的低一层块到高速缓存中，然后更新这个高速缓存块。</p>
<ul>
<li>跟写回搭配。</li>
</ul>
</li>
<li><p>写不分配:直接写到低层。</p>
<ul>
<li>跟直写搭配。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;随着工艺的提升最近几十年CPU的频率不断提升，而受制于制造工艺和成本限制，目前计算机的内存主要是DRAM并且在访问速度上没有质的突破。因此，
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PDO数据库操作</title>
    <link href="http://yoursite.com/2018/05/23/PHP-PDO%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/05/23/PHP-PDO数据库操作/</id>
    <published>2018-05-23T13:26:50.000Z</published>
    <updated>2018-05-23T05:29:07.811Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h3><p>PHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。</p>
<p>PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。</p>
<h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">	$dbms=&apos;mysql&apos;;     //数据库类型 Oracle 用ODI,对于开发者来说，使用不同的数据库，只要改这个，不用记住那么多的函数了</div><div class="line">	$host=&apos;localhost&apos;; //数据库主机名</div><div class="line">	$dbName=&apos;test&apos;;    //使用的数据库</div><div class="line">	$user=&apos;jtahstu&apos;;      //数据库连接用户名</div><div class="line">	$pass=&apos;jtahstu&apos;;          //对应的密码</div><div class="line">	$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;</div><div class="line">	try &#123;</div><div class="line">		$dbh=new PDO($dsn, $user, $pass);</div><div class="line">		//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT =&gt; true) 变成这样：</div><div class="line">		//$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT =&gt; true));</div><div class="line">		echo &quot;数据库连接成功！&lt;br&gt;&quot;;</div><div class="line">		$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</div><div class="line">// 			foreach ($dbh-&gt;query(&apos;SELECT * from information&apos;) as $row) &#123;</div><div class="line">// 				echo $row[0].&quot;&lt;br&gt;&quot;;</div><div class="line">// 				echo $row[1].&quot;&lt;br&gt;&quot;;</div><div class="line">// 				echo $row[2].&quot;&lt;br&gt;&quot;;</div><div class="line">// 				echo $row[3].&quot;&lt;br&gt;&quot;;</div><div class="line">// 				echo $row[4].&quot;&lt;br&gt;&quot;;</div><div class="line">// 			&#125;</div><div class="line">		</div><div class="line">		$a=$dbh-&gt;exec(&quot;insert into information values(&apos;6&apos;,&apos;PDO教程&apos;,&apos;jtahstu&apos;,&apos;电子&apos;,&apos;2015-11-24&apos;)&quot;);</div><div class="line">		if($a)	echo &quot;插入成功！&quot;;</div><div class="line">		else echo &quot;插入失败&quot;;</div><div class="line">// 		$dbh = null;//关闭连接</div><div class="line">	&#125; catch (PDOException $e) &#123;</div><div class="line">		die (&quot;Error!: &quot; . $e-&gt;getMessage() . &quot;&lt;br/&gt;&quot;);</div><div class="line">	&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="PDO-事务与自动提交"><a href="#PDO-事务与自动提交" class="headerlink" title="PDO 事务与自动提交"></a>PDO 事务与自动提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    try &#123;</div><div class="line">      $dbh = new PDO(&apos;odbc:SAMPLE&apos;, &apos;db2inst1&apos;, &apos;ibmdb2&apos;, </div><div class="line">          array(PDO::ATTR_PERSISTENT =&gt; true));</div><div class="line">      echo &quot;Connected\n&quot;;</div><div class="line">    &#125; catch (Exception $e) &#123;</div><div class="line">      die(&quot;Unable to connect: &quot; . $e-&gt;getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;  </div><div class="line">      $dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</div><div class="line"></div><div class="line">      $dbh-&gt;beginTransaction();//启动一个事务</div><div class="line">      $dbh-&gt;exec(&quot;insert into staff (id, first, last) values (23, &apos;Joe&apos;, &apos;Bloggs&apos;)&quot;);</div><div class="line">      $dbh-&gt;exec(&quot;insert into salarychange (id, amount, changedate) </div><div class="line">          values (23, 50000, NOW())&quot;);</div><div class="line">      $dbh-&gt;commit();//提交</div><div class="line"></div><div class="line">    &#125; catch (Exception $e) &#123;</div><div class="line">      $dbh-&gt;rollBack();//回滚</div><div class="line">      echo &quot;Failed: &quot; . $e-&gt;getMessage();</div><div class="line">    &#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h3 id="用预处理语句进行重复插入"><a href="#用预处理语句进行重复插入" class="headerlink" title="用预处理语句进行重复插入"></a>用预处理语句进行重复插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    $stmt = $dbh-&gt;prepare(&quot;INSERT INTO REGISTRY (name, value) VALUES (:name, :value)&quot;);</div><div class="line">    $stmt-&gt;bindParam(&apos;:name&apos;, $name);</div><div class="line">    $stmt-&gt;bindParam(&apos;:value&apos;, $value);</div><div class="line">    // 插入一行</div><div class="line">    $name = &apos;one&apos;;</div><div class="line">    $value = 1;</div><div class="line">    $stmt-&gt;execute();</div><div class="line">    //  用不同的值插入另一行</div><div class="line">    $name = &apos;two&apos;;</div><div class="line">    $value = 2;</div><div class="line">    $stmt-&gt;execute();</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PDO&quot;&gt;&lt;a href=&quot;#PDO&quot; class=&quot;headerlink&quot; title=&quot;PDO&quot;&gt;&lt;/a&gt;PDO&lt;/h3&gt;&lt;p&gt;PHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。&lt;/p&gt;
&lt;p&gt;PDO 提供了一个数据访问抽象层，这
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP|PHP操作Oracle数据库</title>
    <link href="http://yoursite.com/2018/05/23/PHP-PHP%E6%93%8D%E4%BD%9COracle%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/05/23/PHP-PHP操作Oracle数据库/</id>
    <published>2018-05-23T13:13:25.000Z</published>
    <updated>2018-05-23T05:52:36.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PHP是世界上最好的语言"><a href="#PHP是世界上最好的语言" class="headerlink" title="PHP是世界上最好的语言"></a>PHP是世界上最好的语言</h3><p>PHP 是世界上最好的语言，不但支持 MySQL、SQL Server 等常见数据库，还支持 Oracle 数据库。让 PHP 支持 Oracle 只需将 php.ini 中的扩展 extention = php_oci8.dll 开启即可。</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="数据库连接：函数：oci-connect"><a href="#数据库连接：函数：oci-connect" class="headerlink" title="数据库连接：函数：oci_connect()"></a>数据库连接：函数：<code>oci_connect()</code></h4><p>函数：<code>resource oci_connect ( string username, string password [, string db [, string charset [, int session_mode]]] )</code><br>说明：  </p>
<ul>
<li>函数的返回值为资源</li>
<li>username、password：是Oracle的用户名密码，即方案名及密码</li>
<li>db：是可选参数，如果使用本地的Oracle实例或者使用tnsnames.ora配置文件中注册的本地服务名，直接提供其名称即可。如果此参数留空，则使用本地的ORACLE_SID或者搜索tnsnames.ora文件的注册的默认本地服务名。</li>
<li>charset：参数是在Oracle9.2以上的版本使用的参数，默认可以留空，使用NLS_LANG 环境变量替代。</li>
<li>session_mode：用于设定使用特权身份登录（默认禁用），默认有3个选项：OCI_DEFAULT，OCI_SYSOPER 和 OCI_SYSDBA</li>
</ul>
<h4 id="编译SQL语句：函数：oci-parse"><a href="#编译SQL语句：函数：oci-parse" class="headerlink" title="编译SQL语句：函数：oci_parse()"></a>编译SQL语句：函数：<code>oci_parse()</code></h4><p>函数：<code>resource oci_parse ( resource connection, string query )</code><br>说明：   </p>
<ul>
<li>函数返回值为资源，编译以字符串形式提供的SQL语句</li>
<li>connection：为在第一步中创建的链接资源标识符</li>
<li>query：是一个查询字符串，用双引号引起来。</li>
<li>在 connection 上配置 query 并返回语句标识符以用于 oci_bind_by_name()，oci_execute() 以及其它函数</li>
</ul>
<h4 id="执行SQL语句：函数：oci-execute"><a href="#执行SQL语句：函数：oci-execute" class="headerlink" title="执行SQL语句：函数：oci_execute()"></a>执行SQL语句：函数：<code>oci_execute()</code></h4><p>函数：bool oci_execute ( resource stmt [, int mode] )<br>说明：   </p>
<ul>
<li>函数返回布尔值，执行一条之前被解析过的语句</li>
<li>stmt：在第二步创建的编译资源名</li>
<li>mode：允许定义执行模式，<ul>
<li>OCI_COMMIT_ON_SUCCESS（默认）：语句执行成功则自动提交</li>
<li>OCI_DEFAULT：自动建立一个事务，此事务会在连接关闭或者脚本结束自动回退，如果想提交，需要明确调用<code>oci_commit()</code> 提交事务，或者调用<code>oci_rollback()</code>回退事务</li>
</ul>
</li>
</ul>
<h4 id="提取查询的结果"><a href="#提取查询的结果" class="headerlink" title="提取查询的结果"></a>提取查询的结果</h4><p>有几种提取结果的方式，如下：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>int oci_fetch_all ( resource statement, array &amp;output [, int skip [, int maxrows [, int flags]]] )</td>
<td>提取所有的结果数据到数组(返回获取数据的行数)</td>
</tr>
<tr>
<td>array oci_fetch_array ( resource statement [, int mode] )</td>
<td>提取结果数据的一行到一个关联数组<code>(OCI_ASSOC)</code>或者数字索引数组<code>(OCI_NUM )</code>或两者(OCI_BOTH)等</td>
</tr>
<tr>
<td>array oci_fetch_assoc ( resource statement )</td>
<td>提取结果数据的一行到一个关联数组</td>
</tr>
<tr>
<td>object oci_fetch_object ( resource statement )</td>
<td>提取结果数据的一行到一个对象</td>
</tr>
<tr>
<td>array oci_fetch_row ( resource statement )</td>
<td>提取结果数据的一行到一个数字索引数组</td>
</tr>
</tbody>
</table>
<h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool oci_free_statement ( resource statement )</td>
<td>释放关联于语句或游标的所有资源</td>
</tr>
<tr>
<td>bool oci_close ( resource connection )</td>
<td>关闭 Oracle数据库连接</td>
</tr>
</tbody>
</table>
<h4 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h4><p>函数：<code>bool oci_bind_by_name ( resource stmt, string ph_name, mixed &amp;variable [, int maxlength [, int type]] )</code></p>
<p>oci_bind_by_name() 将 PHP 变量 variable 绑定到 Oracle 的位置标志符 ph_name。该变量是否会被用作输入输出是在运行时决定的，并且函数给该变量分配必要的存储空间。length 参数确定该绑定的最大长度，如果将 length 设为 -1，oci_bind_by_name() 会用 variable 变量的当前长度确定绑定的最大长度。</p>
<p>如果要绑定一个抽象数据类型（LOB/ROWID/BFILE），需要先用 oci_new_descriptor() 函数分配空间。length 没有用于抽象数据类型，应被设为 -1。type 参数告诉 Oracle 要使用什么样的描述符。可能的值为：</p>
<ul>
<li>SQLT_FILE - 对应于 BFILE；</li>
<li>SQLT_CFILE - 对应于 CFILE；</li>
<li>SQLT_CLOB - 对应于 CLOB；</li>
<li>SQLT_BLOB - 对应于 BLOB；</li>
<li>SQLT_ROWID - 对应于 ROWID；</li>
<li>SQLT_NTY - 对应于有名字的数据类型；</li>
<li>SQLT_INT - 对应于 integers；</li>
<li>SQLT_CHR - 对应于 VARCHARs；</li>
<li>SQLT_BIN - 对应于 RAW 列；</li>
<li>SQLT_LNG - 对应于 LONG 列；</li>
<li>SQLT_LBI - 对应于 LONG RAW 列；</li>
<li>SQLT_RSET - 对应于游标，是之前由 oci_new_cursor() 创建的。</li>
</ul>
<h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//数据库配置信息</div><div class="line">$db_host = &apos;10.10.10.10&apos;;          //数据库地址</div><div class="line">$db_port = &apos;1521&apos;;                 //端口号</div><div class="line">$db_service_name = &apos;servicename&apos;;  //服务名称</div><div class="line">$db_username = &apos;username&apos;;         //用户名</div><div class="line">$db_password = &apos;password&apos;;         //密码</div><div class="line"></div><div class="line">//连接数据库/</div><div class="line">$db = &quot;(DESCRIPTION =</div><div class="line">            (ADDRESS = (PROTOCOL = TCP) (HOST = $db_host) (PORT = $db_port) )</div><div class="line">            (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = $db_service_name) )</div><div class="line">        )&quot;;</div><div class="line"></div><div class="line">//建立连接</div><div class="line">$conn = oci_connect($db_username, $db_password, $db);</div><div class="line"></div><div class="line">//连接是否成功</div><div class="line">if($conn)&#123;</div><div class="line">    echo &quot;connect success&quot;;</div><div class="line">&#125;else&#123;</div><div class="line">    echo &quot;connect error&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">$sql = &quot;SELECT * FROM USERS WHERE USERNAME=:username&quot;;</div><div class="line"></div><div class="line">//编译SQL语句</div><div class="line">$stmt = oci_parse($conn, $sql);</div><div class="line"></div><div class="line">//设置绑定变量的值</div><div class="line">$username = &quot;admin&quot;;</div><div class="line"></div><div class="line">oci_bind_by_name($stmt, &quot;:username&quot;, $username);</div><div class="line"></div><div class="line">//执行语句</div><div class="line">oci_execute($stmt);</div><div class="line"></div><div class="line">//取结果数据(方法一)</div><div class="line">oci_fetch_all($stmt, $result);</div><div class="line">foreach($result as $rows)&#123;</div><div class="line">    foreach($rows as $val)&#123;</div><div class="line">      echo $val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//取结果数据(方法二)</div><div class="line">// while($row = oci_fetch_array($stmt, OCI_ASSOC)) &#123;</div><div class="line">//     echo $row[&apos;USERNAME&apos;];</div><div class="line">// &#125;</div><div class="line"></div><div class="line">//释放资源</div><div class="line">oci_free_statement($stmt);</div><div class="line">oci_close($conn);</div></pre></td></tr></table></figure>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$sql = &quot;INSERT INTO USERS (USERNAME,PASSWORD) VALUES (:username,:password)&quot;;</div><div class="line"></div><div class="line">$stmt = oci_parse($conn, $sql);</div><div class="line"></div><div class="line">//设置绑定变量的值</div><div class="line">$username = &quot;admin&quot;;</div><div class="line">$password = &quot;123456&quot;;</div><div class="line"></div><div class="line">oci_bind_by_name($stmt, &quot;:username&quot;, $username);</div><div class="line">oci_bind_by_name($stmt, &quot;:password&quot;, $password);</div><div class="line"></div><div class="line">//执行语句</div><div class="line">oci_execute($stmt);</div><div class="line"></div><div class="line">//检查影响的行数</div><div class="line">if(oci_num_rows($stmt))&#123;</div><div class="line">   echo &quot;insert success&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//释放资源</div><div class="line">oci_free_statement($stmt);</div><div class="line">oci_close($conn);</div></pre></td></tr></table></figure>
<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$sql = &quot;BEGIN :res:=chk_user_exist(:username); end;&quot;;</div><div class="line"></div><div class="line">$stmt = oci_parse($conn, $sql);</div><div class="line"></div><div class="line">//设置绑定变量的值</div><div class="line">$username = &quot;admin&quot;;</div><div class="line"></div><div class="line">oci_bind_by_name($stmt, &quot;:res&quot;, $res);</div><div class="line">oci_bind_by_name($stmt, &quot;:username&quot;, $username);</div><div class="line"></div><div class="line">//执行语句</div><div class="line">oci_execute($stmt);</div><div class="line"></div><div class="line">//判断是否存在</div><div class="line">if($res == 1)&#123;</div><div class="line">    echo &quot;此用户存在&quot;;</div><div class="line">&#125;else&#123;</div><div class="line">    echo &quot;此用户不存在&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//释放资源</div><div class="line">oci_free_statement($stmt);</div><div class="line">oci_close($conn);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PHP是世界上最好的语言&quot;&gt;&lt;a href=&quot;#PHP是世界上最好的语言&quot; class=&quot;headerlink&quot; title=&quot;PHP是世界上最好的语言&quot;&gt;&lt;/a&gt;PHP是世界上最好的语言&lt;/h3&gt;&lt;p&gt;PHP 是世界上最好的语言，不但支持 MySQL、SQL S
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP|关于oci_bind_by_name用foreach循环绑定问题</title>
    <link href="http://yoursite.com/2018/05/23/PHP-%E5%85%B3%E4%BA%8Eoci-bind-by-name%E7%94%A8foreach%E5%BE%AA%E7%8E%AF%E7%BB%91%E5%AE%9A%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/23/PHP-关于oci-bind-by-name用foreach循环绑定问题/</id>
    <published>2018-05-23T12:30:12.000Z</published>
    <updated>2018-05-25T03:34:39.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遇到了神奇的bug"><a href="#遇到了神奇的bug" class="headerlink" title="遇到了神奇的bug"></a>遇到了神奇的bug</h3><p>作为 Web 开发人员，您通常遇到的第二个问题是站点的安全性。 由于该问题体现在很多方面，因此找到解决它的方法无异于一场永无休止但却至观重要的战役。 在数据库驱动的站点中，许多查询都依赖于外部值，如用户从表单中提交的值、在 URL 中传递给页面的值等等。 此类查询很容易受到 SQL 注入攻击的破坏。 （“SQL 注入攻击”是指恶意用户在尝试破坏查询的过程中向 PHP 脚本提供无效数据。） 如果对查询的处理方法不当，恶意用户便有可能从生成的错误消息中了解一些有关脚本、数据库或服务器的信息。</p>
<p>这两天很郁闷，老是为PHP为oracle语句绑定变量时出现问题，下面做为题描述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">oci_bind_by_name($stmt,”:ip”,$ip);</div><div class="line">oci_bind_by_name($stmt,”:username”,$username);</div><div class="line">oci_bind_by_name($stmt,”:telephone”,$telephone);</div><div class="line">oci_bind_by_name($stmt,”:idname”,$idname);</div><div class="line"></div><div class="line">$name=array(“:ip”=&gt;$ip,”:username”=&gt;$username,”:telephone”=&gt;$telephone,”:idname”=&gt;$idname); </div><div class="line">foreach ($name as $k=&gt;$v) &#123;</div><div class="line">    oci_bind_by_name($stmt,$k,$v);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一种方式正常绑定；第二种方式，最后执行结果四个变量都绑定了$idname的值，为什么两种方法出现的结果不同呢？原因在于oci_bind_by_name函数没认识清楚，且看官方手册：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool oci_bind_by_name ( resource stmt, string ph_name, mixed &amp;variable [, int maxlength [, int type]] )</div></pre></td></tr></table></figure></p>
<p>第三个变量，传递的是变量的引用，所以第一次循环，<code>:ip</code>绑定的是<code>$ip</code>的引用，即假设<code>$ip</code>的地址为223，第二次循环，<code>$ip</code>变量的地址被<code>$username</code>占用，所以<code>:username</code>也绑定了地址<code>223</code>，<code>:telephone</code>和<code>:idname</code>都如此，最后一次循环，内存地址223位置上存储的是$idname变量的值，所以当执行<code>oci_execute($stmt)</code>时给四个变量都绑定了<code>$idname</code>的值。哈哈，了解了吧。</p>
<p>如何解决？<code>不用$value</code>,比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foreach ($array as $key =&gt; $value) &#123;</div><div class="line">	  // oci_bind_by_name($stid, $key, $val) does not work</div><div class="line">     // because it binds each placeholder to the same location: $val</div><div class="line">     // instead use the actual location of the data: $ba[$key]</div><div class="line">     </div><div class="line">    oci_bind_by_name($stmt, $key, $array[$key]);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对于PDO的bind也是一样的"><a href="#对于PDO的bind也是一样的" class="headerlink" title="对于PDO的bind也是一样的"></a>对于PDO的bind也是一样的</h3><p>废话不多说, 直接看代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$dbh = new PDO(&apos;mysql:host=localhost;dbname=test&apos;, &quot;test&quot;);</div><div class="line"> </div><div class="line">$query = &lt;&lt;&lt;QUERY</div><div class="line">  INSERT INTO `user` (`username`, `password`) VALUES (:username, :password);</div><div class="line">QUERY;</div><div class="line">$statement = $dbh-&gt;prepare($query);</div><div class="line"> </div><div class="line">$bind_params = array(&apos;:username&apos; =&gt; &quot;laruence&quot;, &apos;:password&apos; =&gt; &quot;weibo&quot;);</div><div class="line">foreach( $bind_params as $key =&gt; $value )&#123;</div><div class="line">    $statement-&gt;bindParam($key, $value);</div><div class="line">&#125;</div><div class="line">$statement-&gt;execute();</div></pre></td></tr></table></figure></p>
<p>请问, 最终执行的SQL语句是什么, 上面的代码是否有什么问题?</p>
<p>Okey, 我想大部分同学会认为, 最终执行的SQL是:</p>
<p><code>INSERT INTO</code>user<code>(</code>username<code>,</code>password<code>) VALUES (&quot;laruence&quot;, &quot;weibo&quot;);</code><br>但是, 可惜的是, 你错了, 最终执行的SQL是:</p>
<p><code>INSERT INTO</code>user<code>(</code>username<code>,</code>password<code>) VALUES (&quot;weibo&quot;, &quot;weibo&quot;);</code></p>
<p>是不是很大的一个坑呢?</p>
<p><strong>Why?!?</strong></p>
<p>究其原因, 也就是bindParam和bindValue的不同之处, bindParam要求第二个参数是一个引用变量(reference).</p>
<p>让我们把上面的代码的foreach拆开, 也就是这个foreach:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">foreach( $bind_params as $key =&gt; $value )&#123;</div><div class="line">    $statement-&gt;bindParam($key, $value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">//第一次循环</div><div class="line">$value = $bind_params[&quot;:username&quot;];</div><div class="line">$statement-&gt;bindParam(&quot;:username&quot;, &amp;$value); //此时, :username是对$value变量的引用</div><div class="line"> </div><div class="line">//第二次循环</div><div class="line">$value = $bind_params[&quot;:password&quot;]; //oops! $value被覆盖成了:password的值</div><div class="line">$statement-&gt;bindParam(&quot;:password&quot;, &amp;$value);</div></pre></td></tr></table></figure></p>
<p>所以, 在使用bindParam的时候, 尤其要注意和foreach联合使用的这个陷阱. 那么正确的作法呢?</p>
<p><strong>How to do ?!?</strong></p>
<ul>
<li><p>不要使用foreach, 而是手动赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$statement-&gt;bindParam(&quot;:username&quot;, $bind_params[&quot;:username&quot;]); //$value是引用变量了</div><div class="line">$statement-&gt;bindParam(&quot;:password&quot;, $bind_params[&quot;:password&quot;]);</div></pre></td></tr></table></figure>
</li>
<li><p>使用bindValue代替bindParam, 或者直接在execute中传递整个参数数组.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;遇到了神奇的bug&quot;&gt;&lt;a href=&quot;#遇到了神奇的bug&quot; class=&quot;headerlink&quot; title=&quot;遇到了神奇的bug&quot;&gt;&lt;/a&gt;遇到了神奇的bug&lt;/h3&gt;&lt;p&gt;作为 Web 开发人员，您通常遇到的第二个问题是站点的安全性。 由于该问题体现在很多
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>操作系统|关于内存管理</title>
    <link href="http://yoursite.com/2018/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/23/操作系统-关于内存管理/</id>
    <published>2018-05-22T17:21:15.000Z</published>
    <updated>2018-06-06T13:08:53.267Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>内存一直是计算机系统中宝贵而又紧俏的资源，内存能否被有效、合理地使用，将直接影响到操作系统的性能。此外，虽然物理内存的增长现在达到了N个GB，但比物理内存增长还快的是程序，所以无论物理内存如何增长，都赶不上程序增长的速度，所以操作系统如何有效的管理内存便显得尤为重要。</p>
<p>为改善CPU的使用率和对用户的相应速度，计算机必须在内存里保留多个进程。</p>
<h3 id="内存管理的目标"><a href="#内存管理的目标" class="headerlink" title="内存管理的目标"></a>内存管理的目标</h3><ul>
<li><p>地址保护：一个程序不能访问另一个程序地址空间。</p>
</li>
<li><p>地址独立：程序发出的地址应该与物理主存地址无关。</p>
</li>
</ul>
<p>这两个目标是衡量一个内存管理系统是否完善的标准，它是所有内存管理系统必须提供的基本抽象。　</p>
<h3 id="虚拟内存的概念"><a href="#虚拟内存的概念" class="headerlink" title="虚拟内存的概念"></a>虚拟内存的概念</h3><p><strong>虚拟内存的中心思想是将物理主存扩大到便宜、大容量的磁盘上，即将磁盘空间看做主存空间的一部分。</strong>可以理解为是将书桌上的比较老的文件先暂时收到抽屉里，用空出来的地方来摊开新的文件。在计算机中，体现在在内存容量不足时将不经常访问的内存空间中的数据写入硬盘，以增加“账面上”可用内存容量的手段（想想我们的内存和硬盘容量对比就知道了）。</p>
<p>但是，如果在书桌和抽屉之间频繁进行文件的交换，工作效率肯定会下降。如果每次要看一份文件都要先收拾书桌再到抽屉里面拿的话，那工作根本就无法进行了。</p>
<p>虚拟内存的优点在于除了让程序员感觉到内存容量大大增加之外，还让程序员感觉到内存速度也增快了。</p>
<p>虚拟内存也有同样的缺点：硬盘的容量比内存大，但也只是相对的，速度却非常缓慢，如果和硬盘之间的数据交换过于频繁，处理速度就会下降，表面上看起来就像卡住了一样，这种现象称为<strong>抖动（Thrushing）</strong>。相信很多人都有过计算机停止响应的经历，而造成死机的主要原因之一就是抖动。</p>
<h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><h4 id="单道编程的内存管理"><a href="#单道编程的内存管理" class="headerlink" title="单道编程的内存管理"></a>单道编程的内存管理</h4><p>在单道编程环境下，整个内存里面只有两个程序：一个是用户程序，另一个是操作系统。</p>
<p>由于只有一个用户程序，而操作系统所占用的内存空间是恒定的，所以我们可以将用户程序总是加载到同一个内存地址上，即用户程序永远从同一个地方开始执行。</p>
<p>这样，用户程序里面的地址都可以事先计算出来，即在程序运行之前就计算出所有的物理地址。这种在运行前即将物理地址计算好的方式叫做<strong>静态地址翻译</strong>。下面看看此方式如何达到两个目标。</p>
<ul>
<li><p>地址独立：用户在编写程序时无需考虑具体的物理内存，用户程序始终都被加载到同一个物理地址上。</p>
</li>
<li><p>地址保护：整个系统里面只有一个用户程序，因此，固定地址的内存管理因为只运行一个用户程序而达到地址保护。</p>
</li>
</ul>
<h4 id="多道编程的内存管理"><a href="#多道编程的内存管理" class="headerlink" title="多道编程的内存管理"></a>多道编程的内存管理</h4><p>在多道编程环境下，无法将程序总是加到固定的内存地址上，也就是无法使用静态地址翻译。因此，必须在程序加载完毕之后才能计算物理地址，也就是在程序运行时进行地址翻译，这种翻译称为<strong>动态地址翻译</strong>。</p>
<p><img src="/images/内存管理-01.jpg" alt=""></p>
<p>多道编程环境下的内管管理策略有两种：</p>
<h5 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h5><p>顾名思义，固定分区管理就是讲内存分为固定的几个区域，每个区域大小固定。最下面的分区为OS占用，其他分区由用户程序使用。分区大小通常各不相同，当需要加载程序时，选择一个当前闲置且容量足够大的分区进行加载，如下图所示，这是一种共享队列的固定分区（多个用户程序排在一个共同的队列里面等待分区）：</p>
<p><img src="/images/内存管理-02.jpg" alt=""></p>
<p>由于程序大小和分区大小不一定匹配，有可能形成一个小程序占用一个大分区的情况，从而造成内存里虽然有小分区闲置但无法加载大程序的情况。这时，我们就想到也许可以采用多个队列，给每个分区一个队列，程序按照大小排在相应的队列里，如下图所示，这时一种分开队列的固定分区：</p>
<p><img src="/images/内存管理-03.jpg" alt=""></p>
<p>上图这种方式也有缺点：如果还有空闲分区，但等待的程序不在该分区的等待队列上，就将造成有空间而不能运行程序的尴尬。</p>
<h5 id="非固定分区"><a href="#非固定分区" class="headerlink" title="非固定分区"></a>非固定分区</h5><p>非固定分区的思想在于除了划分给OS的空间之外，其余的内存空间是作为一个整体存在的。当一个程序需要占用内存空间时，就在该片空间里面分出一个大小刚刚满足程序所需的空间。再来一个程序时，则在剩下的空间里再这样分出一块来。在这种模式下，一个程序可以加载到任何地方，也可以和物理内存一样大。</p>
<p>例如，一开始内存中只有OS，这时候进程A来了，于是分出一片与进程A大小一样的内存空间；随后，进程B来了，于是在进程A之上分出一片给进程B；然后进程C来了，就在进程B上面再分出一片给C。如此，进程A、B和C的起始地址都不是固定的，如下图所示：</p>
<p><img src="/images/内存管理-04.jpg" alt=""></p>
<p>仔细想想，这种方式存在一个重大问题：每个程序像叠罗汉一样累计，如果程序B在运行过程中需要更多空间怎么办？[例如在实际程序中，很多递归嵌套函数调用的时候回造成栈空间的增长]因此，我们可以想到可以再一开始的时候给程序分配空间时就分配足够大的空间，留有一片闲置空间供程序增长使用，如下图所示：</p>
<p><img src="/images/内存管理-05.jpg" alt=""></p>
<p>不过，OS怎么知道应该分配多少空间给一个程序呢？分配多了，就是浪费；而分配少了，则可能造成程序无法继续执行。</p>
<p>因此，可以在空间不够时，给程序换一个空间，这种方式将程序倒到磁盘上，再加载到内存中，被称为<strong>交换（swap）</strong>。但是，如果在交换模式下程序的增长超过了物理内存，就不能再交换了。此时，可以将程序按照功能分成一段一段功能相对完整的单元，一个单元执行完成后再执行下一个单元，这就是<strong>重叠（overlay）</strong>。</p>
<p>但是，交换内存管理这种方式存在两个重要问题：</p>
<ul>
<li><p>空间浪费：随着程序在内存与磁盘间的交换，内存将变得越来越碎片化，即内存将被不同程序分割成尺寸大小无法使用的小片空间。</p>
</li>
<li><p>程序大小受限：这有两层意思，一是指空间增长效率低下（由于磁盘操作耗时，交换出去再找一片更大的空间来增长程序空间的做法效率非常低），二是空间增长存在天花板限制（单一程序不能超过物理内存空间）。</p>
</li>
</ul>
<p>可变分区的分配策略：</p>
<ul>
<li><p>首次适应(First Fit)算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。 </p>
</li>
<li><p>最佳适应(Best Fit)算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 </p>
</li>
<li><p>最坏适应(Worst Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。 </p>
</li>
<li><p>邻近适应(Next Fit)算法：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找。</p>
</li>
</ul>
<h3 id="分页内存管理"><a href="#分页内存管理" class="headerlink" title="分页内存管理"></a>分页内存管理</h3><p>为了解决交换系统存在的缺陷，分页系统横空出世。分页系统的核心在于：将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如4KB、8KB或16KB等，并以页面作为内存空间的最小分配单位，一个程序的一个页面可以存放在任意一个物理页面里。</p>
<ul>
<li>解决空间浪费碎片化问题</li>
</ul>
<p>由于将虚拟内存空间和物理内存空间按照某种规定的大小进行分配，这里我们称之为页（Page），然后按照页进行内存分配，也就克服了外部碎片的问题.(但同时也会带来内部碎片)</p>
<ul>
<li>解决程序大小受限问题</li>
</ul>
<p>程序增长有限是因为一个程序需要全部加载到内存才能运行，因此解决的办法就是使得一个程序无须全部加载就可以运行。使用分页也可以解决这个问题，只需将当前需要的页面放在内存里，其他暂时不用的页面放在磁盘上，这样一个程序同时占用内存和磁盘，其增长空间就大大增加了。而且，分页之后，如果一个程序需要更多的空间，给其分配一个新页即可（而无需将程序倒出倒进从而提高空间增长效率）。</p>
<h4 id="虚拟地址的构成与地址翻译"><a href="#虚拟地址的构成与地址翻译" class="headerlink" title="虚拟地址的构成与地址翻译"></a>虚拟地址的构成与地址翻译</h4><p>虚拟地址的构成</p>
<p>在分页系统下，一个程序发出的虚拟地址由两部分组成：页面号和页内偏移值，如下图所示：</p>
<p><img src="/images/内存管理-06.jpg" alt=""></p>
<p>例如，对于32位寻址的系统，如果页面大小为4KB，则页面号占20位，页内偏移值占12位。是这样算出来的：<code>2^12 = 4kb</code>,所以需要12为页内偏移。</p>
<p>址翻译：虚拟地址→物理地址</p>
<p>分页系统的核心是页面的翻译，即从虚拟页面到物理页面的映射（Mapping）。该翻译过程如下伪代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if(虚拟页面非法、不在内存中或被保护)</div><div class="line">&#123;</div><div class="line">    陷入到操作系统错误服务程序</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">    将虚拟页面号转换为物理页面号</div><div class="line">    根据物理页面号产生最终物理地址</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个翻译过程由内存管理单元（MMU）完成，MMU接收CPU发出的虚拟地址，将其翻译为物理地址后发送给内存。内存管理单元按照该物理地址进行相应访问后读出或写入相关数据，如下图所示：</p>
<p><img src="/images/内存管理-07.jpg" alt=""></p>
<p>那么，这个翻译是怎么实现的呢？答案是<code>查页表</code>，对于每个程序，内存管理单元MMU都为其保存一个页表，该页表中存放的是虚拟页面到物理页面的映射。每当为一个虚拟页面寻找到一个物理页面之后，就在页表里增加一条记录来保留该映射关系。当然，随着虚拟页面进出物理内存，页表的内容也会不断更新变化。</p>
<p><img src="/images/内存管理-08.jpg" alt=""></p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>页表的根本功能是提供从虚拟页面到物理页面的映射。因此，页表的记录条数与虚拟页面数相同。此外，内存管理单元依赖于页表来进行一切与页面有关的管理活动，这些活动包括判断某一页面号是否在内存里，页面是否受到保护，页面是否非法空间等等。</p>
<p>页表的一个记录所包括的内容如下图所示：</p>
<p><img src="/images/内存管理-09.jpg" alt=""></p>
<p>由于页表的特殊地位，决定了它是由硬件直接提供支持，即页表是一个硬件数据结构。</p>
<h4 id="分页系统的优缺点"><a href="#分页系统的优缺点" class="headerlink" title="分页系统的优缺点"></a>分页系统的优缺点</h4><p>优点：</p>
<ul>
<li><p>分页系统不会产生外部碎片，一个进程占用的内存空间可以不是连续的，并且一个进程的虚拟页面在不需要的时候可以放在磁盘中。</p>
</li>
<li><p>分页系统可以共享小的地址，即页面共享。只需要在对应给定页面的页表项里做一个相关的记录即可。</p>
</li>
</ul>
<p>缺点：页表很大，占用了大量的内存空间。</p>
<h4 id="缺页中断处理"><a href="#缺页中断处理" class="headerlink" title="缺页中断处理"></a>缺页中断处理</h4><p>在分页系统中，一个虚拟页面既有可能在物理内存，也有可能保存在磁盘上。如果CPU发出的虚拟地址对应的页面不在物理内存，就将产生一个<code>缺页中断</code>，而缺页中断服务程序负责将需要的虚拟页面找到并加载到内存。缺页中断的处理步骤如下，省略了中间很多的步骤，只保留最核心的几个步骤：</p>
<p><img src="/images/内存管理-10.jpg" alt=""></p>
<p>所以总的访问过程如下：</p>
<p><img src="/images/内存管理-11.jpg" alt=""></p>
<p>上面介绍的地址变换过程可知，若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：一次是<strong>访问页表</strong>，确定所存取的数据或指令的物理地址，第二次才<strong>根据该地址存取数据或指令</strong>。显然，这种方法比通常执行指令的速度慢了一半。</p>
<p>为此，在地址变换机构中增设了一个具有并行查找能力的高速缓冲存储器——<strong>快表</strong>，又称联想寄存器(TLB translation look-aside buffer)，用来存放当前访问的若干页表项，以加速地址变换的过程。</p>
<p><img src="/images/内存管理-12.jpg" alt=""></p>
<h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><p>分页系统存在的一个无法容忍，同时也是分页系统无法解决的一个缺点就是：<strong>一个进程只能占有一个虚拟地址空间</strong>。在此种限制下，一个程序的大小至多只能和虚拟空间一样大，其所有内容都必须从这个共同的虚拟空间内分配。</p>
<h4 id="何为分段管理"><a href="#何为分段管理" class="headerlink" title="何为分段管理"></a>何为分段管理</h4><p>分段管理就是将一个程序按照逻辑单元分成多个程序段，每一个段使用自己单独的虚拟地址空间。例如，对于编译器来说，我们可以给其5个段，占用5个虚拟地址空间，如下图所示：</p>
<p><img src="/images/内存管理-13.jpg" alt=""></p>
<p>如此，一个段占用一个虚拟地址空间，不会发生空间增长时碰撞到另一个段的问题，从而避免因空间不够而造成编译失败的情况。如果某个数据结构对空间的需求超过整个虚拟之地所能够提供的空间，则编译仍将失败。不过出现这种可能的概率恐怕不会比太阳从西边出来的概率高出多少。</p>
<h4 id="分段管理优缺点"><a href="#分段管理优缺点" class="headerlink" title="分段管理优缺点"></a>分段管理优缺点</h4><p>优点：</p>
<ul>
<li><p>每个逻辑单元可单独占用一个虚拟地址空间，这样使得编写程序的空间大为增长。</p>
</li>
<li><p>由于段式按逻辑关系划分，因此共享起来十分方便。</p>
</li>
<li><p>对于空间稀疏的程序来说，分段管理将节省大量的空间。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>外部碎片和一个段必须全部加载到内存。</li>
</ul>
<p>那么，解决办法是什么呢？分页，不过这次的分页不是前面提到的直接对程序进程进行分页，而是对程序里面的段进行分页，于是就形成了所谓的段页式内存管理模式。<strong>对程序分段，对内存分页</strong>。</p>
<h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>段页式管理就是将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用。这样做的目的就是想同时获得分段和分页的好处，但又避免了单独分段或单独分页的缺陷。</p>
<p>如果我们将每个段看做一个单独的程序，则逻辑分段就相当于同时加载多个程序。</p>
<p>地址结构：逻辑地址由段号S、段内页号P与段内偏移量W两部分组成。</p>
<p><img src="/images/内存管理-15.jpg" alt=""></p>
<h4 id="段页式内存管理的实现"><a href="#段页式内存管理的实现" class="headerlink" title="段页式内存管理的实现"></a>段页式内存管理的实现</h4><p>采用多级页表，顶级为段表，次级为页表。由段号在段表里面获得所应该使用的页表，然后在该页表里面查找物理页面号，如下图所示：</p>
<p><img src="/images/内存管理-14.jpg" alt=""></p>
<p>一次访问过程：</p>
<p><img src="/images/内存管理-16.jpg" alt=""></p>
<h3 id="内存管理的演变"><a href="#内存管理的演变" class="headerlink" title="内存管理的演变"></a>内存管理的演变</h3><ol>
<li><p>一开始，人们根据直觉，将一个程序作为一整段进行管理，从而形成了纯粹分段（固定加载地址、固定分区、非固定分区、交换）管理模式，也称为基本内存管理模式，这种模式由于直观易实现，曾经大为流行。</p>
</li>
<li><p>但是，纯粹分段存在重大缺陷（由于此种模式下一个程序只有一段，从而导致内存空间增长困难，外部碎片、程序不能超过物理内存容量、一个程序必须同时加载到内存才能执行等缺点），为了克服这些缺点，引入了页式内存管理模式。</p>
</li>
<li><p>显然，页式内存管理克服了纯粹分段的一系列缺点，但又存在共享不方便、一个程序只能在一个徐地址空间增长的问题，为了解决这个问题，引入了逻辑分段。逻辑分段将一个程序按逻辑关系分解为多个段，从而扩大了程序可以使用的虚拟地址空间并解决了共享难的问题。</p>
</li>
<li><p>但是，逻辑分段终究还是分段，自然又引入了分段的缺点。而要客服这些缺点，自然又想到了分页。这样，人们又引入了段页式管理模式。</p>
</li>
</ol>
<p>因此，内存管理模式经历了从纯粹分段到分页，再到逻辑分段，再到段内分页的演变过程，如下图所示：</p>
<p><img src="/images/内存管理-17.jpg" alt=""></p>
<p><a href="http://www.cnblogs.com/edisonchou/p/5090315.html" target="_blank" rel="external">操作系统核心原理-5.内存管理（上）：基本内存管理</a><br><a href="https://www.cnblogs.com/edisonchou/p/5094066.html" target="_blank" rel="external">操作系统核心原理-5.内存管理（中）：分页内存管理</a><br><a href="https://www.cnblogs.com/edisonchou/p/5115242.html" target="_blank" rel="external">操作系统核心原理-5.内存管理（下）：段式内存管理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;内存一直是计算机系统中宝贵而又紧俏的资源，内存能否被有效、合理地使用，将直接影响到操作系统的性能。此外，虽然物理内存的增长现在达到了N个GB
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统|存储器结构</title>
    <link href="http://yoursite.com/2018/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/05/23/深入理解计算机系统-存储器结构/</id>
    <published>2018-05-22T17:19:37.000Z</published>
    <updated>2018-05-29T03:11:55.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在简单模型中，存储器系统是一个线性的字节数组，CPU能够在一个常数访问每个存储器位置。</p>
<p>实际上，存储器系统(memory system)是一个具有不同容量，成本和访问时间的存储设备的层次结构。</p>
<ul>
<li>CPU寄存器保存着最常用的数据。(0周期)</li>
<li>靠近CPU的小的，快速的高速缓存存储器(cache memory)作为一部分存储在相对慢速的主储存器(main memory,简称主存)中的数据和指令的缓冲区。(1~30周期)</li>
<li>主存暂时存放 储存在容量较大的，慢速磁盘上的数据。(50~200周期)</li>
<li>磁盘又作为存储在通过网络连接的其他机器的磁盘或磁带上数据的缓冲区。(几千万个周期)</li>
</ul>
<h3 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h3><p>随机访问存储器(Random-Access Memory,RAM)分为两类，<code>静态</code>的和<code>动态</code>的。</p>
<p>下面列出两者的不同，稍后再详细分析：</p>
<ul>
<li>静态RAM(SRAM）比动态RAM(DRAM)快地多，也贵得多。</li>
<li>SRAM用来作为高速缓存存储器。(一般只有几兆)</li>
<li>DRAM用来作为主存以及图形系统的帧缓冲区(显存)。(一般有几G)</li>
</ul>
<h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>SRAM将每个位存储在一个双稳态(bistable)存储器单元里。</p>
<ul>
<li>每个存储单元用一个六晶体管电路来实现。<ul>
<li>有这样属性，可以无限期保持在两个不同的电压配置(configuration)或状态之一。</li>
<li>其他任何状态都是不稳定的。如图所示</li>
</ul>
</li>
</ul>
<p><img src="/images/存储器结构-01.png" alt="存储器结构"></p>
<ul>
<li>由于这种双稳态特性，只要有电，它就会永远保持他的值，即使有干扰。<ul>
<li>例如电子噪音，来扰乱电压，当消除干扰时，电路就会恢复稳定值</li>
</ul>
</li>
</ul>
<h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><ul>
<li><p>DRAM将每个位存储为对一个电容充电，这个电容非常小，通常只有30*10^-15法拉。</p>
<ul>
<li>因此，DRAM存储器可以造的十分密集。<ul>
<li>每个单元由一个电容和一个访问晶体管组成。</li>
</ul>
</li>
<li>但是，DRAM存储器对干扰非常敏感。当电容电压被扰乱后，就永远不会恢复。</li>
</ul>
</li>
<li><p>很多原因会漏电，使得DRAM单元在10~100毫秒时间内失去电荷。</p>
<ul>
<li>幸运的是，计算机的时钟周期以纳秒衡量，这个保持时间也相当长。</li>
</ul>
</li>
<li><p>存储器系统必须周期性地读出，然后重写来刷新存储器的每一位。</p>
<ul>
<li>有些系统也使用纠错码。</li>
</ul>
</li>
</ul>
<h4 id="SRAM与DRAM的对比"><a href="#SRAM与DRAM的对比" class="headerlink" title="SRAM与DRAM的对比"></a>SRAM与DRAM的对比</h4><ul>
<li>只要有供电，SRAM就会保持不变。</li>
<li>SRAM不需要刷新</li>
<li>SRAM读取比DRAM快</li>
<li>SRAM对干扰不敏感。</li>
<li>代价是SRAM单元比DRAM单元使用更多的晶体管，因而密集度低，更贵，功耗更大。</li>
</ul>
<h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h3><p>磁盘是用来保存大量数据的存储设备，能比基于RAM的存储器存更多的数据，但是读取数据的速度却远远低于基于RAM的存储器。</p>
<h4 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h4><p>磁盘是由盘片(platter)构成的.</p>
<ul>
<li><p>每个盘片有两面或者称为表面(surface)。</p>
</li>
<li><p>盘片中央有一个可以旋转的主轴(spindle)，它使得盘片以固定的旋转速率(rotational rate)旋转，通常是5400~15 000转每分钟(Revolution Per Minute,RPM)</p>
<ul>
<li>磁盘通常含一个或多个这样的盘片，并封装到一个密封的容器里。</li>
</ul>
</li>
</ul>
<p>如图，展示了一个典型的磁盘表面的结构。</p>
<p><img src="/images/存储器结构-02.png" alt="存储器结构"></p>
<ul>
<li><p>每个表面是由一组称为磁道(track)的同心圆组成的。</p>
<ul>
<li>每个磁道被划分为一组扇区(sector)。<ul>
<li>每个扇区包含相等数量的数据位(通常是512字节)，这些数据编码在扇区的磁性材料中。</li>
<li>扇区之间由一些间隙(gap)分隔<ul>
<li>不存储数据</li>
<li>间隙存储用来标识扇区的格式化位。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘是由一个或多个叠放在一起的盘片组成，被封装在密封包装。</p>
<ul>
<li><p>整个装置称为磁盘驱动器(disk drive),我们通常简称为磁盘(disk).</p>
</li>
<li><p>有时又叫旋转磁盘(rotating disk),使之区别基于闪存的固态硬盘(SSD)。</p>
<ul>
<li>SSD没有可移动的地方</li>
</ul>
</li>
<li><p>磁盘商通常用术语柱面(cylinder)描述多个盘片的构造 。</p>
<ul>
<li>柱面是所有盘片表面上到主轴中心的距离相等的磁道集合。</li>
<li>例如，一个驱动器有三个盘片，六个面。那么柱面k是六个磁道k的集合。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h4><p>整个硬盘上一般有很多的盘片组成，每个盘片如同切西瓜一样被“切”成一块一块的扇面，同时沿着半径的方向被划分成了很多同心圆，就是传说中的磁道，每条磁道被扇面切成很多的扇形区域叫做扇区（扇区是从磁盘读出和写入信息的最小单位，通常大小为512字节），不同盘片上的同半径磁道组成了柱面。</p>
<p>容量：<code>磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</code></p>
<ul>
<li>磁头（head）数：每个盘片一般有上下两面，分别对应1个磁头，共2个磁头；</li>
<li>磁道（track）数：磁道是从盘片外圈往内圈编号0磁道，1磁道.，靠近主轴的同心圆用于停靠磁头，不存储数据；</li>
<li>柱面（cylinder）数：同磁道数量；</li>
<li>扇区（sector）数：每个磁道都别切分成很多扇形区域，每道的扇区数量相同；</li>
<li>圆盘（platter）数：就是盘片的数量。</li>
</ul>
<p><img src="/images/存储器结构-07.png" alt="存储器结构"></p>
<h4 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h4><p>盘用读/写头（read/write head)来读写存储在磁性表面的位，而读写头连接到一个传动臂（actuator arm) —端，如下图。通过沿着半径轴前后移动这个传动臂，驱动器可以将 读/写头定位在盘面上的任何磁道上。这样的机械运动称为<code>寻道（seek)</code>。一旦读/写头定位到了 期望的磁道上，那么当磁道上的每个位通过它的下面时，读/写头可以感知到这个位的值（读该位)，也可以修改这个位的值（写该位)。有多个盘片的磁盘针对每个盘面都有一个独立的读/写头，如下图所示。读/写头垂直排列，一致行动。<strong>在任刻，所有的读/写头都位于同一个柱面上</strong>。</p>
<p><img src="/images/存储器结构-03.png" alt="存储器结构"> <img src="/images/存储器结构-04.png" alt="存储器结构"></p>
<p><strong>磁盘以扇区大小的块来读写数据。对扇区的访问时间(access time)主要有三个部分：寻道时间(seek time)、旋转时间(rotational time)和传送时间(transfer time)。</strong></p>
<h4 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h4><p><img src="/images/存储器结构-05.png" alt="存储器结构"></p>
<p>在磁盘控制器接收到CPU的读命令后，它将逻辑号翻译成一个扇区地址，读该扇区的内容，然后将这些内容直接传送到主存，不需要CPU的干涉，这个过程称为<code>直接存储器传送(Direct Memory Access, DMA)</code>，这种数据传送称为<code>DMA传送</code>。</p>
<ol>
<li>磁盘控制器接收到CPU的读命令后，它将逻辑号翻译成一个扇区地址，读该扇区的内容<br><img src="/images/存储器结构-09.jpg" alt="存储器结构"></li>
<li>DMA传送，将这些内容直接传送到主存，不需要CPU的干涉<br><img src="/images/存储器结构-10.jpg" alt="存储器结构"></li>
<li>给cpu发一个中断信号<br><img src="/images/存储器结构-11.jpg" alt="存储器结构"><h4 id="磁盘总结"><a href="#磁盘总结" class="headerlink" title="磁盘总结"></a>磁盘总结</h4>总的来说，整个硬盘上一般有很多的盘片组成，每个盘片如同切西瓜一样被“切”成一块一块的扇面，同时沿着半径的方向被划分成了很多同心圆，就是传说中的磁道，每条磁道被扇面切成很多的扇形区域叫做扇区（扇区是从磁盘读出和写入信息的最小单位，通常大小为512字节），不同盘片上的同半径磁道组成了柱面。</li>
</ol>
<p><img src="/images/存储器结构-06.png" alt="存储器结构"></p>
<h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><p>固态硬盘内部完全由NAND存储芯片构成，通过高低电平和改变晶体管开关状态，以此来存储数据。从原理方面看，SSD固态硬盘相对与HDD传统硬盘而言再也没有了寻道时间、柱面、坏道等概念，所以其速度和安全性都有极大的提升。</p>
<p><img src="/images/存储器结构-08.jpg" alt="存储器结构"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在简单模型中，存储器系统是一个线性的字节数组，CPU能够在一个常数访问每个存储器位置。&lt;/p&gt;
&lt;p&gt;实际上，存储器系统(memory sy
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode|SQL</title>
    <link href="http://yoursite.com/2018/05/22/LeetCode-SQL/"/>
    <id>http://yoursite.com/2018/05/22/LeetCode-SQL/</id>
    <published>2018-05-22T15:23:52.000Z</published>
    <updated>2018-05-28T16:15:55.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode-181-Employees-Earning-More-Than-Their-Managers"><a href="#leetcode-181-Employees-Earning-More-Than-Their-Managers" class="headerlink" title="leetcode 181 Employees Earning More Than Their Managers"></a><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/description/" target="_blank" rel="external">leetcode 181 Employees Earning More Than Their Managers</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</div><div class="line"></div><div class="line">+----+-------+--------+-----------+</div><div class="line">| Id | Name  | Salary | ManagerId |</div><div class="line">+----+-------+--------+-----------+</div><div class="line">| 1  | Joe   | 70000  | 3         |</div><div class="line">| 2  | Henry | 80000  | 4         |</div><div class="line">| 3  | Sam   | 60000  | NULL      |</div><div class="line">| 4  | Max   | 90000  | NULL      |</div><div class="line">+----+-------+--------+-----------+</div><div class="line"></div><div class="line">给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</div><div class="line"></div><div class="line">+----------+</div><div class="line">| Employee |</div><div class="line">+----------+</div><div class="line">| Joe      |</div><div class="line">+----------+</div></pre></td></tr></table></figure>
<p>MySQL:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	E. NAME Employee</div><div class="line">FROM</div><div class="line">	Employee E,</div><div class="line">	Employee M</div><div class="line">WHERE</div><div class="line">	E.ManagerId = M.Id</div><div class="line">AND E.Salary &gt; M.salary;</div></pre></td></tr></table></figure></p>
<h3 id="leetcode-182-Duplicate-Emails"><a href="#leetcode-182-Duplicate-Emails" class="headerlink" title="leetcode 182 Duplicate Emails"></a><a href="https://leetcode-cn.com/problems/duplicate-emails/description/" target="_blank" rel="external">leetcode 182 Duplicate Emails</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。</div><div class="line"></div><div class="line">示例：</div><div class="line"></div><div class="line">+----+---------+</div><div class="line">| Id | Email   |</div><div class="line">+----+---------+</div><div class="line">| 1  | a@b.com |</div><div class="line">| 2  | c@d.com |</div><div class="line">| 3  | a@b.com |</div><div class="line">+----+---------+</div><div class="line"></div><div class="line">根据以上输入，你的查询应返回以下结果：</div><div class="line"></div><div class="line">+---------+</div><div class="line">| Email   |</div><div class="line">+---------+</div><div class="line">| a@b.com |</div><div class="line">+---------+</div><div class="line"></div><div class="line">说明：所有电子邮箱都是小写字母。</div></pre></td></tr></table></figure>
<p>My Solution</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	Email</div><div class="line">FROM</div><div class="line">	Person</div><div class="line">GROUP BY</div><div class="line">	Email</div><div class="line">HAVING</div><div class="line">	count(*) &gt; 1;</div></pre></td></tr></table></figure>
<h3 id="Leetcode-183-Customers-Who-Never-Order"><a href="#Leetcode-183-Customers-Who-Never-Order" class="headerlink" title="Leetcode 183 Customers Who Never Order"></a><a href="https://leetcode-cn.com/problems/customers-who-never-order/description/" target="_blank" rel="external">Leetcode 183 Customers Who Never Order</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</div><div class="line"></div><div class="line">Customers 表：</div><div class="line"></div><div class="line">+----+-------+</div><div class="line">| Id | Name  |</div><div class="line">+----+-------+</div><div class="line">| 1  | Joe   |</div><div class="line">| 2  | Henry |</div><div class="line">| 3  | Sam   |</div><div class="line">| 4  | Max   |</div><div class="line">+----+-------+</div><div class="line"></div><div class="line">Orders 表：</div><div class="line"></div><div class="line">+----+------------+</div><div class="line">| Id | CustomerId |</div><div class="line">+----+------------+</div><div class="line">| 1  | 3          |</div><div class="line">| 2  | 1          |</div><div class="line">+----+------------+</div><div class="line"></div><div class="line">例如给定上述表格，你的查询应返回：</div><div class="line"></div><div class="line">+-----------+</div><div class="line">| Customers |</div><div class="line">+-----------+</div><div class="line">| Henry     |</div><div class="line">| Max       |</div><div class="line">+-----------+</div></pre></td></tr></table></figure>
<p>My solution：</p>
<ul>
<li>使用not in:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	NAME AS Customers</div><div class="line">FROM</div><div class="line">	Customers c</div><div class="line">WHERE</div><div class="line">	c.Id NOT IN (</div><div class="line">		SELECT</div><div class="line">			CustomerId</div><div class="line">		FROM</div><div class="line">			Orders o</div><div class="line">	);</div></pre></td></tr></table></figure>
<ul>
<li>使用not esists: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	NAME AS Customers</div><div class="line">FROM</div><div class="line">	Customers c</div><div class="line">WHERE</div><div class="line">	NOT EXISTS (</div><div class="line">		SELECT</div><div class="line">			CustomerId</div><div class="line">		FROM</div><div class="line">			Orders o</div><div class="line">		WHERE</div><div class="line">			o.CustomerId = c.id</div><div class="line">	);</div></pre></td></tr></table></figure>
<ul>
<li>使用left join:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	NAME AS Customers</div><div class="line">FROM</div><div class="line">	Customers c</div><div class="line">LEFT JOIN Orders o ON c.Id = o.CustomerId</div><div class="line">WHERE</div><div class="line">	o.Id IS NULL;</div></pre></td></tr></table></figure>
<h3 id="Leetcode-184-Department-Highest-Salary"><a href="#Leetcode-184-Department-Highest-Salary" class="headerlink" title="Leetcode 184 Department Highest Salary"></a><a href="https://leetcode-cn.com/problems/department-highest-salary/description/" target="_blank" rel="external">Leetcode 184 Department Highest Salary</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</div><div class="line"></div><div class="line">+----+-------+--------+--------------+</div><div class="line">| Id | Name  | Salary | DepartmentId |</div><div class="line">+----+-------+--------+--------------+</div><div class="line">| 1  | Joe   | 70000  | 1            |</div><div class="line">| 2  | Henry | 80000  | 2            |</div><div class="line">| 3  | Sam   | 60000  | 2            |</div><div class="line">| 4  | Max   | 90000  | 1            |</div><div class="line">+----+-------+--------+--------------+</div><div class="line"></div><div class="line">Department 表包含公司所有部门的信息。</div><div class="line"></div><div class="line">+----+----------+</div><div class="line">| Id | Name     |</div><div class="line">+----+----------+</div><div class="line">| 1  | IT       |</div><div class="line">| 2  | Sales    |</div><div class="line">+----+----------+</div><div class="line"></div><div class="line">编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</div><div class="line"></div><div class="line">+------------+----------+--------+</div><div class="line">| Department | Employee | Salary |</div><div class="line">+------------+----------+--------+</div><div class="line">| IT         | Max      | 90000  |</div><div class="line">| Sales      | Henry    | 80000  |</div><div class="line">+------------+----------+--------+</div></pre></td></tr></table></figure>
<p>首先使用临时表t查询出每一个部门的最高薪水，然后使用薪水值和部门Id与雇员表Employee做内连接，再通过部门Id与部门表Department做内连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	d.`Name` AS Department,</div><div class="line">	e. NAME AS Employee,</div><div class="line">	t.Salary</div><div class="line">FROM</div><div class="line">	Employee e</div><div class="line">INNER JOIN (</div><div class="line">	SELECT</div><div class="line">		DepartmentId,</div><div class="line">		max(Salary) AS Salary</div><div class="line">	FROM</div><div class="line">		Employee</div><div class="line">	GROUP BY</div><div class="line">		DepartmentId</div><div class="line">) t ON e.DepartmentId = t.DepartmentId</div><div class="line">AND e.Salary = t.Salary</div><div class="line">INNER JOIN Department d ON d.id = t.DepartmentId;</div></pre></td></tr></table></figure>
<h3 id="Leetcode-185-Department-Top-Three-Salaries"><a href="#Leetcode-185-Department-Top-Three-Salaries" class="headerlink" title="Leetcode 185 Department Top Three Salaries"></a><a href="https://leetcode-cn.com/problems/department-top-three-salaries/description/" target="_blank" rel="external">Leetcode 185 Department Top Three Salaries</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id 。</div><div class="line"></div><div class="line">+----+-------+--------+--------------+</div><div class="line">| Id | Name  | Salary | DepartmentId |</div><div class="line">+----+-------+--------+--------------+</div><div class="line">| 1  | Joe   | 70000  | 1            |</div><div class="line">| 2  | Henry | 80000  | 2            |</div><div class="line">| 3  | Sam   | 60000  | 2            |</div><div class="line">| 4  | Max   | 90000  | 1            |</div><div class="line">| 5  | Janet | 69000  | 1            |</div><div class="line">| 6  | Randy | 85000  | 1            |</div><div class="line">+----+-------+--------+--------------+</div><div class="line"></div><div class="line">Department 表包含公司所有部门的信息。</div><div class="line"></div><div class="line">+----+----------+</div><div class="line">| Id | Name     |</div><div class="line">+----+----------+</div><div class="line">| 1  | IT       |</div><div class="line">| 2  | Sales    |</div><div class="line">+----+----------+</div><div class="line"></div><div class="line">编写一个 SQL 查询，找出每个部门工资前三高的员工。例如，根据上述给定的表格，查询结果应返回：</div><div class="line"></div><div class="line">+------------+----------+--------+</div><div class="line">| Department | Employee | Salary |</div><div class="line">+------------+----------+--------+</div><div class="line">| IT         | Max      | 90000  |</div><div class="line">| IT         | Randy    | 85000  |</div><div class="line">| IT         | Joe      | 70000  |</div><div class="line">| Sales      | Henry    | 80000  |</div><div class="line">| Sales      | Sam      | 60000  |</div><div class="line">+------------+----------+--------+</div></pre></td></tr></table></figure>
<p>My Solution</p>
<ul>
<li>使用变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	d. NAME AS Department,</div><div class="line">	t. NAME AS Employee,</div><div class="line">	Salary</div><div class="line">FROM</div><div class="line">	(</div><div class="line">		SELECT</div><div class="line">			DepartmentId,</div><div class="line">			NAME,</div><div class="line">			Salary,</div><div class="line">			@rank :=</div><div class="line">		IF (</div><div class="line">			@prevDeptId != DepartmentId,</div><div class="line">			1,</div><div class="line"></div><div class="line">			IF (</div><div class="line">				@prevSalary = Salary,</div><div class="line">				@rank,</div><div class="line">				@rank + 1</div><div class="line">			)</div><div class="line">		) AS Rank,</div><div class="line">		@prevDeptId := DepartmentId AS prevDeptId,</div><div class="line">		@prevSalary := Salary AS prevSalary</div><div class="line">	FROM</div><div class="line">		Employee e,</div><div class="line">		(</div><div class="line">			SELECT</div><div class="line">				@rank := 0,</div><div class="line">				@prevDeptId := NULL,</div><div class="line">				@prevSalary := NULL</div><div class="line">		) r</div><div class="line">	ORDER BY</div><div class="line">		DepartmentId ASC,</div><div class="line">		Salary DESC</div><div class="line">	) t</div><div class="line">INNER JOIN Department d ON t.DepartmentId = d.Id</div><div class="line">WHERE</div><div class="line">	t.rank &lt;= 3;</div></pre></td></tr></table></figure>
<ul>
<li>不使用变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	D. NAME AS Department,</div><div class="line">	E. NAME AS Employee,</div><div class="line">	E.Salary AS Salary</div><div class="line">FROM</div><div class="line">	Employee E,</div><div class="line">	Department D</div><div class="line">WHERE</div><div class="line">	(</div><div class="line">		SELECT</div><div class="line">			count(DISTINCT(Salary))</div><div class="line">		FROM</div><div class="line">			Employee</div><div class="line">		WHERE</div><div class="line">			DepartmentId = E.DepartmentId</div><div class="line">		AND Salary &gt; E.Salary</div><div class="line">	) &lt; 3</div><div class="line">AND E.DepartmentId = D.Id</div><div class="line">ORDER BY</div><div class="line">	E.DepartmentId,</div><div class="line">	E.Salary DESC;</div></pre></td></tr></table></figure>
<h3 id="leetcode-177-Nth-Highest-Salary"><a href="#leetcode-177-Nth-Highest-Salary" class="headerlink" title="leetcode 177 Nth Highest Salary"></a><a href="https://leetcode-cn.com/proleetcode177-Nth Highest Salaryblems/nth-highest-salary/description/" target="_blank" rel="external">leetcode 177 Nth Highest Salary</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。</div><div class="line"></div><div class="line">+----+--------+</div><div class="line">| Id | Salary |</div><div class="line">+----+--------+</div><div class="line">| 1  | 100    |</div><div class="line">| 2  | 200    |</div><div class="line">| 3  | 300    |</div><div class="line">+----+--------+</div><div class="line"></div><div class="line">例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。</div><div class="line"></div><div class="line">+------------------------+</div><div class="line">| getNthHighestSalary(2) |</div><div class="line">+------------------------+</div><div class="line">| 200                    |</div><div class="line">+------------------------+</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">CREATE FUNCTION getNthHighestSalary (N INT) RETURNS INT</div><div class="line">BEGIN</div><div class="line">	DECLARE</div><div class="line">		n1 INT;</div><div class="line"></div><div class="line"></div><div class="line">SET n1 = N - 1;</div><div class="line"></div><div class="line">RETURN (</div><div class="line">	SELECT</div><div class="line">		Salary</div><div class="line">	FROM</div><div class="line">		(</div><div class="line">			SELECT DISTINCT</div><div class="line">				(Salary)</div><div class="line">			FROM</div><div class="line">				Employee</div><div class="line">		) t</div><div class="line">	ORDER BY</div><div class="line">		Salary DESC</div><div class="line">	LIMIT n1,</div><div class="line">	1</div><div class="line">);</div><div class="line"></div><div class="line">END</div></pre></td></tr></table></figure>
<h3 id="Leetcode-180-Consecutive-Numbers-Medium"><a href="#Leetcode-180-Consecutive-Numbers-Medium" class="headerlink" title="Leetcode 180 Consecutive Numbers-Medium"></a><a href="https://leetcode-cn.com/problems/consecutive-numbers/description/" target="_blank" rel="external">Leetcode 180 Consecutive Numbers-Medium</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">编写一个 SQL 查询，查找所有至少连续出现三次的数字。</div><div class="line"></div><div class="line">+----+-----+</div><div class="line">| Id | Num |</div><div class="line">+----+-----+</div><div class="line">| 1  |  1  |</div><div class="line">| 2  |  1  |</div><div class="line">| 3  |  1  |</div><div class="line">| 4  |  2  |</div><div class="line">| 5  |  1  |</div><div class="line">| 6  |  2  |</div><div class="line">| 7  |  2  |</div><div class="line">+----+-----+</div><div class="line"></div><div class="line">例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。</div><div class="line"></div><div class="line">+-----------------+</div><div class="line">| ConsecutiveNums |</div><div class="line">+-----------------+</div><div class="line">| 1               |</div><div class="line">+-----------------+</div></pre></td></tr></table></figure>
<p>解法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SELECT DISTINCT</div><div class="line">	l1.Num AS ConsecutiveNums</div><div class="line">FROM</div><div class="line">	LOGS l1,</div><div class="line">	LOGS l2,</div><div class="line">	LOGS l3</div><div class="line">WHERE</div><div class="line">	l1.Id = l2.Id - 1</div><div class="line">AND l2.Id = l3.Id - 1</div><div class="line">AND l1.Num = l2.Num</div><div class="line">AND l2.Num = l3.Num</div></pre></td></tr></table></figure></p>
<p>解法二：</p>
<p>解法一有致命的缺点：那就是如果n过大的时候，就不行了。需要用变量的方法来写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">SELECT DISTINCT</div><div class="line">	num</div><div class="line">FROM</div><div class="line">	(</div><div class="line">		SELECT</div><div class="line">			num,</div><div class="line">			CASE</div><div class="line">		WHEN @record = num THEN</div><div class="line">			@count :=@count + 1</div><div class="line">		WHEN @record &lt;&gt; @record := num THEN</div><div class="line">			@count := 1</div><div class="line">		END AS n</div><div class="line">		FROM</div><div class="line">			LOGS,</div><div class="line">			(</div><div class="line">				SELECT</div><div class="line">					@count := 0,</div><div class="line">					@record := (SELECT num FROM LOGS LIMIT 0, 1)</div><div class="line">			) r</div><div class="line">	) a</div><div class="line">WHERE</div><div class="line">	a.n &gt;= 3</div></pre></td></tr></table></figure>
<h3 id="LeetCode-262-Trips-and-Users"><a href="#LeetCode-262-Trips-and-Users" class="headerlink" title="LeetCode 262 Trips and Users"></a><a href="https://leetcode-cn.com/problems/trips-and-users/description/" target="_blank" rel="external">LeetCode 262 Trips and Users</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">Trips 表中存所有出租车的行程信息。每段行程有唯一健 Id，Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。</div><div class="line"></div><div class="line">+----+-----------+-----------+---------+--------------------+----------+</div><div class="line">| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|</div><div class="line">+----+-----------+-----------+---------+--------------------+----------+</div><div class="line">| 1  |     1     |    10     |    1    |     completed      |2013-10-01|</div><div class="line">| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|</div><div class="line">| 3  |     3     |    12     |    6    |     completed      |2013-10-01|</div><div class="line">| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|</div><div class="line">| 5  |     1     |    10     |    1    |     completed      |2013-10-02|</div><div class="line">| 6  |     2     |    11     |    6    |     completed      |2013-10-02|</div><div class="line">| 7  |     3     |    12     |    6    |     completed      |2013-10-02|</div><div class="line">| 8  |     2     |    12     |    12   |     completed      |2013-10-03|</div><div class="line">| 9  |     3     |    10     |    12   |     completed      |2013-10-03| </div><div class="line">| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|</div><div class="line">+----+-----------+-----------+---------+--------------------+----------+</div><div class="line"></div><div class="line">Users 表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（‘client’, ‘driver’, ‘partner’）的枚举类型。</div><div class="line"></div><div class="line">+----------+--------+--------+</div><div class="line">| Users_Id | Banned |  Role  |</div><div class="line">+----------+--------+--------+</div><div class="line">|    1     |   No   | client |</div><div class="line">|    2     |   Yes  | client |</div><div class="line">|    3     |   No   | client |</div><div class="line">|    4     |   No   | client |</div><div class="line">|    10    |   No   | driver |</div><div class="line">|    11    |   No   | driver |</div><div class="line">|    12    |   No   | driver |</div><div class="line">|    13    |   No   | driver |</div><div class="line">+----------+--------+--------+</div><div class="line"></div><div class="line">写一段 SQL 语句查出 2013年10月1日 至 2013年10月3日 期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。</div><div class="line"></div><div class="line">+------------+-------------------+</div><div class="line">|     Day    | Cancellation Rate |</div><div class="line">+------------+-------------------+</div><div class="line">| 2013-10-01 |       0.33        |</div><div class="line">| 2013-10-02 |       0.00        |</div><div class="line">| 2013-10-03 |       0.50        |</div><div class="line">+------------+-------------------+</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">-- SELECT</div><div class="line">-- 	`Status`,</div><div class="line">-- 	DATE(Request_at) AS date,</div><div class="line">-- 	COUNT(*) AS count</div><div class="line">-- FROM</div><div class="line">-- 	trips</div><div class="line">-- GROUP BY</div><div class="line">-- 	`Status`,</div><div class="line">-- 	date</div><div class="line">-- HAVING</div><div class="line">--   date &gt;= DATE(&apos;2013-10-01&apos;)</div><div class="line">-- AND date &lt;= DATE(&apos;2013-10-03&apos;)</div><div class="line">-- ORDER BY</div><div class="line">--   date</div><div class="line">SELECT</div><div class="line">	Request_at DAY,</div><div class="line">	ROUND(</div><div class="line">		COUNT(</div><div class="line">			IF (</div><div class="line">				STATUS != &apos;completed&apos;,</div><div class="line">				TRUE,</div><div class="line">				NULL</div><div class="line">			)</div><div class="line">		) / COUNT(*),</div><div class="line">		2</div><div class="line">	) &apos;Cancellation Rate&apos;</div><div class="line">FROM</div><div class="line">	Trips</div><div class="line">WHERE</div><div class="line">	(</div><div class="line">		Request_at BETWEEN &apos;2013-10-01&apos;</div><div class="line">		AND &apos;2013-10-03&apos;</div><div class="line">	)</div><div class="line">AND Client_Id IN (</div><div class="line">	SELECT</div><div class="line">		Users_Id</div><div class="line">	FROM</div><div class="line">		Users</div><div class="line">	WHERE</div><div class="line">		Banned = &apos;No&apos;</div><div class="line">)</div><div class="line">GROUP BY</div><div class="line">	Request_at;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	request_at AS DAY,</div><div class="line">	round(</div><div class="line">		sum(</div><div class="line">			CASE</div><div class="line">			WHEN STATUS = &quot;completed&quot; THEN</div><div class="line">				0</div><div class="line">			ELSE</div><div class="line">				1</div><div class="line">			END</div><div class="line">		) / count(*),</div><div class="line">		2</div><div class="line">	) AS &quot;Cancellation Rate&quot;</div><div class="line">FROM</div><div class="line">	(</div><div class="line">		SELECT</div><div class="line">			*</div><div class="line">		FROM</div><div class="line">			Trips</div><div class="line">		WHERE</div><div class="line">			client_id NOT IN (</div><div class="line">				SELECT</div><div class="line">					users_id</div><div class="line">				FROM</div><div class="line">					Users</div><div class="line">				WHERE</div><div class="line">					banned = &quot;yes&quot;</div><div class="line">				AND role = &quot;client&quot;</div><div class="line">			)</div><div class="line">		AND request_at BETWEEN &quot;2013-10-01&quot;</div><div class="line">		AND &quot;2013-10-03&quot;</div><div class="line">	) AS t</div><div class="line">GROUP BY</div><div class="line">	request_at</div><div class="line">ORDER BY</div><div class="line">	request_at;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">SELECT</div><div class="line">	request_at AS DAY,</div><div class="line">	round(</div><div class="line">		sum(</div><div class="line">			CASE</div><div class="line">			WHEN STATUS = &quot;completed&quot; THEN</div><div class="line">				0</div><div class="line">			ELSE</div><div class="line">				1</div><div class="line">			END</div><div class="line">		) / count(*),</div><div class="line">		2</div><div class="line">	) AS &quot;Cancellation Rate&quot;</div><div class="line">FROM</div><div class="line">	Trips t</div><div class="line">INNER JOIN Users u ON t.Client_Id = u.Users_Id</div><div class="line">AND u.Banned = &apos;No&apos;</div><div class="line">WHERE</div><div class="line">	request_at BETWEEN &quot;2013-10-01&quot;</div><div class="line">AND &quot;2013-10-03&quot;</div><div class="line">GROUP BY</div><div class="line">	request_at</div><div class="line">ORDER BY</div><div class="line">	request_at;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;leetcode-181-Employees-Earning-More-Than-Their-Managers&quot;&gt;&lt;a href=&quot;#leetcode-181-Employees-Earning-More-Than-Their-Managers&quot; class=&quot;h
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>干货|Arduino初体验</title>
    <link href="http://yoursite.com/2018/05/22/%E5%B9%B2%E8%B4%A7-Arduino%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2018/05/22/干货-Arduino初体验/</id>
    <published>2018-05-21T23:38:53.000Z</published>
    <updated>2018-05-21T16:19:15.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Arduino是一款便捷灵活、方便上手的开源电子原型平台。主要包含两个主要的部分：硬件部分是可以用来做电路连接的各种型号的Arduino开发板；软件则是Arduino IDE(程序开发环境)，你只要在IDE中编写程序代码，将程序上载到Arduino后，程序便会告诉Arduino要做些什么。Arduino能通过各种各样的传感器来感知环境，通过控制灯光、马达和其他的装置来反馈、影响环境。Arduino的简易性，丰富的扩展板和成熟的开源社区使之成为开源硬件和Maker Movement的中流砥柱。</p>
<h3 id="找到的一些干货"><a href="#找到的一些干货" class="headerlink" title="找到的一些干货"></a>找到的一些干货</h3><p><a href="http://www.naozhendang.com/s/learning-arduino" target="_blank" rel="external">干货教程</a><br><a href="https://www.arduino.cc/reference/en/" target="_blank" rel="external">官网教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Arduino是一款便捷灵活、方便上手的开源电子原型平台。主要包含两个主要的部分：硬件部分是可以用来做电路连接的各种型号的Arduino开发
    
    </summary>
    
      <category term="干货" scheme="http://yoursite.com/categories/%E5%B9%B2%E8%B4%A7/"/>
    
    
      <category term="干货" scheme="http://yoursite.com/tags/%E5%B9%B2%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>Linux|Linux的那些事</title>
    <link href="http://yoursite.com/2018/05/16/Linux-Linux%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/05/16/Linux-Linux的那些事/</id>
    <published>2018-05-16T10:13:29.000Z</published>
    <updated>2018-05-18T03:26:30.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux的基础知识"><a href="#Linux的基础知识" class="headerlink" title="Linux的基础知识"></a>Linux的基础知识</h3><p>Linux系统的组成：</p>
<ul>
<li>linux内核（linus 团队管理）</li>
<li>shell：用户与内核交互的接口</li>
<li>文件系统：ext3、ext4等，windows 有 fat32 、ntfs</li>
<li>第三方应用软件</li>
</ul>
<h4 id="Shell的基本知识"><a href="#Shell的基本知识" class="headerlink" title="Shell的基本知识"></a>Shell的基本知识</h4><p><strong>Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口(命令解释器)。</strong></p>
<p>Shell可以执行：</p>
<ul>
<li>内部命令</li>
<li>应用程序</li>
<li>shell脚本</li>
</ul>
<p><img src="/images/linux的那些事-01.png" alt="shell"></p>
<p>于是乎，我们利用Shell就可以干下面这些事了：</p>
<ul>
<li>命令行解释(这是用得最多的！)</li>
<li>命令的多种执行顺序</li>
<li>通配符（ wild-card characters ）</li>
<li>命令补全、别名机制、命令历史</li>
<li>I/O重定向（ Input/output redirection ）</li>
<li>管道（ pipes ）</li>
<li>命令替换（ 或$( ) ）</li>
<li>Shell编程语言（ Shell Script ）</li>
</ul>
<p>常见的shell版本：</p>
<p><img src="/images/linux的那些事-02.png" alt="shell"></p>
<h4 id="Linux基本目录结构"><a href="#Linux基本目录结构" class="headerlink" title="Linux基本目录结构"></a>Linux基本目录结构</h4><p><img src="/images/linux的那些事-03.png" alt="目录结构"></p>
<p>Linux 文件系统是一个目录树的结构，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录。</p>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>一般作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>bin</td>
<td>存放二进制可执行文件(ls,cat,mkdir等)</td>
</tr>
<tr>
<td>boot</td>
<td>存放用于系统引导时使用的各种文件</td>
</tr>
<tr>
<td>dev</td>
<td>用于存放设备文件</td>
</tr>
<tr>
<td>etc</td>
<td>存放系统配置文件</td>
</tr>
<tr>
<td>home</td>
<td>存放所有用户文件的根目录</td>
</tr>
<tr>
<td>lib</td>
<td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td>
</tr>
<tr>
<td>mnt</td>
<td>系统管理员安装临时文件系统的安装点</td>
</tr>
<tr>
<td>opt</td>
<td>额外安装的可选应用程序包所放置的位置</td>
</tr>
<tr>
<td>proc</td>
<td>虚拟文件系统，存放当前内存的映射</td>
</tr>
<tr>
<td>root</td>
<td>超级用户目录</td>
</tr>
<tr>
<td>sbin</td>
<td>存放二进制可执行文件，只有root才能访问</td>
</tr>
<tr>
<td>tmp</td>
<td>用于存放各种临时文件</td>
</tr>
<tr>
<td>usr</td>
<td>用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td>
</tr>
<tr>
<td>var</td>
<td>用于存放运行时需要改变数据的文件</td>
</tr>
</tbody>
</table>
<h4 id="命令基本格式"><a href="#命令基本格式" class="headerlink" title="命令基本格式"></a>命令基本格式</h4><p><code>cmd [options] [arguments]</code>，options称为选项，arguments称为参数。选项和参数都作为Shell命令执行时的输入，它们之间用空格分隔开。同时，<strong>Linux是区分大小写的</strong>。</p>
<p>一般来说，后面跟的选项如果单字符选项前使用一个<code>减号-</code>,单词选项前使用<code>两个减号--</code>。</p>
<p>在Linux中，可执行的文件也进行了分类：</p>
<ul>
<li>内置命令：出于效率的考虑，将一些常用命令的解释程序构造在Shell内部。</li>
<li>外置命令：存放在/bin、/sbin目录下的命令</li>
<li>实用程序：存放在/usr/bin、/usr/sbin、/usr/share、/usr/local/bin等目录下的实用程序</li>
<li>用户程序：用户程序经过编译生成可执行文件后，可作为Shell命令运行</li>
<li>Shell脚本：由Shell语言编写的批处理文件，可作为Shell命令运行</li>
</ul>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>通配符和正则表达式还是不同的，不要混为一谈了。</p>
<ul>
<li>*：匹配任何字符和任何数目的字符</li>
<li>?：匹配单一数目的任何字符</li>
<li>[]：匹配 [] 之内的任意一个字符</li>
<li>[! ]：匹配除了[! ]之外的任意一个字符，!表示非的意思</li>
</ul>
<h4 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h4><p>在Linux下文件的类型有这么多：</p>
<ul>
<li>普通文件<code>-</code></li>
<li>目录 <code>d</code></li>
<li>符号链接 <code>l</code><ul>
<li>硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块</li>
<li>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径(简单地理解为 Windows 中常见的快捷方式)。</li>
</ul>
</li>
<li>字符设备文件 <code>c</code></li>
<li>块设备文件 <code>b</code></li>
<li>套接字 <code>s</code></li>
<li>命名管道 <code>p</code></li>
</ul>
<h3 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h3><p>由于使用Linux的过程中，基本都是通过命令进行操作，所以还是有必要记忆一些常用的命令，比如文件夹、文件的操作，怎么去编辑文件…</p>
<h4 id="常用的文件、目录操作命令"><a href="#常用的文件、目录操作命令" class="headerlink" title="常用的文件、目录操作命令"></a>常用的文件、目录操作命令</h4><p>这是我们使用得最多的命令了，Linux最基础的命令！</p>
<ul>
<li>可用 <code>pwd</code> 命令查看用户的当前目录</li>
<li>可用 <code>cd</code> 命令来切换目录</li>
<li><code>.</code>表示当前目录</li>
<li><code>..</code> 表示当前目录的上一级目录（父目录）</li>
<li><code>-</code>表示用 cd 命令切换目录前所在的目录</li>
<li><code>~</code>表示用户主目录的绝对路径名</li>
</ul>
<p><strong>tips:输入命令的时候要常用<code>tab键</code>来补全</strong></p>
<ul>
<li><code>ls</code>：显示文件或目录信息</li>
<li><code>mkdir</code>：当前目录下创建一个空目录</li>
<li><code>rmdir</code>：要求目录为空</li>
<li><code>touch</code>：生成一个空文件或更改文件的时间</li>
<li><code>cp</code>：复制文件或目录</li>
<li><code>mv</code>：移动文件或目录、文件或目录改名</li>
<li><code>rm</code>：删除文件或目录</li>
<li><code>ln</code>：建立链接文件</li>
<li><code>find</code>：查找文件</li>
<li><code>file/stat</code>：查看文件类型或文件属性信息</li>
<li><code>cat</code>：查看文本文件内容</li>
<li><code>more</code>：可以分页看</li>
<li><code>less</code>：不仅可以分页，还可以方便地搜索，回翻等操作</li>
<li><code>tail -10</code>： 查看文件的尾部的10行</li>
<li><code>head -20</code>：查看文件的头部20行</li>
<li><code>echo</code> ：把内容重定向到指定的文件中 ，有则打开，无则创建</li>
<li><code>管道命令 |</code> ：将前面的结果给后面的命令，例如：ls -la | wc ，将ls的结果加油wc命令来统计字数</li>
<li><code>重定向 &gt; 是覆盖模式，&gt;&gt; 是追加模式</code> :例如：echo “Java3y,zhen de hen xihuan ni” &gt; qingshu.txt 把左边的输出放到右边的文件里去</li>
</ul>
<p>学了这些命令我们能干嘛？其实就是在Windows下复制文件、粘贴文件、创建文件、查看文件这几种~~~</p>
<h4 id="文件打包和压缩命令"><a href="#文件打包和压缩命令" class="headerlink" title="文件打包和压缩命令"></a>文件打包和压缩命令</h4><p>接下来介绍如何在Linux下压缩和解压文件。</p>
<p><img src="/images/linux的那些事-04.png" alt="压缩解压"></p>
<p><img src="/images/linux的那些事-05.png" alt="压缩解压"></p>
<h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p> Linux系统上的所有的文件和目录都有权限<br> 有三种类别的权限：owner，group和other<br> 每个类别都有3个权限位：read, write, execute (rwx)</p>
<p>对于普通文件:</p>
<ul>
<li>r =&gt; Can look at the contents of a file</li>
<li>w =&gt; Can change or delete the contents of a file</li>
<li>x =&gt; Can execute the file (r is also needed if a script)</li>
</ul>
<p>对于目录文件:</p>
<ul>
<li>r =&gt; Can list the files within a directory (ls)</li>
<li>w =&gt; Can <strong>create/remove</strong> files in the directory</li>
<li>x =&gt; Can change into the directory and access the files within (cd)</li>
</ul>
<h5 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h5><p> 修改文件权限用chmod 命令<br> 修改权限有两种方式：</p>
<pre><code>1. 符号表示的权限(Symbolic Notation)
2. 八进制表示的权限(Octal Notation)
</code></pre><p> 必须是文件或目录的所有者才能修改其访问权限<br> root 用户可以修改任何文件和目录的权限</p>
<p><img src="/images/linux的那些事-07.png" alt="文件权限"></p>
<p><img src="/images/linux的那些事-08.png" alt="文件权限"></p>
<h3 id="VI编辑器"><a href="#VI编辑器" class="headerlink" title="VI编辑器"></a>VI编辑器</h3><p><code>vi</code>是 “Visual interface” 的简称，它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需要对其进行定制，这是其他编辑程序所没有的。</p>
<p><img src="/images/linux的那些事-06.png" alt="vi编辑器"></p>
<p><strong>普通模式</strong>：</p>
<ul>
<li><code>G</code> 用于直接跳转到文件尾</li>
<li><code>ZZ</code>用于存盘退出Vi</li>
<li><code>ZQ</code> 用于不存盘退出Vi</li>
<li><code>/和？</code> 用于查找字符串</li>
<li><code>n</code>继续查找下一个</li>
<li><code>yy</code> 复制一行</li>
<li><code>p</code>粘帖在下一行，<code>P</code>粘贴在前一行</li>
<li><code>dd</code> 剪切一行</li>
<li><code>x</code> 删除光标所在的字符</li>
<li><code>u</code> 取消上一次编辑操作（undo）</li>
</ul>
<p><strong>编辑模式</strong>：在编辑模式下，用户输入的任何字符都被vim当做文件内容保存起来，并将其显示在屏幕上。</p>
<p><strong>命令行模式</strong>：Normal 模式下，用户按冒号 :即可进入 Command 模式，此时 vim 会在显示窗口的最后一行 (屏幕的最后一行) 显示一个 “:” 作为 Command 模式的提示符，等待输入命令。</p>
<ul>
<li><code>:w</code> 保存当前编辑文件，但并不退出</li>
<li><code>:w</code> newfile 存为另外一个名为 “newfile” 的文件</li>
<li><code>:wq</code> 用于存盘退出Vi</li>
<li><code>:q!</code> 用于不存盘退出Vi</li>
<li><code>:q</code>用于直接退出Vi （未做修改）</li>
</ul>
<p>在扩展模式下可以进行查找并替换</p>
<p>示例将全文的the 单词替换为the one 的vi 界面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">This file is being created using the vi editor</div><div class="line">Welcome to using the vi editor...</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">:g/ the /s// the one /g</div><div class="line"></div><div class="line">命令解析：</div><div class="line">g/ the 查找文本中所有the的关键词</div><div class="line">/s// the one 替换成the one</div><div class="line">/g 替换所有(global)的关键词</div></pre></td></tr></table></figure></p>
<p>设置Vi环境:</p>
<ul>
<li>:set autoindent* 缩进,常用于程序的编写</li>
<li>:set noautoindent *取消缩进</li>
<li>:set number* 在编辑文件时显示行号</li>
<li>:set nonumber *不显示行号</li>
<li>:set tabstop=value *设置显示制表符的空格字符个数</li>
<li>:set *显示设置的所有选项</li>
<li>:set all* 显示所有可以设置的选项</li>
</ul>
<h3 id="关于进程"><a href="#关于进程" class="headerlink" title="关于进程"></a>关于进程</h3><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p> 进程是一个程序针对一组数据的一次执行<br> 进程是整个系统中资源分配的最小单位<br> 进程是系统调用，系统处理机调度最小的单位<br> 每个程序(命令)的运行都会产生一个进程</p>
<p>执行中的程序在称作进程。当程序以可执行文件存放在存储中，并且运行的时候，每个进程会被动态得分配系统资源、内存、安全属性和与之相关的状态。可以有多个进程关联到同一个程序，并同时执行不会互相干扰。操作系统会有效地管理和追踪所有运行着的进程。</p>
<p>为了管理这些进程，用户应该能够：</p>
<ul>
<li>查看所有运行中的进程</li>
<li>查看进程消耗资源</li>
<li>定位个别进程并且对其执行指定操作</li>
<li>改变进程的优先级</li>
<li>杀死指定进程</li>
<li>限制进程可用的系统资源等</li>
</ul>
<h4 id="进程与变量"><a href="#进程与变量" class="headerlink" title="进程与变量"></a>进程与变量</h4><p> 变量是进程环境的一部分<br> 不同进程间变量是不能互相访问和修改的<br> 子进程要想继续父进程的变量，必须用export命令将变量输出成全局变量</p>
<h4 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h4><p>Linux提供了许多命令来让用户来高效掌控上述的操作。接下来，一个一个的来讲解下。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ps</code></td>
<td>Linux 中最基础的浏览系统中的进程的命令。能列出系统中运行的进程，包括进程号、命令、CPU使用量、内存使用量等。</td>
</tr>
<tr>
<td><code>pstree</code></td>
<td>linux中，每一个进程都是由其父进程创建的。此命令以可视化方式显示进程，通过显示进程的树状图来展示进程间关系。如果指定了pid了，那么树的根是该pid，不然将会是init（pid： 1）。</td>
</tr>
<tr>
<td><code>top</code></td>
<td>top’是一个更加有用的命令，可以监视系统中不同的进程所使用的资源。它提供实时的系统状态信息。显示进程的数据包括 PID、进程属主、优先级、%CPU、%memory等。可以使用这些显示指示出资源使用量。</td>
</tr>
<tr>
<td><code>htop</code></td>
<td>htop与top很类似，但是htop是交互式的文本模式的进程查看器。它通过文字图形化地显示每一个进程的CPU和内存使用量、swap使用量。使用上下光标键选择进程，F7和F8改变优先级，F9杀死进程。Htop不是系统默认安装的，所以需要额外安装。</td>
</tr>
<tr>
<td><code>nice</code></td>
<td>通过nice命令的帮助，用户可以设置和改变进程的优先级。提高一个进程的优先级，内核会分配更多CPU时间片给这个进程。默认情况下，进程以0的优先级启动。进程优先级可以通过top命令显示的NI（nice value）列查看。</td>
</tr>
<tr>
<td><code>renice</code></td>
<td>renice命令类似nice命令。使用这个命令可以改变正在运行的进程优先值。注意，用户只能改变属于他们自己的进程的优先值。</td>
</tr>
<tr>
<td><code>kill</code></td>
<td>这个命令用于发送信号来结束进程。如果一个进程没有响应杀死命令，这也许就需要强制杀死，使用-9参数来执行。注意，使用强制杀死的时候一定要小心，因为进程没有时机清理现场，也许写入文件没有完成。如果我们不知道进程PID或者打算用名字杀死进程时候，killall就能派上用场。</td>
</tr>
<tr>
<td><code>ulimit</code></td>
<td>该命令用于控制系统资源在shell和进程上的分配量。对于系统管理员是最有用的，可以管理重度使用和存在性能问题的系统。限制资源大小可以确保重要进程持续运行，其他进程不会占用过多资源。</td>
</tr>
<tr>
<td><code>w</code></td>
<td>w 提供当前登录的用户及其正在执行的进程的信息。显示信息头包含信息，如当前时间、系统运行时长、登录用户总数、过去的1，5，15分钟内的负载均衡数。</td>
</tr>
<tr>
<td><code>pgrep</code></td>
<td>pgrep的意思是”进程号全局正则匹配输出”。该命令扫描当前运行进程，然后按照命令匹配条件列出匹配结果到标准输出。对于通过名字检索进程号是很有用。</td>
</tr>
<tr>
<td><code>fg</code>,<code>bg</code></td>
<td>有时，命令需要很长的时间才能执行完成。对于这种情况，我们使用‘bg’命令可以将任务放在后台执行，而用‘fg’可以调到前台来使用。</td>
</tr>
<tr>
<td><code>ipcs</code></td>
<td>ipcs命令报告进程间通信设施状态。（共享内存，信号量和消息队列）</td>
</tr>
</tbody>
</table>
<h3 id="一些实用工具"><a href="#一些实用工具" class="headerlink" title="一些实用工具"></a>一些实用工具</h3><h4 id="find-文件查找工具"><a href="#find-文件查找工具" class="headerlink" title="find|文件查找工具"></a><code>find|文件查找工具</code></h4><p>find命令是一个无处不在命令，是linux中最有用的命令之一。find命令用于：在一个目录（及子目录）中搜索文件，你可以指定一些匹配条件，如按文件名、文件类型、用户甚至是时间戳查找文件。</p>
<p><img src="/images/linux的那些事-09.png" alt="find"></p>
<ul>
<li>一般来说find主要用于在指定 目录结构中查找 特定文件:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ find . -name sum</div><div class="line">./color/sum</div><div class="line">./shape/sum</div></pre></td></tr></table></figure>
<ul>
<li>通过find执行命令</li>
</ul>
<p><img src="/images/linux的那些事-10.png" alt="find"></p>
<ul>
<li>交互式的命令执行</li>
</ul>
<p><img src="/images/linux的那些事-11.png" alt="find"></p>
<ul>
<li>find命令的其他选项</li>
</ul>
<p><img src="/images/linux的那些事-12.png" alt="find"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ find . -name &apos;s*&apos; -type f -size +2 -exec ls -l &#123;&#125; \;</div><div class="line">-rwxr-xr-x 1 joe staff 1512 Jan 11 15:43 ./color/sum</div><div class="line">-rwxr-xr-x 1 joe staff 2148 Jan 11 15:57 ./shape/sum</div><div class="line"></div><div class="line">$ find . -perm 644 -mtime +4 -print</div><div class="line">./shape/misc</div><div class="line"></div><div class="line">$ find . -name fleas -o -name misc</div><div class="line">./misc</div><div class="line">./shape/misc</div><div class="line">./fleas</div><div class="line"></div><div class="line">$ find / -name &apos;security&apos; -print 2&gt; errfile</div><div class="line">/var/security</div><div class="line">/usr/lpp/bos.sysmgt/inst_root/var/security</div><div class="line">/usr/lib/security</div><div class="line">/etc/security</div></pre></td></tr></table></figure>
<h4 id="grep-模式匹配工具"><a href="#grep-模式匹配工具" class="headerlink" title="grep|模式匹配工具"></a><code>grep|模式匹配工具</code></h4><p><code>grep (global search regular expression(RE) and print out the line）</code>,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p><img src="/images/linux的那些事-13.png" alt="grep"></p>
<p>grep命令示例样本数据文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">phone1:</div><div class="line">As of: 1/31/2000</div><div class="line">Anatole 389-8200</div><div class="line">Avis Betty 817 422-8345</div><div class="line">Baker John 656-4333</div><div class="line">Computer Room CE phone 689-5790</div><div class="line">Dade Travel Sue 422-5690</div><div class="line">Hotline HW 800 322-4500</div><div class="line"></div><div class="line"></div><div class="line">phone2:</div><div class="line">As of: 2/15/2000</div><div class="line">Anatole 389-8200</div><div class="line">Avis Betty 817 422-8345</div><div class="line">Baker John 656-4333</div><div class="line">Computer Room CE phone 592-5712</div><div class="line">Dade Travel Sue 422-5690</div><div class="line">Hotline HW 800 322-4500</div></pre></td></tr></table></figure>
<ul>
<li><code>grep</code>命令示例 一：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ grep 800 phone1</div><div class="line">Hotline HW 800 322-4500</div><div class="line">$ grep 800 phone*</div><div class="line">phone1:Hotline HW 800 322-4500</div><div class="line">phone2:Hotline</div></pre></td></tr></table></figure>
<p> 第一个例子从文件phone1 中找出了包含800 的行<br> 第二个例子文件名使用了通配符，所以grep 会在phone1和phone2</p>
<p><code>grep</code>命令示例 二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ps -ef | grep team01</div><div class="line">team01 10524 13126 0 09:27:45 pts/1 0:00 –ksh</div></pre></td></tr></table></figure>
<p> 找出当前运行的进程中用户team01的所有进程。通过管道，ps的标准输出作为grep的标准输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep httpd</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p> 找出进程名称包含httpd的进程</p>
<ul>
<li>grep与正则表达式</li>
</ul>
<p><img src="/images/linux的那些事-14.png" alt="grep"></p>
<p><strong>元字符 对比 通配符</strong></p>
<p><img src="/images/linux的那些事-15.png" alt="grep"></p>
<p>注：grep命令和find命令中使用元字符，都应该用单引号括起来，避免shell对元字符进行扩展。</p>
<ul>
<li>grep正则表达式示例</li>
</ul>
<p><img src="/images/linux的那些事-16.png" alt="grep"></p>
<ul>
<li>grep命令的选项</li>
</ul>
<p><img src="/images/linux的那些事-17.png" alt="grep"></p>
<ul>
<li>其他grep工具</li>
</ul>
<p><img src="/images/linux的那些事-18.png" alt="grep"></p>
<h4 id="sort-排序工具"><a href="#sort-排序工具" class="headerlink" title="sort|排序工具"></a><code>sort|排序工具</code></h4><p><code>sort</code>对指定文件中所有的行进行排序，并将结果到标准输出。</p>
<p><code>sort [-t delimiter][+field[.column]][options]</code></p>
<p><img src="/images/linux的那些事-19.png" alt="sort"></p>
<p>命令示例：<br><img src="/images/linux的那些事-20.png" alt="sort"></p>
<h3 id="head和tail工具"><a href="#head和tail工具" class="headerlink" title="head和tail工具"></a><code>head和tail工具</code></h3><p><code>head [-number_of_lines] file(s)</code>,显示文件的前n行，默认是10行。</p>
<p><code>tail [-number_of_lines | +starting_line_number] file(s)</code>,显示文件后n行。<code>-n</code>表示显示文件的最后n行,<code>+n</code>表示从文件的第n行一直显示到文件尾.<code>-f</code>选项显示后10行并且动态刷新.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux的基础知识&quot;&gt;&lt;a href=&quot;#Linux的基础知识&quot; class=&quot;headerlink&quot; title=&quot;Linux的基础知识&quot;&gt;&lt;/a&gt;Linux的基础知识&lt;/h3&gt;&lt;p&gt;Linux系统的组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;linux内核（linus
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据库|MySQL中实现Rank高级排名函数</title>
    <link href="http://yoursite.com/2018/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E4%B8%AD%E5%AE%9E%E7%8E%B0Rank%E9%AB%98%E7%BA%A7%E6%8E%92%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/05/15/数据库-MySQL中实现Rank高级排名函数/</id>
    <published>2018-05-15T00:03:10.000Z</published>
    <updated>2018-05-15T17:21:45.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>MySQL中没有Rank排名函数，当我们需要查询排名时，只能使用MySQL数据库中的基本查询语句来查询普通排名。尽管如此，可不要小瞧基础而简单的查询语句，我们可以利用其来达到Rank函数一样的高级排名效果。</p>
<p>在这里我用一个简单例子来实现排名的查询：</p>
<p>首先我们先创建一个我们需要进行高级排名查询的players表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">CREATE TABLE `players` (</div><div class="line"></div><div class="line">  `pid` int(2) NOT NULL AUTO_INCREMENT,</div><div class="line"></div><div class="line">  `name` varchar(50) NOT NULL,</div><div class="line"></div><div class="line">  `age` int(2) NOT NULL,</div><div class="line"></div><div class="line">  PRIMARY KEY (`pid`),</div><div class="line"></div><div class="line">  UNIQUE KEY `name` (`name`)</div><div class="line"></div><div class="line">) ENGINE=InnoDB  DEFAULT CHARSET=latin1;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">INSERT INTO `players` (`pid`, `name`, `age`) VALUES</div><div class="line"></div><div class="line">(1, &apos;Samual&apos;, 25),</div><div class="line"></div><div class="line">(2, &apos;Vino&apos;, 20),</div><div class="line"></div><div class="line">(3, &apos;John&apos;, 20),</div><div class="line"></div><div class="line">(4, &apos;Andy&apos;, 22),</div><div class="line"></div><div class="line">(5, &apos;Brian&apos;, 21),</div><div class="line"></div><div class="line">(6, &apos;Dew&apos;, 24),</div><div class="line"></div><div class="line">(7, &apos;Kris&apos;, 25),</div><div class="line"></div><div class="line">(8, &apos;William&apos;, 26),</div><div class="line"></div><div class="line">(9, &apos;George&apos;, 23),</div><div class="line"></div><div class="line">(10, &apos;Peter&apos;, 19),</div><div class="line"></div><div class="line">(11, &apos;Tom&apos;, 20),</div><div class="line"></div><div class="line">(12, &apos;Andre&apos;, 20);</div></pre></td></tr></table></figure>
<h3 id="在MySQL中实现Rank普通排名函数"><a href="#在MySQL中实现Rank普通排名函数" class="headerlink" title="在MySQL中实现Rank普通排名函数"></a>在MySQL中实现Rank普通排名函数</h3><p>在这里，我们希望获得一个排名字段的列，以及age的升序排列。所以我们的查询语句将是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT pid, name, age, @curRank := @curRank + 1 AS rank</div><div class="line"></div><div class="line">FROM players p, (</div><div class="line"></div><div class="line">SELECT @curRank := 0</div><div class="line"></div><div class="line">) q</div><div class="line"></div><div class="line">ORDER BY age</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">| PID |    NAME | AGE | RANK |</div><div class="line"></div><div class="line">|-----|---------|-----|------|</div><div class="line"></div><div class="line">|  10 |   Peter |  19 |    1 |</div><div class="line"></div><div class="line">|  12 |   Andre |  20 |    2 |</div><div class="line"></div><div class="line">|   2 |    Vino |  20 |    3 |</div><div class="line"></div><div class="line">|   3 |    John |  20 |    4 |</div><div class="line"></div><div class="line">|  11 |     Tom |  20 |    5 |</div><div class="line"></div><div class="line">|   5 |   Brian |  21 |    6 |</div><div class="line"></div><div class="line">|   4 |    Andy |  22 |    7 |</div><div class="line"></div><div class="line">|   9 |  George |  23 |    8 |</div><div class="line"></div><div class="line">|   6 |     Dew |  24 |    9 |</div><div class="line"></div><div class="line">|   7 |    Kris |  25 |   10 |</div><div class="line"></div><div class="line">|   1 |  Samual |  25 |   11 |</div><div class="line"></div><div class="line">|   8 | William |  26 |   12 |</div></pre></td></tr></table></figure>
<p>要在mysql中声明一个变量，你必须在变量名之前使用<code>@</code>符号。FROM子句中的<code>(@curRank := 0)</code>部分允许我们进行变量初始化，而不需要单独的SET命令。当然，也可以使用SET，但它会处理两个查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SET @curRank := 0;</div><div class="line"></div><div class="line">SELECT pid, name, age, @curRank := @curRank + 1 AS rank</div><div class="line"></div><div class="line">FROM players</div><div class="line"></div><div class="line">ORDER BY age</div></pre></td></tr></table></figure>
<h3 id="查询以降序排列"><a href="#查询以降序排列" class="headerlink" title="查询以降序排列"></a>查询以降序排列</h3><p>首要按age的降序排列，其次按name进行排列，只需修改查询语句加上ORDER BY和 DESC以及列名即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT pid, name, age, @curRank := @curRank + 1 AS rank</div><div class="line"></div><div class="line">FROM players p, (</div><div class="line"></div><div class="line">SELECT @curRank := 0</div><div class="line"></div><div class="line">) q</div><div class="line"></div><div class="line">ORDER BY age DESC, name</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">| PID |    NAME | AGE | RANK |</div><div class="line"></div><div class="line">|-----|---------|-----|------|</div><div class="line"></div><div class="line">|   8 | William |  26 |    1 |</div><div class="line"></div><div class="line">|   7 |    Kris |  25 |    2 |</div><div class="line"></div><div class="line">|   1 |  Samual |  25 |    3 |</div><div class="line"></div><div class="line">|   6 |     Dew |  24 |    4 |</div><div class="line"></div><div class="line">|   9 |  George |  23 |    5 |</div><div class="line"></div><div class="line">|   4 |    Andy |  22 |    6 |</div><div class="line"></div><div class="line">|   5 |   Brian |  21 |    7 |</div><div class="line"></div><div class="line">|  12 |   Andre |  20 |    8 |</div><div class="line"></div><div class="line">|   3 |    John |  20 |    9 |</div><div class="line"></div><div class="line">|  11 |     Tom |  20 |   10 |</div><div class="line"></div><div class="line">|   2 |    Vino |  20 |   11 |</div><div class="line"></div><div class="line">|  10 |   Peter |  19 |   12 |</div></pre></td></tr></table></figure>
<h3 id="在MySQL中实现Rank普通并列排名函数"><a href="#在MySQL中实现Rank普通并列排名函数" class="headerlink" title="在MySQL中实现Rank普通并列排名函数"></a>在MySQL中实现Rank普通并列排名函数</h3><p>现在，如果我们希望为并列数据的行赋予相同的排名，则意味着那些在排名比较列中具有相同值的行应在MySQL中计算排名时保持相同的排名(例如在我们的例子中的<code>age</code>)。为此，我们使用了一个额外的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT pid, name, age, </div><div class="line"></div><div class="line">CASE </div><div class="line"></div><div class="line">WHEN @prevRank = age THEN @curRank </div><div class="line"></div><div class="line">WHEN @prevRank := age THEN @curRank := @curRank + 1</div><div class="line"></div><div class="line">END AS rank</div><div class="line"></div><div class="line">FROM players p, </div><div class="line"></div><div class="line">(SELECT @curRank :=0, @prevRank := NULL) r</div><div class="line"></div><div class="line">ORDER BY age</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">| PID |    NAME | AGE | RANK |</div><div class="line"></div><div class="line">|-----|---------|-----|------|</div><div class="line"></div><div class="line">|  10 |   Peter |  19 |    1 |</div><div class="line"></div><div class="line">|  12 |   Andre |  20 |    2 |</div><div class="line"></div><div class="line">|   2 |    Vino |  20 |    2 |</div><div class="line"></div><div class="line">|   3 |    John |  20 |    2 |</div><div class="line"></div><div class="line">|  11 |     Tom |  20 |    2 |</div><div class="line"></div><div class="line">|   5 |   Brian |  21 |    3 |</div><div class="line"></div><div class="line">|   4 |    Andy |  22 |    4 |</div><div class="line"></div><div class="line">|   9 |  George |  23 |    5 |</div><div class="line"></div><div class="line">|   6 |     Dew |  24 |    6 |</div><div class="line"></div><div class="line">|   7 |    Kris |  25 |    7 |</div><div class="line"></div><div class="line">|   1 |  Samual |  25 |    7 |</div><div class="line"></div><div class="line">|   8 | William |  26 |    8 |</div></pre></td></tr></table></figure>
<p>如上所示，具有相同数据和排行的两行或多行，它们都会获得相同的排名。玩家Andre, Vino, John 和Tom都有相同的age，所以他们排名并列第二。下一个最高age的玩家(Brian)排名第3。这个查询相当于MSSQL和ORACLE 中的<code>DENSE_RANK()</code>函数。</p>
<h4 id="case-when"><a href="#case-when" class="headerlink" title="case when"></a>case when</h4><p>sql语句中的case语句与高级语言中的switch语句，是标准sql的语法，适用于一个条件判断有多种值的情况下分别执行不同的操作。</p>
<p>首先，让我们看一下CASE的语法。在一般的SELECT中，其语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">CASE   &lt;单值表达式&gt;</div><div class="line"></div><div class="line">       WHEN &lt;表达式值&gt; THEN &lt;SQL语句或者返回值&gt;</div><div class="line"></div><div class="line">       WHEN &lt;表达式值&gt; THEN &lt;SQL语句或者返回值&gt;</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">       WHEN &lt;表达式值&gt; THEN &lt;SQL语句或者返回值&gt;</div><div class="line"></div><div class="line">       ELSE &lt;SQL语句或者返回值&gt;</div><div class="line"></div><div class="line">END</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">:= 和 = 运算符在大部分场景下并无区别，但 := 更为全场景些。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">= 只有在 set 和update时才是和 := 一样，赋值的作用，其它都是关系运算符 等于 的作用。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">:= 不只在 set 和 update 时赋值的作用，在 select 也是赋值的作用。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SET @name = &apos;big_cat&apos;;</div><div class="line"></div><div class="line">SELECT @name;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># = 在 select 语句中成为了比较运算符 结果为 NULL (@name 为 NULL, 在 mysql 中 NULL 和任何值比较都为 NULL)</div><div class="line"></div><div class="line"># := 则为仍未赋值，@name_defined 被赋值为 big_cat 后再 select 就出来了</div><div class="line"></div><div class="line">SELECT @name = &apos;big_cat&apos;, @name_defined := &apos;big_cat&apos;, @name_defined;</div><div class="line"></div><div class="line">+-------------------+----------------------------+---------------+</div><div class="line"></div><div class="line">| @name = &apos;big_cat&apos; | @name_defined := &apos;big_cat&apos; | @name_defined |</div><div class="line"></div><div class="line">+-------------------+----------------------------+---------------+</div><div class="line"></div><div class="line">|              NULL | big_cat                    | big_cat       |</div><div class="line"></div><div class="line">+-------------------+----------------------------+---------------+</div></pre></td></tr></table></figure>
<h3 id="在MySQL中实现Rank高级并列排名函数"><a href="#在MySQL中实现Rank高级并列排名函数" class="headerlink" title="在MySQL中实现Rank高级并列排名函数"></a>在MySQL中实现Rank高级并列排名函数</h3><p>当使用RANK()函数时，如果两个或以上的行排名并列，则相同的行都会有相同的排名，但是实际排名中存在有关系的差距。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SELECT</div><div class="line"></div><div class="line">	pid,</div><div class="line"></div><div class="line">	NAME,</div><div class="line"></div><div class="line">	age,</div><div class="line"></div><div class="line">	rank</div><div class="line"></div><div class="line">FROM</div><div class="line"></div><div class="line">	(</div><div class="line"></div><div class="line">		SELECT</div><div class="line"></div><div class="line">			pid,</div><div class="line"></div><div class="line">			NAME,</div><div class="line"></div><div class="line">			age,</div><div class="line"></div><div class="line">			@curRank :=</div><div class="line"></div><div class="line">		IF (</div><div class="line"></div><div class="line">			@prevRank = age,</div><div class="line"></div><div class="line">			@curRank,</div><div class="line"></div><div class="line">			@incRank</div><div class="line"></div><div class="line">		) AS rank,</div><div class="line"></div><div class="line">		@incRank := @incRank + 1,</div><div class="line"></div><div class="line">		@prevRank := age</div><div class="line"></div><div class="line">	FROM</div><div class="line"></div><div class="line">		players p,</div><div class="line"></div><div class="line">		(</div><div class="line"></div><div class="line">			SELECT</div><div class="line"></div><div class="line">				@curRank := 0,</div><div class="line"></div><div class="line">				@prevRank := NULL,</div><div class="line"></div><div class="line">				@incRank := 1</div><div class="line"></div><div class="line">		) r</div><div class="line"></div><div class="line">	ORDER BY</div><div class="line"></div><div class="line">		age</div><div class="line"></div><div class="line">	) s</div></pre></td></tr></table></figure>
<p>这是一个查询中的子查询。我们使用三个变量(<code>@incRank，@prevRank，@curRank</code>)来计算关系的情况下，在查询结果中我们已经补全了因为并列而导致的排名空位。我们已经封闭子查询到查询。这个查询相当于MSSQL和ORACLE中的RANK()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">| PID |    NAME | AGE | RANK |</div><div class="line"></div><div class="line">|-----|---------|-----|------|</div><div class="line"></div><div class="line">|  10 |   Peter |  19 |    1 |</div><div class="line"></div><div class="line">|  12 |   Andre |  20 |    2 |</div><div class="line"></div><div class="line">|   2 |    Vino |  20 |    2 |</div><div class="line"></div><div class="line">|   3 |    John |  20 |    2 |</div><div class="line"></div><div class="line">|  11 |     Tom |  20 |    2 |</div><div class="line"></div><div class="line">|   5 |   Brian |  21 |    6 |</div><div class="line"></div><div class="line">|   4 |    Andy |  22 |    7 |</div><div class="line"></div><div class="line">|   9 |  George |  23 |    8 |</div><div class="line"></div><div class="line">|   6 |     Dew |  24 |    9 |</div><div class="line"></div><div class="line">|   7 |    Kris |  25 |   10 |</div><div class="line"></div><div class="line">|   1 |  Samual |  25 |   10 |</div><div class="line"></div><div class="line">|   8 | William |  26 |   12 |</div></pre></td></tr></table></figure>
<p>在这里我们可以看到，Andre，Vino，John和Tom都有相同的age，所以他们排名并列第二。下一个最高年龄的球员(Brian)排名第6，而不是第3，因为有4个人并列排名在第2。</p>
<h4 id="MySQL-IF"><a href="#MySQL-IF" class="headerlink" title="MySQL IF"></a>MySQL IF</h4><p>MySQL IF语句允许您根据表达式的某个条件或值结果来执行一组SQL语句。 要在MySQL中形成一个表达式，可以结合文字，变量，运算符，甚至函数来组合。表达式可以返回TRUE,FALSE或NULL，这三个值之一。</p>
<p>下面说明了IF语句的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IF expression THEN </div><div class="line"></div><div class="line">   statements;</div><div class="line"></div><div class="line">END IF;</div></pre></td></tr></table></figure>
<p>如果表达式<code>(expression)</code>计算结果为TRUE，那么将执行<code>statements</code>语句，否则控制流将传递到END IF之后的下一个语句。</p>
<p><img src="/images/数据库-07.jpg" alt="IF"></p>
<p>如果表达式计算结果为FALSE时执行语句，请使用IF ELSE语句，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IF expression THEN</div><div class="line"></div><div class="line">   statements;</div><div class="line"></div><div class="line">ELSE</div><div class="line"></div><div class="line">   else-statements;</div><div class="line"></div><div class="line">END IF;</div></pre></td></tr></table></figure>
<p><img src="/images/数据库-08.jpg" alt="IF"></p>
<p>如果要基于多个表达式有条件地执行语句，则使用IF ELSEIF ELSE语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IF expression THEN</div><div class="line"></div><div class="line">   statements;</div><div class="line"></div><div class="line">ELSEIF elseif-expression THEN</div><div class="line"></div><div class="line">   elseif-statements;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">ELSE</div><div class="line"></div><div class="line">   else-statements;</div><div class="line"></div><div class="line">END IF;</div></pre></td></tr></table></figure>
<p>如果表达式<code>(expression)</code>求值为TRUE，则IF分支中的语句<code>(statements)</code>将执行；如果表达式求值为FALSE，则如果<code>elseif_expression</code>的计算结果为TRUE，MySQL将执行<code>elseif-expression</code>，否则执行ELSE分支中的<code>else-statements</code>语句。</p>
<p><img src="/images/数据库-09.jpg" alt="IF"></p>
<p>还有另一种操作：类似于三元运算符</p>
<ul>
<li><code>IF(where,result1,result2) = where?result1:result2</code></li>
</ul>
<p>例如 :<code>SELECT IF(1=1,1,2)    =&gt;  1</code></p>
<ul>
<li><code>IFNULL(result1,result2) = result1 is not null?result1:result2</code></li>
</ul>
<p>例如 :<code>SELECT IF(1,2)  =&gt; 1</code>　　</p>
<p>　　<code>SELECT IF(null,2) =&gt; 2</code></p>
<p>文章来源：<a href="https://www.jianshu.com/p/bb1b72a1623e" target="_blank" rel="external">https://www.jianshu.com/p/bb1b72a1623e</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;MySQL中没有Rank排名函数，当我们需要查询排名时，只能使用MySQL数据库中的基本查询语句来查询普通排名。尽管如此，可不要小瞧基础而简
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库|在2018毕业生彩蛋中学到的</title>
    <link href="http://yoursite.com/2018/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9C%A82018%E6%AF%95%E4%B8%9A%E7%94%9F%E5%BD%A9%E8%9B%8B%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84/"/>
    <id>http://yoursite.com/2018/05/13/数据库-在2018毕业生彩蛋中学到的/</id>
    <published>2018-05-13T12:50:36.000Z</published>
    <updated>2018-05-23T16:25:54.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>SQL SELECT DISTINCT 语句</p>
<p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p>关键词 <code>DISTINCT</code> 用于返回唯一不同的值。</p>
<p>语法：<code>SELECT DISTINCT 列名称 FROM 表名称</code></p>
<h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><p><code>GROUP BY</code>语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p>
<p>SQL GROUP BY 语法 :<code>SELECT column_name, aggregate_function(column_name) FROM table_name  WHERE column_name operator value
GROUP BY column_name;</code> </p>
<h4 id="用法详解"><a href="#用法详解" class="headerlink" title="用法详解"></a>用法详解</h4><p>原始表：</p>
<p><img src="/images/数据库-04.jpg" alt="原始数据"></p>
<h5 id="简单Group-By"><a href="#简单Group-By" class="headerlink" title="简单Group By"></a>简单Group By</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 类别, sum(数量) as 数量之和</div><div class="line">from A</div><div class="line">group by 类别</div></pre></td></tr></table></figure>
<p>返回结果如下表，实际上就是分类汇总。</p>
<p><img src="/images/数据库-05.jpg" alt="Group by"></p>
<h5 id="Group-By中Select指定的字段限制"><a href="#Group-By中Select指定的字段限制" class="headerlink" title="Group By中Select指定的字段限制"></a>Group By中Select指定的字段限制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select 类别, sum(数量) as 数量之和, 摘要</div><div class="line">from A</div><div class="line">group by 类别</div><div class="line">order by 类别 desc</div></pre></td></tr></table></figure>
<p>这个sql语句是错误的，原因是<strong>在select指定的字段要么就要包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中。</strong></p>
<h5 id="GROUP-BY-多列分组的使用"><a href="#GROUP-BY-多列分组的使用" class="headerlink" title="GROUP BY 多列分组的使用"></a>GROUP BY 多列分组的使用</h5><p>“多列分组”实际上就是就是按照多列（字段1+字段2）合并后的值进行分组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 类别, 摘要, sum(数量) as 数量之和</div><div class="line">from A</div><div class="line">group by  类别, 摘要</div></pre></td></tr></table></figure>
<p><img src="/images/数据库-06.jpg" alt="Group by"></p>
<p>“多列分组”实际上就是就是按照多列（类别+摘要）合并后的值进行分组，示例4中可以看到“a, a2001, 13”为“a, a2001, 11”和“a, a2001, 2”两条记录的合并。</p>
<h5 id="Group-By与聚合函数"><a href="#Group-By与聚合函数" class="headerlink" title="Group By与聚合函数"></a>Group By与聚合函数</h5><p>在示例3中提到group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中，常见的聚合函数如下表：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>支持性</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum(列名)</td>
<td>求和    　　　</td>
<td>　</td>
</tr>
<tr>
<td>max(列名)</td>
<td>最大值    　</td>
<td>　　　</td>
</tr>
<tr>
<td>min(列名)</td>
<td>最小值    　</td>
<td>　　　</td>
</tr>
<tr>
<td>avg(列名)</td>
<td>平均值    　　</td>
<td>　　</td>
</tr>
<tr>
<td>first(列名)</td>
<td>第一条记录</td>
<td>仅Access支持</td>
</tr>
<tr>
<td>last(列名)</td>
<td>最后一条记录</td>
<td>仅Access支持</td>
</tr>
<tr>
<td>count(列名)</td>
<td>统计记录数</td>
<td>注意和count(*)的区别</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<ul>
<li>求各组平均值:<code>select 类别, avg(数量) AS 平均值 from A group by 类别;</code></li>
<li>求各组记录数目:<code>select 类别, count(*) AS 记录数 from A group by 类别;</code></li>
</ul>
<h5 id="Having与Where的区别"><a href="#Having与Where的区别" class="headerlink" title="Having与Where的区别"></a>Having与Where的区别</h5><ul>
<li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，where条件中不能包含聚组函数，使用where条件过滤出特定的行。</li>
<li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件过滤出特定的组，也可以使用多个分组标准进行分组。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 类别, sum(数量) as 数量之和 from A</div><div class="line">group by 类别</div><div class="line">having sum(数量) &gt; 18</div></pre></td></tr></table></figure>
<p>Having和Where的联合使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select 类别, SUM(数量)from A</div><div class="line">where 数量 &gt; 8</div><div class="line">group by 类别</div><div class="line">having SUM(数量) &gt; 10</div></pre></td></tr></table></figure></p>
<h3 id="nvl函数"><a href="#nvl函数" class="headerlink" title="nvl函数"></a>nvl函数</h3><p>NVL(E1, E2)的功能为：如果E1为NULL，则函数返回E2，否则返回E1本身。</p>
<h3 id="CUME-DIST-函数"><a href="#CUME-DIST-函数" class="headerlink" title="CUME_DIST 函数"></a>CUME_DIST 函数</h3><p>计算某个窗口或分区中某个值的累积分布。假定升序排序，则使用以下公式确定累积分布：<code>count of rows with values &lt;= x / count of rows in the window or partition</code></p>
<p>其中，x 等于 ORDER BY 子句中指定的列的当前行中的值。以下数据集说明了此公式的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Row#	Value	  Calculation    CUME_DIST</div><div class="line">1        2500	   (1)/(5)	       0.2</div><div class="line">2        2600	   (2)/(5)	   	   0.4</div><div class="line">3        2800	   (3)/(5)	   	   0.6</div><div class="line">4        2900	   (4)/(5)	   	   0.8</div><div class="line">5        3100	   (5)/(5)	       1.0</div></pre></td></tr></table></figure>
<p>返回值范围介于 0 和 1（含 1）之间。</p>
<p>语法：</p>
<pre><code>CUME_DIST ()
OVER ( 
[ PARTITION BY partition_expression ] 
[ ORDER BY order_list ]
)
</code></pre><p>参数：</p>
<pre><code>* OVER：一个指定窗口分区的子句。OVER 子句不能包含窗口框架规范。

* PARTITION BY partition_expression：可选。一个设置 OVER 子句中每个组的记录范围的表达式。

 * ORDER BY order_list：用于计算累积分布的表达式。该表达式必须具有数字数据类型或可隐式转换为 1。如果省略 ORDER BY，则所有行的返回值为 1。
</code></pre><p>如果 ORDER BY 未生成唯一顺序，则行的顺序是不确定的。</p>
<p>返回类型：FLOAT8</p>
<p>效果展示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select * from user;</div><div class="line"> OK</div><div class="line">user.dept    user.userid    user.sal</div><div class="line">d1    user1    1000</div><div class="line">d1    user2    2000</div><div class="line">d1    user3    3000</div><div class="line">d2    user4    4000</div><div class="line">d2    user5    5000</div></pre></td></tr></table></figure>
<p>比如，统计小于等于当前薪水的人数，所占总人数的比例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">select dept,userid,sal,</div><div class="line">cume_dist() over(order by sal) as rn1,</div><div class="line">cume_dist() over(partition by dept order by sal) as rn2</div><div class="line">from user;</div><div class="line"></div><div class="line">OK</div><div class="line">dept    userid    sal    rn1    rn2</div><div class="line">d1    user1    1000    0.2    0.3333333333333333</div><div class="line">d1    user2    2000    0.4    0.6666666666666666</div><div class="line">d1    user3    3000    0.6    1.0</div><div class="line">d2    user4    4000    0.8    0.5</div><div class="line">d2    user5    5000    1.0    1.0</div></pre></td></tr></table></figure></p>
<p>解释：</p>
<ul>
<li>rn1: 没有partition,所有数据均为1组，总行数为5，<ul>
<li>第一行：小于等于1000的行数为1，因此，1/5=0.2</li>
<li>第三行：小于等于3000的行数为3，因此，3/5=0.6</li>
</ul>
</li>
<li>rn2: 按照部门分组，dpet=d1的行数为3,<br>  -第二行：小于等于2000的行数为2，因此，2/3=0.6666666666666666</li>
</ul>
<h3 id="rank函数"><a href="#rank函数" class="headerlink" title="rank函数"></a>rank函数</h3><p>rank函数是排名函数。rank函数最常用的是求某一个数值在某一区域内的排名。</p>
<ul>
<li>语法：<code>RANK() OVER([&lt;partition_by_clause&gt;]&lt;order by clause&gt;)</code></li>
<li>参数<ul>
<li>partition_by_clause 将from子句生成的结果集划分为应用到RANK函数的分区。</li>
<li>Order_by_clause确定将RANK值应用到分区中的行时所使用的顺序。</li>
</ul>
</li>
</ul>
<h3 id="round函数"><a href="#round函数" class="headerlink" title="round函数"></a>round函数</h3><p>Round函数返回一个数值，该数值是按照指定的小数位数进行四舍五入运算的结果。可是当保留位跟着的即使是5，有可能进位，也有可能舍去，机会各50%。这样就会造成在应用程序中计算有误。</p>
<ul>
<li>语法:<code>round(number,digits)</code> </li>
<li>参数<ul>
<li>number,要四舍五入的数，digits是要小数点后保留的位数。</li>
</ul>
</li>
<li>返回值 ：四舍五入后的值</li>
</ul>
<p>注： </p>
<ul>
<li>如果 digits 大于 0，则四舍五入到指定的小数位。 </li>
<li>如果 digits 等于 0，则四舍五入到最接近的整数。 </li>
<li>如果 digits 小于 0，则在小数点左侧进行四舍五入。</li>
<li>如果round函数只有参数number,等同于digits 等于 0。</li>
</ul>
<p>举例：</p>
<ul>
<li>round(3.1415926,2)=3.14;</li>
<li>round(3.1415926,3)=3.142;</li>
<li>select round(193,-2)from dual; 200</li>
<li>select round(193,-1)from dual;190</li>
<li>select round(193,-3)from dual;0</li>
</ul>
<h3 id="TO-CHAR-函数"><a href="#TO-CHAR-函数" class="headerlink" title="TO_CHAR() 函数"></a>TO_CHAR() 函数</h3><p>to_char()，计算机语言函数，指的是将数值型或者日期型转化为字符型。</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_char(1210.73, ‘9999.9’)</td>
<td>would return ‘1210.7’</td>
</tr>
<tr>
<td>to_char(1210.73, ‘9,999.99’)</td>
<td>would return ‘1,210.73’</td>
</tr>
<tr>
<td>to_char(1210.73, ‘$9,999.00’)</td>
<td>would return ‘$1,210.73’</td>
</tr>
<tr>
<td>to_char(21, ‘000099’)</td>
<td>would return ‘000021’</td>
</tr>
</tbody>
</table>
<p>The following is a list of valid parameters when the to_char function is used to convert a date to a string. These parameters can be used in many combinations.</p>
<p><img src="/images/数据库-03.png" alt="to_char函数模板"></p>
<p>The following are date examples for the to_char function.</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_char(sysdate, ‘yyyy/mm/dd’);</td>
<td>would return ‘2003/07/09’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘Month DD, YYYY’);</td>
<td>would return ‘July 09, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMonth DD, YYYY’);</td>
<td>would return ‘July 9, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘MON DDth, YYYY’);</td>
<td>would return ‘JUL 09TH, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMON DDth, YYYY’);</td>
<td>would return ‘JUL 9TH, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMon ddth, YYYY’);</td>
<td>would return ‘Jul 9th, 2003’</td>
</tr>
</tbody>
</table>
<p>You will notice that in some examples, the format_mask parameter begins with “FM”. This means that zeros and blanks are suppressed. This can be seen in the examples below.</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_char(sysdate, ‘FMMonth DD, YYYY’);</td>
<td>would return ‘July 9, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMON DDth, YYYY’);</td>
<td>would return ‘JUL 9TH, 2003’</td>
</tr>
<tr>
<td>to_char(sysdate, ‘FMMon ddth, YYYY’);</td>
<td>would return ‘Jul 9th, 2003’</td>
</tr>
</tbody>
</table>
<h3 id="Oracle-中-decode-函数用法"><a href="#Oracle-中-decode-函数用法" class="headerlink" title="Oracle 中 decode 函数用法"></a>Oracle 中 decode 函数用法</h3><p><code>decode(条件,值1,返回值1,值2,返回值2,...值n,返回值n,缺省值)</code></p>
<p>该函数的含义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">IF 条件=值1 THEN</div><div class="line">　　　　RETURN(返回值1)</div><div class="line">ELSIF 条件=值2 THEN</div><div class="line">　　　　RETURN(返回值2)</div><div class="line">　　　　......</div><div class="line">ELSIF 条件=值n THEN</div><div class="line">　　　　RETURN(返回值n)</div><div class="line">ELSE</div><div class="line">　　　　RETURN(缺省值)</div><div class="line">END IF</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DISTINCT&quot;&gt;&lt;a href=&quot;#DISTINCT&quot; class=&quot;headerlink&quot; title=&quot;DISTINCT&quot;&gt;&lt;/a&gt;DISTINCT&lt;/h3&gt;&lt;p&gt;SQL SELECT DISTINCT 语句&lt;/p&gt;
&lt;p&gt;在表中，可能会包含重复值。这并不
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
