<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只为不凡而来</title>
  <subtitle>小智的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-12T01:49:26.298Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wuduozhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/08/12/Hibernate/"/>
    <id>http://yoursite.com/2017/08/12/Hibernate/</id>
    <published>2017-08-12T01:18:20.304Z</published>
    <updated>2017-08-12T01:49:26.298Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎使用 <strong>{小书匠}(xiaoshujiang)编辑器</strong>，您可以通过==设置==里的修改模板来改变新建文章的内容。1.下载hibernate</p>
<pre><code>需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
</code></pre><p>2.解压hibernate</p>
<pre><code>下载后解压缩，得到一个hibernate-release-4.3.11.Final文件夹（我下载的hibernate版本是4.3.11），在hibernate-release-4.3.11.Final文件夹里有一个lib文件夹，里面放着hibernate的jar包。

例子中使用了lib下的required文件夹中的所有jar包。如图：



这些包的作用如下（待验证）：
</code></pre><p>包名<br>说明<br>antlr-2.7.7<br>可以接收词文法语言描述，并能产生识别这些语言的语句的程序，hibernate利用它实现hql到sql的转换。<br>dom4j-1.6.1<br>xml解析器，用来读写xml文件的。<br>hibernate-commons-annotations-4.0.5.Final<br>hibernate中支持注解开发的程序。<br>hibernate-core-4.3.11.Final<br>hibernate的核心程序。<br>hibernate-jpa-2.1-api-1.0.0.Final    hibernate对jap(java persistence API)规范的支持，可以理解为JAP是标准接口，hibernate是实现。<br>jandex-1.1.0.Final    用来检索注解(annotation)索引的程序，识别该对象是注解对象(待验证)？<br>javassist-3.18.1-GA    用来操作字节码的程序，可直接编辑和生成java字节码，以达到对.class文件的动态修改。<br>jboss-logging-3.1.3.GA    提供hibernate日志功能的程序(待验证)?<br>jboss-logging-annotations-1.2.0.Beta1    解析logging的注解模式程序(待验证)?<br>jboss-transaction-api_1.2_spec-1.0.0.Final    事务控制程序(待验证)?<br>3.导入hibernate的jar包</p>
<pre><code>创建一个JavaProject，引用上面图片中的jar包，这里需要另外一个jar包，由于我连接的是mysql数据库，所以需要在导入一个mysql-connector-java-5.1.7-bin.jar
</code></pre><p>4.新建一个测试用的java对象</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>public class User {</p>
<pre><code>public User() {
}

public User(String name, Date birthday) {
    this.name = name;
    this.birthday = birthday;
}

@Override
public String toString() {
    return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, birthday=&quot; + birthday
            + &quot;]&quot;;
}

public int getId() {
    return id;
}

public void setId(int id) {
    this.id = id;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public Date getBirthday() {
    return birthday;
}

public void setBirthday(Date birthday) {
    this.birthday = birthday;
}

private int id;
private String name;
private Date birthday;
</code></pre><p>}<br>    编写的java对象需要满足如下要素：</p>
<p>需要有一个无参的构造函数，因为在session.get时需要用到反射创建java对象；</p>
<p>需要提供一个id属性，对应数据库的主键；</p>
<p>需要为对象的其他属性提供get/set方法；</p>
<p>需要定义成非final的类，以便在hibernate进行延迟加载时为类创建代理；</p>
<p>如有必要保存到集合中，需要重equals方法和hashcode方法；</p>
<p>5.设置java对象与数据库的映射关系</p>
<pre><code>需要创建一个User.hbm.xml文件，编辑java对象与数据库的映射关系，格式如下：
</code></pre><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE hibernate-mapping PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN”<br>“<a href="http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-mapping><br>    <class name="cn.net.bysoft.lesson1.User" table="S_USER"><br>        <id name="id" type="integer" column="ID"><br>            <!-- 指定主键的生成方式，native是使用数据库本地的方式 --><br>            <generator class="native"></generator><br>        </id><br>        <property name="name" type="string" column="NAME"></property><br>        <property name="birthday" type="timestamp" column="BIRTHDAY"></property><br>    </class><br></hibernate-mapping><br>    该文件是用来配置java对象与数据表之间的映射关系的，其中需要留意的是id这个属性，generator来指定主键的生成方式，而native则代表是调用数据库本地的方式来生成主键，我使用的mysql数据库就会自动将id列设置成自增。</p>
<pre><code>主键具体有哪些生成方式，待接下来详细研究。
</code></pre><p>6.配置hibernate的配置信息</p>
<p>在src下创建一个hibernate.cfg.xml文件，格式如下：</p>
<p>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>    “-//Hibernate/Hibernate Configuration DTD 3.0//EN”<br>    “<a href="http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-configuration><br>    <session-factory><br>        <!-- 连接数据库的基本信息 --><br>        <property name="hibernate.connection.username">root</property><br>        <property name="hibernate.connection.password">root</property><br>        <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property><br>        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate4</property></session-factory></hibernate-configuration></p>
<pre><code>    &lt;!-- hibernate使用的数据库方言
         如果不知道可以去/hibernate-release-4.3.11.Final/project/etc/hibernate.properties
         中查找 --&gt;
    &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;
    &lt;!-- 是否在控制台显示sql语句 --&gt;
    &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否格式化显示的sql语句 --&gt;
    &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否自动生成数据表的策略,create代表每次启动程序都重新创建数据表 --&gt;
    &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;

    &lt;!-- 需要使用到的*.hbm.xml文件 --&gt;
    &lt;mapping resource=&quot;cn/net/bysoft/lesson1/User.hbm.xml&quot;/&gt;
&lt;/session-factory&gt;
</code></pre><p><br>    该文件需要注意的有两个地方，第一个是mapping属性，第二个是hibernate.hbm2ddl.auto这个属性。</p>
<pre><code>mapping属性用来配置*.hbm.xml的资源文件地址，这里需要注意的是没有用cn.net.bysoft.lession的形式，而是使用的&apos;/&apos;来描述目录位置。

接下来是自动执行ddl语句的设置(也就是hibernate.hbm2ddl.auto)参数有4个，分别是：
</code></pre><p>create</p>
<p>create为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来drop掉数据表，drop后重新create数据表；</p>
<p>create-drop</p>
<p>create-drop为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来create数据表。而每当sessionfactory被close时，会drop掉开始时create的数据表；</p>
<p>update</p>
<p>update为每次创建sessionfactory时，如果数据库中没有对应的表，则新建。</p>
<p>若已经新建过，则会判断*.hbm.xml文件的配置与建立好的数据表的结构是否相同。</p>
<p>如果相同则不去进行ddl的操作。</p>
<p>如果不同，则会根据*.hbm.xml文件中有变化的配置项去更新数据表，但不会删除数据表中已创建过的任何信息。</p>
<p>validate</p>
<p>validate为每次创建sessionfactory时，将用*.hbm.xml文件中的配置信息与现有的对应的数据表结构进行比较，若发现不同则抛出异常。</p>
<p>7.编写代码测试</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.hibernate.Transaction;<br>import org.hibernate.boot.registry.StandardServiceRegistry;<br>import org.hibernate.boot.registry.StandardServiceRegistryBuilder;<br>import org.hibernate.cfg.Configuration;<br>import org.junit.Test;</p>
<p>public class UserTest {</p>
<pre><code>@Test
public void test() {
    // 0.创建configuration对象，该对象保存着hibernate的配置信息和对象关系映射的信息。
    Configuration cfg = new Configuration().configure();
    // 1.创建sessionfactory对象
    StandardServiceRegistryBuilder builder = new StandardServiceRegistryBuilder().applySettings(cfg.getProperties());
    StandardServiceRegistry registry =  builder.build();
    SessionFactory sessionFactory = cfg.buildSessionFactory(registry); 
    // 2.创建session对象
    Session session = sessionFactory.openSession();
    // 3.开始事务
    Transaction transaction = session.beginTransaction();
    // 4.保存
    User user = new User(&quot;Jack&quot;, new Date());
    session.save(user);
    // 5.提交事务
    transaction.commit();
    // 6.关闭session对象
    session.close();
    // 7.关闭sessionfactory对象
    sessionFactory.close();
}
</code></pre><p>}<br>    上面这段代码中configuration对象用来保存则hibernate的配置信息，如hibernate.cfg.xml中的配置信息，和*.hbm.xml的映射信息。</p>
<pre><code>sessionfactory为创建session的工厂，它是线程安全的。一般建议一个项目中只有一个sessionfactory，因为创建sessionfactory非常费资源。

接下来是session对象，该对象是hibernate的核心，是一个单线程的对象，内部有session缓存。

对需要持久化的java对象的所有操作都用到了session。

常用的方法有get、load、save、update、saveorupdate、delete、begintransaction、isopen、flush、clear、evicto、close等等方法，接下来将会一个一个研究这些方法的使用。

这是执行这段代码后，控制台输出的内容：



创建了一张名为S_USER的数据表，并insert了一条数据。



到此位置，一个简单的hibernate环境就搭建好了。工程的目录结构如下：
</code></pre><p>1.下载hibernate</p>
<pre><code>需要到hibernate的官网下载一个hibernate。网址是：http://hibernate.org/orm/downloads/
</code></pre><p>2.解压hibernate</p>
<pre><code>下载后解压缩，得到一个hibernate-release-4.3.11.Final文件夹（我下载的hibernate版本是4.3.11），在hibernate-release-4.3.11.Final文件夹里有一个lib文件夹，里面放着hibernate的jar包。

例子中使用了lib下的required文件夹中的所有jar包。如图：



这些包的作用如下（待验证）：
</code></pre><p>包名<br>说明<br>antlr-2.7.7<br>可以接收词文法语言描述，并能产生识别这些语言的语句的程序，hibernate利用它实现hql到sql的转换。<br>dom4j-1.6.1<br>xml解析器，用来读写xml文件的。<br>hibernate-commons-annotations-4.0.5.Final<br>hibernate中支持注解开发的程序。<br>hibernate-core-4.3.11.Final<br>hibernate的核心程序。<br>hibernate-jpa-2.1-api-1.0.0.Final    hibernate对jap(java persistence API)规范的支持，可以理解为JAP是标准接口，hibernate是实现。<br>jandex-1.1.0.Final    用来检索注解(annotation)索引的程序，识别该对象是注解对象(待验证)？<br>javassist-3.18.1-GA    用来操作字节码的程序，可直接编辑和生成java字节码，以达到对.class文件的动态修改。<br>jboss-logging-3.1.3.GA    提供hibernate日志功能的程序(待验证)?<br>jboss-logging-annotations-1.2.0.Beta1    解析logging的注解模式程序(待验证)?<br>jboss-transaction-api_1.2_spec-1.0.0.Final    事务控制程序(待验证)?<br>3.导入hibernate的jar包</p>
<pre><code>创建一个JavaProject，引用上面图片中的jar包，这里需要另外一个jar包，由于我连接的是mysql数据库，所以需要在导入一个mysql-connector-java-5.1.7-bin.jar
</code></pre><p>4.新建一个测试用的java对象</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>public class User {</p>
<pre><code>public User() {
}

public User(String name, Date birthday) {
    this.name = name;
    this.birthday = birthday;
}

@Override
public String toString() {
    return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, birthday=&quot; + birthday
            + &quot;]&quot;;
}

public int getId() {
    return id;
}

public void setId(int id) {
    this.id = id;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public Date getBirthday() {
    return birthday;
}

public void setBirthday(Date birthday) {
    this.birthday = birthday;
}

private int id;
private String name;
private Date birthday;
</code></pre><p>}<br>    编写的java对象需要满足如下要素：</p>
<p>需要有一个无参的构造函数，因为在session.get时需要用到反射创建java对象；</p>
<p>需要提供一个id属性，对应数据库的主键；</p>
<p>需要为对象的其他属性提供get/set方法；</p>
<p>需要定义成非final的类，以便在hibernate进行延迟加载时为类创建代理；</p>
<p>如有必要保存到集合中，需要重equals方法和hashcode方法；</p>
<p>5.设置java对象与数据库的映射关系</p>
<pre><code>需要创建一个User.hbm.xml文件，编辑java对象与数据库的映射关系，格式如下：
</code></pre><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE hibernate-mapping PUBLIC “-//Hibernate/Hibernate Mapping DTD 3.0//EN”<br>“<a href="http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-mapping><br>    <class name="cn.net.bysoft.lesson1.User" table="S_USER"><br>        <id name="id" type="integer" column="ID"><br>            <!-- 指定主键的生成方式，native是使用数据库本地的方式 --><br>            <generator class="native"></generator><br>        </id><br>        <property name="name" type="string" column="NAME"></property><br>        <property name="birthday" type="timestamp" column="BIRTHDAY"></property><br>    </class><br></hibernate-mapping><br>    该文件是用来配置java对象与数据表之间的映射关系的，其中需要留意的是id这个属性，generator来指定主键的生成方式，而native则代表是调用数据库本地的方式来生成主键，我使用的mysql数据库就会自动将id列设置成自增。</p>
<pre><code>主键具体有哪些生成方式，待接下来详细研究。
</code></pre><p>6.配置hibernate的配置信息</p>
<p>在src下创建一个hibernate.cfg.xml文件，格式如下：</p>
<p>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>    “-//Hibernate/Hibernate Configuration DTD 3.0//EN”<br>    “<a href="http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;" target="_blank" rel="external">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</a></p>
<p><hibernate-configuration><br>    <session-factory><br>        <!-- 连接数据库的基本信息 --><br>        <property name="hibernate.connection.username">root</property><br>        <property name="hibernate.connection.password">root</property><br>        <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property><br>        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate4</property></session-factory></hibernate-configuration></p>
<pre><code>    &lt;!-- hibernate使用的数据库方言
         如果不知道可以去/hibernate-release-4.3.11.Final/project/etc/hibernate.properties
         中查找 --&gt;
    &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;
    &lt;!-- 是否在控制台显示sql语句 --&gt;
    &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否格式化显示的sql语句 --&gt;
    &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;
    &lt;!-- 是否自动生成数据表的策略,create代表每次启动程序都重新创建数据表 --&gt;
    &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;

    &lt;!-- 需要使用到的*.hbm.xml文件 --&gt;
    &lt;mapping resource=&quot;cn/net/bysoft/lesson1/User.hbm.xml&quot;/&gt;
&lt;/session-factory&gt;
</code></pre><p><br>    该文件需要注意的有两个地方，第一个是mapping属性，第二个是hibernate.hbm2ddl.auto这个属性。</p>
<pre><code>mapping属性用来配置*.hbm.xml的资源文件地址，这里需要注意的是没有用cn.net.bysoft.lession的形式，而是使用的&apos;/&apos;来描述目录位置。

接下来是自动执行ddl语句的设置(也就是hibernate.hbm2ddl.auto)参数有4个，分别是：
</code></pre><p>create</p>
<p>create为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来drop掉数据表，drop后重新create数据表；</p>
<p>create-drop</p>
<p>create-drop为每次创建sessionfactory时，会根据*.hbm.xml文件中所配置的信息来create数据表。而每当sessionfactory被close时，会drop掉开始时create的数据表；</p>
<p>update</p>
<p>update为每次创建sessionfactory时，如果数据库中没有对应的表，则新建。</p>
<p>若已经新建过，则会判断*.hbm.xml文件的配置与建立好的数据表的结构是否相同。</p>
<p>如果相同则不去进行ddl的操作。</p>
<p>如果不同，则会根据*.hbm.xml文件中有变化的配置项去更新数据表，但不会删除数据表中已创建过的任何信息。</p>
<p>validate</p>
<p>validate为每次创建sessionfactory时，将用*.hbm.xml文件中的配置信息与现有的对应的数据表结构进行比较，若发现不同则抛出异常。</p>
<p>7.编写代码测试</p>
<p>package cn.net.bysoft.lesson1;</p>
<p>import java.util.Date;</p>
<p>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.hibernate.Transaction;<br>import org.hibernate.boot.registry.StandardServiceRegistry;<br>import org.hibernate.boot.registry.StandardServiceRegistryBuilder;<br>import org.hibernate.cfg.Configuration;<br>import org.junit.Test;</p>
<p>public class UserTest {</p>
<pre><code>@Test
public void test() {
    // 0.创建configuration对象，该对象保存着hibernate的配置信息和对象关系映射的信息。
    Configuration cfg = new Configuration().configure();
    // 1.创建sessionfactory对象
    StandardServiceRegistryBuilder builder = new StandardServiceRegistryBuilder().applySettings(cfg.getProperties());
    StandardServiceRegistry registry =  builder.build();
    SessionFactory sessionFactory = cfg.buildSessionFactory(registry); 
    // 2.创建session对象
    Session session = sessionFactory.openSession();
    // 3.开始事务
    Transaction transaction = session.beginTransaction();
    // 4.保存
    User user = new User(&quot;Jack&quot;, new Date());
    session.save(user);
    // 5.提交事务
    transaction.commit();
    // 6.关闭session对象
    session.close();
    // 7.关闭sessionfactory对象
    sessionFactory.close();
}
</code></pre><p>}<br>    上面这段代码中configuration对象用来保存则hibernate的配置信息，如hibernate.cfg.xml中的配置信息，和*.hbm.xml的映射信息。</p>
<pre><code>sessionfactory为创建session的工厂，它是线程安全的。一般建议一个项目中只有一个sessionfactory，因为创建sessionfactory非常费资源。

接下来是session对象，该对象是hibernate的核心，是一个单线程的对象，内部有session缓存。

对需要持久化的java对象的所有操作都用到了session。

常用的方法有get、load、save、update、saveorupdate、delete、begintransaction、isopen、flush、clear、evicto、close等等方法，接下来将会一个一个研究这些方法的使用。

这是执行这段代码后，控制台输出的内容：



创建了一张名为S_USER的数据表，并insert了一条数据。



到此位置，一个简单的hibernate环境就搭建好了。工程的目录结构如下：
</code></pre><p>配置对象<br>配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。</p>
<p>数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。<br>类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。<br>SessionFactory 对象<br>配置对象被用于创造一个 SessionFactory 对象，使用提供的配置文件为应用程序依次配置 Hibernate，并允许实例化一个会话对象。SessionFactory 是一个线程安全对象并由应用程序所有的线程所使用。</p>
<p>SessionFactory 是一个重量级对象所以通常它都是在应用程序启动时创造然后留存为以后使用。每个数据库需要一个 SessionFactory 对象使用一个单独的配置文件。所以如果你使用多种数据库那么你要创造多种 SessionFactory 对象。</p>
<p>Session 对象<br>一个会话被用于与数据库的物理连接。Session 对象是轻量级的，并被设计为每次实例化都需要与数据库的交互。持久对象通过 Session 对象保存和检索。</p>
<p>Session 对象不应该长时间保持开启状态因为它们通常情况下并非线程安全，并且它们应该按照所需创造和销毁。</p>
<p>Transaction 对象<br>一个事务代表了与数据库工作的一个单元并且大部分 RDBMS 支持事务功能。在 Hibernate 中事务由底层事务管理器和事务（来自 JDBC 或者 JTA）处理。</p>
<p>这是一个选择性对象，Hibernate 应用程序可能不选择使用这个接口，而是在自己应用程序代码中管理事务。</p>
<p>Query 对象<br>Query 对象使用 SQL 或者 Hibernate 查询语言（HQL）字符串在数据库中来检索数据并创造对象。一个查询的实例被用于连结查询参数，限制由查询返回的结果数量，并最终执行查询。</p>
<p>Criteria 对象<br>Criteria 对象被用于创造和执行面向规则查询的对象来检索对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎使用 &lt;strong&gt;{小书匠}(xiaoshujiang)编辑器&lt;/strong&gt;，您可以通过==设置==里的修改模板来改变新建文章的内容。1.下载hibernate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;需要到hibernate的官网下载一个hibernate。网址是：ht
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hibernate基础</title>
    <link href="http://yoursite.com/2017/08/11/Hibernate%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/08/11/Hibernate基础/</id>
    <published>2017-08-11T11:11:43.000Z</published>
    <updated>2017-08-12T01:49:34.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>众所周知，Java是面向对象的世界，但数据库不是，现在的主流数据库大多都是关系型数据库。Java的对象想要进入数据库，就必须遵守数据库的“关系”规范，变成一条条的“记录”，数据库中的记录要变成Java中的对象，也同样需要有一个变身的过程—-繁琐的过程。通过SQL这个关系世界的魔法，我们建立起了“面向世界的世界”和“面向关系的世界”的桥梁。</p>
<p>那么问题来了，SQL是面向关系的语言， 它的脑袋里只有数据库中死板的记录，和眼中 “万事万物皆对象” 的Java在一起，显得格格不入。所以，“用面向对象的方法处理数据库操作”的 Hibernate 出世了。可以这么说，Hibernate 为 “面向对象” 和 “面向关系” 这两个截然不同的世界搭起了桥梁，所以它被称为ORM（Object–Relation Maping）—-对象映射框架。</p>
<h3 id="Hibernate基本工作原理"><a href="#Hibernate基本工作原理" class="headerlink" title="Hibernate基本工作原理"></a>Hibernate基本工作原理</h3><p>配置对象<br>配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。</p>
<p>数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。<br>类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。<br>SessionFactory 对象<br>配置对象被用于创造一个 SessionFactory 对象，使用提供的配置文件为应用程序依次配置 Hibernate，并允许实例化一个会话对象。SessionFactory 是一个线程安全对象并由应用程序所有的线程所使用。</p>
<p>SessionFactory 是一个重量级对象所以通常它都是在应用程序启动时创造然后留存为以后使用。每个数据库需要一个 SessionFactory 对象使用一个单独的配置文件。所以如果你使用多种数据库那么你要创造多种 SessionFactory 对象。</p>
<p>Session 对象<br>一个会话被用于与数据库的物理连接。Session 对象是轻量级的，并被设计为每次实例化都需要与数据库的交互。持久对象通过 Session 对象保存和检索。</p>
<p>Session 对象不应该长时间保持开启状态因为它们通常情况下并非线程安全，并且它们应该按照所需创造和销毁。</p>
<p>Transaction 对象<br>一个事务代表了与数据库工作的一个单元并且大部分 RDBMS 支持事务功能。在 Hibernate 中事务由底层事务管理器和事务（来自 JDBC 或者 JTA）处理。</p>
<p>这是一个选择性对象，Hibernate 应用程序可能不选择使用这个接口，而是在自己应用程序代码中管理事务。</p>
<p>Query 对象<br>Query 对象使用 SQL 或者 Hibernate 查询语言（HQL）字符串在数据库中来检索数据并创造对象。一个查询的实例被用于连结查询参数，限制由查询返回的结果数量，并最终执行查询。</p>
<p>Criteria 对象<br>Criteria 对象被用于创造和执行面向规则查询的对象来检索对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;Why&lt;/h3&gt;&lt;p&gt;众所周知，Java是面向对象的世界，但数据库不是，现在的主流数据库大多都是关系型数据库。Java的对象想要进入数据库，就必须遵守数据
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java动态网页</title>
    <link href="http://yoursite.com/2017/08/09/Java%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/"/>
    <id>http://yoursite.com/2017/08/09/Java动态网页/</id>
    <published>2017-08-09T12:56:59.000Z</published>
    <updated>2017-08-09T14:28:53.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何为动态网页"><a href="#何为动态网页" class="headerlink" title="何为动态网页"></a>何为动态网页</h3><p>所谓动态，是指浏览器所接受到的HTML页面是由服务器端的程序动态生成的，而不是事先制作好的。</p>
<h4 id="Java动态网页"><a href="#Java动态网页" class="headerlink" title="Java动态网页"></a>Java动态网页</h4><p>Java的动态Web编程技术是从Servlet（Servlet是服务器端小程序的意思）开始的。它在服务器端运行，动态地向客户端输出HTML页面。</p>
<h4 id="从HTML到JSP"><a href="#从HTML到JSP" class="headerlink" title="从HTML到JSP"></a>从HTML到JSP</h4><p>JSP是Servlet技术的扩展—-JSP(Java Server Pages) 。JSP实际上是Servlet的 一种变体，二者在本质上是一致的。为什么这样说呢？首先，Servlet和JSP是不能直接运行的，它们必须部署到一种特殊的应用程序—-Web服务器中。Web服务器会将JSP编译为Servlet，最后用于响应客户端浏览器的请求。虽然JSP和Servlet在本质上没有不同。只是Servlet在Java中插入HTML代码，而JSP是在HTML中插入Java代码而已。但这种形式上的转变简化了页面的编写工作：在JSP中书写静态HTML代码更加方便，不必在用print输出每一行。网页设计师和JSP程序员也可以很好地配合，前者只需要制作好HTML静态页面，将需要生成的地方预留空白，再交给后者加入动态内容、制作成JSP页面就可以了。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;何为动态网页&quot;&gt;&lt;a href=&quot;#何为动态网页&quot; class=&quot;headerlink&quot; title=&quot;何为动态网页&quot;&gt;&lt;/a&gt;何为动态网页&lt;/h3&gt;&lt;p&gt;所谓动态，是指浏览器所接受到的HTML页面是由服务器端的程序动态生成的，而不是事先制作好的。&lt;/p&gt;
&lt;h4
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDBC简单用</title>
    <link href="http://yoursite.com/2017/08/08/JDBC%E7%AE%80%E5%8D%95%E7%94%A8/"/>
    <id>http://yoursite.com/2017/08/08/JDBC简单用/</id>
    <published>2017-08-07T22:15:28.000Z</published>
    <updated>2017-08-07T14:40:31.782Z</updated>
    
    <content type="html"><![CDATA[<h4 id="何为JDBC"><a href="#何为JDBC" class="headerlink" title="何为JDBC"></a>何为JDBC</h4><p>JDBC（Java Data Base Connectivity,Java数据库连接）是由原Sun公司制定的数据库连接技术。SQL是用户操作数据库的语言，JDBC则为用户与数据库之间搭起了<strong>通信</strong>的通道。JDBC的根本目的：<strong>为Java编程人员提供操作各种数据库统一接口</strong></p>
<p>作为程序员，我们不能要求我们的用户只用一种数据库，所以说同一个Java应用能运用在不同的数据库之上是非常重要的，同时，这也是很不容易的。当今的数据库种类繁多，就像不同的国家的人说不同的语言一样，不同的数据库也使用着不同的语言…想要跟不同的数据库“交流”，就要使用他们的语言，那是不是说作为一名Java程序员要懂得所有的数据库语言？</p>
<p>要解决这个问题，我们就需要一个翻译，就像国家领导人经常出访不同的国家，但不需要懂得全世界的语言一样。</p>
<p>原Sun公司制定了JDBC的标准，这个标准规定了JDBC的接口，就如同规定了Java程序员与JDBC使用的语言。不同数据库语言的表达方式被JDBC统一了起来。就拿 “给我一个数据库连接” 这样一个命令来说，不论在各个数据库中是怎么实现的，在JDBC中都是一个命令—-“getConnection” 。</p>
<p>这些功能的实现，主要靠的是“JDBC驱动” 这个东西，它承担了翻译的核心机能。JDBC标准规定后，各个数据库厂商根据这个标准，开发出对应自己数据库产品的JDBC驱动。所以想要操作什么数据库，只要找到相应的驱动就好了。当然，JDBC驱动实际上就是一组class文件，它们被打包为Java专用压缩格式jar。</p>
<p>这样一来，数据库程序的开发就变得简单了。JDBC为Java提供了一个统一接口，程序员在编程时，可以不考虑所要操作的是什么数据库，只需要使用标准的JDBC书写数据库操作代码，再根据目标数据库的不同，加在相应的JDBC驱动就行了。</p>
<p>JDBC的所有接口都在Java基础类库的  java.sql 包以及 javax.sql 包中，但请注意这些都只是接口，所有的实现类就是由各数据库厂商根据这些接口编写的具体类而已。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;何为JDBC&quot;&gt;&lt;a href=&quot;#何为JDBC&quot; class=&quot;headerlink&quot; title=&quot;何为JDBC&quot;&gt;&lt;/a&gt;何为JDBC&lt;/h4&gt;&lt;p&gt;JDBC（Java Data Base Connectivity,Java数据库连接）是由原Sun公司制定的
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库的优势</title>
    <link href="http://yoursite.com/2017/08/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/08/07/数据库相关/</id>
    <published>2017-08-07T15:18:28.000Z</published>
    <updated>2017-08-07T14:11:20.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用数据库的优势"><a href="#使用数据库的优势" class="headerlink" title="使用数据库的优势"></a>使用数据库的优势</h3><h4 id="1、灵活、高效地管理数据"><a href="#1、灵活、高效地管理数据" class="headerlink" title="1、灵活、高效地管理数据"></a>1、灵活、高效地管理数据</h4><p>数据库可不是简单地把存进去的数据堆积起来。它会将数据分门别类存放好，并在此基础上建立起一整套查询、修改、输入与输出的机制，极大地提高工作效率。</p>
<h4 id="2、方便共享数据"><a href="#2、方便共享数据" class="headerlink" title="2、方便共享数据"></a>2、方便共享数据</h4><p>在现实中，不少用户之间都经常存在重复数据的现象。此外，现实中的数据经常要同时提供给许多使用者，如果每个使用者都保存一份相同的数据，一方面会造成巨大的浪费，另一方面也会为保证数据的一致性增加困难。举个简单例子，中国所有的公民的有关数据的量是非常庞大的，而很多地方都需要这些数据，即使真的把这些数据都复制成千上万份发放给各个机关，那么一旦这些数据更改（每一秒都有人出生、死亡），所有的机关必须对自己手中的数据进行准确无误的更改…工作量是很大的。但将公民的数据统一保存在数据库中，以上的问题便能迎刃而解：各个机关通过网络访问数据库，数据库中数据的更改也会及时。统一地反映给各个机构。</p>
<p>将“数据”与“应用”分离。把程序中的数据部分转移到数据库这个安全稳定的盒子中，这些数据就与应用程序之间有了清晰的界限。这样一来，程序的任何改变都不会影响到数据，就算程序废弃了，数据库中的数据仍然能为其他应用程序所用。</p>
<h4 id="3、增强安全性"><a href="#3、增强安全性" class="headerlink" title="3、增强安全性"></a>3、增强安全性</h4><p>任何对数据库内任何数据的访问都必须经过数据库系统的授权，从而更加有力地保障了数据的安全。举个例子吧，说白了，数据库就相当与现实生活中的图书馆，堆积如山的书籍就是数据。乱七八糟的图书进入图书馆后，被一个个贴上标签，分类整理好之后放入指定的位置。之后，读者更方便查找、借阅书籍，一本书也能给更多人阅读—-这些都类似于数据库为数据提供的管理、共享功能。与此同时，读者借阅书籍时必须经过图书管理者的允许，借阅之后限期归还，这就像数据库为数据提供的安全保障。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用数据库的优势&quot;&gt;&lt;a href=&quot;#使用数据库的优势&quot; class=&quot;headerlink&quot; title=&quot;使用数据库的优势&quot;&gt;&lt;/a&gt;使用数据库的优势&lt;/h3&gt;&lt;h4 id=&quot;1、灵活、高效地管理数据&quot;&gt;&lt;a href=&quot;#1、灵活、高效地管理数据&quot; cla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写代码前的准备</title>
    <link href="http://yoursite.com/2017/08/06/%E5%86%99%E4%BB%A3%E7%A0%81%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2017/08/06/写代码前的准备/</id>
    <published>2017-08-05T23:16:38.000Z</published>
    <updated>2017-08-05T16:07:37.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写代码前的准备"><a href="#写代码前的准备" class="headerlink" title="写代码前的准备"></a>写代码前的准备</h3><p>对很多初学者来说，写程序前的第一件事就是打开IDE，然后开始敲代码…</p>
<p>其实，这样是不对的，我们不能着急，程序开发的第一步是分析设计。我们大多数人在初学编程的时候，都喜欢上手就开始写代码，而不习惯先做一些设计思考，更别提将这些设计付诸于笔端了。这有两个方面的原因：一是因为和 “设计” 这样看起来虚无缥缈的东西比起来，代码是实实在在的，运行起来就很有成就感；二是初学编程是写的都是一些小程序，前期设计的作用在这些小规模的程序上体现不出来。但请读者记住，在实际的编程之前做一些前期设计，必要时动笔在纸上写一谢、画一画，是百利无一害的。简单的设计图表能帮助程序员整理思路，回避一些不必要的错误。</p>
<h4 id="什么是设计"><a href="#什么是设计" class="headerlink" title="什么是设计"></a>什么是设计</h4><p>对于面向对象的程序，本质上是对象之间的关系，所以设计的第一步就是找出这个程序里究竟有那些对象。方法说起来也简单：分析现实应用场景，从这些情境中抽出相应的 “角色” ，这些 “角色” 就是程序中的对象。那什么是角色呢？简单来说，就是现实环境中的人与物。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写代码前的准备&quot;&gt;&lt;a href=&quot;#写代码前的准备&quot; class=&quot;headerlink&quot; title=&quot;写代码前的准备&quot;&gt;&lt;/a&gt;写代码前的准备&lt;/h3&gt;&lt;p&gt;对很多初学者来说，写程序前的第一件事就是打开IDE，然后开始敲代码…&lt;/p&gt;
&lt;p&gt;其实，这样是不对
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>代码之髓读书笔记</title>
    <link href="http://yoursite.com/2017/08/01/%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%AB%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/01/代码之髓读书笔记/</id>
    <published>2017-07-31T21:26:19.000Z</published>
    <updated>2017-08-01T04:14:28.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>“内容能够理解，但总觉得不够彻底。”<br>我们在学习编程的过程中总是有这样的感觉。当新学的知识与之身经验以及原来掌握的知识尚未很好的结合的时候，往往会出现这种似懂非懂的状态。<br>“要学的东西太多了，先学什么好呢？”<br>大家曾经为这种问题苦恼过吗？<br>我们都要集中精力学习一些知识要点，但是怎样才能做到呢？</p>
<h4 id="在比较中学习"><a href="#在比较中学习" class="headerlink" title="在比较中学习"></a>在比较中学习</h4><p>我们学习语言也不仅仅是学习语言，而是从学习这门语言中学到一些在其他语言中也能用的一些知识。多种语言共同的知识才是要点。掌握了这些要点，学习其他语言时才会更加轻松。</p>
<ul>
<li><p>语言不同，规则不同</p>
<ul>
<li>在比较中学习多种语言，一些知识我们就能理解的更深刻，因为我们学的是不同语言之间的共性，最基本也是最重要的东西。某种具体的编程语言教程中会罗列出各种各样的规则。其实这些规则并不具有普遍意义，只是因为 “在当前的特定情况下，作此规定能更方便”。也就是说，某种语言的教材里出现的某某规则不过是该语言里的规则，仅此而已。就像在C语言中，0代表假；在Ruby中代表的是真；但在Java中，不能用来当作布尔变量。</li>
</ul>
</li>
</ul>
<h4 id="在历史中学习"><a href="#在历史中学习" class="headerlink" title="在历史中学习"></a>在历史中学习</h4><ul>
<li><p>理解语言设计者的意图</p>
<ul>
<li>在学某种编程语言的某个功能时，如果我们觉得掌握的并不够彻底，无法深入学习时，我么应该站在设计者的角度想一想。为什么设计者要设计这个功能？设计者是为了解决什么问题而设计了这种功能？</li>
</ul>
</li>
<li><p>应该学那种语言，我们无从所知</p>
<ul>
<li>了解了语言的历史，我们对其的理解会更加深刻。“想学编程，但该学那种语言呢？”这个问题是很多初学者要问的，但这个问题有意义吗？没有。因为未来的事谁也说不准。</li>
</ul>
</li>
<li><p>学习适用于各种语言的知识</p>
<ul>
<li>现在还有很多被不同人以不同理由推荐学习的编程语言。然而，在5年后、十年后，单个语言的知识是否依然有用？没人能说的清楚。通过比较不同的语言、了解语言的发展历史及其变化原因，培养对不同语言都试用的理解能力，是非常重要的。</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>“在比较中学习”不是学习某种特定语言的编程，而指的是同时比较几种语言，从而掌握那些知识是因语言的不同而不同的，那些知识是几种语言共享的。</li>
<li>“在历史中学习”指的是探寻语言是如何变化的，以及在发生变化前存在那些问题，从而理解语言为何开发出各种功能。</li>
</ul>
<h3 id="程序语言诞生史"><a href="#程序语言诞生史" class="headerlink" title="程序语言诞生史"></a>程序语言诞生史</h3><p>程序设计语言是如何诞生的？<br>前人是基于什么目的发明了程序设计语言？</p>
<h4 id="连接电缆"><a href="#连接电缆" class="headerlink" title="连接电缆"></a>连接电缆</h4><p>1946年，世界上第一台电子计算机—-ENIAC问世。它可以改变计算方式，即可以更改程序。用现在的话来讲，它是一台可编程计算机。但其编程方法和如今大家熟知的程序设计有很大的不同。它的程序设计就是指把这台计算机不同的端口通过电缆连接起来。每次更改程序是都要重新调整电缆连接方式，是在费劲。<br> 有没有方便一点的方式呢？</p>
<h4 id="程序内置"><a href="#程序内置" class="headerlink" title="程序内置"></a>程序内置</h4><p> 1949年，EDSAC问世。这是一种通过纸带打点的方式来记录和读取数据的计算机。程序作为数据通过纸带输入。不需要重新连接电缆，只需要让计算机不断读取纸带上的数据就可以更改程序了。这比重新连接电缆进步一点了，但还是有缺点了，如果想改程序的话，就很麻烦，代价也很大，虽然我们只想改一个标点符号还是全部，都要从头再来。</p>
<h4 id="FORTRAN语言问世"><a href="#FORTRAN语言问世" class="headerlink" title="FORTRAN语言问世"></a>FORTRAN语言问世</h4><p> 直到1954年，与大家现在使用的语言类似的程序设计语言才被发明出来。这就是FORYRAN（Formula Translating System  公式翻译系统）。现在，我们常用 “X*Y+Z”来表达“X乘 以Y在加Z“ 。最早实现这一点的就是是FORYRAN。将公式转化为机器是是FORYRAN的特点之一。 </p>
<h4 id="程序设计语言产生的原因"><a href="#程序设计语言产生的原因" class="headerlink" title="程序设计语言产生的原因"></a>程序设计语言产生的原因</h4><p> 我们为了获得更轻松辩解的体验而编写程序。但轻松便捷不等于偷工减料。偷工减料在前，痛苦在后，这不是真正的便捷。</p>
<ul>
<li>懒惰：程序员的三大美德之一<ul>
<li>优秀的程序员具有三大美德：懒惰、急躁和傲慢。</li>
<li>懒惰是一项为了减少总量支出，而不留余力地努力的素质。为了节省功夫，设计的程序逐渐被更多的人使用。单独回答每个使用者疑问费时费力，所以出现了注释。所以说，懒惰是程序员最宝贵的素质。</li>
</ul>
</li>
</ul>
<h4 id="语言们各有各的便捷"><a href="#语言们各有各的便捷" class="headerlink" title="语言们各有各的便捷"></a>语言们各有各的便捷</h4><ul>
<li><p>何为便捷</p>
<ul>
<li>语言是为了使什么变得便捷呢？是高速的代码执行？还是简单易于掌握的语言规范呢？抑或是轻松地理解他人编写的代码？比如，C++具有很高的执行力，但其的语言规范变得很复杂；Scheme重视语言规范，追求语言规范简洁；python是一种侧重于把代码阅读变得容易的语言。</li>
</ul>
<ul>
<li>各有各的便捷<ul>
<li>语言的便捷之处各不相同。比如,PHP语言编写Web服务很轻松，但它不擅长文字处理。相反，Haskll和OCaml这样的ML系列语言，编写处理文字的应用很便捷，但编写Web服务是就没有PHP那么便捷了。总的来说，程序设计语言的选用因使用者目的不同而不同。</li>
</ul>
</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>语言只是工具。某种语言是否适合自己，要看使用这种语言能否给我们当前的工作发挥作用或者说能发挥多大的作用，而不是看这种语言是否流行。我们要根据自己的情况选择合适的工具。</li>
</ul>
</li>
</ul>
<h3 id="专栏"><a href="#专栏" class="headerlink" title="专栏"></a>专栏</h3><h4 id="要确认理解是否正确，首先得表达出来"><a href="#要确认理解是否正确，首先得表达出来" class="headerlink" title="要确认理解是否正确，首先得表达出来"></a>要确认理解是否正确，首先得表达出来</h4><ul>
<li>假设我们正在学习一些知识，并自我感觉已经理解了。那么，我们到底是真正理解了呢，还是感觉自己已经理解了呢？仅凭自己苦思冥想是不行的。为了验证理解正确与否，需要表达出来。只能基于自己的理解说出自己的观点，然后让第三方来判断和检验。比如学习英语，就要在别人面前使用自己学到的英语，同时观察别人的反应。不这样做的话，就无法知道自己是否真正掌握了英语。</li>
<li>程序员一直收益于这一点。写文章，写出来的东西即使有错误也可能没人指点出来，或者根本没有人看你的东西。但写程序不一样，语言处理器会事无巨细地做错误检查并指出。这和人打交道不同，只要你方便，它总是有足够的时间和耐心陪你一起。</li>
</ul>
<h4 id="当你不知道学习什么时"><a href="#当你不知道学习什么时" class="headerlink" title="当你不知道学习什么时"></a>当你不知道学习什么时</h4><ul>
<li>应该学习什么？我们经常听到这样的问题。在回答之前，笔者想先问这样一个问题：你学习的目的是什么？我们生活在一个信息爆炸的时代。不管三七二十一统统都学，这样的学习策略已经不在适用。必然要有所学，有所不学。这时，我们就要事先明确自己到底想做什么，然后再去学习能够达到这一目标的知识。</li>
<li>不知道自己要做什么？或许你从一开始就在思考，想做一件完美的事情。一件从没有人想到过的，能获得别人赞誉的事情。如果最初的设想太过宏大导致无从下手，那么这一设想就永远不可能实现。还不如从小事做起，从简单的事情做起。这个过程中，你可以逐渐明白自己那些已经能做、那些还不能做，如果要做还要学习那些知识。长此以往，就能培养出完成更复杂任务的能力。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h3&gt;&lt;p&gt;“内容能够理解，但总觉得不够彻底。”&lt;br&gt;我们在学习编程的过程中总是有这样的感觉。当新学的知识与之身经验以及原来掌握的知识尚未很好
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>玩转cmd</title>
    <link href="http://yoursite.com/2017/07/31/%E7%8E%A9%E8%BD%ACcmd/"/>
    <id>http://yoursite.com/2017/07/31/玩转cmd/</id>
    <published>2017-07-31T00:22:04.000Z</published>
    <updated>2017-07-30T16:50:36.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cmd应用基础"><a href="#cmd应用基础" class="headerlink" title="cmd应用基础"></a>cmd应用基础</h3><p>Posted on 2012-12-15</p>
<h4 id="cmd是什么？"><a href="#cmd是什么？" class="headerlink" title="cmd是什么？"></a>cmd是什么？</h4><p>对于程序员而言，cmd命令提示符是windows操作系统下一个比较重要的工具。对于程序员而言，为了追求更高的效率而抛弃花俏的界面已然是意见很常见的行为，截止到目前的，全世界仍有大量的服务器还使用着单一的命令行界面。</p>
<p>使用命令行界面的一个重要因素就是，在远程管理的过程中，命令行操作紧需要传递少量的数据就可以对机器进行操作，如果是图形界面，由于需要传输大量的图形数据，很可能出现延迟、链接不稳定等情况，亦或者在同样情况下效率没有使用命令行界面操作来得高。所以，至今人们依旧离不开命令行操作。</p>
<p>而cmd则是windows系列操作系统下的命令行操作程序 <strong>(不论是命令行或者是桌面这样的图形界面本质上都是程序)</strong></p>
<p>命令行界面程序cmd.exe所在的目录是C:\Windows\System32</p>
<p>顺带一提我们的桌面（图形操作界面）则是位于C:\Windows下的explorer.exe</p>
<h4 id="如何打开cmd"><a href="#如何打开cmd" class="headerlink" title="如何打开cmd"></a>如何打开cmd</h4><p><strong>方法有很多，以下列举几种</strong></p>
<ol>
<li>打开C:\WindowsSystem32目录，找到cmd.exe双击运行。当然，通常人们都不会这么做。</li>
<li>打开开始菜单-&gt;运行-&gt;输入cmd-&gt;回车</li>
<li>通过快捷键：win（windows商标键） + r 调出运行框，然后输入cmd回车</li>
<li>win7打开开始菜单之后可以直接输入cmd回车</li>
</ol>
<p><strong>关于当前目录</strong></p>
<p>对于新手而言，这是一个必须要搞清楚的问题。首先我们来学习几个命令：</p>
<h5 id="cd-C-cd是change-directory的简写，意思是改变目录，上面这条命令的意思就是切换到C-目录下。"><a href="#cd-C-cd是change-directory的简写，意思是改变目录，上面这条命令的意思就是切换到C-目录下。" class="headerlink" title="cd C:\  cd是change directory的简写，意思是改变目录，上面这条命令的意思就是切换到C:\目录下。"></a>cd C:\  cd是change directory的简写，意思是改变目录，上面这条命令的意思就是切换到C:\目录下。</h5><p>可以观察到，cmd界面上的目录变成了C:\</p>
<p><img src="/images/cmd.jpg" alt=""></p>
<p>我们可以从图中看到，cmd中的文字有变化，而有变化的地方就是我们要注意的地方。</p>
<p>在每一行的最前面就是当前目录的地址，例如最开始的</p>
<p>C:\Users\Lellansin&gt;cd C:\  这当中”C:\Users\Lellansin” 你的账户名称是Admin的话就是C:\Users\Admin,注意是win7的默认目录)就是我的当前目录而执行了cd C:\命令之后当前目录就变成了 C:\</p>
<p>当前目录是一个相对重要的概念，因为很多操作只能对当前目录里面的文件进行。就好比，通常情况下，你要操作E盘某个目录下的某个文件，你首先要双击“我的电脑”打开E盘相应的文件夹，找到那个目录才能操作那个目录下的文件一样。对于cmd而言，要操作相应目录下的文件需要切换到相应的目录。</p>
<h5 id="输入dir回车，系统会返回当前目录下的文件列表"><a href="#输入dir回车，系统会返回当前目录下的文件列表" class="headerlink" title="输入dir回车，系统会返回当前目录下的文件列表"></a>输入dir回车，系统会返回当前目录下的文件列表</h5><ol>
<li><p>如何执行或打开文件</p>
<ul>
<li><p>C:>1.txt</p>
<ul>
<li><p>如果我在C盘根目录下有一个1.txt的文本文件，那么就可以直接输入1.txt回车，即可打开该文件。（这个在linux下也是同样的情况，博主当年也搞不清楚怎么运行程序来着）</p>
</li>
<li><p>同样的，如果存在hello.exe，那么直接输入hello.exe即可运行该程序。当然需要注意的是，某些系统默认的应用程序格式（如.exe文件）在cmd中调用的时候是可以省略后缀的。也就是可以直接输入hello，然后回车也同样可以运行hello.exe。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>环境变量</p>
<ul>
<li><p>环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等。</p>
</li>
<li><p>常见的环境变量：</p>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>变量名</th>
<th style="text-align:right">变量值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Path</td>
<td style="text-align:right">…太多省略…</td>
</tr>
<tr>
<td>OS</td>
<td style="text-align:right">Windows_NT</td>
</tr>
<tr>
<td>windir</td>
<td style="text-align:right">%SystemRoot%</td>
</tr>
<tr>
<td>TMP</td>
<td style="text-align:right">%SystemRoot%TEMP</td>
</tr>
<tr>
<td>ComSpec</td>
<td style="text-align:right">%SystemRoot%system32cmd.exe</td>
</tr>
</tbody>
</table>
<p>至于%SystemRoot%的值是什么，大家只要把它复制到文件浏览上面的地址栏里面然后回车就知道了。</p>
<ol>
<li><p>环境变量的作用</p>
<ul>
<li>为系统或者用户程序设置一些默认参数。比如windir这个环境变量，就可能有程序通过读取这个环境变量的值来查看系统的版本。</li>
</ul>
</li>
<li><p>环境变量的设置方法</p>
<p> -【我的电脑】-&gt;右键【属性】-&gt;【高级】-&gt;【环境变量】-&gt;选中你要修改的环境变量点击【编辑】即可</p>
<ul>
<li>通过cmd设置（不推荐）</li>
</ul>
</li>
<li><p>path的作用</p>
<ul>
<li><p>path是一个很常见得环境变量。主要用来配置系统的默认路径。也就是当你在某个目录下执行某个程序，但是本身目录下却没有这个程序的时候，系统会自动到默认路径下面也去找一找，有没有你要执行的程序。</p>
</li>
<li><p>比如你写了一个hello.exe（编译运行后，能在在程序的相应的debug目录下能找到）。然后把这个hello.exe移动到E:\test目录下，接着</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 切换到E盘</div><div class="line">cd E:\</div><div class="line"># 切换到E盘下的test文件中</div><div class="line">cd test</div><div class="line">#执行hello.exe</div><div class="line">hello.exe</div><div class="line"># 假设程序输出hello world</div><div class="line"># 这个时候再切换到E盘根目录下(cd .. 是切换到上级目录)</div><div class="line">cd ..</div><div class="line"># 再执行hello.exe</div><div class="line">hello.exe</div><div class="line"># 这个时候系统会提醒你找不到这个命令</div><div class="line"># 但是如果你将 E:\test 这个目录加入到 path中，</div><div class="line"># 就可以在任意地方运行hello.exe</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="cmd的常见作用"><a href="#cmd的常见作用" class="headerlink" title="cmd的常见作用"></a>cmd的常见作用</h4><p>1.自动关机<br>2.常看本地ip<br>3.使用ping<br>4.快速查询本地服务、端口使用情况<br>5.快速调用一些常用工具<br>6.原始编程方式，用cmd调用编译<br>7.学汇编都应该知道cmd下的debug<br>8.批处理</p>
<h4 id="自动关机"><a href="#自动关机" class="headerlink" title="自动关机"></a>自动关机</h4><p>先说自动关机,貌似很多人都被开过自动关机的玩笑,我们通过cmd就可以实现自动关机命令</p>
<h6 id="输入shutdown回车"><a href="#输入shutdown回车" class="headerlink" title="输入shutdown回车"></a>输入shutdown回车</h6><p>shutdown并不是一个cmd命令而是一个windows系统自带的程序shutdown.exe，位于C:\WINDOWS\system32目录下，之所以能够直接执行，是因为C:\WINDOWS\system32目录，是系统默认配置在环境变量path中的。其他还有很多的自带程序都在这个目录，以下其他程序不做过多说明。（PS：这里仅仅只讲一些cmd的常见应用，至于cmd的语法之类的，讲了也有些鸡肋，如果想学习批处理再研究也不迟）<br>废话不多说，我们可以从上面的图片看到，直接输入程序自动给出了一些提示，这些参数告诉了我们这个shutdown.exe要怎么使用</p>
<h4 id="shutdown-s"><a href="#shutdown-s" class="headerlink" title="shutdown -s"></a>shutdown -s</h4><p>按照他提示的参数输入这个命令，会弹出提示：</p>
<p>博主是在xp下测试，当然如果是在win7等系统下的话效果会不一样。如果你在实验这个命令，不要慌张马上按照提示执行下面的命令：</p>
<h4 id="取消关机"><a href="#取消关机" class="headerlink" title="取消关机"></a>取消关机</h4><p>shutdown -a<br>接下来我们来看一下这个程序最常用的方式：</p>
<h4 id="1小时-3600秒-后关机"><a href="#1小时-3600秒-后关机" class="headerlink" title="1小时(3600秒)后关机"></a>1小时(3600秒)后关机</h4><p>shutdown -s -t 3600<br>博主就经常用到上面这个命令，甚至桌面常备取消关机的批处理（哈哈，当年没少被开过这种玩笑）<br>好吧，少年，你是要问我批处理是什么嘛？<br>请你新建一个文件把“shutdown -s -t 3600”复制进去，然后保存，另存为.bat后缀的文件（如何更改文件后缀，不懂请戳度娘谷歌），接着双击这个bat文件。<br>如果你看到系统提示你一小时后会自动关闭，那么恭喜你，你已经写好了一个自动关机的批处理文件。那么同样的可以想象，取消关机的批处理，就是一个.bat文件，里面写着一行“shutdown -a”，双击一下就可以运行了（批处理的特点之一）。</p>
<p>当然如果，想在C语言中调用这个命令也很简单。<br>先引入stdlib.h库。接着就可以通过system()命令来调用了，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">    system(&quot;shutdown -s -t 3600&quot;);</div><div class="line">    printf(&quot;自动关机已设置！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="常看本地ip"><a href="#常看本地ip" class="headerlink" title="常看本地ip"></a>常看本地ip</h4><p>通过ipconfig.exe就可以查看本地ip</p>
<p>当然也可以通过 /? 参数获取更多的帮助</p>
<p>ipconfig /?</p>
<p>当然ipconfig还有很多其他的用处，比如按照提示上面说的<br>/all Display full configuration information.<br>通过/all参数调用,可以显示出全部的设置信息:</p>
<p>Windows IP Configuration</p>
<pre><code>Host Name . . . . . . . . . . . . : s3049
Primary Dns Suffix  . . . . . . . :
Node Type . . . . . . . . . . . . : Unknown
IP Routing Enabled. . . . . . . . : No
WINS Proxy Enabled. . . . . . . . : No
</code></pre><p>Ethernet adapter 本地连接:</p>
<pre><code>Connection-specific DNS Suffix  . :
Description . . . . . . . . . . . : Realtek PCIe GBE Family Controller
Physical Address. . . . . . . . . : 78-E3-B5-A3-A5-44
Dhcp Enabled. . . . . . . . . . . : No
IP Address. . . . . . . . . . . . : 172.26.22.49
Subnet Mask . . . . . . . . . . . : 255.255.0.0
Default Gateway . . . . . . . . . : 172.26.2.6
DNS Servers . . . . . . . . . . . : 58.22.96.66
</code></pre><p>（直接复制了，发图麻烦）</p>
<p>这里可以查看到一些常见的信息，比如host name是主机名，Physical Address 则是传说中的mac地址，IP Address 就是你的本机地址（注意这个通常是局域网下的）。至于后面的子网掩码还有默认网关什么的，想了解的一可以去搜索一下。<br>还有/flushdns(flush DNS)刷新DNS缓存什么的。相信这些信息，网管专业的同学应该都非常熟悉。（注：不明情况的围观群众不要随意开跳这个坑，了解基本即可。）</p>
<h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>记得原来微博上面有个吐槽，就是说很多人普通人用百度来搜索，而很多程序员则用百度来测试网络是否联通。那么如果使用ping.exe来测试网络是否联通：</p>
<p>ping www.baidu.com</p>
<p>除了这个用处以外还有一个很常见的作用就是测试自己是否能够连接到某个ip，这里有一个路由器，连接了两台电脑，在每台电脑上都可以通过ipconfig查看自己在局域网中的ip地址，假设对方的ip是192.168.1.106。那么便可以使用ping命令测试是否能联通对方的电脑。</p>
<p>ping 192.168.1.106<br>当然，眼尖的同学应该已经发现了ping.exe的另一个作用，那就使用获取某个网站的ip地址：</p>
<p>其他闲话</p>
<p>至于<br>4.快速查询本地服务、端口使用情况<br>5.快速调用一些常用工具<br>6.原始编程方式，用cmd调用编译<br>7.学汇编都应该知道cmd下的debug<br>8.批处理</p>
<p>这些有的内容对于新手而言略坑，这里暂不做介绍。</p>
<p>其中的5.快速调用一些常用工具，就简单说一下博主常用的工具：</p>
<p>notepad 记事本<br>calc 计算器<br>mspaint 画图板</p>
<p>这些实际上通过菜单调出运行（或者win+r）就可以直接输入调出来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;cmd应用基础&quot;&gt;&lt;a href=&quot;#cmd应用基础&quot; class=&quot;headerlink&quot; title=&quot;cmd应用基础&quot;&gt;&lt;/a&gt;cmd应用基础&lt;/h3&gt;&lt;p&gt;Posted on 2012-12-15&lt;/p&gt;
&lt;h4 id=&quot;cmd是什么？&quot;&gt;&lt;a href=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="http://yoursite.com/2017/07/31/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2017/07/31/Java异常处理/</id>
    <published>2017-07-30T19:13:02.000Z</published>
    <updated>2017-08-05T16:13:46.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><h4 id="先说什么是异常"><a href="#先说什么是异常" class="headerlink" title="先说什么是异常"></a>先说什么是异常</h4><p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的错误条件。当条件生成时，错误将引发异常。<strong>异常的正确使用，能帮助程序员迅速找到异常的出现，同时，也不至于让程序崩溃，得已继续执行下去。当然，在出现异常后，还能让程序继续运行去，对程序员的要求是极高的。</strong></p>
<h4 id="Java的异常处理方式"><a href="#Java的异常处理方式" class="headerlink" title="Java的异常处理方式"></a>Java的异常处理方式</h4><ol>
<li><p>throw Exception.当我们写个函数来处理IO流或Socket连接的时候，函数内部可能会发生错误，我们就需要把程序抛出给调用函数的人，让他来处理。</p>
</li>
<li><p>try..catch。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">    可能出现异常的语句</div><div class="line">&#125;eacth(Exception e)&#123;  //捕捉异常</div><div class="line">    处理异常的语句</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方式，也就是说我们知道要发生的具体错误是什么，然后我们自己解决掉错误。</p>
<h4 id="异常的重要性"><a href="#异常的重要性" class="headerlink" title="异常的重要性"></a>异常的重要性</h4><blockquote>
<p>在一个完美的世界中，用户不会输入错误，计算机硬件永远不会出错，相关的数据文件永远不会被丢失…遗憾的是，这个世界并不是如此美好。</p>
</blockquote>
<p>程序运行时可能遇到各种非正常状况—-用户输入的数据非法、电脑硬盘空间不足，程序所需要的文件被删除等等。一个足够健壮的程序，用于处理异常的代码要占到很大部分。正是由于异常处理如此重要，Java设计者将异常处理作为Java语言的一种内置特性。在其他语言中，编写者可以偷懒不写异常处理；而在Java中，如果一个方法声明可能会抛出异常，那么调用方法的人必须对此进行处理；否则不能编译通过。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>不知道我们有没有想过为什么Java需要有两种异常处理方式呢？我们应该知道，我们写的代码、写的类、写的函数，不仅仅只是我们自己用的，同时我们也发现这两种方式对异常的处理也是不同的。throw这种方式，错误是由调用方来解决的；try..catch这种方式呢，是写代码的人来解决的。学技术，不仅仅只是为了知道怎么使用这种技术，还应该清楚技术背后的含义。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java异常处理&quot;&gt;&lt;a href=&quot;#Java异常处理&quot; class=&quot;headerlink&quot; title=&quot;Java异常处理&quot;&gt;&lt;/a&gt;Java异常处理&lt;/h3&gt;&lt;h4 id=&quot;先说什么是异常&quot;&gt;&lt;a href=&quot;#先说什么是异常&quot; class=&quot;header
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>windows 安装Mysql</title>
    <link href="http://yoursite.com/2017/07/31/windows-%E5%AE%89%E8%A3%85Mysql/"/>
    <id>http://yoursite.com/2017/07/31/windows-安装Mysql/</id>
    <published>2017-07-30T19:11:01.000Z</published>
    <updated>2017-07-30T15:59:29.802Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Windows-环境下-MySQL-5-7-安装配置指南"><a href="#Windows-环境下-MySQL-5-7-安装配置指南" class="headerlink" title="Windows 环境下 MySQL 5.7 安装配置指南"></a>Windows 环境下 MySQL 5.7 安装配置指南</h3><h5 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h5><ul>
<li>Windows 版本：Windows 10 专业版 64bit</li>
<li>MySQL 版本：MySQL 5.7.16</li>
</ul>
<h5 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h5><p>在安装 MySQL 前请务必确认自己电脑的 net 指令是正常工作的。有些 Windows 系统会丢失 net 指令<em>(环境变量缺失)</em>，解决方法请自行搜索一下。</p>
<h4 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h4><ol>
<li><p>下载 MySQL Community Server <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">下载链接</a></p>
<ul>
<li>选择合适自己操作系统的版本，通常使用 Windows (x86, 64-bit), ZIP Archive</li>
</ul>
</li>
<li><p>解压并“合理安放” MySQL Server。</p>
<ul>
<li>将下载好的mysql-5.7.16-winx64.zip解压，并将解压好的文件夹妥善放置（比如放置在 Program FIles 文件夹内）。本教程中 MySQL 被放置在了D:\ProgramFiles下，并被重命名为了 MySQL。</li>
</ul>
</li>
<li><p>为 MySQL Server 配置环境变量</p>
<ul>
<li>右击开始菜单按钮，选择“系统”选项。</li>
<li>在“系统”界面左侧，选择“高级系统设置”。</li>
<li><p>在打开的“系统属性”对话框中的“高级”选项卡页面的下方，选择“环境变量”。</p>
<ul>
<li><p>系统属性设置窗口</p>
<p> 在“用户变量”区块中，选择“新建”，在打开的对话框中，变量名写 MySQL，变量值写 MySQL 文件夹的完整路径（本教程为D:\Program Files\MySQL）。</p>
</li>
<li><p>添加环境变量</p>
<p> 同样在用户区块中寻找 PATH 环境变量，如果有，点击“编辑”。在弹出的对<br> 话框中点击“新建”，输入%MySQL%\bin（在老版本 Windows 系统中，变量值末尾用英文分号;分开后再添加%MySQL%\bin）。如果没有，点击“新建”，添加一个变量名为 Path 的环境变量。在这个环境变量的变量值处，添加%MySQL%\bin</p>
</li>
<li><p>修改环境变量<br>  点击确定按钮退出环境变量配置对话框。<br>  点击确定按钮退出系统属性配置对话框。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注册 MySQL 服务</p>
<ul>
<li>右击开始菜单按钮，选择/“命令提示符（管理员）”/选项。</li>
<li>输入盘符 + “:” 指令，进入MySQL文件夹所在的磁盘（本教程是 D 盘）。再使用  cd指令进入MySQL Server所在文件夹的bin文件夹中。<strong>这一步非常重要，如果不在这个目录下，无法正确注册 MySQL 服务。</strong></li>
</ul>
</li>
<li><p>定位到 MySQL 所在路径</p>
<ul>
<li>执行mysqld -install指令，注册 MySQL 服务。</li>
</ul>
</li>
<li><p>注册 MySQL 服务</p>
<ul>
<li>执行完毕后，请不要退出“命令提示符”。</li>
</ul>
</li>
<li><p>配置 MySQL Server</p>
<ul>
<li>进入 MySQL Server 所在的文件夹 （本教程为D:\Program Files\MySQL）</li>
<li><p>编辑my-default.ini</p>
<ul>
<li><p>在该文件中，#是注释标记。<br>去掉 basedir 的注释符号，并在等号后边填写 MySQL Server 文件夹的完整地址。<br>去掉 datadir 的注释符号，并在等号后边填写 MySQL Server 文件夹的完整地址外加\data。<br> <strong>切记不要手动创建 data 文件夹！</strong></p>
</li>
<li><p>port 不需要配置，不配置的状态下默认为 3306。（MySQL Server 默认使用的端口号）</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>最终配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># For advice on how to change settings please see</div><div class="line"># http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</div><div class="line"># *** DO NOT EDIT THIS FILE. It&apos;s a template which will be copied to the</div><div class="line"># *** default location during install, and will be replaced if you</div><div class="line"># *** upgrade to a newer version of MySQL.</div><div class="line"></div><div class="line">[mysqld]</div><div class="line"></div><div class="line"># Remove leading # and set to the amount of RAM for the most important data</div><div class="line"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</div><div class="line"># innodb_buffer_pool_size = 128M</div><div class="line"></div><div class="line"># Remove leading # to turn on a very important data integrity option: logging</div><div class="line"># changes to the binary log between backups.</div><div class="line"># log_bin</div><div class="line"></div><div class="line"># These are commonly set, remove the # and set as required.</div><div class="line">basedir =D:\Program Files\MySQL</div><div class="line">datadir =D:\Program Files\MySQL\date</div><div class="line"># port = .....</div><div class="line"># server_id = .....</div><div class="line"></div><div class="line"></div><div class="line"># Remove leading # to set options mainly useful for reporting servers.</div><div class="line"># The server defaults are faster for transactions and fast SELECTs.</div><div class="line"># Adjust sizes as needed, experiment to find the optimal values.</div><div class="line"># join_buffer_size = 128M</div><div class="line"># sort_buffer_size = 2M</div><div class="line"># read_rnd_buffer_size = 2M </div><div class="line"></div><div class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</div></pre></td></tr></table></figure></p>
<p>保存退出。退出后将my-default.ini重命名为my.ini</p>
<ol>
<li><p>在刚才的“命令提示符”中，执行mysqld –initialize（可能会假死，等一分钟手动关闭就好）。</p>
</li>
<li><p>开启 MySQL Server</p>
<ul>
<li>在“命令提示符”中执行net start mysql，开启 MySQL Server。</li>
</ul>
</li>
<li><p>配置 MySQL root 账户。</p>
<ul>
<li>在“命令提示符”中，执行net stop mysql关闭 MySQL Server。</li>
<li>再执行mysqld –skip-grant-tables开启无密码的 MySQL Server。</li>
</ul>
</li>
<li><p>无密码启动 MySQL Server</p>
<ul>
<li>打开一个新的“命令提示符”，执行mysql -u root登陆 MySQL Server。</li>
<li>执行flush privileges刷新权限。</li>
<li>执行grant all privileges on <em>.</em> to ‘root’@’localhost’ identified by ‘你想设置的密码’ with grant option;。</li>
<li>执行flush privileges刷新新的 root 用户密码。</li>
<li>执行exit退出 MySQL。</li>
</ul>
</li>
<li><p>结束进程</p>
<ul>
<li>在任务管理器下手动结束mysqld.exe。</li>
</ul>
</li>
<li><p>正常登陆</p>
<ul>
<li>在“命令提示符”下执行net mysql start重新开启MySQL Server，再次使用mysql -u root -p 你设置的密码即可安全登陆 MySQL。</li>
</ul>
</li>
</ol>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p><strong>本教程中所有的“命令提示符”，一定要运行在 管理员模式下，否则会出现“拒绝访问”的问题。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Windows-环境下-MySQL-5-7-安装配置指南&quot;&gt;&lt;a href=&quot;#Windows-环境下-MySQL-5-7-安装配置指南&quot; class=&quot;headerlink&quot; title=&quot;Windows 环境下 MySQL 5.7 安装配置指南&quot;&gt;&lt;/a&gt;Wi
    
    </summary>
    
      <category term="config" scheme="http://yoursite.com/categories/config/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>我的大一</title>
    <link href="http://yoursite.com/2017/07/29/%E6%88%91%E7%9A%84%E5%A4%A7%E4%B8%80/"/>
    <id>http://yoursite.com/2017/07/29/我的大一/</id>
    <published>2017-07-29T00:07:02.000Z</published>
    <updated>2017-08-25T08:12:57.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>一眨眼间，我的大一就结束了，等开学就有人叫我学长了，还真有点不习惯。现在还记得刚来时的陌生、军训时的痛苦，回想起来，感觉还是昨天的事情，但早已过去一年了，自己也从当初的小鲜肉变成老司机了。大一新生的保护伞也没了，遇到问题再也不能说自己是大一新生，以前没学过，不懂了。这一年自己都干嘛了呢？</p>
<h4 id="大一上"><a href="#大一上" class="headerlink" title="大一上"></a>大一上</h4><p>在大一上个学期，一时间还是不能适应大学这种宽松的生活，但还好自己以前也都是住校生，能管理好自己的生活和学习，虽然不是完全适应，但还不会迷失自己，不会一天天无所事事。</p>
<p>后来，在老乡群，有一个学长发了一个招新信息，是学校千年弦歌网络工作室的。恰好自己对网站这一块也比较感兴趣，大一上的课也很少，跟学长了解了一下，就报名了，然后过段时间就面试，自己第一次面试，挺紧张的。但自己也很幸运，当了实习程序员。<br>还记得第一次去开会的时候，学长们说的一些名词，自己之前从来没听过，学长们说的很happy，自己听的很懵逼，但也装作听懂了一样。弦歌实行的是放养政策，就是你不懂，你就自己学去。</p>
<p>之后，自己就踏上了自学的道路，这个过程中自己学到了很多。自己先看了前端的一些知识，就是一些简单的HTML便签很CSS样式表，然后简写一些简单的页面，接着学习了JS,让自己的网页有了一些特效。现在说起来，感觉没什么，但回想其自己当时的学习历程，还是觉得自己很棒。在大学之前，只会装软件，上网聊天的人，要自己学习这些东西，还是有点困难的。那段时间，自己总是往图书馆跑，每次都是借好几本书回来，因为自己不知道那本适合自己，也不知道从哪里开始学起，就把自己觉得还可以的都借回来了，然后慢慢看，找到一本适合自己的。同时呢，因为在网上学习，看一些视频呀，做一些小练习呀。就这样的学习节奏，自己的大一上就结束了。</p>
<h4 id="大一下"><a href="#大一下" class="headerlink" title="大一下"></a>大一下</h4><p>寒假回家过个年回来，就是大一下半年了。没有了当初的那份陌生与羞涩了，一来就进入状态，开始正常的生活了。</p>
<p>这学期，学校的课程也多了起来，有高数、离散、线代，三门数学，没有一本是简单的，所以自己得花一定的时间来学习，应付学校的考试。但是，老师在课上讲的都是很表面的东西，就拿线性代数来说吧：老师讲的都是都是很浅显的矩阵运算、解方程组，但线代的作用仅非于此，更重要的是自己能从中抽象出对空间的理解，知道课本上的名词，对应空间中向量的变换是什么。为此，自己就找其他书籍和上网找资源来充饥。所以说呀，上课讲的有时候并不是我们需要的，我们需要发挥自己的能动性去寻找自己需要的知识。</p>
<p>此外，自己还继续在Web这条路上探索着，开始学习一些后端的数据操作。有一次去开会，有个学长叫我搭个个人博客。自己也在CSDN或者其他平台写过博客，也想过弄个自己的个人网站。</p>
<p>然后就开始网站搭建个人博客风波。谷歌到有Word这一个框架搭建个人博客非常方便，不过需要搭建LAMP（Linux+Apache+MySql+PHP）环境。自己在学的开始学的时候，用的是集成的wamp软件。然后自己就想不如分开装试试，反正也是在学习嘛。</p>
<p>还真别说，要搞定这三者（Apache+Mysql+PHP），不是一件容易的事噢，也明白了为什么当初学长推荐我们使用集成软件来学习了。自己当时摸索了三天才让这三者开始工作，但自己能连接数据库，打印“Hello world”的那一刻，自己很是开心啊，觉得很有成就感。经过这一次经历，自己再也不怕配置软件了，比如一些IDE啊。</p>
<p>环境搭好了，就开始搭建个人软件了，过程中也出现了一些问题，但自己摸索和上网查资料，也都解决了。这是在本地弄得，然后自己又想着是不是可以在服务器上弄弄。</p>
<p>然后又开始搞事情了。最开始是买服务器，是在阿里云买的，不巧，选择的是Linux的操作系统，在操作服务器的时候，还得学习一波Linux的操作，然后上传镜像，配置，跟本地操作差不多，很快搞定了。搞定后，有寻思着，应该有个域名，说干就干，就买域名，建立映射关系，也很快搞定。</p>
<p>虽然这一切自己描述都挺顺利的，但过程中还是遇到了一些难题的，不过，这一路都是自己在摸索，知道了遇到问题怎么去解决，所以，遇到的问题自己都很快解决了，就觉得没什么问题了。</p>
<h4 id="大一下之蓝杰篇"><a href="#大一下之蓝杰篇" class="headerlink" title="大一下之蓝杰篇"></a>大一下之蓝杰篇</h4><p>自己能知道蓝杰这个培训机构的存在，可以说是上天的安排。为什么这么说呢？</p>
<p>记得我在自习室自习，接到一个电话，说自己是蓝杰的，还说认识我，但我问她我的名字，她说的并不是我的名字，后来还说知道我的家乡、专业，但当我问他时，都是错的。但我也不知道为什么，就相信她了，就到了蓝杰上免费的六节课了。第一次到蓝杰，就觉得那边挺好的，虽然学费挺贵的，自己还是咬咬牙牙报名了，还是感谢老爸老妈和我的好兄弟阿伟仔啊。</p>
<p>然后，晚上没课和周末就过去蓝杰上课，其他的空余时间就自己琢磨Web和学习数学啦，所以感觉大一下过的挺充实挺快的。</p>
<p>自己要去蓝杰学习，其实不光是为了学习，最主要的原因是去那里认识更多喜欢计算机的人，大家一起学习、交流，以后工作后，还能互相照应。是的，在蓝杰这边，也认识了挺多和自己谈得来的朋友，也认识了挺牛逼的学长学姐，有保研的、有值博的、有国外留学的…跟这些牛人的交流，自己开阔了眼界，知道了大学四年能有这么多不一样的选择，很受启发。当然，这都是要通过自己的努力，才能达到的高度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h3&gt;&lt;p&gt;一眨眼间，我的大一就结束了，等开学就有人叫我学长了，还真有点不习惯。现在还记得刚来时的陌生、军训时的痛苦，回想起来，感觉还是昨天的事情，但早
    
    </summary>
    
      <category term="colleage" scheme="http://yoursite.com/categories/colleage/"/>
    
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Java浅谈Socket</title>
    <link href="http://yoursite.com/2017/07/29/Java%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/07/29/Java服务器编程/</id>
    <published>2017-07-28T20:30:36.000Z</published>
    <updated>2017-07-28T13:23:20.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>现在是互联网的时代，说到底也就是连接的时代。人与人、人与物、物与物都需要连接，那为什么要连接呢？<br>我的答案是：为了交换信息。人与人的连接，就是我们说的交流，这也是一个互享信息的过程；人与物的连接，也是为了交换信息，举个简单的例子：但我们在自动购物机上购物时，我们通过挑选我们需要的商品告诉购物机我们要的是什么，这是你给购物机的信息，你扫二维码付款，告诉了购物机你的身份，这难道不是一个交换信息的过程吗？物与物的连接，也是这样的，就像智能家居里的家具，是要连接起来，共享信息，才能把我们的家控制在一个适宜的状态。我们写程序也一样，也要连接，也要交流，也要共享信息…</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>客户端套接字（也可以就叫“套接字”），套接字是两台机器之间的通信端点，是源IP地址和目的IP地址以及源端口号和目的端口号的组合，一般用于标识客户端请求的服务器和服务，是支持TCP/IP的网络通信的基本操作单元。</p>
<p>一个Socket由一个IP地址和一个端口号唯一确定。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。具体的介绍参考Oracle的Socket说明文档。</p>
<h5 id="使用Socket的过程有："><a href="#使用Socket的过程有：" class="headerlink" title="使用Socket的过程有："></a>使用Socket的过程有：</h5><ol>
<li><p>创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">指定ip地址和端口号</div><div class="line">Socket client = new Socket(&quot;127.0.0.1.&quot;, 8080);</div><div class="line">打开连接到Socket的输入/输出流</div><div class="line">BufferedReader input=new BufferedReader(new InputStreamReader(client.getInputStream()));</div><div class="line">BufferedReader output=new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));</div></pre></td></tr></table></figure>
</li>
<li><p>进行读/写操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String line = input.readLine();</div><div class="line">output.write(&quot;Success!&quot;);</div><div class="line">output.flush();</div></pre></td></tr></table></figure>
</li>
<li><p>关闭Socket</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input.close();</div><div class="line">output.close();</div><div class="line">client.close();</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>服务器套接字，可以绑定到指定的服务器IP地址和端口，等待请求通过网络传入，基于该请求执行某些操作，然后可能向请求者返回结果。</p>
<h5 id="使用ServerSocket的过程有："><a href="#使用ServerSocket的过程有：" class="headerlink" title="使用ServerSocket的过程有："></a>使用ServerSocket的过程有：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">这里绑定8080端口，默认绑定本地IP地址，侦听并接收HTTP请求。</div><div class="line">ServerSocket server = new ServerSocket(8080);</div><div class="line">accept()方法，侦听并接受到此套接字的连接,程序会在此处堵塞，简单点说，程序会在此处停住，一直等到有客户端连接</div><div class="line">Socket socket = server.accept();</div><div class="line"></div><div class="line">Server接收消息后再对请求做处理，注意服务端input对应客户端的output，服务端的output对应客户端的input。</div></pre></td></tr></table></figure>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">package service.com;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">import org.apache.commons.lang3.time.DateFormatUtils;</div><div class="line"></div><div class="line">public class HttpServer &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 侦听8080端口</div><div class="line">            ServerSocket server = new ServerSocket(8080);</div><div class="line"></div><div class="line">            System.out.println(&quot;Info:Server start,&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;));</div><div class="line">            while (1 == 1) &#123;</div><div class="line">                // 接收客户端请求数据   程序堵塞</div><div class="line">                Socket socket = server.accept();</div><div class="line"></div><div class="line">                // 读取</div><div class="line">                BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));</div><div class="line">                // 写入</div><div class="line">                BufferedWriter output = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</div><div class="line"></div><div class="line">                String line = input.readLine();</div><div class="line"></div><div class="line">                while (line != null) &#123;</div><div class="line">                    System.out.println(line);</div><div class="line">                    output.write(&quot;Success!!&quot; + DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;) + &quot;\r\n&quot;);</div><div class="line">                    output.flush();</div><div class="line">                    line = input.readLine();</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                //必须关闭</div><div class="line">                input.close();</div><div class="line">                output.close();</div><div class="line"></div><div class="line">                socket.close();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">           System.out.println(&quot;Error binding the specified port.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><ol>
<li><p>启动程序后，控制台信息输出：<br>Info:Server start,2016-12-02 15:26:13</p>
</li>
<li><p>使用cmd,输入命令 telnet localhost 8080:<br>输入 hello world</p>
</li>
<li><p>命令行显示:<br>Success!!2016-12-02 15:29:01</p>
</li>
<li><p>控制台输出：<br>hello world</p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过上面的讲述，不难发现，虽然我们说的Socket编程，但这一部分的内容并不多，无非就是建立SocketServer和Socket，两者使用同样的端口，就能相互连接上，<br>最主要的还是怎么处理连接后的的IO流的操作。此外，还需要服务器端的输入输出流和客户端的输入输出流，必要弄混淆了。</p>
<p>我们用的例子是发送字符串，但我们要看到本质性的东西：我们发送的字符串是以字节的形式发送出去的，那是不是说明我们就可以发送图像、视频…了呢？是的，我们能把计算机上的任何东西发送出去，只需要找到我们要发送的文件的URI，就能打开它，保存到字节数组里，然后发送出去。当然，如果文件过大，还要注意内存溢出的问题。</p>
<p>此外，我们常说的Web服务器，其实也就是一个用来接收客户端请求，并处理用户端的请求并返回信息的程序，只不过有一些特别的规定，也就是Http协议。那是不是说，如果我们了解了Http协议的规定，我们也能写一个Http服务器了呢？下一节咱们就来完成一个简单的能处理http请求的服务器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h3&gt;&lt;p&gt;现在是互联网的时代，说到底也就是连接的时代。人与人、人与物、物与物都需要连接，那为什么要连接呢？&lt;br&gt;我的答案是：为了交换信息。人与人的连
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>jxl操作excel</title>
    <link href="http://yoursite.com/2017/07/28/jxl%E6%93%8D%E4%BD%9Cexcel/"/>
    <id>http://yoursite.com/2017/07/28/jxl操作excel/</id>
    <published>2017-07-28T09:53:44.000Z</published>
    <updated>2017-07-28T01:59:07.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java操作Excel（jxl）"><a href="#Java操作Excel（jxl）" class="headerlink" title="Java操作Excel（jxl）"></a>Java操作Excel（jxl）</h3><h5 id="读"><a href="#读" class="headerlink" title="读"></a>读</h5><p>读的时候是这样的一个思路,先用一个输入流(InputStream)得到Excel文件,然后用jxl中的Workbook得到工作薄,用Sheet从工作薄中得到工作表,用Cell得到工作表中得某个单元格.<br>InputStream-&gt;Workbook-&gt;Sheet-&gt;Cell,就得到了excel文件中的单元格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String path = &quot;c:\\excel.xls&quot;; //Excel文件URL</div><div class="line">InputStream is = new FileInputStream(path); //写入到FileInputStream</div><div class="line">jxl.Workbook wb = Workbook.getWorkbook(is); //得到工作薄 </div><div class="line">jxl.Sheet st = wb.getSheet(0); //得到工作薄中的第一个工作表</div><div class="line">Cell cell = st.getCell(0, 0); //得到工作表的第一个单元格,即A1</div><div class="line">String content = cell.getContents(); //getContents()将Cell中的字符转为字符串</div><div class="line">wb.close(); //关闭工作薄</div><div class="line">is.close(); //关闭输入流</div></pre></td></tr></table></figure>
<p>我们可以通过Sheet的getCell(x,y)方法得到任意一个单元格,x,y和excel中的坐标对应.<br>例如A1对应(0,0),A2对应(0,1),D3对应(3,2).Excel中坐标从A,1开始,jxl中全部是从0开始.<br>还可以通过Sheet的getRows(),getColumns()方法得到行数列数,并用于循环控制,输出一个sheet中的所有内容.</p>
<h5 id="写"><a href="#写" class="headerlink" title="写"></a>写</h5><p>往Excel中写入内容主要是用jxl.write包中的类.<br>思路是这样的:<br>OutputStream&lt;-WritableWorkbook&lt;-WritableSheet&lt;-Label<br>这里面Label代表的是写入Sheet的Cell位置及内容.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">OutputStream os = new FileOutputStream(&quot;c:\\test.xls&quot;); </div><div class="line">WritableWorkbook wwb = Workbook.createWorkbook(os); </div><div class="line">WritableSheet ws = wwb.createSheet(&quot;sheet1&quot;, 0);    //创建可写工作表</div><div class="line">Label labelCF = new Label(0, 0, &quot;hello&quot;);    //创建写入位置和内容</div><div class="line">ws.addCell(labelCF);    //将Label写入sheet中</div><div class="line">//Label的构造函数Label(int x, int y,String aString)xy意同读的时候的xy,aString是写入的内容.</div><div class="line">WritableFont wf = new WritableFont(WritableFont.TIMES, 12, WritableFont.BOLD, false);   //设置写入字体</div><div class="line">WritableCellFormat wcfF = new WritableCellFormat(wf);    //设置CellFormat</div><div class="line">Label labelCF = new Label(0, 0, &quot;hello&quot;);   //创建写入位置,内容和格式</div><div class="line">//Label的另一构造函数Label(int c, int r, String cont, CellFormat st)可以对写入内容进行格式化,设置字体及其它的属性.</div><div class="line">    </div><div class="line">wwb.write();</div><div class="line">wwb.close();</div><div class="line">os.close;</div></pre></td></tr></table></figure></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>OK,了解了怎么读与写，我们只要把读和写结合起来,就可以在N个Excel中读取数据写入你希望的Excel新表中,还是比较方便的。举个例子吧:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">sql = &quot;select * from tablename&quot;;</div><div class="line">rs = stmt.executeQuery(sql);</div><div class="line">//新建Excel文件</div><div class="line">String filePath = request.getRealPath(&quot;aaa.xls&quot;);</div><div class="line">File myFilePath = new File(filePath);</div><div class="line">if (!myFilePath.exists()) myFilePath.createNewFile();</div><div class="line">FileWriter resultFile = new FileWriter(myFilePath);</div><div class="line">PrintWriter myFile = new PrintWriter(resultFile);</div><div class="line">resultFile.close();</div><div class="line">//用JXL向新建的文件中添加内容</div><div class="line">OutputStream outf = new FileOutputStream(filePath);</div><div class="line">jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(outf);</div><div class="line">jxl.write.WritableSheet ws = wwb.createSheet(&quot;sheettest&quot;, 0);</div><div class="line">int i = 0;</div><div class="line">int j = 0;</div><div class="line">for (int k = 0; k &lt; rs.getMetaData().getColumnCount(); k++) &#123;</div><div class="line">    ws.addCell(new Label(k, 0, rs.getMetaData().getColumnName(k + 1)));</div><div class="line">&#125;</div><div class="line">while (rs.next()) &#123;</div><div class="line">    out.println(rs.getMetaData().getColumnCount());</div><div class="line">    for (int k = 0; k &lt; rs.getMetaData().getColumnCount(); k++) &#123;</div><div class="line">        ws.addCell(new Label(k, j + i + 1, rs.getString(k + 1)));</div><div class="line">    &#125;</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line">wwb.write();</div><div class="line">wwb.close();</div><div class="line">&#125; catch(Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">    rs.close();</div><div class="line">    conn.close();</div><div class="line">&#125;</div><div class="line">response.sendRedirect(&quot;aaa.xls&quot;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java操作Excel（jxl）&quot;&gt;&lt;a href=&quot;#Java操作Excel（jxl）&quot; class=&quot;headerlink&quot; title=&quot;Java操作Excel（jxl）&quot;&gt;&lt;/a&gt;Java操作Excel（jxl）&lt;/h3&gt;&lt;h5 id=&quot;读&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>a+b=c</title>
    <link href="http://yoursite.com/2017/07/28/a-b-c/"/>
    <id>http://yoursite.com/2017/07/28/a-b-c/</id>
    <published>2017-07-27T16:53:27.000Z</published>
    <updated>2017-07-27T14:39:52.285Z</updated>
    
    <content type="html"><![CDATA[<h3 id="见林见森"><a href="#见林见森" class="headerlink" title="见林见森"></a>见林见森</h3><p>小时候，常听大人们讲”看问题要看本质”，那是还小，不太懂这句话的意思，也没有进行深入的思考。慢慢的长大，经历的许多事情后，再次听到这句话，觉得自己有了一点理解。</p>
<p>就拿我们小时候学的算术来举个例子，我们都知道2+3=5，6+8=10…在小学，我们学了很多这样的例子；等我们到了初中的时候，接触到代数，有了这样的表达式  a+b=c ，人们所说的代数。一个简单的表达式就涵盖了我们小学6年所学的算术，说到底，我们在小学学的无穷的算术，就是为了在初中能更好地理解为什么 a+b=c 是可以成立的。换句话来说a+b=c就是我们在学了无穷的算术后，所真正需要掌握的东西,如果小学毕业后我们不能理解为什么a+b=c ，那就是我们的不对了。a+b=c的背后，是一种思考方法…</p>
<p>我们长大了，需要学习的东西也变多了，也没有多少个六年让我们去掌握一件东西了。所以在学习的时候，我们就需要从表面的东西看到最深层的东西，这不容易，需要平常多思考，多与人交流。</p>
<p>拿自己来说吧，一个以后极其可能走上码农道路上的人来说，有无数中高级语言需要我们去学习，因为我们并不知道客户的需求是什么样的。那是不是说如果客户要求使用的语言我没学过，那这工作我是不是就不能接了呢？如果是这样，那码农这个职业的存在就是不合理的。要解决这种问题，需要我们有学过一本语言，就能知道怎么使用其他语言的能力，那怎么做到呢？是的，这时候我们就需要找到这些编程语言的共性。如果我们有学过一本编程语言，就应该知道用这门语言完成一些操作时的步骤，比如说用来操作文件，一般都是先找到文件、建立通道、操作文件…再比如说数据库操作，一般步骤为怎么连接数据库、怎么发送SQL语句…是的，能够发现这些基本的步骤，才是我们学习一门语言的目的，也只有这样，我们才能更快的学习另一门语言，满足客户的要求。</p>
<p>在唠叨一下，如果我们今天自己完成了一个可以复制、加密文件的小程序，第二天，有一个叫做“学生信息管理系统”的项目需要你来完成，你的反应是什么呢？第一反应极大可能是我不会呀，我只会最基本的文件复制、加密，怎么完成你的这个学生信息管理系统呀。这是正常的，我们接触到新的事物时，正常反应都是这样的。但如果我们仔细想想，管理系统说到底也就是信息处理呀，就是把把填写的学生信息存起来或者能把学生的信息读取出来，跟我们完成的文件复制、加密程序，不是一样的功能吗？还是那句话，见到树，就要想到森林。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;见林见森&quot;&gt;&lt;a href=&quot;#见林见森&quot; class=&quot;headerlink&quot; title=&quot;见林见森&quot;&gt;&lt;/a&gt;见林见森&lt;/h3&gt;&lt;p&gt;小时候，常听大人们讲”看问题要看本质”，那是还小，不太懂这句话的意思，也没有进行深入的思考。慢慢的长大，经历的许多事情后，再
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java加密系统</title>
    <link href="http://yoursite.com/2017/07/27/Java%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/07/27/Java加密系统/</id>
    <published>2017-07-26T20:17:32.000Z</published>
    <updated>2017-07-26T13:02:02.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加密系统"><a href="#加密系统" class="headerlink" title="加密系统"></a>加密系统</h3><p>最近,在学习文件操作这一部分的内容，在了解了一些文件的增、删、改、查后，突发奇想不如来整合一些这些功能，弄个简单的软件。</p>
<h5 id="生成密文"><a href="#生成密文" class="headerlink" title="生成密文"></a>生成密文</h5><p>加密的方法有很多种，有对称、非对称加密算法，具体区别就不再这里细说了。初次尝试，用的是对称的加密算法，就是用来加密和解密的密文都是一样的。对于密文的实现，自己用的是一个很简单的算法，就是随机生成一些随机数，然后写进一个文件里，然后就可以使用其进行加密。</p>
<h5 id="加密-解密"><a href="#加密-解密" class="headerlink" title="加密/解密"></a>加密/解密</h5><p>密文有了，我们就可以加密了，也很简单。我们先把密文的信息取出来，存在一个数组中，然后一个字节一个字节的把需要在加密的信息读出来，先加上数组的值，然后在写到另一个文件，这样就能加密了。是不是很简单呀，知道了加密，那解密也就不是事了，用同样的密文，减去相应的值就好啦。</p>
<h5 id="Finall"><a href="#Finall" class="headerlink" title="Finall"></a>Finall</h5><p>最后，需要指出的是这种加密方法还是挺容易被破解的，只要拿到加密所需要的密文，一切就都可以解决了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;加密系统&quot;&gt;&lt;a href=&quot;#加密系统&quot; class=&quot;headerlink&quot; title=&quot;加密系统&quot;&gt;&lt;/a&gt;加密系统&lt;/h3&gt;&lt;p&gt;最近,在学习文件操作这一部分的内容，在了解了一些文件的增、删、改、查后，突发奇想不如来整合一些这些功能，弄个简单的软件。&lt;/
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java文件处处理</title>
    <link href="http://yoursite.com/2017/07/26/Java%E6%96%87%E4%BB%B6%E5%A4%84%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2017/07/26/Java文件处处理/</id>
    <published>2017-07-25T22:46:17.000Z</published>
    <updated>2017-07-27T02:57:58.678Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谈谈Java文件处理"><a href="#谈谈Java文件处理" class="headerlink" title="谈谈Java文件处理"></a>谈谈Java文件处理</h3><p>今天，一时兴起，用Java跟着教程弄了一个文件管理器，其功能有复制源文件夹内的容到目标文件夹、查看、修改功能。</p>
<p>文件管理器的核心就是文件的操作，Java为我们封装了许多用于文件操作的类，初学的话对这些类不熟悉，常常会觉得文件操作很困难，但其实并不困难，只要我们记住一下的步骤：</p>
<ol>
<li>定位要操作的文件</li>
<li>建立管道</li>
<li>进行操作</li>
</ol>
<p>简单点说，就是我们只需要找到我们想要操作的文件的路径，就能定位到它，就能对其进行一些列的操作，比如查看、复制、删除…这些操作，Java都已经为我们准备好了，需要用的时候查看文档就好了，最主要的是要记住步骤。</p>
<p>另外，需要注意的是，IO流的操作是很占用内存的，举个例子吧：如果我们要把文件A里的内容复制到B中，计算机是这样工作的：计算机要先找到A文件，然后读取内容到JVM的内存中，然后在写进B文件中，但我们的A文件很大时，计算机就需要进行多次这样的循环工作，非常耗时，浪费资源。所以我们可以改进一下，我们可以这样设想，如果我们把从A读取的内容先在JVM中存起来，当达到足够的量时在一次把这些内容写进B中，这样就减少了一些重复性的工作，效率会提高不少。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;谈谈Java文件处理&quot;&gt;&lt;a href=&quot;#谈谈Java文件处理&quot; class=&quot;headerlink&quot; title=&quot;谈谈Java文件处理&quot;&gt;&lt;/a&gt;谈谈Java文件处理&lt;/h3&gt;&lt;p&gt;今天，一时兴起，用Java跟着教程弄了一个文件管理器，其功能有复制源文件夹内
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java文件处理器</title>
    <link href="http://yoursite.com/2017/07/26/Java%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://yoursite.com/2017/07/26/Java文件处理器/</id>
    <published>2017-07-25T22:46:17.000Z</published>
    <updated>2017-07-26T12:32:02.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谈谈Java文件处理"><a href="#谈谈Java文件处理" class="headerlink" title="谈谈Java文件处理"></a>谈谈Java文件处理</h3><p>今天，一时兴起，用Java跟着教程弄了一个文件管理器，其功能有复制源文件夹内的容到目标文件夹、查看、修改功能。</p>
<p>文件管理器的核心就是文件的操作，Java为我们封装了许多用于文件操作的类，初学的话对这些类不熟悉，常常会觉得文件操作很困难，但其实并不困难，只要我们记住一下的步骤：</p>
<ol>
<li>定位要操作的文件</li>
<li>建立管道</li>
<li>进行操作</li>
</ol>
<p>简单点说，就是我们只需要找到我们想要操作的文件的路径，就能定位到它，就能对其进行一些列的操作，比如查看、复制、删除…这些操作，Java都已经为我们准备好了，需要用的时候查看文档就好了，最主要的是要记住步骤。</p>
<p>另外，需要注意的是，IO流的操作是很占用内存的，举个例子吧：如果我们要把文件A里的内容复制到B中，计算机是这样工作的：计算机要先找到A文件，然后读取内容到JVM的内存中，然后在写进B文件中，但我们的A文件很大时，计算机就需要进行多次这样的循环工作，非常耗时，浪费资源。所以我们可以改进一下，我们可以这样设想，如果我们把从A读取的内容先在JVM中存起来，当达到足够的量时在一次把这些内容写进B中，这样就减少了一些重复性的工作，效率会提高不少。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;谈谈Java文件处理&quot;&gt;&lt;a href=&quot;#谈谈Java文件处理&quot; class=&quot;headerlink&quot; title=&quot;谈谈Java文件处理&quot;&gt;&lt;/a&gt;谈谈Java文件处理&lt;/h3&gt;&lt;p&gt;今天，一时兴起，用Java跟着教程弄了一个文件管理器，其功能有复制源文件夹内
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo</title>
    <link href="http://yoursite.com/2017/07/25/MyBlog/"/>
    <id>http://yoursite.com/2017/07/25/MyBlog/</id>
    <published>2017-07-25T01:05:19.000Z</published>
    <updated>2017-07-30T15:29:35.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="My-First-Hexo-Blog"><a href="#My-First-Hexo-Blog" class="headerlink" title="My First Hexo Blog"></a>My First Hexo Blog</h3><p>  Hexo，一个博客框架，之前听学长讲过，今天跟着教程弄了一下，不是很难，如果之前有接触过git，那就更简单了，跟装个软件差不多。<a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="external">教程</a> <a href="https://lfkid.github.io/2016/11/16/Hexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B0%86%E6%9C%AC%E5%9C%B0Hexo%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages/" target="_blank" rel="external">部署</a> <a href="https://lfkid.github.io/2016/11/16/Hexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%88%9D%E4%BD%93%E9%AA%8C/" target="_blank" rel="external">系列教程</a></p>
<h3 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">* hexo new &quot;postName&quot; #新建文章</div><div class="line">* hexo generate #生成静态页面至public目录</div><div class="line">* hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div><div class="line">* hexo deploy #部署到GitHub</div><div class="line">* hexo help  # 查看帮助</div><div class="line">* hexo version  #查看Hexo的版本</div><div class="line"></div><div class="line">缩写：</div><div class="line"></div><div class="line">* hexo n == hexo new</div><div class="line">* hexo g == hexo generate</div><div class="line">* hexo s == hexo server</div><div class="line">* hexo d == hexo deploy</div><div class="line"></div><div class="line">组合命令：</div><div class="line"></div><div class="line">* hexo s -g #生成并本地预览</div><div class="line">* hexo d -g #生成并上传</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;My-First-Hexo-Blog&quot;&gt;&lt;a href=&quot;#My-First-Hexo-Blog&quot; class=&quot;headerlink&quot; title=&quot;My First Hexo Blog&quot;&gt;&lt;/a&gt;My First Hexo Blog&lt;/h3&gt;&lt;p&gt;  Hexo
    
    </summary>
    
      <category term="colleage" scheme="http://yoursite.com/categories/colleage/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="markdowm" scheme="http://yoursite.com/tags/markdowm/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/07/24/hello-world/"/>
    <id>http://yoursite.com/2017/07/24/hello-world/</id>
    <published>2017-07-24T15:54:03.205Z</published>
    <updated>2017-07-24T15:54:03.206Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
